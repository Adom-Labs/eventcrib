"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethers";
exports.ids = ["vendor-chunks/ethers"];
exports.modules = {

/***/ "(rsc)/./node_modules/ethers/node_modules/tslib/tslib.es6.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/node_modules/tslib/tslib.es6.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __createBinding = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction __exportStar(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\n/** @deprecated */ function __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: n === \"return\"\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\n;\nvar __setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nfunction __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n}\nfunction __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSwyQkFBMkIsR0FFM0IsSUFBSUEsZ0JBQWdCLFNBQVNDLENBQUMsRUFBRUMsQ0FBQztJQUM3QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1FBQUVDLFdBQVcsRUFBRTtJQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1FBQUlELEVBQUVJLFNBQVMsR0FBR0g7SUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRU8sU0FBU1MsVUFBVVYsQ0FBQyxFQUFFQyxDQUFDO0lBQzFCLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVUsVUFBVSx5QkFBeUJDLE9BQU9YLEtBQUs7SUFDN0RGLGNBQWNDLEdBQUdDO0lBQ2pCLFNBQVNZO1FBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdkO0lBQUc7SUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPYSxNQUFNLENBQUNkLEtBQU1ZLENBQUFBLEdBQUdOLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlNLElBQUc7QUFDdEY7QUFFTyxJQUFJRyxXQUFXO0lBQ2xCQSxXQUFXZCxPQUFPZSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFF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RUMsS0FBSyxFQUFFN0UsS0FBSyxFQUFFOEUsSUFBSSxFQUFFNUQsQ0FBQztJQUNsRSxJQUFJNEQsU0FBUyxLQUFLLE1BQU0sSUFBSXpILFVBQVU7SUFDdEMsSUFBSXlILFNBQVMsT0FBTyxDQUFDNUQsR0FBRyxNQUFNLElBQUk3RCxVQUFVO0lBQzVDLElBQUksT0FBT3dILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDM0QsSUFBSSxDQUFDMkQsTUFBTUUsR0FBRyxDQUFDSCxXQUFXLE1BQU0sSUFBSXZILFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU02RCxFQUFFL0QsSUFBSSxDQUFDeUgsVUFBVTVFLFNBQVNrQixJQUFJQSxFQUFFbEIsS0FBSyxHQUFHQSxRQUFRNkUsTUFBTUksR0FBRyxDQUFDTCxVQUFVNUUsUUFBU0E7QUFDeEc7QUFFTyxTQUFTa0Ysc0JBQXNCTCxLQUFLLEVBQUVELFFBQVE7SUFDakQsSUFBSUEsYUFBYSxRQUFTLE9BQU9BLGFBQWEsWUFBWSxPQUFPQSxhQUFhLFlBQWEsTUFBTSxJQUFJdkgsVUFBVTtJQUMvRyxPQUFPLE9BQU93SCxVQUFVLGFBQWFELGFBQWFDLFFBQVFBLE1BQU1FLEdBQUcsQ0FBQ0g7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/ZTYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIl0sIm5hbWVzIjpbImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19yZXN0IiwiZSIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fbWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJtZXRhZGF0YSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidiIsIm9wIiwicG9wIiwicHVzaCIsIl9fY3JlYXRlQmluZGluZyIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIl9fZXhwb3J0U3RhciIsIl9fdmFsdWVzIiwiX19yZWFkIiwiYXIiLCJlcnJvciIsIl9fc3ByZWFkIiwiY29uY2F0IiwiX19zcHJlYWRBcnJheXMiLCJpbCIsImEiLCJqIiwiamwiLCJfX3NwcmVhZEFycmF5IiwidG8iLCJmcm9tIiwicGFjayIsImwiLCJzbGljZSIsIl9fYXdhaXQiLCJfX2FzeW5jR2VuZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsInEiLCJyZXN1bWUiLCJzZXR0bGUiLCJmdWxmaWxsIiwic2hpZnQiLCJfX2FzeW5jRGVsZWdhdG9yIiwiX19hc3luY1ZhbHVlcyIsIl9fbWFrZVRlbXBsYXRlT2JqZWN0IiwiY29va2VkIiwicmF3IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwiX19pbXBvcnRTdGFyIiwibW9kIiwiX19pbXBvcnREZWZhdWx0IiwiZGVmYXVsdCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImhhcyIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkSW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket.js\");\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/sender.js\");\nWebSocket.WebSocket = WebSocket;\nWebSocket.WebSocketServer = WebSocket.Server;\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCRCxVQUFVRSxxQkFBcUIsR0FBR0QsbUJBQU9BLENBQUM7QUFDMUNELFVBQVVHLE1BQU0sR0FBR0YsbUJBQU9BLENBQUM7QUFDM0JELFVBQVVJLFFBQVEsR0FBR0gsbUJBQU9BLENBQUM7QUFDN0JELFVBQVVLLE1BQU0sR0FBR0osbUJBQU9BLENBQUM7QUFFM0JELFVBQVVBLFNBQVMsR0FBR0E7QUFDdEJBLFVBQVVNLGVBQWUsR0FBR04sVUFBVUcsTUFBTTtBQUU1Q0ksT0FBT0MsT0FBTyxHQUFHUiIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzPzNmOWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iXSwibmFtZXMiOlsiV2ViU29ja2V0IiwicmVxdWlyZSIsImNyZWF0ZVdlYlNvY2tldFN0cmVhbSIsIlNlcnZlciIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiV2ViU29ja2V0U2VydmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/buffer-util.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ function concat(list, totalLength) {\n    if (list.length === 0) return EMPTY_BUFFER;\n    if (list.length === 1) return list[0];\n    const target = Buffer.allocUnsafe(totalLength);\n    let offset = 0;\n    for(let i = 0; i < list.length; i++){\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n    }\n    if (offset < totalLength) return target.slice(0, offset);\n    return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */ function _mask(source, mask, output, offset, length) {\n    for(let i = 0; i < length; i++){\n        output[offset + i] = source[i] ^ mask[i & 3];\n    }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */ function _unmask(buffer, mask) {\n    for(let i = 0; i < buffer.length; i++){\n        buffer[i] ^= mask[i & 3];\n    }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */ function toArrayBuffer(buf) {\n    if (buf.byteLength === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */ function toBuffer(data) {\n    toBuffer.readOnly = true;\n    if (Buffer.isBuffer(data)) return data;\n    let buf;\n    if (data instanceof ArrayBuffer) {\n        buf = Buffer.from(data);\n    } else if (ArrayBuffer.isView(data)) {\n        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n    } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n    }\n    return buf;\n}\ntry {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"(rsc)/./node_modules/bufferutil/index.js\");\n    module.exports = {\n        concat,\n        mask (source, mask, output, offset, length) {\n            if (length < 48) _mask(source, mask, output, offset, length);\n            else bufferUtil.mask(source, mask, output, offset, length);\n        },\n        toArrayBuffer,\n        toBuffer,\n        unmask (buffer, mask) {\n            if (buffer.length < 32) _unmask(buffer, mask);\n            else bufferUtil.unmask(buffer, mask);\n        }\n    };\n} catch (e) /* istanbul ignore next */ {\n    module.exports = {\n        concat,\n        mask: _mask,\n        toArrayBuffer,\n        toBuffer,\n        unmask: _unmask\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFlBQVksRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUVqQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsT0FBT0MsSUFBSSxFQUFFQyxXQUFXO0lBQy9CLElBQUlELEtBQUtFLE1BQU0sS0FBSyxHQUFHLE9BQU9MO0lBQzlCLElBQUlHLEtBQUtFLE1BQU0sS0FBSyxHQUFHLE9BQU9GLElBQUksQ0FBQyxFQUFFO0lBRXJDLE1BQU1HLFNBQVNDLE9BQU9DLFdBQVcsQ0FBQ0o7SUFDbEMsSUFBSUssU0FBUztJQUViLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxLQUFLRSxNQUFNLEVBQUVLLElBQUs7UUFDcEMsTUFBTUMsTUFBTVIsSUFBSSxDQUFDTyxFQUFFO1FBQ25CSixPQUFPTSxHQUFHLENBQUNELEtBQUtGO1FBQ2hCQSxVQUFVRSxJQUFJTixNQUFNO0lBQ3RCO0lBRUEsSUFBSUksU0FBU0wsYUFBYSxPQUFPRSxPQUFPTyxLQUFLLENBQUMsR0FBR0o7SUFFakQsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNRLE1BQU1DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVSLE1BQU0sRUFBRUosTUFBTTtJQUNqRCxJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUwsUUFBUUssSUFBSztRQUMvQk8sTUFBTSxDQUFDUixTQUFTQyxFQUFFLEdBQUdLLE1BQU0sQ0FBQ0wsRUFBRSxHQUFHTSxJQUFJLENBQUNOLElBQUksRUFBRTtJQUM5QztBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1EsUUFBUUMsTUFBTSxFQUFFSCxJQUFJO0lBQzNCLElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJUyxPQUFPZCxNQUFNLEVBQUVLLElBQUs7UUFDdENTLE1BQU0sQ0FBQ1QsRUFBRSxJQUFJTSxJQUFJLENBQUNOLElBQUksRUFBRTtJQUMxQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1UsY0FBY1QsR0FBRztJQUN4QixJQUFJQSxJQUFJVSxVQUFVLEtBQUtWLElBQUlRLE1BQU0sQ0FBQ0UsVUFBVSxFQUFFO1FBQzVDLE9BQU9WLElBQUlRLE1BQU07SUFDbkI7SUFFQSxPQUFPUixJQUFJUSxNQUFNLENBQUNOLEtBQUssQ0FBQ0YsSUFBSVcsVUFBVSxFQUFFWCxJQUFJVyxVQUFVLEdBQUdYLElBQUlVLFVBQVU7QUFDekU7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0UsU0FBU0MsSUFBSTtJQUNwQkQsU0FBU0UsUUFBUSxHQUFHO0lBRXBCLElBQUlsQixPQUFPbUIsUUFBUSxDQUFDRixPQUFPLE9BQU9BO0lBRWxDLElBQUliO0lBRUosSUFBSWEsZ0JBQWdCRyxhQUFhO1FBQy9CaEIsTUFBTUosT0FBT3FCLElBQUksQ0FBQ0o7SUFDcEIsT0FBTyxJQUFJRyxZQUFZRSxNQUFNLENBQUNMLE9BQU87UUFDbkNiLE1BQU1KLE9BQU9xQixJQUFJLENBQUNKLEtBQUtMLE1BQU0sRUFBRUssS0FBS0YsVUFBVSxFQUFFRSxLQUFLSCxVQUFVO0lBQ2pFLE9BQU87UUFDTFYsTUFBTUosT0FBT3FCLElBQUksQ0FBQ0o7UUFDbEJELFNBQVNFLFFBQVEsR0FBRztJQUN0QjtJQUVBLE9BQU9kO0FBQ1Q7QUFFQSxJQUFJO0lBQ0YsTUFBTW1CLGFBQWE3QixtQkFBT0EsQ0FBQztJQUUzQjhCLE9BQU9DLE9BQU8sR0FBRztRQUNmOUI7UUFDQWMsTUFBS0QsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRVIsTUFBTSxFQUFFSixNQUFNO1lBQ3ZDLElBQUlBLFNBQVMsSUFBSVMsTUFBTUMsUUFBUUMsTUFBTUMsUUFBUVIsUUFBUUo7aUJBQ2hEeUIsV0FBV2QsSUFBSSxDQUFDRCxRQUFRQyxNQUFNQyxRQUFRUixRQUFRSjtRQUNyRDtRQUNBZTtRQUNBRztRQUNBVSxRQUFPZCxNQUFNLEVBQUVILElBQUk7WUFDakIsSUFBSUcsT0FBT2QsTUFBTSxHQUFHLElBQUlhLFFBQVFDLFFBQVFIO2lCQUNuQ2MsV0FBV0csTUFBTSxDQUFDZCxRQUFRSDtRQUNqQztJQUNGO0FBQ0YsRUFBRSxPQUFPa0IsR0FBRyx3QkFBd0IsR0FBRztJQUNyQ0gsT0FBT0MsT0FBTyxHQUFHO1FBQ2Y5QjtRQUNBYyxNQUFNRjtRQUNOTTtRQUNBRztRQUNBVSxRQUFRZjtJQUNWO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanM/NmNhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJFTVBUWV9CVUZGRVIiLCJyZXF1aXJlIiwiY29uY2F0IiwibGlzdCIsInRvdGFsTGVuZ3RoIiwibGVuZ3RoIiwidGFyZ2V0IiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJpIiwiYnVmIiwic2V0Iiwic2xpY2UiLCJfbWFzayIsInNvdXJjZSIsIm1hc2siLCJvdXRwdXQiLCJfdW5tYXNrIiwiYnVmZmVyIiwidG9BcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJieXRlT2Zmc2V0IiwidG9CdWZmZXIiLCJkYXRhIiwicmVhZE9ubHkiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiZnJvbSIsImlzVmlldyIsImJ1ZmZlclV0aWwiLCJtb2R1bGUiLCJleHBvcnRzIiwidW5tYXNrIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/constants.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    BINARY_TYPES: [\n        \"nodebuffer\",\n        \"arraybuffer\",\n        \"fragments\"\n    ],\n    EMPTY_BUFFER: Buffer.alloc(0),\n    GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n    kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n    kListener: Symbol(\"kListener\"),\n    kStatusCode: Symbol(\"status-code\"),\n    kWebSocket: Symbol(\"websocket\"),\n    NOOP: ()=>{}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxjQUFjO1FBQUM7UUFBYztRQUFlO0tBQVk7SUFDeERDLGNBQWNDLE9BQU9DLEtBQUssQ0FBQztJQUMzQkMsTUFBTTtJQUNOQyxzQkFBc0JDLE9BQU87SUFDN0JDLFdBQVdELE9BQU87SUFDbEJFLGFBQWFGLE9BQU87SUFDcEJHLFlBQVlILE9BQU87SUFDbkJJLE1BQU0sS0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz9kZTAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQklOQVJZX1RZUEVTIiwiRU1QVFlfQlVGRkVSIiwiQnVmZmVyIiwiYWxsb2MiLCJHVUlEIiwia0Zvck9uRXZlbnRBdHRyaWJ1dGUiLCJTeW1ib2wiLCJrTGlzdGVuZXIiLCJrU3RhdHVzQ29kZSIsImtXZWJTb2NrZXQiLCJOT09QIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/event-target.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/event-target.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\n/**\n * Class representing an event.\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */ constructor(type){\n        this[kTarget] = null;\n        this[kType] = type;\n    }\n    /**\n   * @type {*}\n   */ get target() {\n        return this[kTarget];\n    }\n    /**\n   * @type {String}\n   */ get type() {\n        return this[kType];\n    }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n    enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n    enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */ constructor(type, options = {}){\n        super(type);\n        this[kCode] = options.code === undefined ? 0 : options.code;\n        this[kReason] = options.reason === undefined ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n    }\n    /**\n   * @type {Number}\n   */ get code() {\n        return this[kCode];\n    }\n    /**\n   * @type {String}\n   */ get reason() {\n        return this[kReason];\n    }\n    /**\n   * @type {Boolean}\n   */ get wasClean() {\n        return this[kWasClean];\n    }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n    enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */ class ErrorEvent extends Event {\n    /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */ constructor(type, options = {}){\n        super(type);\n        this[kError] = options.error === undefined ? null : options.error;\n        this[kMessage] = options.message === undefined ? \"\" : options.message;\n    }\n    /**\n   * @type {*}\n   */ get error() {\n        return this[kError];\n    }\n    /**\n   * @type {String}\n   */ get message() {\n        return this[kMessage];\n    }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n    enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n    enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */ constructor(type, options = {}){\n        super(type);\n        this[kData] = options.data === undefined ? null : options.data;\n    }\n    /**\n   * @type {*}\n   */ get data() {\n        return this[kData];\n    }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n    enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */ addEventListener (type, listener, options = {}) {\n        let wrapper;\n        if (type === \"message\") {\n            wrapper = function onMessage(data, isBinary) {\n                const event = new MessageEvent(\"message\", {\n                    data: isBinary ? data : data.toString()\n                });\n                event[kTarget] = this;\n                listener.call(this, event);\n            };\n        } else if (type === \"close\") {\n            wrapper = function onClose(code, message) {\n                const event = new CloseEvent(\"close\", {\n                    code,\n                    reason: message.toString(),\n                    wasClean: this._closeFrameReceived && this._closeFrameSent\n                });\n                event[kTarget] = this;\n                listener.call(this, event);\n            };\n        } else if (type === \"error\") {\n            wrapper = function onError(error) {\n                const event = new ErrorEvent(\"error\", {\n                    error,\n                    message: error.message\n                });\n                event[kTarget] = this;\n                listener.call(this, event);\n            };\n        } else if (type === \"open\") {\n            wrapper = function onOpen() {\n                const event = new Event(\"open\");\n                event[kTarget] = this;\n                listener.call(this, event);\n            };\n        } else {\n            return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = listener;\n        if (options.once) {\n            this.once(type, wrapper);\n        } else {\n            this.on(type, wrapper);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */ removeEventListener (type, handler) {\n        for (const listener of this.listeners(type)){\n            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                this.removeListener(type, listener);\n                break;\n            }\n        }\n    }\n};\nmodule.exports = {\n    CloseEvent,\n    ErrorEvent,\n    Event,\n    EventTarget,\n    MessageEvent\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxvQkFBb0IsRUFBRUMsU0FBUyxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRXBELE1BQU1DLFFBQVFDLE9BQU87QUFDckIsTUFBTUMsUUFBUUQsT0FBTztBQUNyQixNQUFNRSxTQUFTRixPQUFPO0FBQ3RCLE1BQU1HLFdBQVdILE9BQU87QUFDeEIsTUFBTUksVUFBVUosT0FBTztBQUN2QixNQUFNSyxVQUFVTCxPQUFPO0FBQ3ZCLE1BQU1NLFFBQVFOLE9BQU87QUFDckIsTUFBTU8sWUFBWVAsT0FBTztBQUV6Qjs7Q0FFQyxHQUNELE1BQU1RO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0wsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHSTtJQUNoQjtJQUVBOztHQUVDLEdBQ0QsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDTixRQUFRO0lBQ3RCO0lBRUE7O0dBRUMsR0FDRCxJQUFJSyxPQUFPO1FBQ1QsT0FBTyxJQUFJLENBQUNKLE1BQU07SUFDcEI7QUFDRjtBQUVBTSxPQUFPQyxjQUFjLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxVQUFVO0lBQUVDLFlBQVk7QUFBSztBQUNwRUgsT0FBT0MsY0FBYyxDQUFDTCxNQUFNTSxTQUFTLEVBQUUsUUFBUTtJQUFFQyxZQUFZO0FBQUs7QUFFbEU7Ozs7Q0FJQyxHQUNELE1BQU1DLG1CQUFtQlI7SUFDdkI7Ozs7Ozs7Ozs7OztHQVlDLEdBQ0RDLFlBQVlDLElBQUksRUFBRU8sVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUM5QixLQUFLLENBQUNQO1FBRU4sSUFBSSxDQUFDWCxNQUFNLEdBQUdrQixRQUFRQyxJQUFJLEtBQUtDLFlBQVksSUFBSUYsUUFBUUMsSUFBSTtRQUMzRCxJQUFJ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LENBQUNwQyxNQUFNbUI7Z0JBQzFCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQWtCLE9BQU9DLE9BQU8sR0FBRztJQUNmaEM7SUFDQU07SUFDQWQ7SUFDQW1CO0lBQ0FGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzPzJmNjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGtGb3JPbkV2ZW50QXR0cmlidXRlLCBrTGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtDb2RlID0gU3ltYm9sKCdrQ29kZScpO1xuY29uc3Qga0RhdGEgPSBTeW1ib2woJ2tEYXRhJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2tFcnJvcicpO1xuY29uc3Qga01lc3NhZ2UgPSBTeW1ib2woJ2tNZXNzYWdlJyk7XG5jb25zdCBrUmVhc29uID0gU3ltYm9sKCdrUmVhc29uJyk7XG5jb25zdCBrVGFyZ2V0ID0gU3ltYm9sKCdrVGFyZ2V0Jyk7XG5jb25zdCBrVHlwZSA9IFN5bWJvbCgna1R5cGUnKTtcbmNvbnN0IGtXYXNDbGVhbiA9IFN5bWJvbCgna1dhc0NsZWFuJyk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGV2ZW50LlxuICovXG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGB0eXBlYCBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpc1trVGFyZ2V0XSA9IG51bGw7XG4gICAgdGhpc1trVHlwZV0gPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpc1trVGFyZ2V0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba1R5cGVdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0YXJnZXQnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndHlwZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjbG9zZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29kZT0wXSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbj0nJ10gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHlcbiAgICogICAgIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trQ29kZV0gPSBvcHRpb25zLmNvZGUgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmNvZGU7XG4gICAgdGhpc1trUmVhc29uXSA9IG9wdGlvbnMucmVhc29uID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMucmVhc29uO1xuICAgIHRoaXNba1dhc0NsZWFuXSA9IG9wdGlvbnMud2FzQ2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy53YXNDbGVhbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NvZGVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzW2tSZWFzb25dO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHdhc0NsZWFuKCkge1xuICAgIHJldHVybiB0aGlzW2tXYXNDbGVhbl07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnY29kZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3JlYXNvbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ3dhc0NsZWFuJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBlcnJvciBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmVycm9yPW51bGxdIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlPScnXSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzW2tNZXNzYWdlXSA9IG9wdGlvbnMubWVzc2FnZSA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXNba01lc3NhZ2VdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ2Vycm9yJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnbWVzc2FnZScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBtZXNzYWdlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmRhdGE9bnVsbF0gVGhlIG1lc3NhZ2UgY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tEYXRhXSA9IG9wdGlvbnMuZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzW2tEYXRhXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgJ2RhdGEnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogVGhpcyBwcm92aWRlcyBtZXRob2RzIGZvciBlbXVsYXRpbmcgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLiBJdCdzIG5vdFxuICogbWVhbnQgdG8gYmUgdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBAbWl4aW5cbiAqL1xuY29uc3QgRXZlbnRUYXJnZXQgPSB7XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGxpc3RlbmVyO1xuXG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgdGhpcy5vbmNlKHR5cGUsIHdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG4gICAgICBpZiAobGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBFdmVudCxcbiAgRXZlbnRUYXJnZXQsXG4gIE1lc3NhZ2VFdmVudFxufTtcbiJdLCJuYW1lcyI6WyJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsInJlcXVpcmUiLCJrQ29kZSIsIlN5bWJvbCIsImtEYXRhIiwia0Vycm9yIiwia01lc3NhZ2UiLCJrUmVhc29uIiwia1RhcmdldCIsImtUeXBlIiwia1dhc0NsZWFuIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJ0YXJnZXQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJDbG9zZUV2ZW50Iiwib3B0aW9ucyIsImNvZGUiLCJ1bmRlZmluZWQiLCJyZWFzb24iLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJlcnJvciIsIm1lc3NhZ2UiLCJNZXNzYWdlRXZlbnQiLCJkYXRhIiwiRXZlbnRUYXJnZXQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJ3cmFwcGVyIiwib25NZXNzYWdlIiwiaXNCaW5hcnkiLCJldmVudCIsInRvU3RyaW5nIiwiY2FsbCIsIm9uQ2xvc2UiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50Iiwib25FcnJvciIsIm9uT3BlbiIsIm9uY2UiLCJvbiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/extension.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/extension.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (dest[name] === undefined) dest[name] = [\n        elem\n    ];\n    else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = Object.create(null);\n    let params = Object.create(null);\n    let mustUnescape = false;\n    let isEscaping = false;\n    let inQuotes = false;\n    let extensionName;\n    let paramName;\n    let start = -1;\n    let code = -1;\n    let end = -1;\n    let i = 0;\n    for(; i < header.length; i++){\n        code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = Object.create(null);\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                let value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, params);\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */ function format(extensions) {\n    return Object.keys(extensions).map((extension)=>{\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [\n            configurations\n        ];\n        return configurations.map((params)=>{\n            return [\n                extension\n            ].concat(Object.keys(params).map((k)=>{\n                let values = params[k];\n                if (!Array.isArray(values)) values = [\n                    values\n                ];\n                return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvZXh0ZW5zaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxVQUFVLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFL0I7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0MsS0FBS0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFDNUIsSUFBSUYsSUFBSSxDQUFDQyxLQUFLLEtBQUtFLFdBQVdILElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQUNDO0tBQUs7U0FDNUNGLElBQUksQ0FBQ0MsS0FBSyxDQUFDRixJQUFJLENBQUNHO0FBQ3ZCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0UsTUFBTUMsTUFBTTtJQUNuQixNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUM7SUFDN0IsSUFBSUMsU0FBU0YsT0FBT0MsTUFBTSxDQUFDO0lBQzNCLElBQUlFLGVBQWU7SUFDbkIsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxXQUFXO0lBQ2YsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDLFFBQVEsQ0FBQztJQUNiLElBQUlDLE9BQU8sQ0FBQztJQUNaLElBQUlDLE1BQU0sQ0FBQztJQUNYLElBQUlDLElBQUk7SUFFUixNQUFPQSxJQUFJYixPQUFPYyxNQUFNLEVBQUVELElBQUs7UUFDN0JGLE9BQU9YLE9BQU9lLFVBQVUsQ0FBQ0Y7UUFFekIsSUFBSUwsa0JBQWtCVixXQUFXO1lBQy9CLElBQUljLFFBQVEsQ0FBQyxLQUFLcEIsVUFBVSxDQUFDbUIsS0FBSyxLQUFLLEdBQUc7Z0JBQ3hDLElBQUlELFVBQVUsQ0FBQyxHQUFHQSxRQUFRRztZQUM1QixPQUFPLElBQ0xBLE1BQU0sS0FDTEYsQ0FBQUEsU0FBUyxLQUFLLE9BQU8sT0FBTUEsU0FBUyxJQUFHLEdBQ3hDO2dCQUNBLElBQUlDLFFBQVEsQ0FBQyxLQUFLRixVQUFVLENBQUMsR0FBR0UsTUFBTUM7WUFDeEMsT0FBTyxJ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L3dzL2xpYi9leHRlbnNpb24uanM/Mzk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwdXNoIiwiZGVzdCIsIm5hbWUiLCJlbGVtIiwidW5kZWZpbmVkIiwicGFyc2UiLCJoZWFkZXIiLCJvZmZlcnMiLCJPYmplY3QiLCJjcmVhdGUiLCJwYXJhbXMiLCJtdXN0VW5lc2NhcGUiLCJpc0VzY2FwaW5nIiwiaW5RdW90ZXMiLCJleHRlbnNpb25OYW1lIiwicGFyYW1OYW1lIiwic3RhcnQiLCJjb2RlIiwiZW5kIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInNsaWNlIiwidmFsdWUiLCJyZXBsYWNlIiwidG9rZW4iLCJmb3JtYXQiLCJleHRlbnNpb25zIiwia2V5cyIsIm1hcCIsImV4dGVuc2lvbiIsImNvbmZpZ3VyYXRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwiayIsInZhbHVlcyIsInYiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/limiter.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/limiter.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */ class Limiter {\n    /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */ constructor(concurrency){\n        this[kDone] = ()=>{\n            this.pending--;\n            this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n    }\n    /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */ add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n    }\n    /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */ [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n            const job = this.jobs.shift();\n            this.pending++;\n            job(this[kDone]);\n        }\n    }\n}\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFFBQVFDLE9BQU87QUFDckIsTUFBTUMsT0FBT0QsT0FBTztBQUVwQjs7O0NBR0MsR0FDRCxNQUFNRTtJQUNKOzs7OztHQUtDLEdBQ0RDLFlBQVlDLFdBQVcsQ0FBRTtRQUN2QixJQUFJLENBQUNMLE1BQU0sR0FBRztZQUNaLElBQUksQ0FBQ00sT0FBTztZQUNaLElBQUksQ0FBQ0osS0FBSztRQUNaO1FBQ0EsSUFBSSxDQUFDRyxXQUFXLEdBQUdBLGVBQWVFO1FBQ2xDLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7UUFDZCxJQUFJLENBQUNGLE9BQU8sR0FBRztJQUNqQjtJQUVBOzs7OztHQUtDLEdBQ0RHLElBQUlDLEdBQUcsRUFBRTtRQUNQLElBQUksQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNEO1FBQ2YsSUFBSSxDQUFDUixLQUFLO0lBQ1o7SUFFQTs7OztHQUlDLEdBQ0QsQ0FBQ0EsS0FBSyxHQUFHO1FBQ1AsSUFBSSxJQUFJLENBQUNJLE9BQU8sS0FBSyxJQUFJLENBQUNELFdBQVcsRUFBRTtRQUV2QyxJQUFJLElBQUksQ0FBQ0csSUFBSSxDQUFDSSxNQUFNLEVBQUU7WUFDcEIsTUFBTUYsTUFBTSxJQUFJLENBQUNGLElBQUksQ0FBQ0ssS0FBSztZQUUzQixJQUFJLENBQUNQLE9BQU87WUFDWkksSUFBSSxJQUFJLENBQUNWLE1BQU07UUFDakI7SUFDRjtBQUNGO0FBRUFjLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcz9kMzM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qga0RvbmUgPSBTeW1ib2woJ2tEb25lJyk7XG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXG4gKi9cbmNsYXNzIExpbWl0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgTGltaXRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcbiAgICogICAgIHRvIHJ1biBjb25jdXJyZW50bHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG4gICAgdGhpc1trRG9uZV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgIHRoaXNba1J1bl0oKTtcbiAgICB9O1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmpvYnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKGpvYikge1xuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XG4gICAgdGhpc1trUnVuXSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUgYW5kIHJ1bnMgaXQgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBba1J1bl0oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuXG4gICAgICB0aGlzLnBlbmRpbmcrKztcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcbiJdLCJuYW1lcyI6WyJrRG9uZSIsIlN5bWJvbCIsImtSdW4iLCJMaW1pdGVyIiwiY29uc3RydWN0b3IiLCJjb25jdXJyZW5jeSIsInBlbmRpbmciLCJJbmZpbml0eSIsImpvYnMiLCJhZGQiLCJqb2IiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter(concurrency);\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            this._inflate.close();\n            this._inflate = null;\n        }\n        if (this._deflate) {\n            const callback = this._deflate[kCallback];\n            this._deflate.close();\n            this._deflate = null;\n            if (callback) {\n                callback(new Error(\"The deflate stream was closed while data was being processed\"));\n            }\n        }\n    }\n    /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params)=>{\n            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return false;\n            }\n            return true;\n        });\n        if (!accepted) {\n            throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n            accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n            accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n            accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n            accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n            delete accepted.client_max_window_bits;\n        }\n        return accepted;\n    }\n    /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n            throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */ normalizeParams(configurations) {\n        configurations.forEach((params)=>{\n            Object.keys(params).forEach((key)=>{\n                let value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Parameter \"${key}\" must have only a single value`);\n                }\n                value = value[0];\n                if (key === \"client_max_window_bits\") {\n                    if (value !== true) {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (!this._isServer) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else if (key === \"server_max_window_bits\") {\n                    const num = +value;\n                    if (!Number.isInteger(num) || num < 8 || num > 15) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                    value = num;\n                } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                    if (value !== true) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else {\n                    throw new Error(`Unknown parameter \"${key}\"`);\n                }\n                params[key] = value;\n            });\n        });\n        return configurations;\n    }\n    /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                ...this._options.zlibInflateOptions,\n                windowBits\n            });\n            this._inflate[kPerMessageDeflate] = this;\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (this._inflate._readableState.endEmitted) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._inflate.reset();\n                }\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                ...this._options.zlibDeflateOptions,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            if (!this._deflate) {\n                //\n                // The deflate stream was closed while data was being processed.\n                //\n                return;\n            }\n            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) data = data.slice(0, data.length - 4);\n            //\n            // Ensure that the callback will not be called again in\n            // `PerMessageDeflate#cleanup()`.\n            //\n            this._deflate[kCallback] = null;\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                this._deflate.reset();\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new RangeError(\"Max payload size exceeded\");\n    this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n    this[kError][kStatusCode] = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kPerMessageDeflate]._inflate = null;\n    err[kStatusCode] = 1007;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFFckIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDeEIsTUFBTSxFQUFFRyxXQUFXLEVBQUUsR0FBR0gsbUJBQU9BLENBQUM7QUFFaEMsTUFBTUksVUFBVUMsT0FBT0MsSUFBSSxDQUFDO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBSztBQUNwRCxNQUFNQyxxQkFBcUJDLE9BQU87QUFDbEMsTUFBTUMsZUFBZUQsT0FBTztBQUM1QixNQUFNRSxZQUFZRixPQUFPO0FBQ3pCLE1BQU1HLFdBQVdILE9BQU87QUFDeEIsTUFBTUksU0FBU0osT0FBTztBQUV0QixFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHFGQUFxRjtBQUNyRixtREFBbUQ7QUFDbkQsRUFBRTtBQUNGLHFFQUFxRTtBQUNyRSxFQUFFO0FBQ0YsSUFBSUs7QUFFSjs7Q0FFQyxHQUNELE1BQU1DO0lBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUJDLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLENBQUU7UUFDekMsSUFBSSxDQUFDQyxXQUFXLEdBQUdELGFBQWE7UUFDaEMsSUFBSSxDQUFDRSxRQUFRLEdBQUdKLFdBQVcsQ0FBQztRQUM1QixJQUFJLENBQUNLLFVBQVUsR0FDYixJQUFJLENBQUNELFFBQVEsQ0FBQ0UsU0FBUyxLQUFLQyxZQUFZLElBQUksQ0FBQ0gsUUFBUSxDQUFDRSxTQUFTLEdBQUc7UUFDcEUsSUFBSSxDQUFDRSxTQUFTLEdBQUcsQ0FBQyxDQUFDUDtRQUNuQixJQUFJLENBQUNRLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUVoQixJQUFJLENBQUNDLE1BQU0sR0FBRztR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SSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQ1QsWUFBWSxHQUFHO0lBQzVCLElBQUksQ0FBQ2dHLGNBQWMsQ0FBQyxRQUFRbEI7SUFDNUIsSUFBSSxDQUFDTSxLQUFLO0FBQ1o7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNQLGVBQWVWLEdBQUc7SUFDekIsRUFBRTtJQUNGLHlFQUF5RTtJQUN6RSxtQ0FBbUM7SUFDbkMsRUFBRTtJQUNGLElBQUksQ0FBQy9ELG1CQUFtQixDQUFDbUIsUUFBUSxHQUFHO0lBQ3BDNEMsR0FBRyxDQUFDbkUsWUFBWSxHQUFHO0lBQ25CLElBQUksQ0FBQ08sVUFBVSxDQUFDNEQ7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzPzA5NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxuICAgICAgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29wdGlvbnMudGhyZXNob2xkIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgICA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgICB0aGlzLl9pbmZsYXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gNCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiJdLCJuYW1lcyI6WyJ6bGliIiwicmVxdWlyZSIsImJ1ZmZlclV0aWwiLCJMaW1pdGVyIiwia1N0YXR1c0NvZGUiLCJUUkFJTEVSIiwiQnVmZmVyIiwiZnJvbSIsImtQZXJNZXNzYWdlRGVmbGF0ZSIsIlN5bWJvbCIsImtUb3RhbExlbmd0aCIsImtDYWxsYmFjayIsImtCdWZmZXJzIiwia0Vycm9yIiwiemxpYkxpbWl0ZXIiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsIl9tYXhQYXlsb2FkIiwiX29wdGlvbnMiLCJfdGhyZXNob2xkIiwidGhyZXNob2xkIiwidW5kZWZpbmVkIiwiX2lzU2VydmVyIiwiX2RlZmxhdGUiLCJfaW5mbGF0ZSIsInBhcmFtcyIsImNvbmN1cnJlbmN5IiwiY29uY3VycmVuY3lMaW1pdCIsImV4dGVuc2lvbk5hbWUiLCJvZmZlciIsInNlcnZlck5vQ29udGV4dFRha2VvdmVyIiwic2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIiLCJjbGllbnROb0NvbnRleHRUYWtlb3ZlciIsImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyIiwic2VydmVyTWF4V2luZG93Qml0cyIsInNlcnZlcl9tYXhfd2luZG93X2JpdHMiLCJjbGllbnRNYXhXaW5kb3dCaXRzIiwiY2xpZW50X21heF93aW5kb3dfYml0cyIsImFjY2VwdCIsImNvbmZpZ3VyYXRpb25zIiwibm9ybWFsaXplUGFyYW1zIiwiYWNjZXB0QXNTZXJ2ZXIiLCJhY2NlcHRBc0NsaWVudCIsImNsZWFudXAiLCJjbG9zZSIsImNhbGxiYWNrIiwiRXJyb3IiLCJvZmZlcnMiLCJvcHRzIiwiYWNjZXB0ZWQiLCJmaW5kIiwicmVzcG9uc2UiLCJmb3JFYWNoIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsInZhbHVlIiwibGVuZ3RoIiwibnVtIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiVHlwZUVycm9yIiwiZGVjb21wcmVzcyIsImRhdGEiLCJmaW4iLCJhZGQiLCJkb25lIiwiX2RlY29tcHJlc3MiLCJlcnIiLCJyZXN1bHQiLCJjb21wcmVzcyIsIl9jb21wcmVzcyIsImVuZHBvaW50Iiwid2luZG93Qml0cyIsIlpfREVGQVVMVF9XSU5ET1dCSVRTIiwiY3JlYXRlSW5mbGF0ZVJhdyIsInpsaWJJbmZsYXRlT3B0aW9ucyIsIm9uIiwiaW5mbGF0ZU9uRXJyb3IiLCJpbmZsYXRlT25EYXRhIiwid3JpdGUiLCJmbHVzaCIsImNvbmNhdCIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsInJlc2V0IiwiY3JlYXRlRGVmbGF0ZVJhdyIsInpsaWJEZWZsYXRlT3B0aW9ucyIsImRlZmxhdGVPbkRhdGEiLCJaX1NZTkNfRkxVU0giLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjaHVuayIsInB1c2giLCJSYW5nZUVycm9yIiwiY29kZSIsInJlbW92ZUxpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/receiver.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/receiver.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */ class Receiver extends Writable {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */ constructor(options = {}){\n        super();\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = undefined;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = undefined;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._state = GET_INFO;\n        this._loop = false;\n    }\n    /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */ _write(chunk, encoding, cb) {\n        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n    }\n    /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */ consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n            const buf = this._buffers[0];\n            this._buffers[0] = buf.slice(n);\n            return buf.slice(0, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n            const buf = this._buffers[0];\n            const offset = dst.length - n;\n            if (n >= buf.length) {\n                dst.set(this._buffers.shift(), offset);\n            } else {\n                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                this._buffers[0] = buf.slice(n);\n            }\n            n -= buf.length;\n        }while (n > 0);\n        return dst;\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ startLoop(cb) {\n        let err;\n        this._loop = true;\n        do {\n            switch(this._state){\n                case GET_INFO:\n                    err = this.getInfo();\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    err = this.getPayloadLength16();\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    err = this.getPayloadLength64();\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    err = this.getData(cb);\n                    break;\n                default:\n                    // `INFLATING`\n                    this._loop = false;\n                    return;\n            }\n        }while (this._loop);\n        cb(err);\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getInfo() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            this._loop = false;\n            return error(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            this._loop = false;\n            return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (!this._fragmented) {\n                this._loop = false;\n                return error(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._opcode = this._fragmented;\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                this._loop = false;\n                return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                this._loop = false;\n                return error(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n            }\n            if (compressed) {\n                this._loop = false;\n                return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            }\n            if (this._payloadLength > 0x7d) {\n                this._loop = false;\n                return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n            }\n        } else {\n            this._loop = false;\n            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._isServer) {\n            if (!this._masked) {\n                this._loop = false;\n                return error(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n            }\n        } else if (this._masked) {\n            this._loop = false;\n            return error(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength16() {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        return this.haveLength();\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ getPayloadLength64() {\n        if (this._bufferedBytes < 8) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            this._loop = false;\n            return error(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        return this.haveLength();\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */ haveLength() {\n        if (this._payloadLength && this._opcode < 0x08) {\n            this._totalPayloadLength += this._payloadLength;\n            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                this._loop = false;\n                return error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n            }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (this._bufferedBytes < 4) {\n            this._loop = false;\n            return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (this._bufferedBytes < this._payloadLength) {\n                this._loop = false;\n                return;\n            }\n            data = this.consume(this._payloadLength);\n            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                unmask(data, this._mask);\n            }\n        }\n        if (this._opcode > 0x07) return this.controlMessage(data);\n        if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data, cb);\n            return;\n        }\n        if (data.length) {\n            //\n            // This message is not compressed so its length is the sum of the payload\n            // length of all fragments.\n            //\n            this._messageLength = this._totalPayloadLength;\n            this._fragments.push(data);\n        }\n        return this.dataMessage();\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */ decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) return cb(err);\n            if (buf.length) {\n                this._messageLength += buf.length;\n                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                    return cb(error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"));\n                }\n                this._fragments.push(buf);\n            }\n            const er = this.dataMessage();\n            if (er) return cb(er);\n            this.startLoop(cb);\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */ dataMessage() {\n        if (this._fin) {\n            const messageLength = this._messageLength;\n            const fragments = this._fragments;\n            this._totalPayloadLength = 0;\n            this._messageLength = 0;\n            this._fragmented = 0;\n            this._fragments = [];\n            if (this._opcode === 2) {\n                let data;\n                if (this._binaryType === \"nodebuffer\") {\n                    data = concat(fragments, messageLength);\n                } else if (this._binaryType === \"arraybuffer\") {\n                    data = toArrayBuffer(concat(fragments, messageLength));\n                } else {\n                    data = fragments;\n                }\n                this.emit(\"message\", data, true);\n            } else {\n                const buf = concat(fragments, messageLength);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    this._loop = false;\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"message\", buf, false);\n            }\n        }\n        this._state = GET_INFO;\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ controlMessage(data) {\n        if (this._opcode === 0x08) {\n            this._loop = false;\n            if (data.length === 0) {\n                this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n                this.end();\n            } else if (data.length === 1) {\n                return error(RangeError, \"invalid payload length 1\", true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n            } else {\n                const code = data.readUInt16BE(0);\n                if (!isValidStatusCode(code)) {\n                    return error(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                }\n                const buf = data.slice(2);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                }\n                this.emit(\"conclude\", code, buf);\n                this.end();\n            }\n        } else if (this._opcode === 0x09) {\n            this.emit(\"ping\", data);\n        } else {\n            this.emit(\"pong\", data);\n        }\n        this._state = GET_INFO;\n    }\n}\nmodule.exports = Receiver;\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */ function error(ErrorCtor, message, prefix, statusCode, errorCode) {\n    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n    Error.captureStackTrace(err, error);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFFBQVEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUU3QixNQUFNQyxvQkFBb0JELG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU0sRUFDSkUsWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLFdBQVcsRUFDWEMsVUFBVSxFQUNYLEdBQUdMLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGFBQWEsRUFBRUMsTUFBTSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ2xELE1BQU0sRUFBRVMsaUJBQWlCLEVBQUVDLFdBQVcsRUFBRSxHQUFHVixtQkFBT0EsQ0FBQztBQUVuRCxNQUFNVyxXQUFXO0FBQ2pCLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyx3QkFBd0I7QUFDOUIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFlBQVk7QUFFbEI7Ozs7Q0FJQyxHQUNELE1BQU1DLGlCQUFpQmxCO0lBQ3JCOzs7Ozs7Ozs7Ozs7R0FZQyxHQUNEbUIsWUFBWUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN4QixLQUFLO1FBRUwsSUFBSSxDQUFDQyxXQUFXLEdBQUdELFFBQVFFLFVBQVUsSUFBSW5CLFlBQVksQ0FBQyxFQUFFO1FBQ3hELElBQUksQ0FBQ29CLFdBQVcsR0FBR0gsUUFBUUksVUFBVSxJQUFJLENBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxDQUFDTCxRQUFRTSxRQUFRO1FBQ25DLElBQUksQ0FBQ0MsV0FBVyxHQUFHUCxRQUFRUSxVQUFVLEdBQUc7UUFDeEMsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxDQUFDLENBQUNULFFBQVFVLGtCQUFrQjtRQUN2RCxJQUFJLENBQUN4QixXQUFXLEdBQUd5QjtRQUVuQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0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QyxZQUFZRyxNQUFNckM7Z0JBQzVCLElBQUksQ0FBQ29DLEdBQUc7WUFDVjtRQUNGLE9BQU8sSUFBSSxJQUFJLENBQUNwRCxPQUFPLEtBQUssTUFBTTtZQUNoQyxJQUFJLENBQUNrRCxJQUFJLENBQUMsUUFBUVI7UUFDcEIsT0FBTztZQUNMLElBQUksQ0FBQ1EsSUFBSSxDQUFDLFFBQVFSO1FBQ3BCO1FBRUEsSUFBSSxDQUFDdEMsTUFBTSxHQUFHaEM7SUFDaEI7QUFDRjtBQUVBa0YsT0FBT0MsT0FBTyxHQUFHN0U7QUFFakI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTc0QsTUFBTXdCLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUM5RCxNQUFNbEMsTUFBTSxJQUFJOEIsVUFDZEUsU0FBUyxDQUFDLHlCQUF5QixFQUFFRCxRQUFRLENBQUMsR0FBR0E7SUFHbkROLE1BQU1VLGlCQUFpQixDQUFDbkMsS0FBS007SUFDN0JOLElBQUkyQixJQUFJLEdBQUdPO0lBQ1hsQyxHQUFHLENBQUM3RCxZQUFZLEdBQUc4RjtJQUNuQixPQUFPakM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcz9jN2MwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDAsIG4pO1xuICAgIH1cblxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcblxuICAgICAgaWYgKG4gPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICBkc3Quc2V0KHRoaXMuX2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIG4pLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIGxldCBlcnI7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBgSU5GTEFUSU5HYFxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBjYihlcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoMik7XG5cbiAgICBpZiAoKGJ1ZlswXSAmIDB4MzApICE9PSAweDAwKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YyIGFuZCBSU1YzIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzJfMydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBvcGNvZGUgMCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDEgfHwgdGhpcy5fb3Bjb2RlID09PSAweDAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgcGF5bG9hZCBsZW5ndGggJHt0aGlzLl9wYXlsb2FkTGVuZ3RofWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01BU0sgbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX01BU0snXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tYXNrZWQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ01BU0sgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9NQVNLJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrMTYpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXREYXRhKGNiKSB7XG4gICAgbGV0IGRhdGEgPSBFTVBUWV9CVUZGRVI7XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCB0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX21hc2tlZCAmJlxuICAgICAgICAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiJdLCJuYW1lcyI6WyJXcml0YWJsZSIsInJlcXVpcmUiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsImNvbmNhdCIsInRvQXJyYXlCdWZmZXIiLCJ1bm1hc2siLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImlzVmFsaWRVVEY4IiwiR0VUX0lORk8iLCJHRVRfUEFZTE9BRF9MRU5HVEhfMTYiLCJHRVRfUEFZTE9BRF9MRU5HVEhfNjQiLCJHRVRfTUFTSyIsIkdFVF9EQVRBIiwiSU5GTEFUSU5HIiwiUmVjZWl2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlciIsIl9tYXhQYXlsb2FkIiwibWF4UGF5bG9hZCIsIl9za2lwVVRGOFZhbGlkYXRpb24iLCJza2lwVVRGOFZhbGlkYXRpb24iLCJ1bmRlZmluZWQiLCJfYnVmZmVyZWRCeXRlcyIsIl9idWZmZXJzIiwiX2NvbXByZXNzZWQiLCJfcGF5bG9hZExlbmd0aCIsIl9tYXNrIiwiX2ZyYWdtZW50ZWQiLCJfbWFza2VkIiwiX2ZpbiIsIl9vcGNvZGUiLCJfdG90YWxQYXlsb2FkTGVuZ3RoIiwiX21lc3NhZ2VMZW5ndGgiLCJfZnJhZ21lbnRzIiwiX3N0YXRlIiwiX2xvb3AiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJsZW5ndGgiLCJwdXNoIiwic3RhcnRMb29wIiwiY29uc3VtZSIsIm4iLCJzaGlmdCIsImJ1ZiIsInNsaWNlIiwiZHN0IiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJvZmZzZXQiLCJzZXQiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImVyciIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImVycm9yIiwiUmFuZ2VFcnJvciIsImNvbXByZXNzZWQiLCJleHRlbnNpb25OYW1lIiwiaGF2ZUxlbmd0aCIsInJlYWRVSW50MTZCRSIsIm51bSIsInJlYWRVSW50MzJCRSIsIk1hdGgiLCJwb3ciLCJkYXRhIiwiY29udHJvbE1lc3NhZ2UiLCJkZWNvbXByZXNzIiwiZGF0YU1lc3NhZ2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImVyIiwibWVzc2FnZUxlbmd0aCIsImZyYWdtZW50cyIsImVtaXQiLCJFcnJvciIsImVuZCIsImNvZGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiRXJyb3JDdG9yIiwibWVzc2FnZSIsInByZWZpeCIsInN0YXR1c0NvZGUiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/sender.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/sender.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */ \nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst { isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._deflating = false;\n        this._queue = [];\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                randomFillSync(mask, 0, 4);\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (this._deflating) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        if (perMessageDeflate) {\n            const opts = {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1\n            };\n            if (this._deflating) {\n                this.enqueue([\n                    this.dispatch,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.dispatch(data, this._compress, opts, cb);\n            }\n        } else {\n            this.sendFrame(Sender.frame(data, {\n                [kByteLength]: byteLength,\n                fin: options.fin,\n                generateMask: this._generateMask,\n                mask: options.mask,\n                maskBuffer: this._maskBuffer,\n                opcode,\n                readOnly,\n                rsv1: false\n            }), cb);\n        }\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._deflating = true;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                if (typeof cb === \"function\") cb(err);\n                for(let i = 0; i < this._queue.length; i++){\n                    const params = this._queue[i];\n                    const callback = params[params.length - 1];\n                    if (typeof callback === \"function\") callback(err);\n                }\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._deflating = false;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(!this._deflating && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRSxHQUUxRTtBQUVBLE1BQU1BLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRUUsY0FBYyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBRW5DLE1BQU1HLG9CQUFvQkgsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUFFSSxZQUFZLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFFSyxpQkFBaUIsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUN0QyxNQUFNLEVBQUVNLE1BQU1DLFNBQVMsRUFBRUMsUUFBUSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBRTlDLE1BQU1TLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsYUFBYUMsT0FBT0MsS0FBSyxDQUFDO0FBRWhDOztDQUVDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7OztHQU9DLEdBQ0RDLFlBQVlDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLENBQUU7UUFDNUMsSUFBSSxDQUFDQyxXQUFXLEdBQUdGLGNBQWMsQ0FBQztRQUVsQyxJQUFJQyxjQUFjO1lBQ2hCLElBQUksQ0FBQ0UsYUFBYSxHQUFHRjtZQUNyQixJQUFJLENBQUNHLFdBQVcsR0FBR1QsT0FBT0MsS0FBSyxDQUFDO1FBQ2xDO1FBRUEsSUFBSSxDQUFDUyxPQUFPLEdBQUdOO1FBRWYsSUFBSSxDQUFDTyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQyxHQUNELE9BQU9DLE1BQU1DLElBQUksRUFB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YyxJQUFJeUMsTUFBTSxDQUFDLEVBQUUsQ0FBQ3pELFlBQVk7WUFDN0NxRSxRQUFRQyxLQUFLLENBQUNiLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFQSxPQUFPYyxLQUFLLENBQUM7UUFDOUM7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0R4QixRQUFRVSxNQUFNLEVBQUU7UUFDZCxJQUFJLENBQUN6QyxjQUFjLElBQUl5QyxNQUFNLENBQUMsRUFBRSxDQUFDekQsWUFBWTtRQUM3QyxJQUFJLENBQUNrQixNQUFNLENBQUNzRCxJQUFJLENBQUNmO0lBQ25CO0lBRUE7Ozs7OztHQU1DLEdBQ0RSLFVBQVV3QixJQUFJLEVBQUVqQyxFQUFFLEVBQUU7UUFDbEIsSUFBSWlDLEtBQUs3QyxNQUFNLEtBQUssR0FBRztZQUNyQixJQUFJLENBQUNmLE9BQU8sQ0FBQzZELElBQUk7WUFDakIsSUFBSSxDQUFDN0QsT0FBTyxDQUFDZ0MsS0FBSyxDQUFDNEIsSUFBSSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDNUQsT0FBTyxDQUFDZ0MsS0FBSyxDQUFDNEIsSUFBSSxDQUFDLEVBQUUsRUFBRWpDO1lBQzVCLElBQUksQ0FBQzNCLE9BQU8sQ0FBQzhELE1BQU07UUFDckIsT0FBTztZQUNMLElBQUksQ0FBQzlELE9BQU8sQ0FBQ2dDLEtBQUssQ0FBQzRCLElBQUksQ0FBQyxFQUFFLEVBQUVqQztRQUM5QjtJQUNGO0FBQ0Y7QUFFQW9DLE9BQU9DLE9BQU8sR0FBR3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcz82MjJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3Qga0J5dGVMZW5ndGggPSBTeW1ib2woJ2tCeXRlTGVuZ3RoJyk7XG5jb25zdCBtYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5kb21GaWxsU3luYyhtYXNrLCAwLCA0KTtcbiAgICAgIH1cblxuICAgICAgc2tpcE1hc2tpbmcgPSAobWFza1swXSB8IG1hc2tbMV0gfCBtYXNrWzJdIHwgbWFza1szXSkgPT09IDA7XG4gICAgICBvZmZzZXQgPSA2O1xuICAgIH1cblxuICAgIGxldCBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFxuICAgICAgICAoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiZcbiAgICAgICAgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZExlbmd0aCA9IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAoZGF0YUxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhTGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0WzJdID0gdGFyZ2V0WzNdID0gMDtcbiAgICAgIHRhcmdldC53cml0ZVVJbnRCRShkYXRhTGVuZ3RoLCA0LCA2KTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubWFzaykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChza2lwTWFza2luZykgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuXG4gICAgaWYgKG1lcmdlKSB7XG4gICAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgdGFyZ2V0LCBvZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhTGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBidWYubGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA5LFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIHJlYWRPbmx5LFxuICAgICAgICByc3YxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgcmVhZE9ubHksXG4gICAgICAgICAgcnN2MTogZmFsc2VcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZVtpXTtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKCF0aGlzLl9kZWZsYXRpbmcgJiYgdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgICBSZWZsZWN0LmFwcGx5KHBhcmFtc1swXSwgdGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlKHBhcmFtcykge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBmcmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcbiJdLCJuYW1lcyI6WyJuZXQiLCJyZXF1aXJlIiwidGxzIiwicmFuZG9tRmlsbFN5bmMiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkVNUFRZX0JVRkZFUiIsImlzVmFsaWRTdGF0dXNDb2RlIiwibWFzayIsImFwcGx5TWFzayIsInRvQnVmZmVyIiwia0J5dGVMZW5ndGgiLCJTeW1ib2wiLCJtYXNrQnVmZmVyIiwiQnVmZmVyIiwiYWxsb2MiLCJTZW5kZXIiLCJjb25zdHJ1Y3RvciIsInNvY2tldCIsImV4dGVuc2lvbnMiLCJnZW5lcmF0ZU1hc2siLCJfZXh0ZW5zaW9ucyIsIl9nZW5lcmF0ZU1hc2siLCJfbWFza0J1ZmZlciIsIl9zb2NrZXQiLCJfZmlyc3RGcmFnbWVudCIsIl9jb21wcmVzcyIsIl9idWZmZXJlZEJ5dGVzIiwiX2RlZmxhdGluZyIsIl9xdWV1ZSIsImZyYW1lIiwiZGF0YSIsIm9wdGlvbnMiLCJtZXJnZSIsIm9mZnNldCIsInNraXBNYXNraW5nIiwiZGF0YUxlbmd0aCIsInVuZGVmaW5lZCIsImZyb20iLCJsZW5ndGgiLCJyZWFkT25seSIsInBheWxvYWRMZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsImZpbiIsIm9wY29kZSIsInJzdjEiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50QkUiLCJjbG9zZSIsImNvZGUiLCJjYiIsImJ1ZiIsIlR5cGVFcnJvciIsImJ5dGVMZW5ndGgiLCJSYW5nZUVycm9yIiwid3JpdGUiLCJzZXQiLCJlbnF1ZXVlIiwiZGlzcGF0Y2giLCJzZW5kRnJhbWUiLCJwaW5nIiwicG9uZyIsInNlbmQiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImV4dGVuc2lvbk5hbWUiLCJiaW5hcnkiLCJjb21wcmVzcyIsInBhcmFtcyIsIl9pc1NlcnZlciIsIl90aHJlc2hvbGQiLCJvcHRzIiwiXyIsImRlc3Ryb3llZCIsImVyciIsIkVycm9yIiwiaSIsImNhbGxiYWNrIiwiZGVxdWV1ZSIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/stream.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */ function emitClose(stream) {\n    stream.emit(\"close\");\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */ function duplexOnEnd() {\n    if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n    }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */ function duplexOnError(err) {\n    this.removeListener(\"error\", duplexOnError);\n    this.destroy();\n    if (this.listenerCount(\"error\") === 0) {\n        // Do not suppress the throwing behavior.\n        this.emit(\"error\", err);\n    }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */ function createWebSocketStream(ws, options) {\n    let terminateOnDestroy = true;\n    const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n    });\n    ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n    });\n    ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n        //\n        // - If the `'error'` event is emitted before the `'open'` event, then\n        //   `ws.terminate()` is a noop as no socket is assigned.\n        // - Otherwise, the error is re-emitted by the listener of the `'error'`\n        //   event of the `Receiver` object. The listener already closes the\n        //   connection by calling `ws.close()`. This allows a close frame to be\n        //   sent to the other peer. If `ws.terminate()` is called right after this,\n        //   then the close frame might not be sent.\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n    });\n    ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n    });\n    duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n            callback(err);\n            process.nextTick(emitClose, duplex);\n            return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err) {\n            called = true;\n            callback(err);\n        });\n        ws.once(\"close\", function close() {\n            if (!called) callback(err);\n            process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n    };\n    duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._final(callback);\n            });\n            return;\n        }\n        // If the value of the `_socket` property is `null` it means that `ws` is a\n        // client websocket and the handshake failed. In fact, when this happens, a\n        // socket is never assigned to the websocket. Wait for the `'error'` event\n        // that will be emitted by the websocket.\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n            callback();\n            if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n            ws._socket.once(\"finish\", function finish() {\n                // `duplex` is not destroyed here because the `'end'` event will be\n                // emitted on `duplex` after this `'finish'` event. The EOF signaling\n                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n                callback();\n            });\n            ws.close();\n        }\n    };\n    duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n    };\n    duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._write(chunk, encoding, callback);\n            });\n            return;\n        }\n        ws.send(chunk, callback);\n    };\n    duplex.on(\"end\", duplexOnEnd);\n    duplex.on(\"error\", duplexOnError);\n    return duplex;\n}\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0I7Ozs7O0NBS0MsR0FDRCxTQUFTQyxVQUFVQyxNQUFNO0lBQ3ZCQSxPQUFPQyxJQUFJLENBQUM7QUFDZDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQztJQUNQLElBQUksQ0FBQyxJQUFJLENBQUNDLFNBQVMsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFO1FBQ25ELElBQUksQ0FBQ0MsT0FBTztJQUNkO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGNBQWNDLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyxjQUFjLENBQUMsU0FBU0Y7SUFDN0IsSUFBSSxDQUFDRCxPQUFPO0lBQ1osSUFBSSxJQUFJLENBQUNJLGFBQWEsQ0FBQyxhQUFhLEdBQUc7UUFDckMseUNBQXlDO1FBQ3pDLElBQUksQ0FBQ1QsSUFBSSxDQUFDLFNBQVNPO0lBQ3JCO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csc0JBQXNCQyxFQUFFLEVBQUVDLE9BQU87SUFDeEMsSUFBSUMscUJBQXFCO0lBRXpCLE1BQU1DLFNBQVMsSUFBSWxCLE9BQU87UUFDeEIsR0FBR2dCLE9BQU87UUFDVkcsYUFBYTtRQUNiakIsV0FBVztRQUNYa0IsWUFBWTtRQUNaQyxvQkFBb0I7SUFDdEI7SUFFQU4sR0FBR08sRUFBRSxDQUFDLFdBQVcsU0FBU0MsUUFBUUMsR0FBRyxFQUFFQyxRQUFRO1FBQzdDLE1BQU1DLE9BQ0osQ0FBQ0QsWUFBWVAsT0FBT1MsY0FBYyxDQUFDUCxVQUFVLEdBQUdJLElBQUlJLFFBQVEsS0FBS0o7UUFFbkUsSUFBSSxDQUFDTixPQUFPVyxJQUFJLENBQUNILE9BQU9YLEdBQUdlLEtBQUs7SUFDbEM7SUFFQWYsR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNDLE1BQU1yQixHQUFHO1FBQ2pDLElBQUlPLE9BQU9aLFNBQVMsRUFBRTtRQUV0QixxRUFBcUU7UUFDckUsRUFBRTtRQUNGLHNFQUFzRTtRQUN0RSx5REFBeUQ7UUFDekQsd0VBQXdFO1FBQ3hFLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLDRDQUE0QztRQUM1Q1cscUJBQXFCO1FBQ3JCQyxPQUFPVCxPQUFPLENBQUNFO0lBQ2pCO0lBRUFJLEdBQUdnQixJQUFJLENBQUMsU0FBUyxTQUFTRTtRQUN4QixJQUFJZixPQUFPWixTQUFTLEVBQUU7UUFFdEJZLE9BQU9XLElBQUksQ0FBQztJQUNkO0lBRUFYLE9BQU9nQixRQUFRLEdBQUcsU0FBVXZCLEdBQUcsRUFBRXdCLFFBQVE7UUFDdkMsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHc0IsTUFBTSxFQUFFO1lBQy9CRixTQUFTeEI7WUFDVDJCLFFBQVFDLFFBQVEsQ0FBQ3JDLFdBQVdnQjtZQUM1QjtRQUNGO1FBRUEsSUFBSXNCLFNBQVM7UUFFYnpCLEdBQUdnQixJQUFJLENBQUMsU0FBUyxTQUFTQyxNQUFNckIsR0FBRztZQUNqQzZCLFNBQVM7WUFDVEwsU0FBU3hCO1FBQ1g7UUFFQUksR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNFO1lBQ3hCLElBQUksQ0FBQ08sUUFBUUwsU0FBU3hCO1lBQ3RCMkIsUUFBUUMsUUFBUSxDQUFDckMsV0FBV2dCO1FBQzlCO1FBRUEsSUFBSUQsb0JBQW9CRixHQUFHMEIsU0FBUztJQUN0QztJQUVBdkIsT0FBT3dCLE1BQU0sR0FBRyxTQUFVUCxRQUFRO1FBQ2hDLElBQUlwQixHQUFHcUIsVUFBVSxLQUFLckIsR0FBRzRCLFVBQVUsRUFBRTtZQUNuQzVCLEdBQUdnQixJQUFJLENBQUMsUUFBUSxTQUFTYTtnQkFDdkIxQixPQUFPd0IsTUFBTSxDQUFDUDtZQUNoQjtZQUNBO1FBQ0Y7UUFFQSwyRUFBMkU7UUFDM0UsMkVBQTJFO1FBQzNFLDBFQUEwRTtRQUMxRSx5Q0FBeUM7UUFDekMsSUFBSXBCLEdBQUc4QixPQUFPLEtBQUssTUFBTTtRQUV6QixJQUFJOUIsR0FBRzhCLE9BQU8sQ0FBQ3RDLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFO1lBQ3RDMkI7WUFDQSxJQUFJakIsT0FBT1MsY0FBYyxDQUFDbUIsVUFBVSxFQUFFNUIsT0FBT1QsT0FBTztRQUN0RCxPQUFPO1lBQ0xNLEdBQUc4QixPQUFPLENBQUNkLElBQUksQ0FBQyxVQUFVLFNBQVNnQjtnQkFDakMsbUVBQW1FO2dCQUNuRSxxRUFBcUU7Z0JBQ3JFLHVFQUF1RTtnQkFDdkVaO1lBQ0Y7WUFDQXBCLEdBQUdrQixLQUFLO1FBQ1Y7SUFDRjtJQUVBZixPQUFPOEIsS0FBSyxHQUFHO1FBQ2IsSUFBSWpDLEdBQUdrQyxRQUFRLEVBQUVsQyxHQUFHbUMsTUFBTTtJQUM1QjtJQUVBaEMsT0FBT2lDLE1BQU0sR0FBRyxTQUFVQyxLQUFLLEVBQUVDLFFBQVEsRUFBRWxCLFFBQVE7UUFDakQsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHNEIsVUFBVSxFQUFFO1lBQ25DNUIsR0FBR2dCLElBQUksQ0FBQyxRQUFRLFNBQVNhO2dCQUN2QjFCLE9BQU9pQyxNQUFNLENBQUNDLE9BQU9DLFVBQVVsQjtZQUNqQztZQUNBO1FBQ0Y7UUFFQXBCLEdBQUd1QyxJQUFJLENBQUNGLE9BQU9qQjtJQUNqQjtJQUVBakIsT0FBT0ksRUFBRSxDQUFDLE9BQU9qQjtJQUNqQmEsT0FBT0ksRUFBRSxDQUFDLFNBQVNaO0lBQ25CLE9BQU9RO0FBQ1Q7QUFFQXFDLE9BQU9DLE9BQU8sR0FBRzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcz9kYzJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG5cbiAgICBpZiAoIWR1cGxleC5wdXNoKGRhdGEpKSB3cy5wYXVzZSgpO1xuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IGB3cy50ZXJtaW5hdGUoKWAgZnJvbSBiZWluZyBjYWxsZWQgYnkgYGR1cGxleC5fZGVzdHJveSgpYC5cbiAgICAvL1xuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cbiAgICAvLyAgIGB3cy50ZXJtaW5hdGUoKWAgaXMgYSBub29wIGFzIG5vIHNvY2tldCBpcyBhc3NpZ25lZC5cbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxuICAgIC8vICAgY29ubmVjdGlvbiBieSBjYWxsaW5nIGB3cy5jbG9zZSgpYC4gVGhpcyBhbGxvd3MgYSBjbG9zZSBmcmFtZSB0byBiZVxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcblxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiJdLCJuYW1lcyI6WyJEdXBsZXgiLCJyZXF1aXJlIiwiZW1pdENsb3NlIiwic3RyZWFtIiwiZW1pdCIsImR1cGxleE9uRW5kIiwiZGVzdHJveWVkIiwiX3dyaXRhYmxlU3RhdGUiLCJmaW5pc2hlZCIsImRlc3Ryb3kiLCJkdXBsZXhPbkVycm9yIiwiZXJyIiwicmVtb3ZlTGlzdGVuZXIiLCJsaXN0ZW5lckNvdW50IiwiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwid3MiLCJvcHRpb25zIiwidGVybWluYXRlT25EZXN0cm95IiwiZHVwbGV4IiwiYXV0b0Rlc3Ryb3kiLCJvYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwib24iLCJtZXNzYWdlIiwibXNnIiwiaXNCaW5hcnkiLCJkYXRhIiwiX3JlYWRhYmxlU3RhdGUiLCJ0b1N0cmluZyIsInB1c2giLCJwYXVzZSIsIm9uY2UiLCJlcnJvciIsImNsb3NlIiwiX2Rlc3Ryb3kiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsZWQiLCJ0ZXJtaW5hdGUiLCJfZmluYWwiLCJDT05ORUNUSU5HIiwib3BlbiIsIl9zb2NrZXQiLCJlbmRFbWl0dGVkIiwiZmluaXNoIiwiX3JlYWQiLCJpc1BhdXNlZCIsInJlc3VtZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJzZW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/subprotocol.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js\");\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */ function parse(header) {\n    const protocols = new Set();\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(i; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n        } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n            if (end === -1 && start !== -1) end = i;\n        } else if (code === 0x2c /* ',' */ ) {\n            if (start === -1) {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const protocol = header.slice(start, end);\n            if (protocols.has(protocol)) {\n                throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n            }\n            protocols.add(protocol);\n            start = end = -1;\n        } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n    }\n    if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    const protocol = header.slice(start, i);\n    if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n    }\n    protocols.add(protocol);\n    return protocols;\n}\nmodule.exports = {\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUvQjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxNQUFNQyxNQUFNO0lBQ25CLE1BQU1DLFlBQVksSUFBSUM7SUFDdEIsSUFBSUMsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSUMsSUFBSTtJQUVSLElBQUtBLEdBQUdBLElBQUlMLE9BQU9NLE1BQU0sRUFBRUQsSUFBSztRQUM5QixNQUFNRSxPQUFPUCxPQUFPUSxVQUFVLENBQUNIO1FBRS9CLElBQUlELFFBQVEsQ0FBQyxLQUFLUCxVQUFVLENBQUNVLEtBQUssS0FBSyxHQUFHO1lBQ3hDLElBQUlKLFVBQVUsQ0FBQyxHQUFHQSxRQUFRRTtRQUM1QixPQUFPLElBQ0xBLE1BQU0sS0FDTEUsQ0FBQUEsU0FBUyxLQUFLLE9BQU8sT0FBTUEsU0FBUyxJQUFHLEdBQ3hDO1lBQ0EsSUFBSUgsUUFBUSxDQUFDLEtBQUtELFVBQVUsQ0FBQyxHQUFHQyxNQUFNQztRQUN4QyxPQUFPLElBQUlFLFNBQVMsS0FBSyxPQUFPLEtBQUk7WUFDbEMsSUFBSUosVUFBVSxDQUFDLEdBQUc7Z0JBQ2hCLE1BQU0sSUFBSU0sWUFBWSxDQUFDLDhCQUE4QixFQUFFSixFQUFFLENBQUM7WUFDNUQ7WUFFQSxJQUFJRCxRQUFRLENBQUMsR0FBR0EsTUFBTUM7WUFFdEIsTUFBTUssV0FBV1YsT0FBT1csS0FBSyxDQUFDUixPQUFPQztZQUVyQyxJQUFJSCxVQUFVVyxHQUFHLENBQUNGLFdBQVc7Z0JBQzNCLE1BQU0sSUFBSUQsWUFBWSxDQUFDLEtBQUssRUFBRUMsU0FBUywyQkFBMkIsQ0FBQztZQUNyRTtZQUVBVCxVQUFVWSxHQUFHLENBQUNIO1lBQ2RQLFFBQVFDLE1BQU0sQ0FBQztRQUNqQixPQUFPO1lBQ0wsTUFBTSxJQUFJSyxZQUFZLENBQUMsOEJBQThCLEVBQUVKLEVBQUUsQ0FBQztRQUM1RDtJQUNGO0lBRUEsSUFBSUYsVUFBVSxDQUFDLEtBQUtDLFFBQVEsQ0FBQyxHQUFHO1FBQzlCLE1BQU0sSUFBSUssWUFBWTtJQUN4QjtJQUVBLE1BQU1DLFdBQVdWLE9BQU9XLEtBQUssQ0FBQ1IsT0FBT0U7SUFFckMsSUFBSUosVUFBVVcsR0FBRyxDQUFDRixXQUFXO1FBQzNCLE1BQU0sSUFBSUQsWUFBWSxDQUFDLEtBQUssRUFBRUMsU0FBUywyQkFBMkIsQ0FBQztJQUNyRTtJQUVBVCxVQUFVWSxHQUFHLENBQUNIO0lBQ2QsT0FBT1Q7QUFDVDtBQUVBYSxPQUFPQyxPQUFPLEdBQUc7SUFBRWhCO0FBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanM/YWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgaGVhZGVyIGludG8gYSBzZXQgb2Ygc3VicHJvdG9jb2wgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7U2V0fSBUaGUgc3VicHJvdG9jb2wgbmFtZXNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoaTsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaSAhPT0gMCAmJlxuICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG5cbiAgICAgIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG5cbiAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgfVxuXG4gIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICByZXR1cm4gcHJvdG9jb2xzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyc2UgfTtcbiJdLCJuYW1lcyI6WyJ0b2tlbkNoYXJzIiwicmVxdWlyZSIsInBhcnNlIiwiaGVhZGVyIiwicHJvdG9jb2xzIiwiU2V0Iiwic3RhcnQiLCJlbmQiLCJpIiwibGVuZ3RoIiwiY29kZSIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInByb3RvY29sIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/validation.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */ function isValidStatusCode(code) {\n    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */ function _isValidUTF8(buf) {\n    const len = buf.length;\n    let i = 0;\n    while(i < len){\n        if ((buf[i] & 0x80) === 0) {\n            // 0xxxxxxx\n            i++;\n        } else if ((buf[i] & 0xe0) === 0xc0) {\n            // 110xxxxx 10xxxxxx\n            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n            ) {\n                return false;\n            }\n            i += 2;\n        } else if ((buf[i] & 0xf0) === 0xe0) {\n            // 1110xxxx 10xxxxxx 10xxxxxx\n            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n            buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n            ) {\n                return false;\n            }\n            i += 3;\n        } else if ((buf[i] & 0xf8) === 0xf0) {\n            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n            buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n            ) {\n                return false;\n            }\n            i += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\ntry {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(rsc)/./node_modules/utf-8-validate/index.js\");\n    module.exports = {\n        isValidStatusCode,\n        isValidUTF8 (buf) {\n            return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        },\n        tokenChars\n    };\n} catch (e) /* istanbul ignore next */ {\n    module.exports = {\n        isValidStatusCode,\n        isValidUTF8: _isValidUTF8,\n        tokenChars\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLEVBQUU7QUFDRiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLCtDQUErQztBQUMvQyw4Q0FBOEM7QUFDOUMsRUFBRTtBQUNGLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLE1BQU07QUFDTixFQUFFO0FBQ0Ysa0JBQWtCO0FBQ2xCLE1BQU1BLGFBQWE7SUFDakI7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDN0M7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUcsRUFBRSxZQUFZO0NBQzVEO0FBRUQ7Ozs7OztDQU1DLEdBQ0QsU0FBU0Msa0JBQWtCQyxJQUFJO0lBQzdCLE9BQ0UsUUFBUyxRQUNQQSxRQUFRLFFBQ1JBLFNBQVMsUUFDVEEsU0FBUyxRQUNUQSxTQUFTLFFBQ1ZBLFFBQVEsUUFBUUEsUUFBUTtBQUU3QjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsYUFBYUMsR0FBRztJQUN2QixNQUFNQyxNQUFNRCxJQUFJRSxNQUFNO0lBQ3RCLElBQUlDLElBQUk7SUFFUixNQUFPQSxJQUFJRixJQUFLO1FBQ2QsSUFBSSxDQUFDRCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sR0FBRztZQUN6QixXQUFXO1lBQ1hBO1FBQ0YsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBQ0csRUFBRSxHQUFHLElBQUcsTUFBTyxNQUFNO1lBQ25DLG9CQUFvQjtZQUNwQixJQUNFQSxJQUFJLE1BQU1GLE9BQ1YsQ0FBQ0QsR0FBRyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxJQUFHLE1BQU8sUUFDeEIsQ0FBQ0gsR0FBRyxDQUFDRyxFQUFFLEdBQUcsSUFBRyxNQUFPLEtBQUssV0FBVztjQUNwQztnQkFDQSxPQUFPO1lBQ1Q7WUFFQUEsS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDSCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFBTTtZQUNuQyw2QkFBNkI7WUFDN0IsSUFDRUEsSUFBSSxLQUFLRixPQUNULENBQUNELEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3ZCSCxHQUFHLENBQUNHLEVBQUUsS0FBSyxRQUFRLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQVMsV0FBVztZQUMvREgsR0FBRyxDQUFDRyxFQUFFLEtBQUssUUFBUSxDQUFDSCxHQUFHLENBQUNHLElBQUksRUFBRSxHQUFHLElBQUcsTUFBTyxLQUFNLDhCQUE4QjtjQUNoRjtnQkFDQSxPQUFPO1lBQ1Q7WUFFQUEsS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDSCxHQUFHLENBQUNHLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFBTTtZQUNuQyxzQ0FBc0M7WUFDdEMsSUFDRUEsSUFBSSxLQUFLRixPQUNULENBQUNELEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3hCLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQ3ZCSCxHQUFHLENBQUNHLEVBQUUsS0FBSyxRQUFRLENBQUNILEdBQUcsQ0FBQ0csSUFBSSxFQUFFLEdBQUcsSUFBRyxNQUFPLFFBQVMsV0FBVztZQUMvREgsR0FBRyxDQUFDRyxFQUFFLEtBQUssUUFBUUgsR0FBRyxDQUFDRyxJQUFJLEVBQUUsR0FBRyxRQUNqQ0gsR0FBRyxDQUFDRyxFQUFFLEdBQUcsS0FBSyxhQUFhO2NBQzNCO2dCQUNBLE9BQU87WUFDVDtZQUVBQSxLQUFLO1FBQ1AsT0FBTztZQUNMLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSTtJQUNGLE1BQU1DLGNBQWNDLG1CQUFPQSxDQUFDO0lBRTVCQyxPQUFPQyxPQUFPLEdBQUc7UUFDZlY7UUFDQU8sYUFBWUosR0FBRztZQUNiLE9BQU9BLElBQUlFLE1BQU0sR0FBRyxNQUFNSCxhQUFhQyxPQUFPSSxZQUFZSjtRQUM1RDtRQUNBSjtJQUNGO0FBQ0YsRUFBRSxPQUFPWSxHQUFHLHdCQUF3QixHQUFHO0lBQ3JDRixPQUFPQyxPQUFPLEdBQUc7UUFDZlY7UUFDQU8sYUFBYUw7UUFDYkg7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanM/YmI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjgoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDE1MCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9LFxuICAgIHRva2VuQ2hhcnNcbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsImlzVmFsaWRTdGF0dXNDb2RlIiwiY29kZSIsIl9pc1ZhbGlkVVRGOCIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImkiLCJpc1ZhbGlkVVRGOCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/websocket-server.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = {\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null,\n            WebSocket,\n            ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n            throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            const emitConnection = this.emit.bind(this, \"connection\");\n            this._removeListeners = addListeners(this._server, {\n                listening: this.emit.bind(this, \"listening\"),\n                error: this.emit.bind(this, \"error\"),\n                upgrade: (req, socket, head)=>{\n                    this.handleUpgrade(req, socket, head, emitConnection);\n                }\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n            this.clients = new Set();\n            this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n    }\n    /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */ address() {\n        if (this.options.noServer) {\n            throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n    }\n    /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */ close(cb) {\n        if (this._state === CLOSED) {\n            if (cb) {\n                this.once(\"close\", ()=>{\n                    cb(new Error(\"The server is not running\"));\n                });\n            }\n            process.nextTick(emitClose, this);\n            return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n            if (this._server) {\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n            }\n            if (this.clients) {\n                if (!this.clients.size) {\n                    process.nextTick(emitClose, this);\n                } else {\n                    this._shouldEmitClose = true;\n                }\n            } else {\n                process.nextTick(emitClose, this);\n            }\n        } else {\n            const server = this._server;\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n            //\n            // The HTTP/S server was created internally. Close it, and rely on its\n            // `'close'` event.\n            //\n            server.close(()=>{\n                emitClose(this);\n            });\n        }\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path) {\n            const index = req.url.indexOf(\"?\");\n            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n            if (pathname !== this.options.path) return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"] !== undefined ? req.headers[\"sec-websocket-key\"] : false;\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\" || req.headers.upgrade.toLowerCase() !== \"websocket\" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n            return abortHandshake(socket, 400);\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = new Set();\n        if (secWebSocketProtocol !== undefined) {\n            try {\n                protocols = subprotocol.parse(secWebSocketProtocol);\n            } catch (err) {\n                return abortHandshake(socket, 400);\n            }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = extension.parse(secWebSocketExtensions);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                return abortHandshake(socket, 400);\n            }\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.socket.authorized || req.socket.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message, headers)=>{\n                    if (!verified) {\n                        return abortHandshake(socket, code || 401, message, headers);\n                    }\n                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n            throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null);\n        if (protocols.size) {\n            //\n            // Optionally call external protocol selection handler.\n            //\n            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n            if (protocol) {\n                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                ws._protocol = protocol;\n            }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = extension.format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n            ws._extensions = extensions;\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n            maxPayload: this.options.maxPayload,\n            skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n            this.clients.add(ws);\n            ws.on(\"close\", ()=>{\n                this.clients.delete(ws);\n                if (this._shouldEmitClose && !this.clients.size) {\n                    process.nextTick(emitClose, this);\n                }\n            });\n        }\n        cb(ws, req);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */ function addListeners(server, map) {\n    for (const event of Object.keys(map))server.on(event, map[event]);\n    return function removeListeners() {\n        for (const event of Object.keys(map)){\n            server.removeListener(event, map[event]);\n        }\n    };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */ function emitClose(server) {\n    server._state = CLOSED;\n    server.emit(\"close\");\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */ function socketOnError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */ function abortHandshake(socket, code, message, headers) {\n    if (socket.writable) {\n        message = message || http.STATUS_CODES[code];\n        headers = {\n            Connection: \"close\",\n            \"Content-Type\": \"text/html\",\n            \"Content-Length\": Buffer.byteLength(message),\n            ...headers\n        };\n        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n    }\n    socket.removeListener(\"error\", socketOnError);\n    socket.destroy();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnRkFBZ0YsR0FFaEY7QUFFQSxNQUFNQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUM3QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxNQUFNSCxtQkFBT0EsQ0FBQztBQUNwQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVLLFVBQVUsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUUvQixNQUFNTSxZQUFZTixtQkFBT0EsQ0FBQztBQUMxQixNQUFNTyxvQkFBb0JQLG1CQUFPQSxDQUFDO0FBQ2xDLE1BQU1RLGNBQWNSLG1CQUFPQSxDQUFDO0FBQzVCLE1BQU1TLFlBQVlULG1CQUFPQSxDQUFDO0FBQzFCLE1BQU0sRUFBRVUsSUFBSSxFQUFFQyxVQUFVLEVBQUUsR0FBR1gsbUJBQU9BLENBQUM7QUFFckMsTUFBTVksV0FBVztBQUVqQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUVmOzs7O0NBSUMsR0FDRCxNQUFNQyx3QkFBd0JqQjtJQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCQyxHQUNEa0IsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsS0FBSztRQUVMRCxVQUFVO1lBQ1JFLFlBQVksTUFBTSxPQUFPO1lBQ3pCQyxvQkFBb0I7WUFDcEJDLG1CQUFtQjtZQUNuQkMsaUJBQWlCO1lBQ2pCQyxnQkFBZ0I7WUFDaEJDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLE1BQU07WUFDTnRCO1lBQ0EsR0FBR1MsT0FBTztRQUNaO1FBRUEsSUFDRSxRQUFTYSxJQUFJLElBQUksUUFBUSxD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cy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcz8yOGUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHN8aHR0cHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgZXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHN1YnByb3RvY29sID0gcmVxdWlyZSgnLi9zdWJwcm90b2NvbCcpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J11cbiAgICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChcbiAgICAgIHJlcS5tZXRob2QgIT09ICdHRVQnIHx8XG4gICAgICByZXEuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnIHx8XG4gICAgICAha2V5IHx8XG4gICAgICAha2V5UmVnZXgudGVzdChrZXkpIHx8XG4gICAgICAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykgfHxcbiAgICAgICF0aGlzLnNob3VsZEhhbmRsZShyZXEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwpO1xuXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XG4gICAgICAvL1xuICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuICAgICAgLy9cbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29sc1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmVtYXR1cmUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH07XG5cbiAgICBzb2NrZXQud3JpdGUoXG4gICAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJodHRwIiwiaHR0cHMiLCJuZXQiLCJ0bHMiLCJjcmVhdGVIYXNoIiwiZXh0ZW5zaW9uIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJzdWJwcm90b2NvbCIsIldlYlNvY2tldCIsIkdVSUQiLCJrV2ViU29ja2V0Iiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiQ0xPU0lORyIsIkNMT1NFRCIsIldlYlNvY2tldFNlcnZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNhbGxiYWNrIiwibWF4UGF5bG9hZCIsInNraXBVVEY4VmFsaWRhdGlvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiaGFuZGxlUHJvdG9jb2xzIiwiY2xpZW50VHJhY2tpbmciLCJ2ZXJpZnlDbGllbnQiLCJub1NlcnZlciIsImJhY2tsb2ciLCJzZXJ2ZXIiLCJob3N0IiwicGF0aCIsInBvcnQiLCJUeXBlRXJyb3IiLCJfc2VydmVyIiwiY3JlYXRlU2VydmVyIiwicmVxIiwicmVzIiwiYm9keSIsIlNUQVRVU19DT0RFUyIsIndyaXRlSGVhZCIsImxlbmd0aCIsImVuZCIsImxpc3RlbiIsImVtaXRDb25uZWN0aW9uIiwiZW1pdCIsImJpbmQiLCJfcmVtb3ZlTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXJzIiwibGlzdGVuaW5nIiwiZXJyb3IiLCJ1cGdyYWRlIiwic29ja2V0IiwiaGVhZCIsImhhbmRsZVVwZ3JhZGUiLCJjbGllbnRzIiwiU2V0IiwiX3Nob3VsZEVtaXRDbG9zZSIsIl9zdGF0ZSIsImFkZHJlc3MiLCJFcnJvciIsImNsb3NlIiwiY2IiLCJvbmNlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZW1pdENsb3NlIiwic2l6ZSIsInNob3VsZEhhbmRsZSIsImluZGV4IiwidXJsIiwiaW5kZXhPZiIsInBhdGhuYW1lIiwic2xpY2UiLCJvbiIsInNvY2tldE9uRXJyb3IiLCJrZXkiLCJoZWFkZXJzIiwidW5kZWZpbmVkIiwidmVyc2lvbiIsIm1ldGhvZCIsInRvTG93ZXJDYXNlIiwidGVzdCIsImFib3J0SGFuZHNoYWtlIiwic2VjV2ViU29ja2V0UHJvdG9jb2wiLCJwcm90b2NvbHMiLCJwYXJzZSIsImVyciIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwib2ZmZXJzIiwiZXh0ZW5zaW9uTmFtZSIsImFjY2VwdCIsImluZm8iLCJvcmlnaW4iLCJzZWN1cmUiLCJhdXRob3JpemVkIiwiZW5jcnlwdGVkIiwidmVyaWZpZWQiLCJjb2RlIiwibWVzc2FnZSIsImNvbXBsZXRlVXBncmFkZSIsInJlYWRhYmxlIiwid3JpdGFibGUiLCJkZXN0cm95IiwiZGlnZXN0IiwidXBkYXRlIiwid3MiLCJwcm90b2NvbCIsInZhbHVlcyIsIm5leHQiLCJ2YWx1ZSIsInB1c2giLCJfcHJvdG9jb2wiLCJwYXJhbXMiLCJmb3JtYXQiLCJfZXh0ZW5zaW9ucyIsIndyaXRlIiwiY29uY2F0Iiwiam9pbiIsInJlbW92ZUxpc3RlbmVyIiwic2V0U29ja2V0IiwiYWRkIiwiZGVsZXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIm1hcCIsImV2ZW50IiwiT2JqZWN0Iiwia2V5cyIsInJlbW92ZUxpc3RlbmVycyIsIkNvbm5lY3Rpb24iLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/node_modules/ws/lib/websocket.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/sender.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/constants.js\");\nconst { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/ethers/node_modules/ws/lib/buffer-util.js\");\nconst readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [\n    8,\n    13\n];\nconst closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */ constructor(address, protocols, options){\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n            this._bufferedAmount = 0;\n            this._isServer = false;\n            this._redirects = 0;\n            if (protocols === undefined) {\n                protocols = [];\n            } else if (!Array.isArray(protocols)) {\n                if (typeof protocols === \"object\" && protocols !== null) {\n                    options = protocols;\n                    protocols = [];\n                } else {\n                    protocols = [\n                        protocols\n                    ];\n                }\n            }\n            initAsClient(this, address, protocols, options);\n        } else {\n            this._isServer = true;\n        }\n    }\n    /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n   * @type {String}\n   */ get extensions() {\n        return Object.keys(this._extensions).join();\n    }\n    /**\n   * @type {Boolean}\n   */ get isPaused() {\n        return this._paused;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onclose() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onerror() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onopen() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onmessage() {\n        return null;\n    }\n    /**\n   * @type {String}\n   */ get protocol() {\n        return this._protocol;\n    }\n    /**\n   * @type {Number}\n   */ get readyState() {\n        return this._readyState;\n    }\n    /**\n   * @type {String}\n   */ get url() {\n        return this._url;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */ setSocket(socket, head, options) {\n        const receiver = new Receiver({\n            binaryType: this.binaryType,\n            extensions: this._extensions,\n            isServer: this._isServer,\n            maxPayload: options.maxPayload,\n            skipUTF8Validation: options.skipUTF8Validation\n        });\n        this._sender = new Sender(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        socket.setTimeout(0);\n        socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */ emitClose() {\n        if (!this._socket) {\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n            return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n            this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            return abortHandshake(this, this._req, msg);\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                this._socket.end();\n            }\n            return;\n        }\n        this._readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                this._socket.end();\n            }\n        });\n        //\n        // Specify a timeout for the closing handshake to complete.\n        //\n        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n    }\n    /**\n   * Pause the socket.\n   *\n   * @public\n   */ pause() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = true;\n        this._socket.pause();\n    }\n    /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */ ping(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */ pong(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Resume the socket.\n   *\n   * @public\n   */ resume() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        const opts = {\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true,\n            ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            return abortHandshake(this, this._req, msg);\n        }\n        if (this._socket) {\n            this._readyState = WebSocket.CLOSING;\n            this._socket.destroy();\n        }\n    }\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"isPaused\",\n    \"protocol\",\n    \"readyState\",\n    \"url\"\n].forEach((property)=>{\n    Object.defineProperty(WebSocket.prototype, property, {\n        enumerable: true\n    });\n});\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        enumerable: true,\n        get () {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) return listener[kListener];\n            }\n            return null;\n        },\n        set (handler) {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) {\n                    this.removeListener(method, listener);\n                    break;\n                }\n            }\n            if (typeof handler !== \"function\") return;\n            this.addEventListener(method, handler, {\n                [kForOnEventAttribute]: true\n            });\n        }\n    });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */ function initAsClient(websocket, address, protocols, options) {\n    const opts = {\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        createConnection: undefined,\n        socketPath: undefined,\n        hostname: undefined,\n        protocol: undefined,\n        timeout: undefined,\n        method: undefined,\n        host: undefined,\n        path: undefined,\n        port: undefined\n    };\n    if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    let parsedUrl;\n    if (address instanceof URL) {\n        parsedUrl = address;\n        websocket._url = address.href;\n    } else {\n        try {\n            parsedUrl = new URL(address);\n        } catch (e) {\n            throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n        websocket._url = address;\n    }\n    const isSecure = parsedUrl.protocol === \"wss:\";\n    const isUnixSocket = parsedUrl.protocol === \"ws+unix:\";\n    let invalidURLMessage;\n    if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isUnixSocket) {\n        invalidURLMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n    } else if (isUnixSocket && !parsedUrl.pathname) {\n        invalidURLMessage = \"The URL's pathname is empty\";\n    } else if (parsedUrl.hash) {\n        invalidURLMessage = \"The URL contains a fragment identifier\";\n    }\n    if (invalidURLMessage) {\n        const err = new SyntaxError(invalidURLMessage);\n        if (websocket._redirects === 0) {\n            throw err;\n        } else {\n            emitErrorAndClose(websocket, err);\n            return;\n        }\n    }\n    const defaultPort = isSecure ? 443 : 80;\n    const key = randomBytes(16).toString(\"base64\");\n    const get = isSecure ? https.get : http.get;\n    const protocolSet = new Set();\n    let perMessageDeflate;\n    opts.createConnection = isSecure ? tlsConnect : netConnect;\n    opts.defaultPort = opts.defaultPort || defaultPort;\n    opts.port = parsedUrl.port || defaultPort;\n    opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n    opts.headers = {\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\",\n        ...opts.headers\n    };\n    opts.path = parsedUrl.pathname + parsedUrl.search;\n    opts.timeout = opts.handshakeTimeout;\n    if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (protocols.length) {\n        for (const protocol of protocols){\n            if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n            }\n            protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n    }\n    if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n            opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n            opts.headers.Origin = opts.origin;\n        }\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n    }\n    if (isUnixSocket) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n    }\n    if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n            websocket._originalHost = parsedUrl.host;\n            const headers = options && options.headers;\n            //\n            // Shallow copy the user provided options so that headers can be changed\n            // without mutating the original object.\n            //\n            options = {\n                ...options,\n                headers: {}\n            };\n            if (headers) {\n                for (const [key, value] of Object.entries(headers)){\n                    options.headers[key.toLowerCase()] = value;\n                }\n            }\n        } else if (parsedUrl.host !== websocket._originalHost) {\n            //\n            // Match curl 7.77.0 behavior and drop the following headers. These\n            // headers are also dropped when following a redirect to a subdomain.\n            //\n            delete opts.headers.authorization;\n            delete opts.headers.cookie;\n            delete opts.headers.host;\n            opts.auth = undefined;\n        }\n        //\n        // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n        // If the `Authorization` header is set, then there is nothing to do as it\n        // will take precedence.\n        //\n        if (opts.auth && !options.headers.authorization) {\n            options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n    }\n    let req = websocket._req = get(opts);\n    if (opts.timeout) {\n        req.on(\"timeout\", ()=>{\n            abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n    }\n    req.on(\"error\", (err)=>{\n        if (req === null || req.aborted) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n    });\n    req.on(\"response\", (res)=>{\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n            if (++websocket._redirects > opts.maxRedirects) {\n                abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                return;\n            }\n            req.abort();\n            let addr;\n            try {\n                addr = new URL(location, address);\n            } catch (e) {\n                const err = new SyntaxError(`Invalid URL: ${location}`);\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n            initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n        }\n    });\n    req.on(\"upgrade\", (res, socket, head)=>{\n        websocket.emit(\"upgrade\", res);\n        //\n        // The user may have closed the connection from a listener of the `upgrade`\n        // event.\n        //\n        if (websocket.readyState !== WebSocket.CONNECTING) return;\n        req = websocket._req = null;\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n            return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== undefined) {\n            if (!protocolSet.size) {\n                protError = \"Server sent a subprotocol but none was requested\";\n            } else if (!protocolSet.has(serverProt)) {\n                protError = \"Server sent an invalid subprotocol\";\n            }\n        } else if (protocolSet.size) {\n            protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n            abortHandshake(websocket, socket, protError);\n            return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== undefined) {\n            if (!perMessageDeflate) {\n                const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            let extensions;\n            try {\n                extensions = parse(secWebSocketExtensions);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            const extensionNames = Object.keys(extensions);\n            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                const message = \"Server indicated an extension that was not requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            try {\n                perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n            generateMask: opts.generateMask,\n            maxPayload: opts.maxPayload,\n            skipUTF8Validation: opts.skipUTF8Validation\n        });\n    });\n}\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */ function emitErrorAndClose(websocket, err) {\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit(\"error\", err);\n    websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */ function netConnect(options) {\n    options.path = options.socketPath;\n    return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */ function tlsConnect(options) {\n    options.path = undefined;\n    if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n    }\n    return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */ function abortHandshake(websocket, stream, message) {\n    websocket._readyState = WebSocket.CLOSING;\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshake);\n    if (stream.setHeader) {\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n            //\n            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n            // called after the request completed. See\n            // https://github.com/websockets/ws/issues/1869.\n            //\n            stream.socket.destroy();\n        }\n        stream.once(\"abort\", websocket.emitClose.bind(websocket));\n        websocket.emit(\"error\", err);\n    } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n    }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */ function sendAfterClose(websocket, data, cb) {\n    if (data) {\n        const length = toBuffer(data).length;\n        //\n        // The `_bufferedAmount` property is used only when the peer is a client and\n        // the opening handshake fails. Under these circumstances, in fact, the\n        // `setSocket()` method is not called, so the `_socket` and `_sender`\n        // properties are set to `null`.\n        //\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n    }\n    if (cb) {\n        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n        cb(err);\n    }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */ function receiverOnConclude(code, reason) {\n    const websocket = this[kWebSocket];\n    websocket._closeFrameReceived = true;\n    websocket._closeMessage = reason;\n    websocket._closeCode = code;\n    if (websocket._socket[kWebSocket] === undefined) return;\n    websocket._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket._socket);\n    if (code === 1005) websocket.close();\n    else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */ function receiverOnDrain() {\n    const websocket = this[kWebSocket];\n    if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */ function receiverOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket._socket[kWebSocket] !== undefined) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        //\n        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n        // https://github.com/websockets/ws/issues/1940.\n        //\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n    }\n    websocket.emit(\"error\", err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */ function receiverOnFinish() {\n    this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */ function receiverOnMessage(data, isBinary) {\n    this[kWebSocket].emit(\"message\", data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */ function receiverOnPing(data) {\n    const websocket = this[kWebSocket];\n    websocket.pong(data, !websocket._isServer, NOOP);\n    websocket.emit(\"ping\", data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */ function receiverOnPong(data) {\n    this[kWebSocket].emit(\"pong\", data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */ function resume(stream) {\n    stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */ function socketOnClose() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"close\", socketOnClose);\n    this.removeListener(\"data\", socketOnData);\n    this.removeListener(\"end\", socketOnEnd);\n    websocket._readyState = WebSocket.CLOSING;\n    let chunk;\n    //\n    // The close frame might not have been received or the `'end'` event emitted,\n    // for example, if the socket was destroyed due to an error. Ensure that the\n    // `receiver` stream is closed after writing any remaining buffered data to\n    // it. If the readable side of the socket is in flowing mode then there is no\n    // buffered data as everything has been already written and `readable.read()`\n    // will return `null`. If instead, the socket is paused, any possible buffered\n    // data will be read as a single chunk.\n    //\n    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n        websocket._receiver.write(chunk);\n    }\n    websocket._receiver.end();\n    this[kWebSocket] = undefined;\n    clearTimeout(websocket._closeTimer);\n    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n    } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n    }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function socketOnData(chunk) {\n    if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */ function socketOnEnd() {\n    const websocket = this[kWebSocket];\n    websocket._readyState = WebSocket.CLOSING;\n    websocket._receiver.end();\n    this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */ function socketOnError() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"error\", socketOnError);\n    this.on(\"error\", NOOP);\n    if (websocket) {\n        websocket._readyState = WebSocket.CLOSING;\n        this.destroy();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBLDJFQUEyRSxHQUUzRTtBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU0sRUFBRUssV0FBVyxFQUFFQyxVQUFVLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDNUMsTUFBTSxFQUFFTyxRQUFRLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDN0IsTUFBTSxFQUFFUSxHQUFHLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFeEIsTUFBTVMsb0JBQW9CVCxtQkFBT0EsQ0FBQztBQUNsQyxNQUFNVSxXQUFXVixtQkFBT0EsQ0FBQztBQUN6QixNQUFNVyxTQUFTWCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQ0pZLFlBQVksRUFDWkMsWUFBWSxFQUNaQyxJQUFJLEVBQ0pDLG9CQUFvQixFQUNwQkMsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsSUFBSSxFQUNMLEdBQUduQixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSm9CLGFBQWEsRUFBRUMsZ0JBQWdCLEVBQUVDLG1CQUFtQixFQUFFLEVBQ3ZELEdBQUd0QixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRXVCLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUd4QixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUV5QixRQUFRLEVBQUUsR0FBR3pCLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU0wQixjQUFjO0lBQUM7SUFBYztJQUFRO0lBQVc7Q0FBUztBQUMvRCxNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsbUJBQW1CO0lBQUM7SUFBRztD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U0FBUyxDQUFDYyxjQUFjLENBQUNrTCxRQUFRLElBQzNDekYsVUFBVXZHLFNBQVMsQ0FBQ2MsY0FBYyxDQUFDb0QsWUFBWSxFQUMvQztRQUNBcUMsVUFBVWpELFNBQVM7SUFDckIsT0FBTztRQUNMaUQsVUFBVXZHLFNBQVMsQ0FBQ3NDLEVBQUUsQ0FBQyxTQUFTa0o7UUFDaENqRixVQUFVdkcsU0FBUyxDQUFDc0MsRUFBRSxDQUFDLFVBQVVrSjtJQUNuQztBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTdkksYUFBYXlJLEtBQUs7SUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ3ROLFdBQVcsQ0FBQzRCLFNBQVMsQ0FBQzhMLEtBQUssQ0FBQ0osUUFBUTtRQUM1QyxJQUFJLENBQUNuSCxLQUFLO0lBQ1o7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTckI7SUFDUCxNQUFNcUQsWUFBWSxJQUFJLENBQUNuSSxXQUFXO0lBRWxDbUksVUFBVXpHLFdBQVcsR0FBR2QsVUFBVWlGLE9BQU87SUFDekNzQyxVQUFVdkcsU0FBUyxDQUFDbUUsR0FBRztJQUN2QixJQUFJLENBQUNBLEdBQUc7QUFDVjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTaEI7SUFDUCxNQUFNb0QsWUFBWSxJQUFJLENBQUNuSSxXQUFXO0lBRWxDLElBQUksQ0FBQ2dJLGNBQWMsQ0FBQyxTQUFTakQ7SUFDN0IsSUFBSSxDQUFDYixFQUFFLENBQUMsU0FBU2pFO0lBRWpCLElBQUlrSSxXQUFXO1FBQ2JBLFVBQVV6RyxXQUFXLEdBQUdkLFVBQVVpRixPQUFPO1FBQ3pDLElBQUksQ0FBQ0ksT0FBTztJQUNkO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzPzQ1MWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeUmVhZGFibGUkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAqIHJlcXVpcmVkIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCJcbiAgICogdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuXG4gICAgaWYgKGhlYWQubGVuZ3RoID4gMCkgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG5cbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgICBzb2NrZXQub24oJ2VuZCcsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBjbG9zaW5nIGhhbmRzaGFrZS5cbiAgICpcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tK1xuICAgKiAgICAgLSAtIC18d3MuY2xvc2UoKXwtLT58Y2xvc2UgZnJhbWV8LS0+fHdzLmNsb3NlKCl8LSAtIC1cbiAgICogICAgfCAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tKyAgICAgfFxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgICAgICAgfFxuICAgKiBDTE9TSU5HICB8d3MuY2xvc2UoKXw8LS18Y2xvc2UgZnJhbWV8PC0tKy0tLS0tKyAgICAgICBDTE9TSU5HXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICB8XG4gICAqICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLSsgICAgICAgIHxcbiAgICogICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLT58ZmlufCAtIC0gLSAtXG4gICAqICAgIHwgICAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICAgICB8ICAgKy0tLStcbiAgICogICAgIC0gLSAtIC0gLXxmaW58PC0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICogICAgICAgICAgICAgICstLS0rXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gU3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSByZWFzb24gd2h5IHRoZSBjb25uZWN0aW9uIGlzXG4gICAqICAgICBjbG9zaW5nXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy9cbiAgICAvLyBTcGVjaWZ5IGEgdGltZW91dCBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGNvbXBsZXRlLlxuICAgIC8vXG4gICAgdGhpcy5fY2xvc2VUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveS5iaW5kKHRoaXMuX3NvY2tldCksXG4gICAgICBjbG9zZVRpbWVvdXRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGJpbmFyeTogdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRlci5zZW5kKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBvcHRzLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkJztcbiAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbltcbiAgJ2JpbmFyeVR5cGUnLFxuICAnYnVmZmVyZWRBbW91bnQnLFxuICAnZXh0ZW5zaW9ucycsXG4gICdpc1BhdXNlZCcsXG4gICdwcm90b2NvbCcsXG4gICdyZWFkeVN0YXRlJyxcbiAgJ3VybCdcbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcblxuLy9cbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cbi8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4vL1xuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIGNyZWF0ZUNvbm5lY3Rpb246IHVuZGVmaW5lZCxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogdW5kZWZpbmVkLFxuICAgIHBvcnQ6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSBgICtcbiAgICAgICAgYChzdXBwb3J0ZWQgdmVyc2lvbnM6ICR7cHJvdG9jb2xWZXJzaW9ucy5qb2luKCcsICcpfSlgXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJzZWRVcmw7XG5cbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcy5ocmVmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuX3VybCA9IGFkZHJlc3M7XG4gIH1cblxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xuICBjb25zdCBpc1VuaXhTb2NrZXQgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG4gIGxldCBpbnZhbGlkVVJMTWVzc2FnZTtcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzVW5peFNvY2tldCkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgb3IgXCJ3cyt1bml4OlwiJztcbiAgfSBlbHNlIGlmIChpc1VuaXhTb2NrZXQgJiYgIXBhcnNlZFVybC5wYXRobmFtZSkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID0gXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIjtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIGludmFsaWRVUkxNZXNzYWdlID0gJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJztcbiAgfVxuXG4gIGlmIChpbnZhbGlkVVJMTWVzc2FnZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihpbnZhbGlkVVJMTWVzc2FnZSk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgZ2V0ID0gaXNTZWN1cmUgPyBodHRwcy5nZXQgOiBodHRwLmdldDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwZXJNZXNzYWdlRGVmbGF0ZTtcblxuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0O1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICAnU2VjLVdlYlNvY2tldC1LZXknOiBrZXksXG4gICAgQ29ubmVjdGlvbjogJ1VwZ3JhZGUnLFxuICAgIFVwZ3JhZGU6ICd3ZWJzb2NrZXQnLFxuICAgIC4uLm9wdHMuaGVhZGVyc1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc1VuaXhTb2NrZXQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdCgnOicpO1xuXG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cblxuICBpZiAob3B0cy5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0ID0gcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaG9zdCAhPT0gd2Vic29ja2V0Ll9vcmlnaW5hbEhvc3QpIHtcbiAgICAgIC8vXG4gICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAvLyBoZWFkZXJzIGFyZSBhbHNvIGRyb3BwZWQgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCB0byBhIHN1YmRvbWFpbi5cbiAgICAgIC8vXG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcbiAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVxID0gKHdlYnNvY2tldC5fcmVxID0gZ2V0KG9wdHMpKTtcblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxLmFib3J0ZWQpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0LmVtaXQoJ3VuZXhwZWN0ZWQtcmVzcG9uc2UnLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKFxuICAgICAgICB3ZWJzb2NrZXQsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXEub24oJ3VwZ3JhZGUnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQuZW1pdCgndXBncmFkZScsIHJlcyk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSB1c2VyIG1heSBoYXZlIGNsb3NlZCB0aGUgY29ubmVjdGlvbiBmcm9tIGEgbGlzdGVuZXIgb2YgdGhlIGB1cGdyYWRlYFxuICAgIC8vIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoIXByb3RvY29sU2V0LmhhcyhzZXJ2ZXJQcm90KSkge1xuICAgICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH1cblxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJQcm90KSB3ZWJzb2NrZXQuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiAnICtcbiAgICAgICAgICAnd2FzIHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZXh0ZW5zaW9ucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4dGVuc2lvbk5hbWVzID0gT2JqZWN0LmtleXMoZXh0ZW5zaW9ucyk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgZXh0ZW5zaW9uTmFtZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGV4dGVuc2lvbk5hbWVzWzBdICE9PSBQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3ZWJzb2NrZXQuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPVxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuXG4gICAgaWYgKHN0cmVhbS5zb2NrZXQgJiYgIXN0cmVhbS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAvL1xuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgY29tcGxldGVkLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxuICAgICAgLy9cbiAgICAgIHN0cmVhbS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdhYm9ydCcsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdmaW5pc2gnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRmluaXNoKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ21lc3NhZ2UnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNCaW5hcnkgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgYmluYXJ5IG9yIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSwgaXNCaW5hcnkpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BpbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcGluZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBpbmcoZGF0YSkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5wb25nKGRhdGEsICF3ZWJzb2NrZXQuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnY2xvc2UnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgbGV0IGNodW5rO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4gYW5kIGByZWFkYWJsZS5yZWFkKClgXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYC4gSWYgaW5zdGVhZCwgdGhlIHNvY2tldCBpcyBwYXVzZWQsIGFueSBwb3NzaWJsZSBidWZmZXJlZFxuICAvLyBkYXRhIHdpbGwgYmUgcmVhZCBhcyBhIHNpbmdsZSBjaHVuay5cbiAgLy9cbiAgaWYgKFxuICAgICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgJiZcbiAgICAhd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAoY2h1bmsgPSB3ZWJzb2NrZXQuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsXG4gICkge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG5cbiAgd2Vic29ja2V0Ll9yZWNlaXZlci5lbmQoKTtcblxuICB0aGlzW2tXZWJTb2NrZXRdID0gdW5kZWZpbmVkO1xuXG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQuX2Nsb3NlVGltZXIpO1xuXG4gIGlmIChcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgKSB7XG4gICAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZmluaXNoJywgcmVjZWl2ZXJPbkZpbmlzaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXRdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBuZXQuU29ja2V0YCBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzLmVuZCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG4gIHRoaXMub24oJ2Vycm9yJywgTk9PUCk7XG5cbiAgaWYgKHdlYnNvY2tldCkge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImh0dHBzIiwiaHR0cCIsIm5ldCIsInRscyIsInJhbmRvbUJ5dGVzIiwiY3JlYXRlSGFzaCIsIlJlYWRhYmxlIiwiVVJMIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJSZWNlaXZlciIsIlNlbmRlciIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsIkdVSUQiLCJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsIk5PT1AiLCJFdmVudFRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9ybWF0IiwicGFyc2UiLCJ0b0J1ZmZlciIsInJlYWR5U3RhdGVzIiwic3VicHJvdG9jb2xSZWdleCIsInByb3RvY29sVmVyc2lvbnMiLCJjbG9zZVRpbWVvdXQiLCJXZWJTb2NrZXQiLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJwcm90b2NvbHMiLCJvcHRpb25zIiwiX2JpbmFyeVR5cGUiLCJfY2xvc2VDb2RlIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIl9jbG9zZU1lc3NhZ2UiLCJfY2xvc2VUaW1lciIsIl9leHRlbnNpb25zIiwiX3BhdXNlZCIsIl9wcm90b2NvbCIsIl9yZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsIl9zZW5kZXIiLCJfc29ja2V0IiwiX2J1ZmZlcmVkQW1vdW50IiwiX2lzU2VydmVyIiwiX3JlZGlyZWN0cyIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImluaXRBc0NsaWVudCIsImJpbmFyeVR5cGUiLCJ0eXBlIiwiaW5jbHVkZXMiLCJidWZmZXJlZEFtb3VudCIsIl93cml0YWJsZVN0YXRlIiwibGVuZ3RoIiwiX2J1ZmZlcmVkQnl0ZXMiLCJleHRlbnNpb25zIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJpc1BhdXNlZCIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJyZWNlaXZlciIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsInNraXBVVEY4VmFsaWRhdGlvbiIsImdlbmVyYXRlTWFzayIsIm9uIiwicmVjZWl2ZXJPbkNvbmNsdWRlIiwicmVjZWl2ZXJPbkRyYWluIiwicmVjZWl2ZXJPbkVycm9yIiwicmVjZWl2ZXJPbk1lc3NhZ2UiLCJyZWNlaXZlck9uUGluZyIsInJlY2VpdmVyT25Qb25nIiwic2V0VGltZW91dCIsInNldE5vRGVsYXkiLCJ1bnNoaWZ0Iiwic29ja2V0T25DbG9zZSIsInNvY2tldE9uRGF0YSIsInNvY2tldE9uRW5kIiwic29ja2V0T25FcnJvciIsIk9QRU4iLCJlbWl0IiwiZW1pdENsb3NlIiwiQ0xPU0VEIiwiZXh0ZW5zaW9uTmFtZSIsImNsZWFudXAiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjbG9zZSIsImNvZGUiLCJkYXRhIiwibXNnIiwiYWJvcnRIYW5kc2hha2UiLCJfcmVxIiwiQ0xPU0lORyIsImVycm9yRW1pdHRlZCIsImVuZCIsImVyciIsImRlc3Ryb3kiLCJiaW5kIiwicGF1c2UiLCJwaW5nIiwibWFzayIsImNiIiwiRXJyb3IiLCJ0b1N0cmluZyIsInNlbmRBZnRlckNsb3NlIiwicG9uZyIsInJlc3VtZSIsIm5lZWREcmFpbiIsInNlbmQiLCJvcHRzIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJmaW4iLCJ0ZXJtaW5hdGUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJtZXRob2QiLCJnZXQiLCJsaXN0ZW5lciIsImxpc3RlbmVycyIsInNldCIsImhhbmRsZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ3ZWJzb2NrZXQiLCJwcm90b2NvbFZlcnNpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImZvbGxvd1JlZGlyZWN0cyIsIm1heFJlZGlyZWN0cyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJzb2NrZXRQYXRoIiwiaG9zdG5hbWUiLCJ0aW1lb3V0IiwiaG9zdCIsInBhdGgiLCJwb3J0IiwiUmFuZ2VFcnJvciIsInBhcnNlZFVybCIsImhyZWYiLCJlIiwiU3ludGF4RXJyb3IiLCJpc1NlY3VyZSIsImlzVW5peFNvY2tldCIsImludmFsaWRVUkxNZXNzYWdlIiwicGF0aG5hbWUiLCJoYXNoIiwiZW1pdEVycm9yQW5kQ2xvc2UiLCJkZWZhdWx0UG9ydCIsImtleSIsInByb3RvY29sU2V0IiwiU2V0IiwidGxzQ29ubmVjdCIsIm5ldENvbm5lY3QiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJoZWFkZXJzIiwiQ29ubmVjdGlvbiIsIlVwZ3JhZGUiLCJzZWFyY2giLCJoYW5kc2hha2VUaW1lb3V0Iiwib2ZmZXIiLCJ0ZXN0IiwiaGFzIiwiYWRkIiwib3JpZ2luIiwiT3JpZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImF1dGgiLCJwYXJ0cyIsInNwbGl0IiwiX29yaWdpbmFsSG9zdCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsImF1dGhvcml6YXRpb24iLCJjb29raWUiLCJCdWZmZXIiLCJmcm9tIiwicmVxIiwiYWJvcnRlZCIsInJlcyIsImxvY2F0aW9uIiwic3RhdHVzQ29kZSIsImFib3J0IiwiYWRkciIsImRpZ2VzdCIsInVwZGF0ZSIsInNlcnZlclByb3QiLCJwcm90RXJyb3IiLCJzaXplIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsIm1lc3NhZ2UiLCJleHRlbnNpb25OYW1lcyIsImFjY2VwdCIsImNvbm5lY3QiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsInN0cmVhbSIsImNhcHR1cmVTdGFja1RyYWNlIiwic2V0SGVhZGVyIiwiZGVzdHJveWVkIiwib25jZSIsInJlYXNvbiIsInByb2Nlc3MiLCJuZXh0VGljayIsInJlY2VpdmVyT25GaW5pc2giLCJpc0JpbmFyeSIsImNodW5rIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwicmVhZCIsIndyaXRlIiwiY2xlYXJUaW1lb3V0IiwiZmluaXNoZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/_version.js":
/*!******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/_version.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\n/**\n *  The current version of Ethers.\n */ exports.version = \"6.8.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlFQUFpRSxHQUNqRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCOztDQUVDLEdBQ0RBLGVBQWUsR0FBRyxTQUNsQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9fdmVyc2lvbi5qcz9lZDJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogRG8gTk9UIG1vZGlmeSB0aGlzIGZpbGU7IHNlZSAvc3JjLnRzL19hZG1pbi91cGRhdGUtdmVyc2lvbi50cyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuLyoqXG4gKiAgVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBFdGhlcnMuXG4gKi9cbmV4cG9ydHMudmVyc2lvbiA9IFwiNi44LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/_version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/abi-coder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AbiCoder = void 0;\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst address_js_1 = __webpack_require__(/*! ./coders/address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/address.js\");\nconst array_js_1 = __webpack_require__(/*! ./coders/array.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\");\nconst boolean_js_1 = __webpack_require__(/*! ./coders/boolean.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js\");\nconst bytes_js_1 = __webpack_require__(/*! ./coders/bytes.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\");\nconst fixed_bytes_js_1 = __webpack_require__(/*! ./coders/fixed-bytes.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js\");\nconst null_js_1 = __webpack_require__(/*! ./coders/null.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/null.js\");\nconst number_js_1 = __webpack_require__(/*! ./coders/number.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/number.js\");\nconst string_js_1 = __webpack_require__(/*! ./coders/string.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/string.js\");\nconst tuple_js_1 = __webpack_require__(/*! ./coders/tuple.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js\");\nconst fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = (0, index_js_3.getBytes)(data);\n        data = (0, index_js_3.hexlify)(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        } else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\n                    \"string\"\n                ], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [\n                        reason\n                    ]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            } catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\n                    \"uint256\"\n                ], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [\n                        code\n                    ]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            } catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        } else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: tx.to ? (0, index_js_2.getAddress)(tx.to) : null,\n        data: tx.data || \"0x\"\n    };\n    if (tx.from) {\n        transaction.from = (0, index_js_2.getAddress)(tx.from);\n    }\n    return (0, index_js_3.makeError)(message, \"CALL_EXCEPTION\", {\n        action,\n        data,\n        reason,\n        transaction,\n        invocation,\n        revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */ class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new array_js_1.ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new tuple_js_1.TupleCoder(param.components.map((c)=>this.#getCoder(c)), param.name);\n        }\n        switch(param.baseType){\n            case \"address\":\n                return new address_js_1.AddressCoder(param.name);\n            case \"bool\":\n                return new boolean_js_1.BooleanCoder(param.name);\n            case \"string\":\n                return new string_js_1.StringCoder(param.name);\n            case \"bytes\":\n                return new bytes_js_1.BytesCoder(param.name);\n            case \"\":\n                return new null_js_1.NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new number_js_1.NumberCoder(size / 8, match[1] === \"int\", param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            (0, index_js_1.assertArgument)(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new fixed_bytes_js_1.FixedBytesCoder(size, param.name);\n        }\n        (0, index_js_1.assertArgument)(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */ getDefaultValue(types) {\n        const coders = types.map((type)=>this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = new tuple_js_1.TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */ encode(types, values) {\n        (0, index_js_1.assertArgumentCount)(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type)=>this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = new tuple_js_1.TupleCoder(coders, \"_\");\n        const writer = new abstract_coder_js_1.Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */ decode(types, data, loose) {\n        const coders = types.map((type)=>this.#getCoder(fragments_js_1.ParamType.from(type)));\n        const coder = new tuple_js_1.TupleCoder(coders, \"_\");\n        return coder.decode(new abstract_coder_js_1.Reader(data, loose));\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */ static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */ static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\nexports.AbiCoder = AbiCoder; //# sourceMappingURL=abi-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvYWJpLWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7O0NBV0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsbUVBQW1FO0FBQ25FLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQyxzQkFBc0JELG1CQUFPQSxDQUFDLHlHQUE0QjtBQUNoRSxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQywyRkFBcUI7QUFDbEQsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsdUZBQW1CO0FBQzlDLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLDJGQUFxQjtBQUNsRCxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQyx1RkFBbUI7QUFDOUMsTUFBTU0sbUJBQW1CTixtQkFBT0EsQ0FBQyxtR0FBeUI7QUFDMUQsTUFBTU8sWUFBWVAsbUJBQU9BLENBQUMscUZBQWtCO0FBQzVDLE1BQU1RLGNBQWNSLG1CQUFPQSxDQUFDLHlGQUFvQjtBQUNoRCxNQUFNUyxjQUFjVCxtQkFBT0EsQ0FBQyx5RkFBb0I7QUFDaEQsTUFBTVUsYUFBYVYsbUJBQU9BLENBQUMsdUZBQW1CO0FBQzlDLE1BQU1XLGlCQUFpQlgsbUJBQU9BLENBQUMsaUZBQWdCO0FBQy9DLE1BQU1ZLGFBQWFaLG1CQUFPQSxDQUFDLHNGQUFxQjtBQUNoRCxNQUFNYSxhQUFhYixtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsbUVBQW1FO0FBQ25FLE1BQU1jLGVBQWUsSUFBSUM7QUFDekJELGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYsYUFBYUUsR0FBRyxDQUFDLE1BQU07QUFDdkJGLGFBQWFFLEdBQUcsQ0FBQyxNQUFNO0FBQ3ZCRixhQUFhRSxHQUFHLENBQUMsTUFBTTtBQUN2QkYs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RTZELEtBQUssRUFBRTtRQUN2QixNQUFNVCxTQUFTRCxNQUFNaEIsR0FBRyxDQUFDLENBQUNTLE9BQVMsSUFBSSxDQUFDLENBQUNsQixRQUFRLENBQUN2QyxlQUFla0UsU0FBUyxDQUFDN0IsSUFBSSxDQUFDb0I7UUFDaEYsTUFBTVUsUUFBUSxJQUFJcEUsV0FBVytDLFVBQVUsQ0FBQ21CLFFBQVE7UUFDaEQsT0FBT0UsTUFBTTNDLE1BQU0sQ0FBQyxJQUFJbEMsb0JBQW9CcUYsTUFBTSxDQUFDOUQsTUFBTTZEO0lBQzdEO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU9FLGtCQUFrQjtRQUNyQixJQUFJbkUsZ0JBQWdCLE1BQU07WUFDdEJBLGVBQWUsSUFBSXRCO1FBQ3ZCO1FBQ0EsT0FBT3NCO0lBQ1g7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT0Msd0JBQXdCQyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFO1FBQzdDLE9BQU9ILHdCQUF3QkMsUUFBUUMsSUFBSUMsTUFBTTFCLFNBQVN5RixlQUFlO0lBQzdFO0FBQ0o7QUFDQTNGLGdCQUFnQixHQUFHRSxVQUNuQixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvYWJpLWNvZGVyLmpzPzBkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBXaGVuIHNlbmRpbmcgdmFsdWVzIHRvIG9yIHJlY2VpdmluZyB2YWx1ZXMgZnJvbSBhIFtbQ29udHJhY3RdXSwgdGhlXG4gKiAgZGF0YSBpcyBnZW5lcmFsbHkgZW5jb2RlZCB1c2luZyB0aGUgW0FCSSBzdGFuZGFyZF0obGluay1zb2xjLWFiaSkuXG4gKlxuICogIFRoZSBBYmlDb2RlciBwcm92aWRlcyBhIHV0aWxpdHkgdG8gZW5jb2RlIHZhbHVlcyB0byBBQkkgZGF0YSBhbmRcbiAqICBkZWNvZGUgdmFsdWVzIGZyb20gQUJJIGRhdGEuXG4gKlxuICogIE1vc3Qgb2YgdGhlIHRpbWUsIGRldmVsb3BlcnMgc2hvdWxkIGZhdm91ciB0aGUgW1tDb250cmFjdF1dIGNsYXNzLFxuICogIHdoaWNoIGZ1cnRoZXIgYWJzdHJhY3RzIGEgbG90IG9mIHRoZSBmaW5lciBkZXRhaWxzIG9mIEFCSSBkYXRhLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaS9hYmktY29kZXI6QUJJIEVuY29kaW5nXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJpQ29kZXIgPSB2b2lkIDA7XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hZGRyZXNzLmpzXCIpO1xuY29uc3QgYXJyYXlfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hcnJheS5qc1wiKTtcbmNvbnN0IGJvb2xlYW5fanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9ib29sZWFuLmpzXCIpO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9ieXRlcy5qc1wiKTtcbmNvbnN0IGZpeGVkX2J5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvZml4ZWQtYnl0ZXMuanNcIik7XG5jb25zdCBudWxsX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvbnVsbC5qc1wiKTtcbmNvbnN0IG51bWJlcl9qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL251bWJlci5qc1wiKTtcbmNvbnN0IHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4vY29kZXJzL3N0cmluZy5qc1wiKTtcbmNvbnN0IHR1cGxlX2pzXzEgPSByZXF1aXJlKFwiLi9jb2RlcnMvdHVwbGUuanNcIik7XG5jb25zdCBmcmFnbWVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2ZyYWdtZW50cy5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2NvbnRyb2wtc3RydWN0dXJlcy5odG1sXG5jb25zdCBQYW5pY1JlYXNvbnMgPSBuZXcgTWFwKCk7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MDAsIFwiR0VORVJJQ19QQU5JQ1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgwMSwgXCJBU1NFUlRfRkFMU0VcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTEsIFwiT1ZFUkZMT1dcIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MTIsIFwiRElWSURFX0JZX1pFUk9cIik7XG5QYW5pY1JlYXNvbnMuc2V0KDB4MjEsIFwiRU5VTV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHgyMiwgXCJCQURfU1RPUkFHRV9EQVRBXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDMxLCBcIlNUQUNLX1VOREVSRkxPV1wiKTtcblBhbmljUmVhc29ucy5zZXQoMHgzMiwgXCJBUlJBWV9SQU5HRV9FUlJPUlwiKTtcblBhbmljUmVhc29ucy5zZXQoMHg0MSwgXCJPVVRfT0ZfTUVNT1JZXCIpO1xuUGFuaWNSZWFzb25zLnNldCgweDUxLCBcIlVOSU5JVElBTElaRURfRlVOQ1RJT05fQ0FMTFwiKTtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xubGV0IGRlZmF1bHRDb2RlciA9IG51bGw7XG5mdW5jdGlvbiBnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihhY3Rpb24sIHR4LCBkYXRhLCBhYmlDb2Rlcikge1xuICAgIGxldCBtZXNzYWdlID0gXCJtaXNzaW5nIHJldmVydCBkYXRhXCI7XG4gICAgbGV0IHJlYXNvbiA9IG51bGw7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IG51bGw7XG4gICAgbGV0IHJldmVydCA9IG51bGw7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiZXhlY3V0aW9uIHJldmVydGVkXCI7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKGRhdGEpO1xuICAgICAgICBkYXRhID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKG5vIGRhdGEgcHJlc2VudDsgbGlrZWx5IHJlcXVpcmUoZmFsc2UpIG9jY3VycmVkXCI7XG4gICAgICAgICAgICByZWFzb24gPSBcInJlcXVpcmUoZmFsc2UpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoICUgMzIgIT09IDQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIGRhdGEgbGVuZ3RoKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDA4YzM3OWEwXCIpIHtcbiAgICAgICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhc29uID0gYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuICAgICAgICAgICAgICAgIHJldmVydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVhc29uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke0pTT04uc3RyaW5naWZ5KHJlYXNvbil9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGNvdWxkIG5vdCBkZWNvZGUgcmVhc29uOyBpbnZhbGlkIHN0cmluZyBkYXRhKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDQpKSA9PT0gXCIweDRlNDg3YjcxXCIpIHtcbiAgICAgICAgICAgIC8vIFBhbmljKHVpbnQyNTYpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBOdW1iZXIoYWJpQ29kZXIuZGVjb2RlKFtcInVpbnQyNTZcIl0sIGJ5dGVzLnNsaWNlKDQpKVswXSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbY29kZV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYXNvbiA9IGBQYW5pYyBkdWUgdG8gJHtQYW5pY1JlYXNvbnMuZ2V0KGNvZGUpIHx8IFwiVU5LTk9XTlwifSgke2NvZGV9KWA7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOiAke3JlYXNvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoY291bGQgbm90IGRlY29kZSBwYW5pYyBjb2RlKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAodW5rbm93biBjdXN0b20gZXJyb3IpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHRvOiAodHgudG8gPyAoMCwgaW5kZXhfanNfMi5nZXRBZGRyZXNzKSh0eC50bykgOiBudWxsKSxcbiAgICAgICAgZGF0YTogKHR4LmRhdGEgfHwgXCIweFwiKVxuICAgIH07XG4gICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZnJvbSA9ICgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKHR4LmZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMubWFrZUVycm9yKShtZXNzYWdlLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgYWN0aW9uLCBkYXRhLCByZWFzb24sIHRyYW5zYWN0aW9uLCBpbnZvY2F0aW9uLCByZXZlcnRcbiAgICB9KTtcbn1cbi8qKlxuICogIFRoZSAqKkFiaUNvZGVyKiogaXMgYSBsb3ctbGV2ZWwgY2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY29kaW5nIEphdmFTY3JpcHRcbiAqICB2YWx1ZXMgaW50byBiaW5hcnkgZGF0YSBhbmQgZGVjb2RpbmcgYmluYXJ5IGRhdGEgaW50byBKYXZhU2NyaXB0IHZhbHVlcy5cbiAqL1xuY2xhc3MgQWJpQ29kZXIge1xuICAgICNnZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0uaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFycmF5X2pzXzEuQXJyYXlDb2Rlcih0aGlzLiNnZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbS5pc1R1cGxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKHBhcmFtLmNvbXBvbmVudHMubWFwKChjKSA9PiB0aGlzLiNnZXRDb2RlcihjKSksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhZGRyZXNzX2pzXzEuQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJvb2xlYW5fanNfMS5Cb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdHJpbmdfanNfMS5TdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYnl0ZXNfanNfMS5CeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbnVsbF9qc18xLk51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbnVtYmVyX2pzXzEuTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoc2l6ZSAhPT0gMCAmJiBzaXplIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBmaXhlZF9ieXRlc19qc18xLkZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgRm9yIGV4YW1wbGUsIGEgYGB1aW50YGAgaXMgYnkgZGVmYXVsdCBgYDBgYCBhbmQgYGBib29sYGBcbiAgICAgKiAgaXMgYnkgZGVmYXVsdCBgYGZhbHNlYGAuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy4jZ2V0Q29kZXIoZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGUgdGhlICUldmFsdWVzJSUgYXMgdGhlICUldHlwZXMlJSBpbnRvIEFCSSBkYXRhLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAgICAgKi9cbiAgICBlbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudENvdW50KSh2YWx1ZXMubGVuZ3RoLCB0eXBlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihmcmFnbWVudHNfanNfMS5QYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgdHVwbGVfanNfMS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuV3JpdGVyKCk7XG4gICAgICAgIGNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIERlY29kZSB0aGUgQUJJICUlZGF0YSUlIGFzIHRoZSAlJXR5cGVzJSUgaW50byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAgSWYgJSVsb29zZSUlIGRlY29kaW5nIGlzIGVuYWJsZWQsIHRoZW4gc3RyaWN0IHBhZGRpbmcgaXNcbiAgICAgKiAgbm90IGVuZm9yY2VkLiBTb21lIG9sZGVyIHZlcnNpb25zIG9mIFNvbGlkaXR5IGluY29ycmVjdGx5XG4gICAgICogIHBhZGRlZCBldmVudCBkYXRhIGVtaXR0ZWQgZnJvbSBgYGV4dGVybmFsYGAgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLiNnZXRDb2RlcihmcmFnbWVudHNfanNfMS5QYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyB0dXBsZV9qc18xLlR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUobmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuUmVhZGVyKGRhdGEsIGxvb3NlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzaGFyZWQgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgZGVmYXVsdCBbW0FiaUNvZGVyXV0uXG4gICAgICpcbiAgICAgKiAgT24gdGhlIGZpcnN0IGNhbGwsIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRBYmlDb2RlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDb2RlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdENvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtY29tcGF0aWJsZSBbW0NhbGxFeGNlcHRpb25FcnJvcl1dIEVycm9yIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiAgcmVzdWx0ICUlZGF0YSUlIGZvciB0aGUgW1tDYWxsRXhjZXB0aW9uQWN0aW9uXV0gJSVhY3Rpb24lJSBhZ2FpbnN0XG4gICAgICogIHRoZSBUcmFuc2FjdGlvbiAlJXR4JSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKGFjdGlvbiwgdHgsIGRhdGEsIEFiaUNvZGVyLmRlZmF1bHRBYmlDb2RlcigpKTtcbiAgICB9XG59XG5leHBvcnRzLkFiaUNvZGVyID0gQWJpQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQWJpQ29kZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJhZGRyZXNzX2pzXzEiLCJhcnJheV9qc18xIiwiYm9vbGVhbl9qc18xIiwiYnl0ZXNfanNfMSIsImZpeGVkX2J5dGVzX2pzXzEiLCJudWxsX2pzXzEiLCJudW1iZXJfanNfMSIsInN0cmluZ19qc18xIiwidHVwbGVfanNfMSIsImZyYWdtZW50c19qc18xIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJQYW5pY1JlYXNvbnMiLCJNYXAiLCJzZXQiLCJwYXJhbVR5cGVCeXRlcyIsIlJlZ0V4cCIsInBhcmFtVHlwZU51bWJlciIsImRlZmF1bHRDb2RlciIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiYWN0aW9uIiwidHgiLCJkYXRhIiwiYWJpQ29kZXIiLCJtZXNzYWdlIiwicmVhc29uIiwiaW52b2NhdGlvbiIsInJldmVydCIsImJ5dGVzIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwibGVuZ3RoIiwic2xpY2UiLCJkZWNvZGUiLCJzaWduYXR1cmUiLCJuYW1lIiwiYXJncyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvZGUiLCJOdW1iZXIiLCJnZXQiLCJ0cmFuc2FjdGlvbiIsInRvIiwiZ2V0QWRkcmVzcyIsImZyb20iLCJtYWtlRXJyb3IiLCJnZXRDb2RlciIsInBhcmFtIiwiaXNBcnJheSIsIkFycmF5Q29kZXIiLCJhcnJheUNoaWxkcmVuIiwiYXJyYXlMZW5ndGgiLCJpc1R1cGxlIiwiVHVwbGVDb2RlciIsImNvbXBvbmVudHMiLCJtYXAiLCJjIiwiYmFzZVR5cGUiLCJBZGRyZXNzQ29kZXIiLCJCb29sZWFuQ29kZXIiLCJTdHJpbmdDb2RlciIsIkJ5dGVzQ29kZXIiLCJOdWxsQ29kZXIiLCJtYXRjaCIsInR5cGUiLCJzaXplIiwicGFyc2VJbnQiLCJhc3NlcnRBcmd1bWVudCIsIk51bWJlckNvZGVyIiwiRml4ZWRCeXRlc0NvZGVyIiwiZ2V0RGVmYXVsdFZhbHVlIiwidHlwZXMiLCJjb2RlcnMiLCJQYXJhbVR5cGUiLCJjb2RlciIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsInZhbHVlcyIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJ3cml0ZXIiLCJXcml0ZXIiLCJsb29zZSIsIlJlYWRlciIsImRlZmF1bHRBYmlDb2RlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/bytes32.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/bytes32.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  About bytes32 strings...\n *\n *  @_docloc: api/utils:Bytes32 Strings\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeBytes32String = exports.encodeBytes32String = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  Encodes %%text%% as a Bytes32 string.\n */ function encodeBytes32String(text) {\n    // Get the bytes\n    const bytes = (0, index_js_1.toUtf8Bytes)(text);\n    // Check we have room for null-termination\n    if (bytes.length > 31) {\n        throw new Error(\"bytes32 string must be less than 32 bytes\");\n    }\n    // Zero-pad (implicitly null-terminates)\n    return (0, index_js_1.zeroPadBytes)(bytes, 32);\n}\nexports.encodeBytes32String = encodeBytes32String;\n/**\n *  Encodes the Bytes32-encoded %%bytes%% into a string.\n */ function decodeBytes32String(_bytes) {\n    const data = (0, index_js_1.getBytes)(_bytes, \"bytes\");\n    // Must be 32 bytes with a null-termination\n    if (data.length !== 32) {\n        throw new Error(\"invalid bytes32 - not 32 bytes long\");\n    }\n    if (data[31] !== 0) {\n        throw new Error(\"invalid bytes32 string - no null terminator\");\n    }\n    // Find the null termination\n    let length = 31;\n    while(data[length - 1] === 0){\n        length--;\n    }\n    // Determine the string value\n    return (0, index_js_1.toUtf8String)(data.slice(0, length));\n}\nexports.decodeBytes32String = decodeBytes32String; //# sourceMappingURL=bytes32.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvYnl0ZXMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7O0NBSUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ2pFLE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5Qzs7Q0FFQyxHQUNELFNBQVNGLG9CQUFvQkcsSUFBSTtJQUM3QixnQkFBZ0I7SUFDaEIsTUFBTUMsUUFBUSxDQUFDLEdBQUdILFdBQVdJLFdBQVcsRUFBRUY7SUFDMUMsMENBQTBDO0lBQzFDLElBQUlDLE1BQU1FLE1BQU0sR0FBRyxJQUFJO1FBQ25CLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLHdDQUF3QztJQUN4QyxPQUFPLENBQUMsR0FBR04sV0FBV08sWUFBWSxFQUFFSixPQUFPO0FBQy9DO0FBQ0FQLDJCQUEyQixHQUFHRztBQUM5Qjs7Q0FFQyxHQUNELFNBQVNELG9CQUFvQlUsTUFBTTtJQUMvQixNQUFNQyxPQUFPLENBQUMsR0FBR1QsV0FBV1UsUUFBUSxFQUFFRixRQUFRO0lBQzlDLDJDQUEyQztJQUMzQyxJQUFJQyxLQUFLSixNQUFNLEtBQUssSUFBSTtRQUNwQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxJQUFJRyxJQUFJLENBQUMsR0FBRyxLQUFLLEdBQUc7UUFDaEIsTUFBTSxJQUFJSCxNQUFNO0lBQ3BCO0lBQ0EsNEJBQTRCO0lBQzVCLElBQUlELFNBQVM7SUFDYixNQUFPSSxJQUFJLENBQUNKLFNBQVMsRUFBRSxLQUFLLEVBQUc7UUFDM0JBO0lBQ0o7SUFDQSw2QkFBNkI7SUFDN0IsT0FBTyxDQUFDLEdBQUdMLFdBQVdXLFlBQVksRUFBRUYsS0FBS0csS0FBSyxDQUFDLEdBQUdQO0FBQ3REO0FBQ0FULDJCQUEyQixHQUFHRSxxQkFDOUIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2J5dGVzMzIuanM/ZTRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEFib3V0IGJ5dGVzMzIgc3RyaW5ncy4uLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3V0aWxzOkJ5dGVzMzIgU3RyaW5nc1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgRW5jb2RlcyAlJXRleHQlJSBhcyBhIEJ5dGVzMzIgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGVCeXRlczMyU3RyaW5nKHRleHQpIHtcbiAgICAvLyBHZXQgdGhlIGJ5dGVzXG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS50b1V0ZjhCeXRlcykodGV4dCk7XG4gICAgLy8gQ2hlY2sgd2UgaGF2ZSByb29tIGZvciBudWxsLXRlcm1pbmF0aW9uXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDMxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ5dGVzMzIgc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDMyIGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvLyBaZXJvLXBhZCAoaW1wbGljaXRseSBudWxsLXRlcm1pbmF0ZXMpXG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnplcm9QYWRCeXRlcykoYnl0ZXMsIDMyKTtcbn1cbmV4cG9ydHMuZW5jb2RlQnl0ZXMzMlN0cmluZyA9IGVuY29kZUJ5dGVzMzJTdHJpbmc7XG4vKipcbiAqICBFbmNvZGVzIHRoZSBCeXRlczMyLWVuY29kZWQgJSVieXRlcyUlIGludG8gYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJ5dGVzMzJTdHJpbmcoX2J5dGVzKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XG4gICAgfVxuICAgIGlmIChkYXRhWzMxXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBudWxsIHRlcm1pbmF0aW9uXG4gICAgbGV0IGxlbmd0aCA9IDMxO1xuICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS50b1V0ZjhTdHJpbmcpKGRhdGEuc2xpY2UoMCwgbGVuZ3RoKSk7XG59XG5leHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBkZWNvZGVCeXRlczMyU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMzMi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVCeXRlczMyU3RyaW5nIiwiZW5jb2RlQnl0ZXMzMlN0cmluZyIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwidGV4dCIsImJ5dGVzIiwidG9VdGY4Qnl0ZXMiLCJsZW5ndGgiLCJFcnJvciIsInplcm9QYWRCeXRlcyIsIl9ieXRlcyIsImRhdGEiLCJnZXRCeXRlcyIsInRvVXRmOFN0cmluZyIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/bytes32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n * @_ignore:\n */ exports.WordSize = 32;\nconst Padding = new Uint8Array(exports.WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\n    \"then\"\n];\nconst _guard = {};\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */ class Result extends Array {\n    #names;\n    /**\n     *  @private\n     */ constructor(...args){\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index)=>{\n            this[index] = item;\n        });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name)=>{\n            if (typeof name === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, new Map());\n        // Remove any key thats not unique\n        this.#names = Object.freeze(items.map((item, index)=>{\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        }));\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = (0, index_js_1.getNumber)(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function(...args) {\n                            return value.apply(this === receiver ? target : this, args);\n                        };\n                    } else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply(this === receiver ? target : this, [\n                            prop\n                        ]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n    /**\n     *  Returns the Result as a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */ toArray() {\n        const result = [];\n        this.forEach((item, index)=>{\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */ toObject() {\n        return this.#names.reduce((accum, name, index)=>{\n            (0, index_js_1.assert)(name != null, \"value at index ${ index } unnamed\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            // Add values for names that don't conflict\n            if (!(name in accum)) {\n                accum[name] = this.getValue(name);\n            }\n            return accum;\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */ slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const result = [], names = [];\n        for(let i = start; i < end; i++){\n            result.push(this[i]);\n            names.push(this.#names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ filter(callback, thisArg) {\n        const result = [], names = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(this.#names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */ map(callback, thisArg) {\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */ getValue(name) {\n        const index = this.#names.indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */ static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\nexports.Result = Result;\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */ function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function(path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for(let key in object){\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({\n                    path: childPath,\n                    error: error\n                });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexports.checkResultErrors = checkResultErrors;\nfunction getValue(value) {\n    let bytes = (0, index_js_1.toBeArray)(value);\n    (0, index_js_1.assert)(bytes.length <= exports.WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\n        buffer: bytes,\n        length: exports.WordSize,\n        offset: bytes.length\n    });\n    if (bytes.length !== exports.WordSize) {\n        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([\n            Padding.slice(bytes.length % exports.WordSize),\n            bytes\n        ]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */ class Coder {\n    constructor(name, type, localName, dynamic){\n        (0, index_js_1.defineProperties)(this, {\n            name,\n            type,\n            localName,\n            dynamic\n        }, {\n            name: \"string\",\n            type: \"string\",\n            localName: \"string\",\n            dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        (0, index_js_1.assertArgument)(false, message, this.localName, value);\n    }\n}\nexports.Coder = Coder;\n/**\n *  @_ignore\n */ class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor(){\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return (0, index_js_1.concat)(this.#data);\n    }\n    get length() {\n        return this.#dataLength;\n    }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData((0, index_js_1.getBytesCopy)(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = (0, index_js_1.getBytesCopy)(value);\n        const paddingOffset = bytes.length % exports.WordSize;\n        if (paddingOffset) {\n            bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([\n                bytes,\n                Padding.slice(paddingOffset)\n            ]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += exports.WordSize;\n        return (value)=>{\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\nexports.Writer = Writer;\n/**\n *  @_ignore\n */ class Reader {\n    #data;\n    #offset;\n    constructor(data, allowLoose){\n        (0, index_js_1.defineProperties)(this, {\n            allowLoose: !!allowLoose\n        });\n        this.#data = (0, index_js_1.getBytesCopy)(data);\n        this.#offset = 0;\n    }\n    get data() {\n        return (0, index_js_1.hexlify)(this.#data);\n    }\n    get dataLength() {\n        return this.#data.length;\n    }\n    get consumed() {\n        return this.#offset;\n    }\n    get bytes() {\n        return new Uint8Array(this.#data);\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            } else {\n                (0, index_js_1.assert)(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: (0, index_js_1.getBytesCopy)(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));\n    }\n    readIndex() {\n        return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));\n    }\n}\nexports.Reader = Reader; //# sourceMappingURL=abstract-coder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsYUFBYSxHQUFHQSx5QkFBeUIsR0FBR0EsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3ZILE1BQU1RLGFBQWFDLG1CQUFPQSxDQUFDLHFGQUFzQjtBQUNqRDs7Q0FFQyxHQUNEVCxnQkFBZ0IsR0FBRztBQUNuQixNQUFNVSxVQUFVLElBQUlDLFdBQVdYLFFBQVFPLFFBQVE7QUFDL0MscUVBQXFFO0FBQ3JFLGlFQUFpRTtBQUNqRSxNQUFNSyxpQkFBaUI7SUFBQztDQUFPO0FBQy9CLE1BQU1DLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxXQUFXQyxJQUFJLEVBQUVDLEtBQUs7SUFDM0IsTUFBTUMsVUFBVSxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUVILEtBQUssQ0FBQztJQUMxRkUsUUFBUUQsS0FBSyxHQUFHQTtJQUNoQixNQUFNQztBQUNWO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsTUFBTVgsZUFBZWE7SUFDakIsQ0FBQ0MsS0FBSyxDQUFDO0lBQ1A7O0tBRUMsR0FDREMsWUFBWSxHQUFHQyxJQUFJLENBQUU7UUFDakIsb0RBQW9EO1FBQ3BELHVEQUF1RDtRQUN2RCx3REFBd0Q7UUFDeEQsdURBQXVEO1FBQ3ZELGtEQUFrRDtRQUNsRCwyRUFBMkU7UUFDM0UsTUFBTUMsUUFBUUQsSUFBSSxDQUFDLEVBQUU7UUFDckIsSUFBSUUsUUFBUUYsSUFBSSxDQUFDLEVBQUU7UUFDbkIsSUFBSUYsUUFBUSxDQUFDRSxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRUcsS0FBSztRQUNqQyxJQUFJQyxPQUFPO1FBQ1gsSUFBSUgsVUFBVVYsUUFBUTtZQUNsQlcsUUFBUUY7WUFDUkYsUUFB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R3RHLFdBQVd1RyxRQUFRLEVBQUUsSUFBSSxDQUFDSixTQUFTLENBQUMzRyxRQUFRTyxRQUFRO0lBQ25FO0FBQ0o7QUFDQVAsY0FBYyxHQUFHRSxRQUNqQiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzPzU0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWRlciA9IGV4cG9ydHMuV3JpdGVyID0gZXhwb3J0cy5Db2RlciA9IGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSBleHBvcnRzLlJlc3VsdCA9IGV4cG9ydHMuV29yZFNpemUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiBAX2lnbm9yZTpcbiAqL1xuZXhwb3J0cy5Xb3JkU2l6ZSA9IDMyO1xuY29uc3QgUGFkZGluZyA9IG5ldyBVaW50OEFycmF5KGV4cG9ydHMuV29yZFNpemUpO1xuLy8gUHJvcGVydGllcyB1c2VkIHRvIGltbWVkaWF0ZSBwYXNzIHRocm91Z2ggdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0XG4vLyAtIGB0aGVuYCBpcyB1c2VkIHRvIGRldGVjdCBpZiBhbiBvYmplY3QgaXMgYSBQcm9taXNlIGZvciBhd2FpdFxuY29uc3QgcGFzc1Byb3BlcnRpZXMgPSBbXCJ0aGVuXCJdO1xuY29uc3QgX2d1YXJkID0ge307XG5mdW5jdGlvbiB0aHJvd0Vycm9yKG5hbWUsIGVycm9yKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBFcnJvcihgZGVmZXJyZWQgZXJyb3IgZHVyaW5nIEFCSSBkZWNvZGluZyB0cmlnZ2VyZWQgYWNjZXNzaW5nICR7bmFtZX1gKTtcbiAgICB3cmFwcGVkLmVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgd3JhcHBlZDtcbn1cbi8qKlxuICogIEEgW1tSZXN1bHRdXSBpcyBhIHN1Yi1jbGFzcyBvZiBBcnJheSwgd2hpY2ggYWxsb3dzIGFjY2Vzc2luZyBhbnlcbiAqICBvZiBpdHMgdmFsdWVzIGVpdGhlciBwb3NpdGlvbmFsbHkgYnkgaXRzIGluZGV4IG9yLCBpZiBrZXlzIGFyZVxuICogIHByb3ZpZGVkIGJ5IGl0cyBuYW1lLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL2FiaVxuICovXG5jbGFzcyBSZXN1bHQgZXh0ZW5kcyBBcnJheSB7XG4gICAgI25hbWVzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVG8gcHJvcGVybHkgc3ViLWNsYXNzIEFycmF5IHNvIHRoZSBvdGhlciBidWlsdC1pblxuICAgICAgICAvLyBmdW5jdGlvbnMgd29yaywgdGhlIGNvbnN0cnVjdG9yIGhhcyB0byBiZWhhdmUgZmFpcmx5XG4gICAgICAgIC8vIHdlbGwuIFNvLCBpbiB0aGUgZXZlbnQgd2UgYXJlIGNyZWF0ZWQgdmlhIGZyb21JdGVtcygpXG4gICAgICAgIC8vIHdlIGJ1aWxkIHRoZSByZWFkLW9ubHkgUmVzdWx0IG9iamVjdCB3ZSB3YW50LCBidXQgb25cbiAgICAgICAgLy8gYW55IG90aGVyIGlucHV0LCB3ZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3JcbiAgICAgICAgLy8gY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgaXRlbXM6IEFycmF5PGFueT4sIGtleXM/OiBBcnJheTxudWxsIHwgc3RyaW5nPik7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gYXJnc1swXTtcbiAgICAgICAgbGV0IGl0ZW1zID0gYXJnc1sxXTtcbiAgICAgICAgbGV0IG5hbWVzID0gKGFyZ3NbMl0gfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGxldCB3cmFwID0gdHJ1ZTtcbiAgICAgICAgaWYgKGd1YXJkICE9PSBfZ3VhcmQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gYXJncztcbiAgICAgICAgICAgIG5hbWVzID0gW107XG4gICAgICAgICAgICB3cmFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuJ3QganVzdCBwYXNzIGluIC4uLml0ZW1zIHNpbmNlIGFuIGFycmF5IG9mIGxlbmd0aCAxXG4gICAgICAgIC8vIGlzIGEgc3BlY2lhbCBjYXNlIGluIHRoZSBzdXBlci5cbiAgICAgICAgc3VwZXIoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsgdGhpc1tpbmRleF0gPSBpdGVtOyB9KTtcbiAgICAgICAgLy8gRmluZCBhbGwgdW5pcXVlIGtleXNcbiAgICAgICAgY29uc3QgbmFtZUNvdW50cyA9IG5hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0uc2V0KG5hbWUsIChhY2N1bS5nZXQobmFtZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgKG5ldyBNYXAoKSkpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IGtleSB0aGF0cyBub3QgdW5pcXVlXG4gICAgICAgIHRoaXMuI25hbWVzID0gT2JqZWN0LmZyZWV6ZShpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiBuYW1lQ291bnRzLmdldChuYW1lKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCF3cmFwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB3cmFwcGVkIFJlc3VsdCBpcyBpbW11dGFibGVcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgLy8gUHJveHkgaW5kaWNlcyBhbmQgbmFtZXMgc28gd2UgY2FuIHRyYXAgZGVmZXJyZWQgZXJyb3JzXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByb3ApID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGV4IGFjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikocHJvcCwgXCIlaW5kZXhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmVzdWx0IHJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgaW5kZXggJHtpbmRleH1gLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9ucyB3b3JrIHdpdGggcHJpdmF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkjbm9fcHJpdmF0ZV9wcm9wZXJ0eV9mb3J3YXJkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoKHRoaXMgPT09IHJlY2VpdmVyKSA/IHRhcmdldCA6IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgbmFtZSBhY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRWYWx1ZS5hcHBseSgodGhpcyA9PT0gcmVjZWl2ZXIpID8gdGFyZ2V0IDogdGhpcywgW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgUmVzdWx0IGFzIGEgbm9ybWFsIEFycmF5LlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkXG4gICAgICogIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aW5kZXh9YCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBSZXN1bHQgYXMgYW4gT2JqZWN0IHdpdGggZWFjaCBuYW1lLXZhbHVlIHBhaXIuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIGFueSB2YWx1ZSBpcyB1bm5hbWVkLCBvciBpZiB0aGVyZSBhcmVcbiAgICAgKiAgYW55IG91dHN0YW5kaW5nIGRlZmVycmVkIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25hbWVzLnJlZHVjZSgoYWNjdW0sIG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKG5hbWUgIT0gbnVsbCwgXCJ2YWx1ZSBhdCBpbmRleCAkeyBpbmRleCB9IHVubmFtZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b09iamVjdCgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlcyBmb3IgbmFtZXMgdGhhdCBkb24ndCBjb25mbGljdFxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBhY2N1bSkpIHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXSwgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLiNuYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgZmlsdGVyKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGl0ZW0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaCh0aGlzLiNuYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCByZXN1bHQsIG5hbWVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlXG4gICAgICovXG4gICAgbWFwKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGluZGV4ICR7aX1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgaXRlbSwgaSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgJSVuYW1lJSUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhIGtleSB3aG9zZSBuYW1lIGNvbmZsaWN0cyB3aXRoXG4gICAgICogIGEgbWV0aG9kIG9uIGEgW1tSZXN1bHRdXSBvciBpdHMgc3VwZXJjbGFzcyBBcnJheSwgb3IgYW55XG4gICAgICogIEphdmFTY3JpcHQga2V5d29yZCwgdGhpcyBlbnN1cmVzIGFsbCBuYW1lZCB2YWx1ZXMgYXJlIHN0aWxsXG4gICAgICogIGFjY2Vzc2libGUgYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCB2YWx1ZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1Jlc3VsdF1dIGZvciAlJWl0ZW1zJSUgd2l0aCBlYWNoIGVudHJ5XG4gICAgICogIGFsc28gYWNjZXNzaWJsZSBieSBpdHMgY29ycmVzcG9uZGluZyBuYW1lIGluICUla2V5cyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSXRlbXMoaXRlbXMsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHQoX2d1YXJkLCBpdGVtcywga2V5cyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXN1bHQgPSBSZXN1bHQ7XG4vKipcbiAqICBSZXR1cm5zIGFsbCBlcnJvcnMgZm91bmQgaW4gYSBbW1Jlc3VsdF1dLlxuICpcbiAqICBTaW5jZSBjZXJ0YWluIGVycm9ycyBlbmNvdW50ZXJlZCB3aGVuIGNyZWF0aW5nIGEgW1tSZXN1bHRdXSBkb1xuICogIG5vdCBpbXBhY3QgdGhlIGFiaWxpdHkgdG8gY29udGludWUgcGFyc2luZyBkYXRhLCB0aGV5IGFyZVxuICogIGRlZmVycmVkIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5IGFjY2Vzc2VkLiBIZW5jZSBhIGZhdWx0eSBzdHJpbmdcbiAqICBpbiBhbiBFdmVudCB0aGF0IGlzIG5ldmVyIHVzZWQgZG9lcyBub3QgaW1wYWN0IHRoZSBwcm9ncmFtIGZsb3cuXG4gKlxuICogIEhvd2V2ZXIsIHNvbWV0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIGFjY2VzcywgaWRlbnRpZnkgb3JcbiAqICB2YWxpZGF0ZSBjb3JyZWN0bmVzcyBvZiBhIFtbUmVzdWx0XV0uXG4gKlxuICogIEBfZG9jbG9jIGFwaS9hYmlcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnM7XG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGxldCBieXRlcyA9ICgwLCBpbmRleF9qc18xLnRvQmVBcnJheSkodmFsdWUpO1xuICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoYnl0ZXMubGVuZ3RoIDw9IGV4cG9ydHMuV29yZFNpemUsIFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBleHBvcnRzLldvcmRTaXplLCBvZmZzZXQ6IGJ5dGVzLmxlbmd0aCB9KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBleHBvcnRzLldvcmRTaXplKSB7XG4gICAgICAgIGJ5dGVzID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSgoMCwgaW5kZXhfanNfMS5jb25jYXQpKFtQYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIGV4cG9ydHMuV29yZFNpemUpLCBieXRlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQ29kZXIge1xuICAgIC8vIFRoZSBjb2RlciBuYW1lOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZSwgYXJyYXksIGV0Yy5cbiAgICBuYW1lO1xuICAgIC8vIFRoZSBmdWxseSBleHBhbmRlZCB0eXBlLCBpbmNsdWRpbmcgY29tcG9zaXRlIHR5cGVzOlxuICAgIC8vICAgLSBhZGRyZXNzLCB1aW50MjU2LCB0dXBsZShhZGRyZXNzLGJ5dGVzKSwgdWludDI1NlszXVs0XVtdLCAgZXRjLlxuICAgIHR5cGU7XG4gICAgLy8gVGhlIGxvY2FsTmFtZSBib3VuZCBpbiB0aGUgc2lnbmF0dXJlLCBpbiB0aGlzIGV4YW1wbGUgaXQgaXMgXCJiYXpcIjpcbiAgICAvLyAgIC0gdHVwbGUoYWRkcmVzcyBmb28sIHVpbnQgYmFyKSBiYXpcbiAgICBsb2NhbE5hbWU7XG4gICAgLy8gV2hldGhlciB0aGlzIHR5cGUgaXMgZHluYW1pYzpcbiAgICAvLyAgLSBEeW5hbWljOiBieXRlcywgc3RyaW5nLCBhZGRyZXNzW10sIHR1cGxlKGJvb2xlYW5bXSksIGV0Yy5cbiAgICAvLyAgLSBOb3QgRHluYW1pYzogYWRkcmVzcywgdWludDI1NiwgYm9vbGVhblszXSwgdHVwbGUoYWRkcmVzcywgdWludDgpXG4gICAgZHluYW1pYztcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIiwgdHlwZTogXCJzdHJpbmdcIiwgbG9jYWxOYW1lOiBcInN0cmluZ1wiLCBkeW5hbWljOiBcImJvb2xlYW5cIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Rocm93RXJyb3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZXIgPSBDb2Rlcjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFdyaXRlciB7XG4gICAgLy8gQW4gYXJyYXkgb2YgV29yZFNpemUgbGVuZ3RoZWQgb2JqZWN0cyB0byBjb25jYXRlbmF0aW9uXG4gICAgI2RhdGE7XG4gICAgI2RhdGFMZW5ndGg7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2RhdGEgPSBbXTtcbiAgICAgICAgdGhpcy4jZGF0YUxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuY29uY2F0KSh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI2RhdGFMZW5ndGg7IH1cbiAgICAjd3JpdGVEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy4jZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICB0aGlzLiNkYXRhTGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFwcGVuZFdyaXRlcih3cml0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YSgoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHdyaXRlci5kYXRhKSk7XG4gICAgfVxuICAgIC8vIEFycmF5aXNoIGl0ZW07IHBhZCBvbiB0aGUgcmlnaHQgdG8gKm5lYXJlc3QqIFdvcmRTaXplXG4gICAgd3JpdGVCeXRlcyh2YWx1ZSkge1xuICAgICAgICBsZXQgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlc0NvcHkpKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ09mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIGV4cG9ydHMuV29yZFNpemU7XG4gICAgICAgIGlmIChwYWRkaW5nT2Zmc2V0KSB7XG4gICAgICAgICAgICBieXRlcyA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoKDAsIGluZGV4X2pzXzEuY29uY2F0KShbYnl0ZXMsIFBhZGRpbmcuc2xpY2UocGFkZGluZ09mZnNldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3dyaXRlRGF0YShieXRlcyk7XG4gICAgfVxuICAgIC8vIE51bWVyaWMgaXRlbTsgcGFkIG9uIHRoZSBsZWZ0ICp0byogV29yZFNpemVcbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3cml0ZURhdGEoZ2V0VmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0cyBhIG51bWVyaWMgcGxhY2UtaG9sZGVyLCByZXR1cm5pbmcgYSBjYWxsYmFjayB0aGF0IGNhblxuICAgIC8vIGJlIHVzZWQgdG8gYXNqdXN0IHRoZSB2YWx1ZSBsYXRlclxuICAgIHdyaXRlVXBkYXRhYmxlVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuI2RhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLiNkYXRhLnB1c2goUGFkZGluZyk7XG4gICAgICAgIHRoaXMuI2RhdGFMZW5ndGggKz0gZXhwb3J0cy5Xb3JkU2l6ZTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZGF0YVtvZmZzZXRdID0gZ2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVyID0gV3JpdGVyO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgUmVhZGVyIHtcbiAgICAvLyBBbGxvd3MgaW5jb21wbGV0ZSB1bnBhZGRlZCBkYXRhIHRvIGJlIHJlYWQ7IG90aGVyd2lzZSBhbiBlcnJvclxuICAgIC8vIGlzIHJhaXNlZCBpZiBhdHRlbXB0aW5nIHRvIG92ZXJydW4gdGhlIGJ1ZmZlci4gVGhpcyBpcyByZXF1aXJlZFxuICAgIC8vIHRvIGRlYWwgd2l0aCBhbiBvbGQgU29saWRpdHkgYnVnLCBpbiB3aGljaCBldmVudCBkYXRhIGZvclxuICAgIC8vIGV4dGVybmFsIChub3QgcHVibGljIHRob2d1aCkgd2FzIHRpZ2h0bHkgcGFja2VkLlxuICAgIGFsbG93TG9vc2U7XG4gICAgI2RhdGE7XG4gICAgI29mZnNldDtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWxsb3dMb29zZTogISFhbGxvd0xvb3NlIH0pO1xuICAgICAgICB0aGlzLiNkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShkYXRhKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KSh0aGlzLiNkYXRhKTsgfVxuICAgIGdldCBkYXRhTGVuZ3RoKCkgeyByZXR1cm4gdGhpcy4jZGF0YS5sZW5ndGg7IH1cbiAgICBnZXQgY29uc3VtZWQoKSB7IHJldHVybiB0aGlzLiNvZmZzZXQ7IH1cbiAgICBnZXQgYnl0ZXMoKSB7IHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLiNkYXRhKTsgfVxuICAgICNwZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIGV4cG9ydHMuV29yZFNpemUpICogZXhwb3J0cy5Xb3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLiNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLiNvZmZzZXQgKyBsZW5ndGggPD0gdGhpcy4jZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgXCJCVUZGRVJfT1ZFUlJVTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh0aGlzLiNkYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLiNkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc2xpY2UodGhpcy4jb2Zmc2V0LCB0aGlzLiNvZmZzZXQgKyBhbGlnbmVkTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgc3ViLXJlYWRlciB3aXRoIHRoZSBzYW1lIHVuZGVybHlpbmcgZGF0YSwgYnV0IG9mZnNldFxuICAgIHN1YlJlYWRlcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy4jZGF0YS5zbGljZSh0aGlzLiNvZmZzZXQgKyBvZmZzZXQpLCB0aGlzLmFsbG93TG9vc2UpO1xuICAgIH1cbiAgICAvLyBSZWFkIGJ5dGVzXG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy4jcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuI29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFJlYWQgYSBudW1lcmljIHZhbHVlc1xuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvQmlnSW50KSh0aGlzLnJlYWRCeXRlcyhleHBvcnRzLldvcmRTaXplKSk7XG4gICAgfVxuICAgIHJlYWRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnRvTnVtYmVyKSh0aGlzLnJlYWRCeXRlcyhleHBvcnRzLldvcmRTaXplKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFkZXIgPSBSZWFkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWFkZXIiLCJXcml0ZXIiLCJDb2RlciIsImNoZWNrUmVzdWx0RXJyb3JzIiwiUmVzdWx0IiwiV29yZFNpemUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsIlBhZGRpbmciLCJVaW50OEFycmF5IiwicGFzc1Byb3BlcnRpZXMiLCJfZ3VhcmQiLCJ0aHJvd0Vycm9yIiwibmFtZSIsImVycm9yIiwid3JhcHBlZCIsIkVycm9yIiwiQXJyYXkiLCJuYW1lcyIsImNvbnN0cnVjdG9yIiwiYXJncyIsImd1YXJkIiwiaXRlbXMiLCJzbGljZSIsIndyYXAiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaXRlbSIsImluZGV4IiwibmFtZUNvdW50cyIsInJlZHVjZSIsImFjY3VtIiwic2V0IiwiZ2V0IiwiTWFwIiwiZnJlZXplIiwibWFwIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJtYXRjaCIsImdldE51bWJlciIsIlJhbmdlRXJyb3IiLCJpbmRleE9mIiwiUmVmbGVjdCIsIkZ1bmN0aW9uIiwiYXBwbHkiLCJnZXRWYWx1ZSIsInRvQXJyYXkiLCJyZXN1bHQiLCJwdXNoIiwidG9PYmplY3QiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJzdGFydCIsImVuZCIsImkiLCJmaWx0ZXIiLCJjYWxsYmFjayIsInRoaXNBcmciLCJjYWxsIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImZyb21JdGVtcyIsImtleXMiLCJlcnJvcnMiLCJjaGVja0Vycm9ycyIsInBhdGgiLCJvYmplY3QiLCJpc0FycmF5Iiwia2V5IiwiY2hpbGRQYXRoIiwiYnl0ZXMiLCJ0b0JlQXJyYXkiLCJidWZmZXIiLCJvZmZzZXQiLCJnZXRCeXRlc0NvcHkiLCJjb25jYXQiLCJ0eXBlIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsImRlZmluZVByb3BlcnRpZXMiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJhc3NlcnRBcmd1bWVudCIsImRhdGEiLCJkYXRhTGVuZ3RoIiwid3JpdGVEYXRhIiwiYXBwZW5kV3JpdGVyIiwid3JpdGVyIiwid3JpdGVCeXRlcyIsInBhZGRpbmdPZmZzZXQiLCJ3cml0ZVZhbHVlIiwid3JpdGVVcGRhdGFibGVWYWx1ZSIsImFsbG93TG9vc2UiLCJoZXhsaWZ5IiwiY29uc3VtZWQiLCJwZWVrQnl0ZXMiLCJsb29zZSIsImFsaWduZWRMZW5ndGgiLCJNYXRoIiwiY2VpbCIsInN1YlJlYWRlciIsInJlYWRCeXRlcyIsInJlYWRWYWx1ZSIsInRvQmlnSW50IiwicmVhZEluZGV4IiwidG9OdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/address.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/address.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AddressCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst maths_js_1 = __webpack_require__(/*! ../../utils/maths.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */ class AddressCoder extends abstract_coder_js_1.Coder {\n    constructor(localName){\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = typed_js_1.Typed.dereference(_value, \"string\");\n        try {\n            value = (0, index_js_1.getAddress)(value);\n        } catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));\n    }\n}\nexports.AddressCoder = AddressCoder; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHLEtBQUs7QUFDNUIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMseUZBQXdCO0FBQ25ELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHFGQUFzQjtBQUNqRCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRUFBYTtBQUN4QyxNQUFNRyxzQkFBc0JILG1CQUFPQSxDQUFDLGtHQUFxQjtBQUN6RDs7Q0FFQyxHQUNELE1BQU1GLHFCQUFxQkssb0JBQW9CQyxLQUFLO0lBQ2hEQyxZQUFZQyxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFdBQVcsV0FBV0EsV0FBVztJQUMzQztJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUliLFFBQVFLLFdBQVdTLEtBQUssQ0FBQ0MsV0FBVyxDQUFDRixRQUFRO1FBQ2pELElBQUk7WUFDQWIsUUFBUSxDQUFDLEdBQUdFLFdBQVdjLFVBQVUsRUFBRWhCO1FBQ3ZDLEVBQ0EsT0FBT2lCLE9BQU87WUFDVixPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxNQUFNRSxPQUFPLEVBQUVOO1FBQzNDO1FBQ0EsT0FBT0QsT0FBT1EsVUFBVSxDQUFDcEI7SUFDN0I7SUFDQXFCLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sQ0FBQyxHQUFHcEIsV0FBV2MsVUFBVSxFQUFFLENBQUMsR0FBR1osV0FBV21CLE9BQU8sRUFBRUQsT0FBT0UsU0FBUyxJQUFJO0lBQ2xGO0FBQ0o7QUFDQXpCLG9CQUFvQixHQUFHRSxjQUN2QixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FkZHJlc3MuanM/MWU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc0NvZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9tYXRocy5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBBZGRyZXNzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcInN0cmluZ1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoZXJyb3IubWVzc2FnZSwgX3ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgoMCwgbWF0aHNfanNfMS50b0JlSGV4KShyZWFkZXIucmVhZFZhbHVlKCksIDIwKSk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzQ29kZXIgPSBBZGRyZXNzQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFkZHJlc3NDb2RlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwibWF0aHNfanNfMSIsInR5cGVkX2pzXzEiLCJhYnN0cmFjdF9jb2Rlcl9qc18xIiwiQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsIlR5cGVkIiwiZGVyZWZlcmVuY2UiLCJnZXRBZGRyZXNzIiwiZXJyb3IiLCJfdGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwidG9CZUhleCIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AnonymousCoder = void 0;\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */ class AnonymousCoder extends abstract_coder_js_1.Coder {\n    constructor(coder){\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\nexports.AnonymousCoder = AnonymousCoder; //# sourceMappingURL=anonymous.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fub255bW91cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUcsS0FBSztBQUM5QixNQUFNRyxzQkFBc0JDLG1CQUFPQSxDQUFDLGtHQUFxQjtBQUN6RDs7OztDQUlDLEdBQ0QsTUFBTUYsdUJBQXVCQyxvQkFBb0JFLEtBQUs7SUFFbERDLFlBQVlDLEtBQUssQ0FBRTtRQUNmLEtBQUssQ0FBQ0EsTUFBTUMsSUFBSSxFQUFFRCxNQUFNRSxJQUFJLEVBQUUsS0FBS0YsTUFBTUcsT0FBTztRQUNoRCxJQUFJLENBQUNILEtBQUssR0FBR0E7SUFDakI7SUFDQUksZUFBZTtRQUNYLE9BQU8sSUFBSSxDQUFDSixLQUFLLENBQUNJLFlBQVk7SUFDbEM7SUFDQUMsT0FBT0MsTUFBTSxFQUFFWixLQUFLLEVBQUU7UUFDbEIsT0FBTyxJQUFJLENBQUNNLEtBQUssQ0FBQ0ssTUFBTSxDQUFDQyxRQUFRWjtJQUNyQztJQUNBYSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQ1IsS0FBSyxDQUFDTyxNQUFNLENBQUNDO0lBQzdCO0FBQ0o7QUFDQWYsc0JBQXNCLEdBQUdFLGdCQUN6QixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Fub255bW91cy5qcz8zNzViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bbm9ueW1vdXNDb2RlciA9IHZvaWQgMDtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcbiAqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgQW5vbnltb3VzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb2RlcjtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCBcIl9cIiwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHRoaXMuY29kZXIgPSBjb2RlcjtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5vbnltb3VzQ29kZXIgPSBBbm9ueW1vdXNDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFub255bW91cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBbm9ueW1vdXNDb2RlciIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJyZXF1aXJlIiwiQ29kZXIiLCJjb25zdHJ1Y3RvciIsImNvZGVyIiwibmFtZSIsInR5cGUiLCJkeW5hbWljIiwiZGVmYXVsdFZhbHVlIiwiZW5jb2RlIiwid3JpdGVyIiwiZGVjb2RlIiwicmVhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/array.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/array.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ArrayCoder = exports.unpack = exports.pack = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst anonymous_js_1 = __webpack_require__(/*! ./anonymous.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/anonymous.js\");\n/**\n *  @_ignore\n */ function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    } else if (values && typeof values === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder)=>{\n            const name = coder.localName;\n            (0, index_js_1.assert)(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            (0, index_js_1.assert)(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", {\n                argument: \"values\",\n                info: {\n                    coder\n                },\n                value: values\n            });\n            unique[name] = true;\n            return values[name];\n        });\n    } else {\n        (0, index_js_1.assertArgument)(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    (0, index_js_1.assertArgument)(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new abstract_coder_js_1.Writer();\n    let dynamicWriter = new abstract_coder_js_1.Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index)=>{\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset)=>{\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func)=>{\n        func(staticWriter.length);\n    });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nexports.pack = pack;\n/**\n *  @_ignore\n */ function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder)=>{\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0, index_js_1.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if ((0, index_js_1.isError)(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return abstract_coder_js_1.Result.fromItems(values, keys);\n}\nexports.unpack = unpack;\n/**\n *  @_ignore\n */ class ArrayCoder extends abstract_coder_js_1.Coder {\n    constructor(coder, length, localName){\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\";\n        const dynamic = length === -1 || coder.dynamic;\n        super(\"array\", type, localName, dynamic);\n        (0, index_js_1.defineProperties)(this, {\n            coder,\n            length\n        });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for(let i = 0; i < this.length; i++){\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        (0, index_js_1.assertArgumentCount)(value.length, count, \"coder array\" + (this.localName ? \" \" + this.localName : \"\"));\n        let coders = [];\n        for(let i = 0; i < value.length; i++){\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", {\n                buffer: reader.bytes,\n                offset: count * abstract_coder_js_1.WordSize,\n                length: reader.dataLength\n            });\n        }\n        let coders = [];\n        for(let i = 0; i < count; i++){\n            coders.push(new anonymous_js_1.AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n}\nexports.ArrayCoder = ArrayCoder; //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2FycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUcsS0FBSztBQUMxRCxNQUFNSyxhQUFhQyxtQkFBT0EsQ0FBQyxxRkFBc0I7QUFDakQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEVBQWE7QUFDeEMsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQyxrR0FBcUI7QUFDekQsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQyx3RkFBZ0I7QUFDL0M7O0NBRUMsR0FDRCxTQUFTRixLQUFLTSxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUNoQyxJQUFJQyxjQUFjLEVBQUU7SUFDcEIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxTQUFTO1FBQ3ZCQyxjQUFjRDtJQUNsQixPQUNLLElBQUlBLFVBQVUsT0FBUUEsV0FBWSxVQUFVO1FBQzdDLElBQUlJLFNBQVMsQ0FBQztRQUNkSCxjQUFjRixPQUFPTSxHQUFHLENBQUMsQ0FBQ0M7WUFDdEIsTUFBTUMsT0FBT0QsTUFBTUUsU0FBUztZQUMzQixJQUFHZixXQUFXZ0IsTUFBTSxFQUFFRixNQUFNLHlEQUF5RCxvQkFBb0I7Z0JBQUVHLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVMO2dCQUFNO2dCQUFHakIsT0FBT1c7WUFBTztZQUM5SixJQUFHUCxXQUFXZ0IsTUFBTSxFQUFFLENBQUNMLE1BQU0sQ0FBQ0csS0FBSyxFQUFFLDJEQUEyRCxvQkFBb0I7Z0JBQUVHLFVBQVU7Z0JBQVVDLE1BQU07b0JBQUVMO2dCQUFNO2dCQUFHakIsT0FBT1c7WUFBTztZQUMxS0ksTUFBTSxDQUFDRyxLQUFLLEdBQUc7WUFDZixPQUFPUCxNQUFNLENBQUNPLEtBQUs7UUFDdkI7SUFDSixPQUNLO1FBQ0EsSUFBR2QsV0FBV21CLGNBQWMsRUFBRSxPQUFPLHVCQUF1QixTQUFTWjtJQUMxRTtJQUNDLElBQUdQLFdBQVdtQixjQUFjLEVBQUViLE9BQU9jLE1BQU0sS0FBS1osWUFBWVksTUFBTSxFQUFFLCtCQUErQixTQUFTYjtJQUM3RyxJQUFJYyxlQUFlLElBQUlsQixvQkFBb0JtQixNQUFNO0lBQ2pELElBQUlDLGdCQUFnQixJQUFJcEIsb0JBQW9CbUIsTUFBTTtJQUNsRCxJQUFJRSxjQUFjLEVBQUU7SUFDcEJsQixPQUFPbUIsT0FBTyxDQUFDLENBQUNaLE9BQU9hO1FBQ25CLElBQUk5QixRQUFRWSxXQUFXLENBQUNrQixNQUFNO1FBQzlCLElBQUliLE1BQU1jLE9BQU8sRUFBRTtZQUNmLHNEQUFzRDtZQUN0RCxJQUFJQyxnQkFBZ0JMLGNBQWNILE1BQU07WUFDeEMsa0RBQWtEO1lBQ2xEUCxNQUFNZ0IsTUFBTSxDQUFDTixlQUFlM0I7WUFDNUIsMERBQTBEO1lBQzFELElBQUlrQyxhQUFhVCxhQUFhVSxtQkFBbUI7WUFDakRQLFlBQVlRLElBQUksQ0FBQyxDQUFDQztnQkFDZEgsV0FBV0csYUFBYUw7WUFDNUI7UUFDSixPQUNLO1lBQ0RmLE1BQU1nQixNQUFNLENBQUNSLGNBQWN6QjtRQUMvQjtJQUNKO0lBQ0EsdUVBQXVFO0lBQ3ZFNEIsWUFBWUMsT0FBTyxDQUFDLENBQUNTO1FBQVdBLEtBQUtiLGFBQWFELE1BQU07SUFBRztJQUMzRCxJQUFJQSxTQUFTZixPQUFPOEIsWUFBWSxDQUFDZDtJQUNqQ0QsVUFBVWYsT0FBTzhCLFlBQVksQ0FBQ1o7SUFDOUIsT0FBT0g7QUFDWDtBQUNBekIsWUFBWSxHQUFHSTtBQUNmOztDQUVDLEdBQ0QsU0FBU0QsT0FBT3NDLE1BQU0sRUFBRTlCLE1BQU07SUFDMUIsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSThCLE9BQU8sRUFBRTtJQUNiLGlDQUFpQztJQUNqQyxJQUFJQyxhQUFhRixPQUFPRyxTQUFTLENBQUM7SUFDbENqQyxPQUFPbUIsT0FBTyxDQUFDLENBQUNaO1FBQ1osSUFBSWpCLFFBQVE7UUFDWixJQUFJaUIsTUFBTWMsT0FBTyxFQUFFO1lBQ2YsSUFBSWEsU0FBU0osT0FBT0ssU0FBUztZQUM3QixJQUFJQyxlQUFlSixXQUFXQyxTQUFTLENBQUNDO1lBQ3hDLElBQUk7Z0JBQ0E1QyxRQUFRaUIsTUFBTThCLE1BQU0sQ0FBQ0Q7WUFDekIsRUFDQSxPQUFPRSxPQUFPO2dCQUNWLDJCQUEyQjtnQkFDM0IsSUFBSSxDQUFDLEdBQUc1QyxXQUFXNkMsT0FBTyxFQUFFRCxPQUFPLG1CQUFtQjtvQkFDbEQsTUFBTUE7Z0JBQ1Y7Z0JBQ0FoRCxRQUFRZ0Q7Z0JBQ1JoRCxNQUFNa0QsUUFBUSxHQUFHakMsTUFBTUMsSUFBSTtnQkFDM0JsQixNQUFNa0IsSUFBSSxHQUFHRCxNQUFNRSxTQUFTO2dCQUM1Qm5CLE1BQU1tRCxJQUFJLEdBQUdsQyxNQUFNa0MsSUFBSTtZQUMzQjtRQUNKLE9BQ0s7WUFDRCxJQUFJO2dCQUNBbkQsUUFBUWlCLE1BQU04QixNQUFNLENBQUNQO1lBQ3pCLEVBQ0EsT0FBT1EsT0FBTztnQkFDViwyQkFBMkI7Z0JBQzNCLElBQUksQ0FBQyxHQUFHNUMsV0FBVzZDLE9BQU8sRUFBRUQsT0FBTyxtQkFBbUI7b0JBQ2xELE1BQU1BO2dCQUNWO2dCQUNBaEQsUUFBUWdEO2dCQUNSaEQsTUFBTWtELFFBQVEsR0FBR2pDLE1BQU1DLElBQUk7Z0JBQzNCbEIsTUFBTWtCLElBQUksR0FBR0QsTUFBTUUsU0FBUztnQkFDNUJuQixNQUFNbUQsSUFBSSxHQUFHbEMsTUFBTWtDLElBQUk7WUFDM0I7UUFDSjtRQUNBLElBQUluRCxTQUFTb0QsV0FBVztZQUNwQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQTFDLE9BQU95QixJQUFJLENBQUNwQztRQUNaeUMsS0FBS0wsSUFBSSxDQUFDbkIsTUFBTUUsU0FBUyxJQUFJO0lBQ2pDO0lBQ0EsT0FBT1osb0JBQW9CK0MsTUFBTSxDQUFDQyxTQUFTLENBQUM1QyxRQUFROEI7QUFDeEQ7QUFDQTFDLGNBQWMsR0FBR0c7QUFDakI7O0NBRUMsR0FDRCxNQUFNRCxtQkFBbUJNLG9CQUFvQmlELEtBQUs7SUFHOUNDLFlBQVl4QyxLQUFLLEVBQUVPLE1BQU0sRUFBRUwsU0FBUyxDQUFFO1FBQ2xDLE1BQU1nQyxPQUFRbEMsTUFBTWtDLElBQUksR0FBRyxNQUFPM0IsQ0FBQUEsVUFBVSxJQUFJQSxTQUFTLEVBQUMsSUFBSztRQUMvRCxNQUFNTyxVQUFXUCxXQUFXLENBQUMsS0FBS1AsTUFBTWMsT0FBTztRQUMvQyxLQUFLLENBQUMsU0FBU29CLE1BQU1oQyxXQUFXWTtRQUMvQixJQUFHM0IsV0FBV3NELGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUFFekM7WUFBT087UUFBTztJQUMzRDtJQUNBbUMsZUFBZTtRQUNYLCtFQUErRTtRQUMvRSxNQUFNQyxlQUFlLElBQUksQ0FBQzNDLEtBQUssQ0FBQzBDLFlBQVk7UUFDNUMsTUFBTUUsU0FBUyxFQUFFO1FBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3RDLE1BQU0sRUFBRXNDLElBQUs7WUFDbENELE9BQU96QixJQUFJLENBQUN3QjtRQUNoQjtRQUNBLE9BQU9DO0lBQ1g7SUFDQTVCLE9BQU94QixNQUFNLEVBQUVzRCxNQUFNLEVBQUU7UUFDbkIsTUFBTS9ELFFBQVFNLFdBQVcwRCxLQUFLLENBQUNDLFdBQVcsQ0FBQ0YsUUFBUTtRQUNuRCxJQUFJLENBQUNsRCxNQUFNQyxPQUFPLENBQUNkLFFBQVE7WUFDdkIsSUFBSSxDQUFDa0UsV0FBVyxDQUFDLHdCQUF3QmxFO1FBQzdDO1FBQ0EsSUFBSW1FLFFBQVEsSUFBSSxDQUFDM0MsTUFBTTtRQUN2QixJQUFJMkMsVUFBVSxDQUFDLEdBQUc7WUFDZEEsUUFBUW5FLE1BQU13QixNQUFNO1lBQ3BCZixPQUFPMkQsVUFBVSxDQUFDcEUsTUFBTXdCLE1BQU07UUFDbEM7UUFDQyxJQUFHcEIsV0FBV2lFLG1CQUFtQixFQUFFckUsTUFBTXdCLE1BQU0sRUFBRTJDLE9BQU8sZ0JBQWlCLEtBQUksQ0FBQ2hELFNBQVMsR0FBSSxNQUFNLElBQUksQ0FBQ0EsU0FBUyxHQUFJLEVBQUM7UUFDckgsSUFBSVQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJb0QsSUFBSSxHQUFHQSxJQUFJOUQsTUFBTXdCLE1BQU0sRUFBRXNDLElBQUs7WUFDbkNwRCxPQUFPMEIsSUFBSSxDQUFDLElBQUksQ0FBQ25CLEtBQUs7UUFDMUI7UUFDQSxPQUFPZCxLQUFLTSxRQUFRQyxRQUFRVjtJQUNoQztJQUNBK0MsT0FBT1AsTUFBTSxFQUFFO1FBQ1gsSUFBSTJCLFFBQVEsSUFBSSxDQUFDM0MsTUFBTTtRQUN2QixJQUFJMkMsVUFBVSxDQUFDLEdBQUc7WUFDZEEsUUFBUTNCLE9BQU9LLFNBQVM7WUFDeEIsc0RBQXNEO1lBQ3RELHdEQUF3RDtZQUN4RCx5REFBeUQ7WUFDekQsc0RBQXNEO1lBQ3RELDREQUE0RDtZQUMzRCxJQUFHekMsV0FBV2dCLE1BQU0sRUFBRStDLFFBQVE1RCxvQkFBb0IrRCxRQUFRLElBQUk5QixPQUFPK0IsVUFBVSxFQUFFLDRCQUE0QixrQkFBa0I7Z0JBQUVDLFFBQVFoQyxPQUFPaUMsS0FBSztnQkFBRTdCLFFBQVF1QixRQUFRNUQsb0JBQW9CK0QsUUFBUTtnQkFBRTlDLFFBQVFnQixPQUFPK0IsVUFBVTtZQUFDO1FBQ3BPO1FBQ0EsSUFBSTdELFNBQVMsRUFBRTtRQUNmLElBQUssSUFBSW9ELElBQUksR0FBR0EsSUFBSUssT0FBT0wsSUFBSztZQUM1QnBELE9BQU8wQixJQUFJLENBQUMsSUFBSTVCLGVBQWVrRSxjQUFjLENBQUMsSUFBSSxDQUFDekQsS0FBSztRQUM1RDtRQUNBLE9BQU9mLE9BQU9zQyxRQUFROUI7SUFDMUI7QUFDSjtBQUNBWCxrQkFBa0IsR0FBR0UsWUFDckIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9hcnJheS5qcz9jZTE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcnJheUNvZGVyID0gZXhwb3J0cy51bnBhY2sgPSBleHBvcnRzLnBhY2sgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IGFub255bW91c19qc18xID0gcmVxdWlyZShcIi4vYW5vbnltb3VzLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWVzKSB7XG4gICAgbGV0IGFycmF5VmFsdWVzID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKG5hbWUsIFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgXCJJTlZBTElEX0FSR1VNRU5UXCIsIHsgYXJndW1lbnQ6IFwidmFsdWVzXCIsIGluZm86IHsgY29kZXIgfSwgdmFsdWU6IHZhbHVlcyB9KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIXVuaXF1ZVtuYW1lXSwgXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIFwiSU5WQUxJRF9BUkdVTUVOVFwiLCB7IGFyZ3VtZW50OiBcInZhbHVlc1wiLCBpbmZvOiB7IGNvZGVyIH0sIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShjb2RlcnMubGVuZ3RoID09PSBhcnJheVZhbHVlcy5sZW5ndGgsIFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcbiAgICBsZXQgc3RhdGljV3JpdGVyID0gbmV3IGFic3RyYWN0X2NvZGVyX2pzXzEuV3JpdGVyKCk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgYWJzdHJhY3RfY29kZXJfanNfMS5Xcml0ZXIoKTtcbiAgICBsZXQgdXBkYXRlRnVuY3MgPSBbXTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5VmFsdWVzW2luZGV4XTtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGR5bmFtaWMgb2Zmc2V0IChmb3IgdGhlIGZ1dHVyZSBwb2ludGVyKVxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPZmZzZXQgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgZHluYW1pYyB2YWx1ZSBpbnRvIHRoZSBkeW5hbWljV3JpdGVyXG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoZHluYW1pY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuICAgICAgICAgICAgbGV0IHVwZGF0ZUZ1bmMgPSBzdGF0aWNXcml0ZXIud3JpdGVVcGRhdGFibGVWYWx1ZSgpO1xuICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaCgoYmFzZU9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZ1bmMoYmFzZU9mZnNldCArIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2Rlci5lbmNvZGUoc3RhdGljV3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWNrZmlsbCBhbGwgdGhlIGR5bmFtaWMgb2Zmc2V0cywgbm93IHRoYXQgd2Uga25vdyB0aGUgc3RhdGljIGxlbmd0aFxuICAgIHVwZGF0ZUZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYyhzdGF0aWNXcml0ZXIubGVuZ3RoKTsgfSk7XG4gICAgbGV0IGxlbmd0aCA9IHdyaXRlci5hcHBlbmRXcml0ZXIoc3RhdGljV3JpdGVyKTtcbiAgICBsZW5ndGggKz0gd3JpdGVyLmFwcGVuZFdyaXRlcihkeW5hbWljV3JpdGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5wYWNrID0gcGFjaztcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHVucGFjayhyZWFkZXIsIGNvZGVycykge1xuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuICAgIGxldCBiYXNlUmVhZGVyID0gcmVhZGVyLnN1YlJlYWRlcigwKTtcbiAgICBjb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSByZWFkZXIucmVhZEluZGV4KCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJCVUZGRVJfT1ZFUlJVTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlc3RpZ2F0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGtleXMucHVzaChjb2Rlci5sb2NhbE5hbWUgfHwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFic3RyYWN0X2NvZGVyX2pzXzEuUmVzdWx0LmZyb21JdGVtcyh2YWx1ZXMsIGtleXMpO1xufVxuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgYWJzdHJhY3RfY29kZXJfanNfMS5Db2RlciB7XG4gICAgY29kZXI7XG4gICAgbGVuZ3RoO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBjb2RlciwgbGVuZ3RoIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBjaGlsZCBjb2RlciBpcyB2YWxpZCAoZXZlbiBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYyBvciAwLWxlbmd0aClcbiAgICAgICAgY29uc3QgZGVmYXVsdENoaWxkID0gdGhpcy5jb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmYXVsdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlZF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJhcnJheVwiKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50Q291bnQpKHZhbHVlLmxlbmd0aCwgY291bnQsIFwiY29kZXIgYXJyYXlcIiArICh0aGlzLmxvY2FsTmFtZSA/IChcIiBcIiArIHRoaXMubG9jYWxOYW1lKSA6IFwiXCIpKTtcbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaCh0aGlzLmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb3VudCA9IHJlYWRlci5yZWFkSW5kZXgoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgKnJvdWdobHkqIGVub3VnaCBkYXRhIHRvIGVuc3VyZVxuICAgICAgICAgICAgLy8gc3RyYXkgcmFuZG9tIGRhdGEgaXMgbm90IGJlaW5nIHJlYWQgYXMgYSBsZW5ndGguIEVhY2hcbiAgICAgICAgICAgIC8vIHNsb3QgcmVxdWlyZXMgYXQgbGVhc3QgMzIgYnl0ZXMgZm9yIHRoZWlyIHZhbHVlIChvciAzMlxuICAgICAgICAgICAgLy8gYnl0ZXMgYXMgYSBsaW5rIHRvIHRoZSBkYXRhKS4gVGhpcyBjb3VsZCB1c2UgYSBtdWNoXG4gICAgICAgICAgICAvLyB0aWdodGVyIGJvdW5kLCBidXQgd2UgYXJlIGVycm9yaW5nIG9uIHRoZSBzaWRlIG9mIHNhZmV0eS5cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoY291bnQgKiBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplIDw9IHJlYWRlci5kYXRhTGVuZ3RoLCBcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHsgYnVmZmVyOiByZWFkZXIuYnl0ZXMsIG9mZnNldDogY291bnQgKiBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplLCBsZW5ndGg6IHJlYWRlci5kYXRhTGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlcnMucHVzaChuZXcgYW5vbnltb3VzX2pzXzEuQW5vbnltb3VzQ29kZXIodGhpcy5jb2RlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnBhY2socmVhZGVyLCBjb2RlcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlDb2RlciA9IEFycmF5Q29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBcnJheUNvZGVyIiwidW5wYWNrIiwicGFjayIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwidHlwZWRfanNfMSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJhbm9ueW1vdXNfanNfMSIsIndyaXRlciIsImNvZGVycyIsInZhbHVlcyIsImFycmF5VmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidW5pcXVlIiwibWFwIiwiY29kZXIiLCJuYW1lIiwibG9jYWxOYW1lIiwiYXNzZXJ0IiwiYXJndW1lbnQiLCJpbmZvIiwiYXNzZXJ0QXJndW1lbnQiLCJsZW5ndGgiLCJzdGF0aWNXcml0ZXIiLCJXcml0ZXIiLCJkeW5hbWljV3JpdGVyIiwidXBkYXRlRnVuY3MiLCJmb3JFYWNoIiwiaW5kZXgiLCJkeW5hbWljIiwiZHluYW1pY09mZnNldCIsImVuY29kZSIsInVwZGF0ZUZ1bmMiLCJ3cml0ZVVwZGF0YWJsZVZhbHVlIiwicHVzaCIsImJhc2VPZmZzZXQiLCJmdW5jIiwiYXBwZW5kV3JpdGVyIiwicmVhZGVyIiwia2V5cyIsImJhc2VSZWFkZXIiLCJzdWJSZWFkZXIiLCJvZmZzZXQiLCJyZWFkSW5kZXgiLCJvZmZzZXRSZWFkZXIiLCJkZWNvZGUiLCJlcnJvciIsImlzRXJyb3IiLCJiYXNlVHlwZSIsInR5cGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsIlJlc3VsdCIsImZyb21JdGVtcyIsIkNvZGVyIiwiY29uc3RydWN0b3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoaWxkIiwicmVzdWx0IiwiaSIsIl92YWx1ZSIsIlR5cGVkIiwiZGVyZWZlcmVuY2UiLCJfdGhyb3dFcnJvciIsImNvdW50Iiwid3JpdGVWYWx1ZSIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJXb3JkU2l6ZSIsImRhdGFMZW5ndGgiLCJidWZmZXIiLCJieXRlcyIsIkFub255bW91c0NvZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/boolean.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BooleanCoder = void 0;\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */ class BooleanCoder extends abstract_coder_js_1.Coder {\n    constructor(localName){\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n}\nexports.BooleanCoder = BooleanCoder; //# sourceMappingURL=boolean.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHLEtBQUs7QUFDNUIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsMEVBQWE7QUFDeEMsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyxrR0FBcUI7QUFDekQ7O0NBRUMsR0FDRCxNQUFNRixxQkFBcUJHLG9CQUFvQkMsS0FBSztJQUNoREMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxRQUFRLFFBQVFBLFdBQVc7SUFDckM7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixNQUFNWCxRQUFRRSxXQUFXVSxLQUFLLENBQUNDLFdBQVcsQ0FBQ0YsUUFBUTtRQUNuRCxPQUFPRCxPQUFPSSxVQUFVLENBQUNkLFFBQVEsSUFBSTtJQUN6QztJQUNBZSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsQ0FBQ0EsT0FBT0MsU0FBUztJQUM3QjtBQUNKO0FBQ0FsQixvQkFBb0IsR0FBR0UsY0FDdkIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9ib29sZWFuLmpzPzk4ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvb2xlYW5Db2RlciA9IHZvaWQgMDtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJib29sXCIsIFwiYm9vbFwiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVkX2pzXzEuVHlwZWQuZGVyZWZlcmVuY2UoX3ZhbHVlLCBcImJvb2xcIik7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gISFyZWFkZXIucmVhZFZhbHVlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuQ29kZXIgPSBCb29sZWFuQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJvb2xlYW5Db2RlciIsInR5cGVkX2pzXzEiLCJyZXF1aXJlIiwiYWJzdHJhY3RfY29kZXJfanNfMSIsIkNvZGVyIiwiY29uc3RydWN0b3IiLCJsb2NhbE5hbWUiLCJkZWZhdWx0VmFsdWUiLCJlbmNvZGUiLCJ3cml0ZXIiLCJfdmFsdWUiLCJUeXBlZCIsImRlcmVmZXJlbmNlIiwid3JpdGVWYWx1ZSIsImRlY29kZSIsInJlYWRlciIsInJlYWRWYWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/boolean.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/bytes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BytesCoder = exports.DynamicBytesCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */ class DynamicBytesCoder extends abstract_coder_js_1.Coder {\n    constructor(type, localName){\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = (0, index_js_1.getBytesCopy)(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\nexports.DynamicBytesCoder = DynamicBytesCoder;\n/**\n *  @_ignore\n */ class BytesCoder extends DynamicBytesCoder {\n    constructor(localName){\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return (0, index_js_1.hexlify)(super.decode(reader));\n    }\n}\nexports.BytesCoder = BytesCoder; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUN0RCxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxxRkFBc0I7QUFDakQsTUFBTUMsc0JBQXNCRCxtQkFBT0EsQ0FBQyxrR0FBcUI7QUFDekQ7O0NBRUMsR0FDRCxNQUFNRiwwQkFBMEJHLG9CQUFvQkMsS0FBSztJQUNyREMsWUFBWUMsSUFBSSxFQUFFQyxTQUFTLENBQUU7UUFDekIsS0FBSyxDQUFDRCxNQUFNQSxNQUFNQyxXQUFXO0lBQ2pDO0lBQ0FDLGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQUMsT0FBT0MsTUFBTSxFQUFFWixLQUFLLEVBQUU7UUFDbEJBLFFBQVEsQ0FBQyxHQUFHRyxXQUFXVSxZQUFZLEVBQUViO1FBQ3JDLElBQUljLFNBQVNGLE9BQU9HLFVBQVUsQ0FBQ2YsTUFBTWMsTUFBTTtRQUMzQ0EsVUFBVUYsT0FBT0ksVUFBVSxDQUFDaEI7UUFDNUIsT0FBT2M7SUFDWDtJQUNBRyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPQSxPQUFPQyxTQUFTLENBQUNELE9BQU9FLFNBQVMsSUFBSTtJQUNoRDtBQUNKO0FBQ0FyQix5QkFBeUIsR0FBR0c7QUFDNUI7O0NBRUMsR0FDRCxNQUFNRCxtQkFBbUJDO0lBQ3JCSyxZQUFZRSxTQUFTLENBQUU7UUFDbkIsS0FBSyxDQUFDLFNBQVNBO0lBQ25CO0lBQ0FRLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sQ0FBQyxHQUFHZixXQUFXa0IsT0FBTyxFQUFFLEtBQUssQ0FBQ0osT0FBT0M7SUFDaEQ7QUFDSjtBQUNBbkIsa0JBQWtCLEdBQUdFLFlBQ3JCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvYnl0ZXMuanM/ODZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnl0ZXNDb2RlciA9IGV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LWNvZGVyLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuY2xhc3MgRHluYW1pY0J5dGVzQ29kZXIgZXh0ZW5kcyBhYnN0cmFjdF9jb2Rlcl9qc18xLkNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodmFsdWUpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRCeXRlcyhyZWFkZXIucmVhZEluZGV4KCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSBEeW5hbWljQnl0ZXNDb2Rlcjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEJ5dGVzQ29kZXIgZXh0ZW5kcyBEeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYnl0ZXNcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoc3VwZXIuZGVjb2RlKHJlYWRlcikpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXNDb2RlciA9IEJ5dGVzQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCeXRlc0NvZGVyIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJDb2RlciIsImNvbnN0cnVjdG9yIiwidHlwZSIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsImdldEJ5dGVzQ29weSIsImxlbmd0aCIsIndyaXRlVmFsdWUiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZEJ5dGVzIiwicmVhZEluZGV4IiwiaGV4bGlmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FixedBytesCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\n/**\n *  @_ignore\n */ class FixedBytesCoder extends abstract_coder_js_1.Coder {\n    constructor(size, localName){\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        (0, index_js_1.defineProperties)(this, {\n            size\n        }, {\n            size: \"number\"\n        });\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return (0, index_js_1.hexlify)(reader.readBytes(this.size));\n    }\n}\nexports.FixedBytesCoder = FixedBytesCoder; //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL2ZpeGVkLWJ5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLHFGQUFzQjtBQUNqRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywwRUFBYTtBQUN4QyxNQUFNRSxzQkFBc0JGLG1CQUFPQSxDQUFDLGtHQUFxQjtBQUN6RDs7Q0FFQyxHQUNELE1BQU1GLHdCQUF3Qkksb0JBQW9CQyxLQUFLO0lBRW5EQyxZQUFZQyxJQUFJLEVBQUVDLFNBQVMsQ0FBRTtRQUN6QixJQUFJQyxPQUFPLFVBQVVDLE9BQU9IO1FBQzVCLEtBQUssQ0FBQ0UsTUFBTUEsTUFBTUQsV0FBVztRQUM1QixJQUFHUCxXQUFXVSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRUo7UUFBSyxHQUFHO1lBQUVBLE1BQU07UUFBUztJQUN0RTtJQUNBSyxlQUFlO1FBQ1gsT0FBTyxxRUFBdUVDLFNBQVMsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDTixJQUFJLEdBQUc7SUFDL0c7SUFDQU8sT0FBT0MsTUFBTSxFQUFFQyxNQUFNLEVBQUU7UUFDbkIsSUFBSUMsT0FBTyxDQUFDLEdBQUdoQixXQUFXaUIsWUFBWSxFQUFFZixXQUFXZ0IsS0FBSyxDQUFDQyxXQUFXLENBQUNKLFFBQVEsSUFBSSxDQUFDSyxJQUFJO1FBQ3RGLElBQUlKLEtBQUtLLE1BQU0sS0FBSyxJQUFJLENBQUNmLElBQUksRUFBRTtZQUMzQixJQUFJLENBQUNnQixXQUFXLENBQUMseUJBQXlCUDtRQUM5QztRQUNBLE9BQU9ELE9BQU9TLFVBQVUsQ0FBQ1A7SUFDN0I7SUFDQVEsT0FBT0MsTUFBTSxFQUFFO1FBQ1gsT0FBTyxDQUFDLEdBQUd6QixXQUFXMEIsT0FBTyxFQUFFRCxPQUFPRSxTQUFTLENBQUMsSUFBSSxDQUFDckIsSUFBSTtJQUM3RDtBQUNKO0FBQ0FULHVCQUF1QixHQUFHRSxpQkFDMUIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9maXhlZC1ieXRlcy5qcz8xNjMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaXhlZEJ5dGVzQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIHNpemU7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBuYW1lID0gXCJieXRlc1wiICsgU3RyaW5nKHNpemUpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBzaXplIH0sIHsgc2l6ZTogXCJudW1iZXJcIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gKFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpLnN1YnN0cmluZygwLCAyICsgdGhpcy5zaXplICogMik7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImluY29ycmVjdCBkYXRhIGxlbmd0aFwiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocmVhZGVyLnJlYWRCeXRlcyh0aGlzLnNpemUpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpeGVkQnl0ZXNDb2RlciA9IEZpeGVkQnl0ZXNDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpeGVkQnl0ZXNDb2RlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwidHlwZWRfanNfMSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJDb2RlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImxvY2FsTmFtZSIsIm5hbWUiLCJTdHJpbmciLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmYXVsdFZhbHVlIiwic3Vic3RyaW5nIiwiZW5jb2RlIiwid3JpdGVyIiwiX3ZhbHVlIiwiZGF0YSIsImdldEJ5dGVzQ29weSIsIlR5cGVkIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibGVuZ3RoIiwiX3Rocm93RXJyb3IiLCJ3cml0ZUJ5dGVzIiwiZGVjb2RlIiwicmVhZGVyIiwiaGV4bGlmeSIsInJlYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/null.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/null.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NullCoder = void 0;\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */ class NullCoder extends abstract_coder_js_1.Coder {\n    constructor(localName){\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n}\nexports.NullCoder = NullCoder; //# sourceMappingURL=null.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL251bGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsTUFBTUcsc0JBQXNCQyxtQkFBT0EsQ0FBQyxrR0FBcUI7QUFDekQsTUFBTUMsUUFBUSxJQUFJQyxXQUFXLEVBQUU7QUFDL0I7O0NBRUMsR0FDRCxNQUFNSixrQkFBa0JDLG9CQUFvQkksS0FBSztJQUM3Q0MsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxRQUFRLElBQUlBLFdBQVc7SUFDakM7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtJQUNBQyxPQUFPQyxNQUFNLEVBQUVYLEtBQUssRUFBRTtRQUNsQixJQUFJQSxTQUFTLE1BQU07WUFDZixJQUFJLENBQUNZLFdBQVcsQ0FBQyxZQUFZWjtRQUNqQztRQUNBLE9BQU9XLE9BQU9FLFVBQVUsQ0FBQ1Q7SUFDN0I7SUFDQVUsT0FBT0MsTUFBTSxFQUFFO1FBQ1hBLE9BQU9DLFNBQVMsQ0FBQztRQUNqQixPQUFPO0lBQ1g7QUFDSjtBQUNBakIsaUJBQWlCLEdBQUdFLFdBQ3BCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9jb2RlcnMvbnVsbC5qcz85OTYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OdWxsQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBFbXB0eSA9IG5ldyBVaW50OEFycmF5KFtdKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIE51bGxDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcIm51bGxcIiwgXCJcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwibm90IG51bGxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVCeXRlcyhFbXB0eSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLnJlYWRCeXRlcygwKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5OdWxsQ29kZXIgPSBOdWxsQ29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk51bGxDb2RlciIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJyZXF1aXJlIiwiRW1wdHkiLCJVaW50OEFycmF5IiwiQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl90aHJvd0Vycm9yIiwid3JpdGVCeXRlcyIsImRlY29kZSIsInJlYWRlciIsInJlYWRCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/null.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/number.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/number.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NumberCoder = void 0;\nconst index_js_1 = __webpack_require__(/*! ../../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */ class NumberCoder extends abstract_coder_js_1.Coder {\n    constructor(size, signed, localName){\n        const name = (signed ? \"int\" : \"uint\") + size * 8;\n        super(name, name, localName, false);\n        (0, index_js_1.defineProperties)(this, {\n            size,\n            signed\n        }, {\n            size: \"number\",\n            signed: \"boolean\"\n        });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);\n        if (this.signed) {\n            let bounds = (0, index_js_1.mask)(maxUintValue, this.size * 8 - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);\n        } else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = (0, index_js_1.fromTwos)(value, this.size * 8);\n        }\n        return value;\n    }\n}\nexports.NumberCoder = NumberCoder; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxxRkFBc0I7QUFDakQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEVBQWE7QUFDeEMsTUFBTUUsc0JBQXNCRixtQkFBT0EsQ0FBQyxrR0FBcUI7QUFDekQsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLE1BQU1FLGlCQUFpQkYsT0FBTztBQUM5Qjs7Q0FFQyxHQUNELE1BQU1OLG9CQUFvQkksb0JBQW9CSyxLQUFLO0lBRy9DQyxZQUFZQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQ2pDLE1BQU1DLE9BQVEsQ0FBQ0YsU0FBUyxRQUFRLE1BQUssSUFBTUQsT0FBTztRQUNsRCxLQUFLLENBQUNHLE1BQU1BLE1BQU1ELFdBQVc7UUFDNUIsSUFBR1osV0FBV2MsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQUVKO1lBQU1DO1FBQU8sR0FBRztZQUFFRCxNQUFNO1lBQVVDLFFBQVE7UUFBVTtJQUNqRztJQUNBSSxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLElBQUlwQixRQUFRLENBQUMsR0FBR0UsV0FBV21CLFNBQVMsRUFBRWpCLFdBQVdrQixLQUFLLENBQUNDLFdBQVcsQ0FBQ0gsUUFBUSxJQUFJLENBQUNJLElBQUk7UUFDcEYscUNBQXFDO1FBQ3JDLElBQUlDLGVBQWUsQ0FBQyxHQUFHdkIsV0FBV3dCLElBQUksRUFBRWpCLGdCQUFnQkosb0JBQW9Cc0IsUUFBUSxHQUFHO1FBQ3ZGLElBQUksSUFBSSxDQUFDZCxNQUFNLEVBQUU7WUFDYixJQUFJZSxTQUFTLENBQUMsR0FBRzFCLFdBQVd3QixJQUFJLEVBQUVELGNBQWMsSUFBSyxDQUFDYixJQUFJLEdBQUcsSUFBSztZQUNsRSxJQUFJWixRQUFRNEIsVUFBVTVCLFFBQVEsQ0FBRTRCLENBQUFBLFNBQVNwQixJQUFHLEdBQUk7Z0JBQzVDLElBQUksQ0FBQ3FCLFdBQVcsQ0FBQyx1QkFBdUJUO1lBQzVDO1lBQ0FwQixRQUFRLENBQUMsR0FBR0UsV0FBVzRCLE1BQU0sRUFBRTlCLE9BQU8sSUFBSUssb0JBQW9Cc0IsUUFBUTtRQUMxRSxPQUNLLElBQUkzQixRQUFRTSxRQUFRTixRQUFRLENBQUMsR0FBR0UsV0FBV3dCLElBQUksRUFBRUQsY0FBYyxJQUFJLENBQUNiLElBQUksR0FBRyxJQUFJO1lBQ2hGLElBQUksQ0FBQ2lCLFdBQVcsQ0FBQyx1QkFBdUJUO1FBQzVDO1FBQ0EsT0FBT0QsT0FBT1ksVUFBVSxDQUFDL0I7SUFDN0I7SUFDQWdDLE9BQU9DLE1BQU0sRUFBRTtRQUNYLElBQUlqQyxRQUFRLENBQUMsR0FBR0UsV0FBV3dCLElBQUksRUFBRU8sT0FBT0MsU0FBUyxJQUFJLElBQUksQ0FBQ3RCLElBQUksR0FBRztRQUNqRSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxFQUFFO1lBQ2JiLFFBQVEsQ0FBQyxHQUFHRSxXQUFXaUMsUUFBUSxFQUFFbkMsT0FBTyxJQUFJLENBQUNZLElBQUksR0FBRztRQUN4RDtRQUNBLE9BQU9aO0lBQ1g7QUFDSjtBQUNBRCxtQkFBbUIsR0FBR0UsYUFDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWJpL2NvZGVycy9udW1iZXIuanM/OWQ4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnVtYmVyQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X2NvZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fTUFYX1VJTlQyNTYgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBOdW1iZXJDb2RlciBleHRlbmRzIGFic3RyYWN0X2NvZGVyX2pzXzEuQ29kZXIge1xuICAgIHNpemU7XG4gICAgc2lnbmVkO1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAoKHNpZ25lZCA/IFwiaW50XCIgOiBcInVpbnRcIikgKyAoc2l6ZSAqIDgpKTtcbiAgICAgICAgc3VwZXIobmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgc2l6ZSwgc2lnbmVkIH0sIHsgc2l6ZTogXCJudW1iZXJcIiwgc2lnbmVkOiBcImJvb2xlYW5cIiB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgX3ZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLmdldEJpZ0ludCkodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIHRoaXMudHlwZSkpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSAoMCwgaW5kZXhfanNfMS5tYXNrKShCTl9NQVhfVUlOVDI1NiwgYWJzdHJhY3RfY29kZXJfanNfMS5Xb3JkU2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIGxldCBib3VuZHMgPSAoMCwgaW5kZXhfanNfMS5tYXNrKShtYXhVaW50VmFsdWUsICh0aGlzLnNpemUgKiA4KSAtIDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gYm91bmRzIHx8IHZhbHVlIDwgLShib3VuZHMgKyBCTl8xKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIF92YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLnRvVHdvcykodmFsdWUsIDggKiBhYnN0cmFjdF9jb2Rlcl9qc18xLldvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IEJOXzAgfHwgdmFsdWUgPiAoMCwgaW5kZXhfanNfMS5tYXNrKShtYXhVaW50VmFsdWUsIHRoaXMuc2l6ZSAqIDgpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBfdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gKDAsIGluZGV4X2pzXzEubWFzaykocmVhZGVyLnJlYWRWYWx1ZSgpLCB0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18xLmZyb21Ud29zKSh2YWx1ZSwgdGhpcy5zaXplICogOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuTnVtYmVyQ29kZXIgPSBOdW1iZXJDb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJOdW1iZXJDb2RlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwidHlwZWRfanNfMSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOX01BWF9VSU5UMjU2IiwiQ29kZXIiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJzaWduZWQiLCJsb2NhbE5hbWUiLCJuYW1lIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsImdldEJpZ0ludCIsIlR5cGVkIiwiZGVyZWZlcmVuY2UiLCJ0eXBlIiwibWF4VWludFZhbHVlIiwibWFzayIsIldvcmRTaXplIiwiYm91bmRzIiwiX3Rocm93RXJyb3IiLCJ0b1R3b3MiLCJ3cml0ZVZhbHVlIiwiZGVjb2RlIiwicmVhZGVyIiwicmVhZFZhbHVlIiwiZnJvbVR3b3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/string.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StringCoder = void 0;\nconst utf8_js_1 = __webpack_require__(/*! ../../utils/utf8.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst bytes_js_1 = __webpack_require__(/*! ./bytes.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/bytes.js\");\n/**\n *  @_ignore\n */ class StringCoder extends bytes_js_1.DynamicBytesCoder {\n    constructor(localName){\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return (0, utf8_js_1.toUtf8String)(super.decode(reader));\n    }\n}\nexports.StringCoder = StringCoder; //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixNQUFNRyxZQUFZQyxtQkFBT0EsQ0FBQyxtRkFBcUI7QUFDL0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEVBQWE7QUFDeEMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsZ0ZBQVk7QUFDdkM7O0NBRUMsR0FDRCxNQUFNRixvQkFBb0JJLFdBQVdDLGlCQUFpQjtJQUNsREMsWUFBWUMsU0FBUyxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFVQTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ25CLE9BQU8sS0FBSyxDQUFDRixPQUFPQyxRQUFRLENBQUMsR0FBR1QsVUFBVVcsV0FBVyxFQUFFVCxXQUFXVSxLQUFLLENBQUNDLFdBQVcsQ0FBQ0gsUUFBUTtJQUNoRztJQUNBSSxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsR0FBR2YsVUFBVWdCLFlBQVksRUFBRSxLQUFLLENBQUNGLE9BQU9DO0lBQ3BEO0FBQ0o7QUFDQWxCLG1CQUFtQixHQUFHRSxhQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3N0cmluZy5qcz9kZWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdDb2RlciA9IHZvaWQgMDtcbmNvbnN0IHV0ZjhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91dGY4LmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlZC5qc1wiKTtcbmNvbnN0IGJ5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5qc1wiKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIFN0cmluZ0NvZGVyIGV4dGVuZHMgYnl0ZXNfanNfMS5EeW5hbWljQnl0ZXNDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwic3RyaW5nXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIF92YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW5jb2RlKHdyaXRlciwgKDAsIHV0ZjhfanNfMS50b1V0ZjhCeXRlcykodHlwZWRfanNfMS5UeXBlZC5kZXJlZmVyZW5jZShfdmFsdWUsIFwic3RyaW5nXCIpKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGY4X2pzXzEudG9VdGY4U3RyaW5nKShzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdDb2RlciA9IFN0cmluZ0NvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0cmluZ0NvZGVyIiwidXRmOF9qc18xIiwicmVxdWlyZSIsInR5cGVkX2pzXzEiLCJieXRlc19qc18xIiwiRHluYW1pY0J5dGVzQ29kZXIiLCJjb25zdHJ1Y3RvciIsImxvY2FsTmFtZSIsImRlZmF1bHRWYWx1ZSIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsInRvVXRmOEJ5dGVzIiwiVHlwZWQiLCJkZXJlZmVyZW5jZSIsImRlY29kZSIsInJlYWRlciIsInRvVXRmOFN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/coders/tuple.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TupleCoder = void 0;\nconst properties_js_1 = __webpack_require__(/*! ../../utils/properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst typed_js_1 = __webpack_require__(/*! ../typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nconst array_js_1 = __webpack_require__(/*! ./array.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/array.js\");\n/**\n *  @_ignore\n */ class TupleCoder extends abstract_coder_js_1.Coder {\n    constructor(coders, localName){\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder)=>{\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = \"tuple(\" + types.join(\",\") + \")\";\n        super(\"tuple\", type, localName, dynamic);\n        (0, properties_js_1.defineProperties)(this, {\n            coders: Object.freeze(coders.slice())\n        });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder)=>{\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder)=>{\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index)=>{\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = typed_js_1.Typed.dereference(_value, \"tuple\");\n        return (0, array_js_1.pack)(writer, this.coders, value);\n    }\n    decode(reader) {\n        return (0, array_js_1.unpack)(reader, this.coders);\n    }\n}\nexports.TupleCoder = TupleCoder; //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3R1cGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsK0ZBQTJCO0FBQzNELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDBFQUFhO0FBQ3hDLE1BQU1FLHNCQUFzQkYsbUJBQU9BLENBQUMsa0dBQXFCO0FBQ3pELE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLGdGQUFZO0FBQ3ZDOztDQUVDLEdBQ0QsTUFBTUYsbUJBQW1CSSxvQkFBb0JFLEtBQUs7SUFFOUNDLFlBQVlDLE1BQU0sRUFBRUMsU0FBUyxDQUFFO1FBQzNCLElBQUlDLFVBQVU7UUFDZCxNQUFNQyxRQUFRLEVBQUU7UUFDaEJILE9BQU9JLE9BQU8sQ0FBQyxDQUFDQztZQUNaLElBQUlBLE1BQU1ILE9BQU8sRUFBRTtnQkFDZkEsVUFBVTtZQUNkO1lBQ0FDLE1BQU1HLElBQUksQ0FBQ0QsTUFBTUUsSUFBSTtRQUN6QjtRQUNBLE1BQU1BLE9BQVEsV0FBV0osTUFBTUssSUFBSSxDQUFDLE9BQU87UUFDM0MsS0FBSyxDQUFDLFNBQVNELE1BQU1OLFdBQVdDO1FBQy9CLElBQUdULGdCQUFnQmdCLGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUFFVCxRQUFRWixPQUFPc0IsTUFBTSxDQUFDVixPQUFPVyxLQUFLO1FBQUk7SUFDeEY7SUFDQUMsZUFBZTtRQUNYLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixJQUFJLENBQUNiLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDO1lBQ2pCUSxPQUFPUCxJQUFJLENBQUNELE1BQU1PLFlBQVk7UUFDbEM7UUFDQSw0REFBNEQ7UUFDNUQsTUFBTUUsY0FBYyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTSxDQUFDLENBQUNDLE9BQU9YO1lBQzNDLE1BQU1ZLE9BQU9aLE1BQU1KLFNBQVM7WUFDNUIsSUFBSWdCLE1BQU07Z0JBQ04sSUFBSSxDQUFDRCxLQUFLLENBQUNDLEtBQUssRUFBRTtvQkFDZEQsS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2xCO2dCQUNBRCxLQUFLLENBQUNDLEtBQUs7WUFDZjtZQUNBLE9BQU9EO1FBQ1gsR0FBRyxDQUFDO1FBQ0osbUJBQW1CO1FBQ25CLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ0ksT0FBTyxDQUFDLENBQUNDLE9BQU9hO1lBQ3hCLElBQUlELE9BQU9aLE1BQU1KLFNBQVM7WUFDMUIsSUFBSSxDQUFDZ0IsUUFBUUgsV0FBVyxDQUFDRyxLQUFLLEtBQUssR0FBRztnQkFDbEM7WUFDSjtZQUNBLElBQUlBLFNBQVMsVUFBVTtnQkFDbkJBLE9BQU87WUFDWDtZQUNBLElBQUlKLE1BQU0sQ0FBQ0ksS0FBSyxJQUFJLE1BQU07Z0JBQ3RCO1lBQ0o7WUFDQUosTUFBTSxDQUFDSSxLQUFLLEdBQUdKLE1BQU0sQ0FBQ0ssTUFBTTtRQUNoQztRQUNBLE9BQU85QixPQUFPc0IsTUFBTSxDQUFDRztJQUN6QjtJQUNBTSxPQUFPQyxNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNuQixNQUFNOUIsUUFBUUksV0FBVzJCLEtBQUssQ0FBQ0MsV0FBVyxDQUFDRixRQUFRO1FBQ25ELE9BQU8sQ0FBQyxHQUFHeEIsV0FBVzJCLElBQUksRUFBRUosUUFBUSxJQUFJLENBQUNwQixNQUFNLEVBQUVUO0lBQ3JEO0lBQ0FrQyxPQUFPQyxNQUFNLEVBQUU7UUFDWCxPQUFPLENBQUMsR0FBRzdCLFdBQVc4QixNQUFNLEVBQUVELFFBQVEsSUFBSSxDQUFDMUIsTUFBTTtJQUNyRDtBQUNKO0FBQ0FWLGtCQUFrQixHQUFHRSxZQUNyQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvY29kZXJzL3R1cGxlLmpzPzU5MDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR1cGxlQ29kZXIgPSB2b2lkIDA7XG5jb25zdCBwcm9wZXJ0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvcHJvcGVydGllcy5qc1wiKTtcbmNvbnN0IHR5cGVkX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZWQuanNcIik7XG5jb25zdCBhYnN0cmFjdF9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtY29kZXIuanNcIik7XG5jb25zdCBhcnJheV9qc18xID0gcmVxdWlyZShcIi4vYXJyYXkuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgYWJzdHJhY3RfY29kZXJfanNfMS5Db2RlciB7XG4gICAgY29kZXJzO1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICAoMCwgcHJvcGVydGllc19qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgY29kZXJzOiBPYmplY3QuZnJlZXplKGNvZGVycy5zbGljZSgpKSB9KTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCBfdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlZF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKF92YWx1ZSwgXCJ0dXBsZVwiKTtcbiAgICAgICAgcmV0dXJuICgwLCBhcnJheV9qc18xLnBhY2spKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIGFycmF5X2pzXzEudW5wYWNrKShyZWFkZXIsIHRoaXMuY29kZXJzKTtcbiAgICB9XG59XG5leHBvcnRzLlR1cGxlQ29kZXIgPSBUdXBsZUNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHVwbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHVwbGVDb2RlciIsInByb3BlcnRpZXNfanNfMSIsInJlcXVpcmUiLCJ0eXBlZF9qc18xIiwiYWJzdHJhY3RfY29kZXJfanNfMSIsImFycmF5X2pzXzEiLCJDb2RlciIsImNvbnN0cnVjdG9yIiwiY29kZXJzIiwibG9jYWxOYW1lIiwiZHluYW1pYyIsInR5cGVzIiwiZm9yRWFjaCIsImNvZGVyIiwicHVzaCIsInR5cGUiLCJqb2luIiwiZGVmaW5lUHJvcGVydGllcyIsImZyZWV6ZSIsInNsaWNlIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVzIiwidW5pcXVlTmFtZXMiLCJyZWR1Y2UiLCJhY2N1bSIsIm5hbWUiLCJpbmRleCIsImVuY29kZSIsIndyaXRlciIsIl92YWx1ZSIsIlR5cGVkIiwiZGVyZWZlcmVuY2UiLCJwYWNrIiwiZGVjb2RlIiwicmVhZGVyIiwidW5wYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/tuple.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/fragments.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/fragments.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k)=>result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [\n    _kwTypes,\n    _kwModifiers,\n    _kwOther,\n    _kwVisib\n].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\",\n    \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\",\n    \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\",\n    \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() {\n        return this.#offset;\n    }\n    get length() {\n        return this.#tokens.length - this.#offset;\n    }\n    constructor(tokens){\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() {\n        return new TokenString(this.#tokens);\n    }\n    reset() {\n        this.#offset = 0;\n    }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t)=>{\n            return Object.freeze(Object.assign({}, t, {\n                match: t.match - from,\n                linkBack: t.linkBack - from,\n                linkNext: t.linkNext - from\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while(this.#offset < top.match - 1){\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return top != null && allowed.has(top) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return top.type === type ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for(let i = this.#offset; i < this.#tokens.length; i++){\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message)=>{\n        const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while(offset < text.length){\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = {\n            depth: brackets.length,\n            linkBack: -1,\n            linkNext: -1,\n            match: -1,\n            type: \"\",\n            text: \"\",\n            offset,\n            value: -1\n        };\n        tokens.push(token);\n        let type = SimpleTokens[cur[0]] || \"\";\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            } else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                tokens[token.match].match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n            } else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                tokens[token.linkBack].linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            } else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            } else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                tokens[tokens.length - 1].text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t)=>Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for(const key in allowed.keys()){\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while(true){\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || allowed && !allowed.has(keyword)) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t)=>ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return (0, index_js_1.getBigInt)(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    (0, index_js_1.assertArgument)(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        (0, index_js_1.assertArgument)(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    } else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */ class ParamType {\n    /**\n     *  @private\n     */ constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren){\n        (0, index_js_1.assertPrivate)(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, {\n            value: ParamTypeInternal\n        });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        } else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        } else if (components != null) {\n            throw new Error(\"\");\n        }\n        (0, index_js_1.defineProperties)(this, {\n            name,\n            type,\n            baseType,\n            indexed,\n            components,\n            arrayLength,\n            arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n                name\n            };\n            if (typeof this.indexed === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c)=>JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n        } else {\n            if (this.isTuple()) {\n                if (format !== \"sighash\") {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp)=>comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */ isArray() {\n        return this.baseType === \"array\";\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */ isTuple() {\n        return this.baseType === \"tuple\";\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */ isIndexable() {\n        return this.indexed != null;\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */ walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v)=>_this.arrayChildren.walk(v, process));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i)=>_this.components[i].walk(v, process));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index)=>{\n                childType.#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            } else {\n                if (value == null || typeof value !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param)=>{\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index)=>{\n                components[index].#walkAsync(promises, value, process, (value)=>{\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push(async function() {\n                setValue(await result);\n            }());\n        } else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS naes by walking and resolving each\n     *  ``\"address\"`` type.\n     */ async walkAsync(value, process) {\n        const promises = [];\n        const result = [\n            value\n        ];\n        this.#walkAsync(promises, value, process, (value)=>{\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */ static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid param type\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\n                \"tuple\"\n            ])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t)=>ParamType.from(t));\n                type = `tuple(${comps.map((c)=>c.format()).join(\",\")})`;\n            } else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while(obj.length && obj.peekType(\"BRACKET\")){\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        (0, index_js_1.assertArgument)(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            (0, index_js_1.assertArgument)(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */ ) || type.startsWith(\"(\" /* fix: ) */ )) {\n            const comps = obj.components != null ? obj.components.map((c)=>ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */ static isParamType(value) {\n        return value && value[internal] === ParamTypeInternal;\n    }\n}\nexports.ParamType = ParamType;\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */ class Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs){\n        (0, index_js_1.assertPrivate)(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        (0, index_js_1.defineProperties)(this, {\n            type,\n            inputs\n        });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            } catch (e) {}\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch(type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n        } else if (typeof obj === \"object\") {\n            // JSON ABI\n            switch(obj.type){\n                case \"constructor\":\n                    return ConstructorFragment.from(obj);\n                case \"error\":\n                    return ErrorFragment.from(obj);\n                case \"event\":\n                    return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\":\n                    return FunctionFragment.from(obj);\n                case \"struct\":\n                    return StructFragment.from(obj);\n            }\n            (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        (0, index_js_1.assertArgument)(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */ static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */ static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */ static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */ static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */ static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\nexports.Fragment = Fragment;\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */ class NamedFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, name, inputs){\n        super(guard, type, inputs);\n        (0, index_js_1.assertArgument)(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        (0, index_js_1.defineProperties)(this, {\n            name\n        });\n    }\n}\nexports.NamedFragment = NamedFragment;\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p)=>p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */ class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: ErrorFragmentInternal\n        });\n    }\n    /**\n     *  The Custom Error selector.\n     */ get selector() {\n        return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ErrorFragmentInternal;\n    }\n}\nexports.ErrorFragment = ErrorFragment;\n/**\n *  A Fragment which represents an Event.\n */ class EventFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs, anonymous){\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: EventFragmentInternal\n        });\n        (0, index_js_1.defineProperties)(this, {\n            anonymous\n        });\n    }\n    /**\n     *  The Event topic hash.\n     */ get topicHash() {\n        return (0, index_js_2.id)(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */ static getTopicHash(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */ static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\n                \"anonymous\"\n            ])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p)=>ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === EventFragmentInternal;\n    }\n}\nexports.EventFragment = EventFragment;\n/**\n *  A Fragment which represents a constructor.\n */ class ConstructorFragment extends Fragment {\n    /**\n     *  @private\n     */ constructor(guard, type, inputs, payable, gas){\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, {\n            value: ConstructorFragmentInternal\n        });\n        (0, index_js_1.defineProperties)(this, {\n            payable,\n            gas\n        });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */ format(format) {\n        (0, index_js_1.assert)(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"format(sighash)\"\n        });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format)))\n            });\n        }\n        const result = [\n            `constructor${joinParams(format, this.inputs)}`\n        ];\n        result.push(this.payable ? \"payable\" : \"nonpayable\");\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */ static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\n                \"constructor\"\n            ]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === ConstructorFragmentInternal;\n    }\n}\nexports.ConstructorFragment = ConstructorFragment;\n/**\n *  A Fragment which represents a method.\n */ class FallbackFragment extends Fragment {\n    constructor(guard, inputs, payable){\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, {\n            value: FallbackFragmentInternal\n        });\n        (0, index_js_1.defineProperties)(this, {\n            payable\n        });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */ format(format) {\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n        if (format === \"json\") {\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n            return JSON.stringify({\n                type,\n                stateMutability\n            });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            (0, index_js_1.assertArgument)(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\n                \"fallback\",\n                \"receive\"\n            ]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                (0, index_js_1.assertArgument)(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\n                    \"payable\"\n                ]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            } else {\n                inputs = [\n                    ParamType.from(\"bytes\")\n                ];\n            }\n            const mutability = consumeMutability(obj);\n            (0, index_js_1.assertArgument)(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i)=>i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [\n                ParamType.from(\"bytes\")\n            ];\n            const payable = obj.stateMutability === \"payable\";\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        (0, index_js_1.assertArgument)(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FallbackFragmentInternal;\n    }\n}\nexports.FallbackFragment = FallbackFragment;\n/**\n *  A Fragment which represents a method.\n */ class FunctionFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, stateMutability, inputs, outputs, gas){\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: FunctionFragmentInternal\n        });\n        outputs = Object.freeze(outputs.slice());\n        const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n        const payable = stateMutability === \"payable\";\n        (0, index_js_1.defineProperties)(this, {\n            constant,\n            gas,\n            outputs,\n            payable,\n            stateMutability\n        });\n    }\n    /**\n     *  The Function selector.\n     */ get selector() {\n        return (0, index_js_2.id)(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */ format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n                payable: this.payable,\n                gas: this.gas != null ? this.gas : undefined,\n                inputs: this.inputs.map((i)=>JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o)=>JSON.parse(o.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */ static getSelector(name, params) {\n        params = (params || []).map((p)=>ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */ static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof obj === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\n                \"returns\"\n            ])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof obj.constant === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === FunctionFragmentInternal;\n    }\n}\nexports.FunctionFragment = FunctionFragment;\n/**\n *  A Fragment which represents a structure.\n */ class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */ constructor(guard, name, inputs){\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, {\n            value: StructFragmentInternal\n        });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */ format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */ static from(obj) {\n        if (typeof obj === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            } catch (error) {\n                (0, index_js_1.assertArgument)(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        } else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */ static isFragment(value) {\n        return value && value[internal] === StructFragmentInternal;\n    }\n}\nexports.StructFragment = StructFragment; //# sourceMappingURL=fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvZnJhZ21lbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Q0FVQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ2pPLE1BQU1XLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBa0I7O0FBRTdDLHFDQUFxQztBQUNyQyxTQUFTRSxPQUFPQyxLQUFLO0lBQ2pCLE1BQU1DLFNBQVMsSUFBSUM7SUFDbkJGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDQyxJQUFNSCxPQUFPSSxHQUFHLENBQUNEO0lBQ2hDLE9BQU9yQixPQUFPdUIsTUFBTSxDQUFDTDtBQUN6QjtBQUNBLE1BQU1NLGlCQUFpQjtBQUN2QixNQUFNQyxnQkFBZ0JULE9BQU9RLGVBQWVFLEtBQUssQ0FBQztBQUNsRCxzQkFBc0I7QUFDdEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxVQUFVWixPQUFPVyxTQUFTRCxLQUFLLENBQUM7QUFDdEMsTUFBTUcsV0FBVztBQUNqQixNQUFNQyxVQUFVZCxPQUFPYSxTQUFTSCxLQUFLLENBQUM7QUFDdEMsTUFBTUssZUFBZTtBQUNyQixNQUFNQyxjQUFjaEIsT0FBT2UsYUFBYUwsS0FBSyxDQUFDO0FBQzlDLE1BQU1PLFdBQVc7QUFDakIsZUFBZTtBQUNmLE1BQU1DLFlBQVk7SUFBQ0w7SUFBVUU7SUFBY0U7SUFBVU47Q0FBUyxDQUFDUSxJQUFJLENBQUM7QUFDcEUsTUFBTUMsV0FBV3BCLE9BQU9rQixVQUFVUixLQUFLLENBQUM7QUFDeEMsMEJBQTBCO0FBQzFC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QUNEc0MsWUFBWTRFLEtBQUssRUFBRUMsSUFBSSxFQUFFc0MsTUFBTSxDQUFFO1FBQzdCLEtBQUssQ0FBQ3ZDLE9BQU8sVUFBVUMsTUFBTXNDO1FBQzdCbkssT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRWlILFVBQVU7WUFBRS9HLE9BQU93SDtRQUF1QjtJQUMxRTtJQUNBOztLQUVDLEdBQ0RVLFNBQVM7UUFDTCxNQUFNLElBQUlqRSxNQUFNO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDRCxPQUFPZixLQUFLc0csR0FBRyxFQUFFO1FBQ2IsSUFBSSxPQUFRQSxRQUFTLFVBQVU7WUFDM0IsSUFBSTtnQkFDQSxPQUFPdkosZUFBZWlELElBQUksQ0FBQzZCLElBQUl5RTtZQUNuQyxFQUNBLE9BQU9FLE9BQU87Z0JBQ1QsSUFBR2hKLFdBQVdpRyxjQUFjLEVBQUUsT0FBTywyQkFBMkIsT0FBTzZDO1lBQzVFO1FBQ0osT0FDSyxJQUFJQSxlQUFlL0csYUFBYTtZQUNqQyxNQUFNaUYsT0FBTzVCLFlBQVksVUFBVTBEO1lBQ25DLE1BQU1RLFNBQVM1RCxjQUFjb0Q7WUFDN0JoRCxXQUFXZ0Q7WUFDWCxPQUFPLElBQUl2SixlQUFlNkcsUUFBUVksTUFBTXNDO1FBQzVDO1FBQ0EsT0FBTyxJQUFJL0osZUFBZTZHLFFBQVEwQyxJQUFJOUIsSUFBSSxFQUFFOEIsSUFBSVEsTUFBTSxHQUFHUixJQUFJUSxNQUFNLENBQUM1RyxHQUFHLENBQUMzQyxVQUFVeUMsSUFBSSxJQUFJLEVBQUU7SUFDaEc7SUFDQSw4QkFBOEI7SUFDOUI7OztLQUdDLEdBQ0QsT0FBT21ILFdBQVdySyxLQUFLLEVBQUU7UUFDckIsT0FBUUEsU0FBU0EsS0FBSyxDQUFDK0csU0FBUyxLQUFLUztJQUN6QztBQUNKO0FBQ0F6SCxzQkFBc0IsR0FBR0UsZ0JBQ3pCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9mcmFnbWVudHMuanM/MTdlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgZnJhZ21lbnQgaXMgYSBzaW5nbGUgaXRlbSBmcm9tIGFuIEFCSSwgd2hpY2ggbWF5IHJlcHJlc2VudCBhbnkgb2Y6XG4gKlxuICogIC0gW0Z1bmN0aW9uc10oRnVuY3Rpb25GcmFnbWVudClcbiAqICAtIFtFdmVudHNdKEV2ZW50RnJhZ21lbnQpXG4gKiAgLSBbQ29uc3RydWN0b3JzXShDb25zdHJ1Y3RvckZyYWdtZW50KVxuICogIC0gQ3VzdG9tIFtFcnJvcnNdKEVycm9yRnJhZ21lbnQpXG4gKiAgLSBbRmFsbGJhY2sgb3IgUmVjZWl2ZV0oRmFsbGJhY2tGcmFnbWVudCkgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvYWJpL2FiaS1jb2RlcjpGcmFnbWVudHMgIFthYm91dC1mcmFnbWVudHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RydWN0RnJhZ21lbnQgPSBleHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBleHBvcnRzLkZhbGxiYWNrRnJhZ21lbnQgPSBleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBleHBvcnRzLkVycm9yRnJhZ21lbnQgPSBleHBvcnRzLk5hbWVkRnJhZ21lbnQgPSBleHBvcnRzLkZyYWdtZW50ID0gZXhwb3J0cy5QYXJhbVR5cGUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuO1xuLy8gWyBcImFcIiwgXCJiXCIgXSA9PiB7IFwiYVwiOiAxLCBcImJcIjogMSB9XG5mdW5jdGlvbiBzZXRpZnkoaXRlbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgaXRlbXMuZm9yRWFjaCgoaykgPT4gcmVzdWx0LmFkZChrKSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbn1cbmNvbnN0IF9rd1Zpc2liRGVwbG95ID0gXCJleHRlcm5hbCBwdWJsaWMgcGF5YWJsZVwiO1xuY29uc3QgS3dWaXNpYkRlcGxveSA9IHNldGlmeShfa3dWaXNpYkRlcGxveS5zcGxpdChcIiBcIikpO1xuLy8gVmlzaWJpbGl0eSBLZXl3b3Jkc1xuY29uc3QgX2t3VmlzaWIgPSBcImNvbnN0YW50IGV4dGVybmFsIGludGVybmFsIHBheWFibGUgcHJpdmF0ZSBwdWJsaWMgcHVyZSB2aWV3XCI7XG5jb25zdCBLd1Zpc2liID0gc2V0aWZ5KF9rd1Zpc2liLnNwbGl0KFwiIFwiKSk7XG5jb25zdCBfa3dUeXBlcyA9IFwiY29uc3RydWN0b3IgZXJyb3IgZXZlbnQgZmFsbGJhY2sgZnVuY3Rpb24gcmVjZWl2ZSBzdHJ1Y3RcIjtcbmNvbnN0IEt3VHlwZXMgPSBzZXRpZnkoX2t3VHlwZXMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd01vZGlmaWVycyA9IFwiY2FsbGRhdGEgbWVtb3J5IHN0b3JhZ2UgcGF5YWJsZSBpbmRleGVkXCI7XG5jb25zdCBLd01vZGlmaWVycyA9IHNldGlmeShfa3dNb2RpZmllcnMuc3BsaXQoXCIgXCIpKTtcbmNvbnN0IF9rd090aGVyID0gXCJ0dXBsZSByZXR1cm5zXCI7XG4vLyBBbGwgS2V5d29yZHNcbmNvbnN0IF9rZXl3b3JkcyA9IFtfa3dUeXBlcywgX2t3TW9kaWZpZXJzLCBfa3dPdGhlciwgX2t3VmlzaWJdLmpvaW4oXCIgXCIpO1xuY29uc3QgS2V5d29yZHMgPSBzZXRpZnkoX2tleXdvcmRzLnNwbGl0KFwiIFwiKSk7XG4vLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuY29uc3QgU2ltcGxlVG9rZW5zID0ge1xuICAgIFwiKFwiOiBcIk9QRU5fUEFSRU5cIiwgXCIpXCI6IFwiQ0xPU0VfUEFSRU5cIixcbiAgICBcIltcIjogXCJPUEVOX0JSQUNLRVRcIiwgXCJdXCI6IFwiQ0xPU0VfQlJBQ0tFVFwiLFxuICAgIFwiLFwiOiBcIkNPTU1BXCIsIFwiQFwiOiBcIkFUXCJcbn07XG4vLyBQYXJzZXIgcmVnZXhlcyB0byBjb25zdW1lIHRoZSBuZXh0IHRva2VuXG5jb25zdCByZWdleFdoaXRlc3BhY2VQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIpO1xuY29uc3QgcmVnZXhOdW1iZXJQcmVmaXggPSBuZXcgUmVnRXhwKFwiXihbMC05XSspXCIpO1xuY29uc3QgcmVnZXhJZFByZWZpeCA9IG5ldyBSZWdFeHAoXCJeKFthLXpBLVokX11bYS16QS1aMC05JF9dKilcIik7XG4vLyBQYXJzZXIgcmVnZXhzIHRvIGNoZWNrIHZhbGlkaXR5XG5jb25zdCByZWdleElkID0gbmV3IFJlZ0V4cChcIl4oW2EtekEtWiRfXVthLXpBLVowLTkkX10qKSRcIik7XG5jb25zdCByZWdleFR5cGUgPSBuZXcgUmVnRXhwKFwiXihhZGRyZXNzfGJvb2x8Ynl0ZXMoWzAtOV0qKXxzdHJpbmd8dT9pbnQoWzAtOV0qKSkkXCIpO1xuY2xhc3MgVG9rZW5TdHJpbmcge1xuICAgICNvZmZzZXQ7XG4gICAgI3Rva2VucztcbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy4jb2Zmc2V0OyB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3Rva2Vucy5sZW5ndGggLSB0aGlzLiNvZmZzZXQ7IH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy4jdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkgeyByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRoaXMuI3Rva2Vucyk7IH1cbiAgICByZXNldCgpIHsgdGhpcy4jb2Zmc2V0ID0gMDsgfVxuICAgICNzdWJUb2tlblN0cmluZyhmcm9tID0gMCwgdG8gPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5TdHJpbmcodGhpcy4jdG9rZW5zLnNsaWNlKGZyb20sIHRvKS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICAgICAgICAgICAgICBtYXRjaDogKHQubWF0Y2ggLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rQmFjazogKHQubGlua0JhY2sgLSBmcm9tKSxcbiAgICAgICAgICAgICAgICBsaW5rTmV4dDogKHQubGlua05leHQgLSBmcm9tKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBQb3BzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGFsbG93ZWQ7IHRocm93cyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcG9wS2V5d29yZChhbGxvd2VkKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAodG9wLnR5cGUgIT09IFwiS0VZV09SRFwiIHx8ICFhbGxvd2VkLmhhcyh0b3AudGV4dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQga2V5d29yZCAke3RvcC50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IHRva2VuIGlmIGl0IGlzIGB0eXBlYDsgdGhyb3dzIGlmIG91dCBvZiB0b2tlbnNcbiAgICBwb3BUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfTsgZ290ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5wZWVrKCkpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpLnRleHQ7XG4gICAgfVxuICAgIC8vIFBvcHMgYW5kIHJldHVybnMgYSBcIihcIiBUT0tFTlMgXCIpXCJcbiAgICBwb3BQYXJlbigpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNzdWJUb2tlblN0cmluZyh0aGlzLiNvZmZzZXQgKyAxLCB0b3AubWF0Y2ggKyAxKTtcbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUG9wcyBhbmQgcmV0dXJucyB0aGUgaXRlbXMgd2l0aGluIFwiKFwiIElURU0xIFwiLFwiIElURU0yIFwiLFwiIC4uLiBcIilcIlxuICAgIHBvcFBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICh0b3AudHlwZSAhPT0gXCJPUEVOX1BBUkVOXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBzdGFydFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuI29mZnNldCA8IHRvcC5tYXRjaCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnBlZWsoKS5saW5rTmV4dDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuI3N1YlRva2VuU3RyaW5nKHRoaXMuI29mZnNldCArIDEsIGxpbmspKTtcbiAgICAgICAgICAgIHRoaXMuI29mZnNldCA9IGxpbms7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jb2Zmc2V0ID0gdG9wLm1hdGNoICsgMTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdG9wIFRva2VuLCB0aHJvd2luZyBpZiBvdXQgb2YgdG9rZW5zXG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI29mZnNldCA+PSB0aGlzLiN0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQtb2YtYm91bmRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN0b2tlbnNbdGhpcy4jb2Zmc2V0XTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCB2YWx1ZSwgaWYgaXQgaXMgYSBrZXl3b3JkIGluIGBhbGxvd2VkYFxuICAgIHBlZWtLZXl3b3JkKGFsbG93ZWQpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIHJldHVybiAodG9wICE9IG51bGwgJiYgYWxsb3dlZC5oYXModG9wKSkgPyB0b3AgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgbmV4dCB0b2tlbiBpZiBpdCBpcyBgdHlwZWBcbiAgICBwZWVrVHlwZSh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHJldHVybiAodG9wLnR5cGUgPT09IHR5cGUpID8gdG9wLnRleHQgOiBudWxsO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXh0IHRva2VuOyB0aHJvd3MgaWYgb3V0IG9mIHRva2Vuc1xuICAgIHBvcCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIHRoaXMuI29mZnNldCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNvZmZzZXQ7IGkgPCB0aGlzLiN0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy4jdG9rZW5zW2ldO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goYCR7dG9rZW4udHlwZX06JHt0b2tlbi50ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPFRva2VuU3RyaW5nICR7dG9rZW5zLmpvaW4oXCIgXCIpfT5gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gKG9mZnNldCA8IHRleHQubGVuZ3RoKSA/IEpTT04uc3RyaW5naWZ5KHRleHRbb2Zmc2V0XSkgOiBcIiRFT0lcIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHRva2VuICR7dG9rZW59IGF0ICR7b2Zmc2V0fTogJHttZXNzYWdlfWApO1xuICAgIH07XG4gICAgbGV0IGJyYWNrZXRzID0gW107XG4gICAgbGV0IGNvbW1hcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAvLyBTdHJpcCBvZmYgYW55IGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICBsZXQgY3VyID0gdGV4dC5zdWJzdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgbGV0IG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4V2hpdGVzcGFjZVByZWZpeCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGN1ciA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB7IGRlcHRoOiBicmFja2V0cy5sZW5ndGgsIGxpbmtCYWNrOiAtMSwgbGlua05leHQ6IC0xLCBtYXRjaDogLTEsIHR5cGU6IFwiXCIsIHRleHQ6IFwiXCIsIG9mZnNldCwgdmFsdWU6IC0xIH07XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgbGV0IHR5cGUgPSAoU2ltcGxlVG9rZW5zW2N1clswXV0gfHwgXCJcIik7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBjdXJbMF07XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk9QRU5fUEFSRU5cIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbW1hcy5wdXNoKHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJDTE9TRV9QQVJFTlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwibm8gbWF0Y2hpbmcgb3BlbiBicmFja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaCA9IGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW4ubWF0Y2hdKS5tYXRjaCA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHRva2VuLmRlcHRoLS07XG4gICAgICAgICAgICAgICAgdG9rZW4ubGlua0JhY2sgPSBjb21tYXMucG9wKCk7XG4gICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbi5saW5rQmFja10pLmxpbmtOZXh0ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIkNPTU1BXCIpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5saW5rQmFjayA9IGNvbW1hcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAodG9rZW5zW3Rva2VuLmxpbmtCYWNrXSkubGlua05leHQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb21tYXMucHVzaCh0b2tlbnMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBcIk9QRU5fQlJBQ0tFVFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiQlJBQ0tFVFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJDTE9TRV9CUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIENMT1NFX0JSQUNLRVRcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdG9rZW5zLnBvcCgpLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJOVU1CRVJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRva2Vucy5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB2YWx1ZSArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pLnZhbHVlID0gKDAsIGluZGV4X2pzXzEuZ2V0TnVtYmVyKSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJCUkFDS0VUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvcGVuaW5nIGJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKS50ZXh0ICs9IHN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4SWRQcmVmaXgpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChLZXl3b3Jkcy5oYXModG9rZW4udGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJLRVlXT1JEXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dC5tYXRjaChyZWdleFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiVFlQRVwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiSURcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gY3VyLm1hdGNoKHJlZ2V4TnVtYmVyUHJlZml4KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gXCJOVU1CRVJcIjtcbiAgICAgICAgICAgIG9mZnNldCArPSB0b2tlbi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCB0b2tlbiAke0pTT04uc3RyaW5naWZ5KGN1clswXSl9IGF0IHBvc2l0aW9uICR7b2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRva2VuU3RyaW5nKHRva2Vucy5tYXAoKHQpID0+IE9iamVjdC5mcmVlemUodCkpKTtcbn1cbi8vIENoZWNrIG9ubHkgb25lIG9mIGBhbGxvd2VkYCBpcyBpbiBgc2V0YFxuZnVuY3Rpb24gYWxsb3dTaW5nbGUoc2V0LCBhbGxvd2VkKSB7XG4gICAgbGV0IGluY2x1ZGVkID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dlZC5rZXlzKCkpIHtcbiAgICAgICAgaWYgKHNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaW5jbHVkZWQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uZmxpY3RpbmcgdHlwZXM6ICR7aW5jbHVkZWQuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbn1cbi8vIEZ1bmN0aW9ucyB0byBwcm9jZXNzIGEgU29saWRpdHkgU2lnbmF0dXJlIFRva2VuU3RyaW5nIGZyb20gbGVmdC10by1yaWdodCBmb3IuLi5cbi8vIC4uLnRoZSBuYW1lIHdpdGggYW4gb3B0aW9uYWwgdHlwZSwgcmV0dXJuaW5nIHRoZSBuYW1lXG5mdW5jdGlvbiBjb25zdW1lTmFtZSh0eXBlLCB0b2tlbnMpIHtcbiAgICBpZiAodG9rZW5zLnBlZWtLZXl3b3JkKEt3VHlwZXMpKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSB0b2tlbnMucG9wKCkudGV4dDtcbiAgICAgICAgaWYgKGtleXdvcmQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHt0eXBlfSwgZ290ICR7a2V5d29yZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zLnBvcFR5cGUoXCJJRFwiKTtcbn1cbi8vIC4uLmFsbCBrZXl3b3JkcyBtYXRjaGluZyBhbGxvd2VkLCByZXR1cm5pbmcgdGhlIGtleXdvcmRzXG5mdW5jdGlvbiBjb25zdW1lS2V5d29yZHModG9rZW5zLCBhbGxvd2VkKSB7XG4gICAgY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IHRva2Vucy5wZWVrVHlwZShcIktFWVdPUkRcIik7XG4gICAgICAgIGlmIChrZXl3b3JkID09IG51bGwgfHwgKGFsbG93ZWQgJiYgIWFsbG93ZWQuaGFzKGtleXdvcmQpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAoa2V5d29yZHMuaGFzKGtleXdvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZSBrZXl3b3JkczogJHtKU09OLnN0cmluZ2lmeShrZXl3b3JkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBrZXl3b3Jkcy5hZGQoa2V5d29yZCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGtleXdvcmRzKTtcbn1cbi8vIC4uLmFsbCB2aXNpYmlsaXR5IGtleXdvcmRzLCByZXR1cm5pbmcgdGhlIGNvYWxlc2NlZCBtdXRhYmlsaXR5XG5mdW5jdGlvbiBjb25zdW1lTXV0YWJpbGl0eSh0b2tlbnMpIHtcbiAgICBsZXQgbW9kaWZpZXJzID0gY29uc3VtZUtleXdvcmRzKHRva2VucywgS3dWaXNpYik7XG4gICAgLy8gRGV0ZWN0IGNvbmZsaWN0aW5nIG1vZGlmaWVyc1xuICAgIGFsbG93U2luZ2xlKG1vZGlmaWVycywgc2V0aWZ5KFwiY29uc3RhbnQgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgYWxsb3dTaW5nbGUobW9kaWZpZXJzLCBzZXRpZnkoXCJwdXJlIHZpZXcgcGF5YWJsZSBub25wYXlhYmxlXCIuc3BsaXQoXCIgXCIpKSk7XG4gICAgLy8gUHJvY2VzcyBtdXRhYmlsaXR5IHN0YXRlc1xuICAgIGlmIChtb2RpZmllcnMuaGFzKFwidmlld1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ2aWV3XCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicHVyZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwdXJlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwicGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJwYXlhYmxlXCI7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwibm9ucGF5YWJsZVwiKSkge1xuICAgICAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgbGVnYWN5IGBjb25zdGFudGAgbGFzdFxuICAgIGlmIChtb2RpZmllcnMuaGFzKFwiY29uc3RhbnRcIikpIHtcbiAgICAgICAgcmV0dXJuIFwidmlld1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJub25wYXlhYmxlXCI7XG59XG4vLyAuLi5hIHBhcmFtZXRlciBsaXN0LCByZXR1cm5pbmcgdGhlIFBhcmFtVHlwZSBsaXN0XG5mdW5jdGlvbiBjb25zdW1lUGFyYW1zKHRva2VucywgYWxsb3dJbmRleGVkKSB7XG4gICAgcmV0dXJuIHRva2Vucy5wb3BQYXJhbXMoKS5tYXAoKHQpID0+IFBhcmFtVHlwZS5mcm9tKHQsIGFsbG93SW5kZXhlZCkpO1xufVxuLy8gLi4uYSBnYXMgbGltaXQsIHJldHVybmluZyBhIEJpZ051bWJlciBvciBudWxsIGlmIG5vbmVcbmZ1bmN0aW9uIGNvbnN1bWVHYXModG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIkFUXCIpKSB7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRva2Vucy5wZWVrVHlwZShcIk5VTUJFUlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEJpZ0ludCkodG9rZW5zLnBvcCgpLnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZ2FzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVFb2kodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHRva2VuczogJHt0b2tlbnMudG9TdHJpbmcoKX1gKTtcbiAgICB9XG59XG5jb25zdCByZWdleEFycmF5VHlwZSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5mdW5jdGlvbiB2ZXJpZnlCYXNpY1R5cGUodHlwZSkge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChyZWdleFR5cGUpO1xuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCwgXCJpbnZhbGlkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIGlmICh0eXBlID09PSBcInVpbnRcIikge1xuICAgICAgICByZXR1cm4gXCJ1aW50MjU2XCI7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBcImludDI1NlwiO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgLy8gYnl0ZXNYWFxuICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IDMyLCBcImludmFsaWQgYnl0ZXMgbGVuZ3RoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgLy8gaW50WFggb3IgdWludFhYXG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShzaXplICE9PSAwICYmIHNpemUgPD0gMjU2ICYmIChzaXplICUgOCkgPT09IDAsIFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBNYWtlIHRoZSBGcmFnbWVudCBjb25zdHJ1Y3RvcnMgZWZmZWN0aXZlbHkgcHJpdmF0ZVxuY29uc3QgX2d1YXJkID0ge307XG5jb25zdCBpbnRlcm5hbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX2ludGVybmFsXCIpO1xuY29uc3QgUGFyYW1UeXBlSW50ZXJuYWwgPSBcIl9QYXJhbVR5cGVJbnRlcm5hbFwiO1xuY29uc3QgRXJyb3JGcmFnbWVudEludGVybmFsID0gXCJfRXJyb3JJbnRlcm5hbFwiO1xuY29uc3QgRXZlbnRGcmFnbWVudEludGVybmFsID0gXCJfRXZlbnRJbnRlcm5hbFwiO1xuY29uc3QgQ29uc3RydWN0b3JGcmFnbWVudEludGVybmFsID0gXCJfQ29uc3RydWN0b3JJbnRlcm5hbFwiO1xuY29uc3QgRmFsbGJhY2tGcmFnbWVudEludGVybmFsID0gXCJfRmFsbGJhY2tJbnRlcm5hbFwiO1xuY29uc3QgRnVuY3Rpb25GcmFnbWVudEludGVybmFsID0gXCJfRnVuY3Rpb25JbnRlcm5hbFwiO1xuY29uc3QgU3RydWN0RnJhZ21lbnRJbnRlcm5hbCA9IFwiX1N0cnVjdEludGVybmFsXCI7XG4vKipcbiAqICBFYWNoIGlucHV0IGFuZCBvdXRwdXQgb2YgYSBbW0ZyYWdtZW50XV0gaXMgYW4gQXJyYXkgb2YgKipQYXJhbVR5cGUqKi5cbiAqL1xuY2xhc3MgUGFyYW1UeXBlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGxvY2FsIG5hbWUgb2YgdGhlIHBhcmFtZXRlciAob3IgYGBcIlwiYGAgaWYgdW5ib3VuZClcbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbHkgcXVhbGlmaWVkIHR5cGUgKGUuZy4gYGBcImFkZHJlc3NcImBgLCBgYFwidHVwbGUoYWRkcmVzcylcImBgLFxuICAgICAqICBgYFwidWludDI1NlszXVtdXCJgYClcbiAgICAgKi9cbiAgICB0eXBlO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmFzZSB0eXBlIChlLmcuIGBgXCJhZGRyZXNzXCJgYCwgYGBcInR1cGxlXCJgYCwgYGBcImFycmF5XCJgYClcbiAgICAgKi9cbiAgICBiYXNlVHlwZTtcbiAgICAvKipcbiAgICAgKiAgVHJ1ZSBpZiB0aGUgcGFyYW1ldGVycyBpcyBpbmRleGVkLlxuICAgICAqXG4gICAgICogIEZvciBub24taW5kZXhhYmxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgaW5kZXhlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXBvbmVudHMgZm9yIHRoZSB0dXBsZS5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLXR1cGxlIHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgY29tcG9uZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFycmF5IGxlbmd0aCwgb3IgYGAtMWBgIGZvciBkeW5hbWljLWxlbmd0aGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqICBGb3Igbm9uLWFycmF5IHR5cGVzIHRoaXMgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgYXJyYXlMZW5ndGg7XG4gICAgLyoqXG4gICAgICogIFRoZSB0eXBlIG9mIGVhY2ggY2hpbGQgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogIEZvciBub24tYXJyYXkgdHlwZXMgdGhpcyBpcyBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBhcnJheUNoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0UHJpdmF0ZSkoZ3VhcmQsIF9ndWFyZCwgXCJQYXJhbVR5cGVcIik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogUGFyYW1UeXBlSW50ZXJuYWwgfSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlMZW5ndGggPT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJyYXlMZW5ndGggIT0gbnVsbCB8fCBhcnJheUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBuYW1lLCB0eXBlLCBiYXNlVHlwZSwgaW5kZXhlZCwgY29tcG9uZW50cywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLFxuICAgICAqXG4gICAgICogIGBgc2lnaGFzaFwiID0+IFwiKHVpbnQyNTYsYWRkcmVzcylcImBgXG4gICAgICpcbiAgICAgKiAgYGBcIm1pbmltYWxcIiA9PiBcInR1cGxlKHVpbnQyNTYsYWRkcmVzcykgaW5kZXhlZFwiYGBcbiAgICAgKlxuICAgICAqICBgYFwiZnVsbFwiID0+IFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlc3MgYmFyKSBpbmRleGVkIGJhelwiYGBcbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UodGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudHlwZSArPSBgWyR7KHRoaXMuYXJyYXlMZW5ndGggPCAwID8gXCJcIiA6IFN0cmluZyh0aGlzLmFycmF5TGVuZ3RoKSl9XWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXhlZCA9IHRoaXMuaW5kZXhlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoYykgPT4gSlNPTi5wYXJzZShjLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGBbJHsodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoKGNvbXApID0+IGNvbXAuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gXCJmdWxsXCIpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZnVsbFwiICYmIHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEFycmF5IHR5cGUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIHR5cGUgZ2F1cmQgZW5zdXJpbmcgdGhhdCBbW2FycmF5Q2hpbGRyZW5dXVxuICAgICAqICBhbmQgW1thcnJheUxlbmd0aF1dIGFyZSBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0FycmF5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgYSBUdXBsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tjb21wb25lbnRzXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNUdXBsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGFuIEluZGV4YWJsZSB0eXBlLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSB0eXBlIGdhdXJkIGVuc3VyaW5nIHRoYXQgW1tpbmRleGVkXV1cbiAgICAgKiAgaXMgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNJbmRleGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleGVkICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGNhbGxpbmcgJSVwcm9jZXNzJSVcbiAgICAgKiAgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqL1xuICAgIHdhbGsodmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhcnJheSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5TGVuZ3RoICE9PSAtMSAmJiB2YWx1ZS5sZW5ndGggIT09IHRoaXMuYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiAoX3RoaXMuYXJyYXlDaGlsZHJlbi53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUdXBsZSgpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiAoX3RoaXMuY29tcG9uZW50c1tpXS53YWxrKHYsIHByb2Nlc3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2Nlc3ModGhpcy50eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgICN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCBzZXRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFycmF5IHZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXlMZW5ndGggIT09IC0xICYmIHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5hcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IGlzIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuYXJyYXlDaGlsZHJlbjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRUeXBlLiN3YWxrQXN5bmMocHJvbWlzZXMsIHZhbHVlLCBwcm9jZXNzLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHVwbGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdCBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiAodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHVwbGUgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBvbmVudHMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2Ugb2JqZWN0IHZhbHVlIHdpdGggdW5uYW1lZCBjb21wb25lbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtLm5hbWUgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGNvbXBvbmVudCAke3BhcmFtLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW3BhcmFtLm5hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyB3cm9uZyBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpbmRleF0uI3dhbGtBc3luYyhwcm9taXNlcywgdmFsdWUsIHByb2Nlc3MsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFZhbHVlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzcyh0aGlzLnR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHNldFZhbHVlKGF3YWl0IHJlc3VsdCk7IH0pKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgV2Fsa3MgdGhlICoqUGFyYW1UeXBlKiogd2l0aCAlJXZhbHVlJSUsIGFzeW5jaHJvbm91c2x5IGNhbGxpbmdcbiAgICAgKiAgJSVwcm9jZXNzJSUgb24gZWFjaCB0eXBlLCBkZXN0cnVjdGluZyB0aGUgJSV2YWx1ZSUlIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSBFTlMgbmFlcyBieSB3YWxraW5nIGFuZCByZXNvbHZpbmcgZWFjaFxuICAgICAqICBgYFwiYWRkcmVzc1wiYGAgdHlwZS5cbiAgICAgKi9cbiAgICBhc3luYyB3YWxrQXN5bmModmFsdWUsIHByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3ZhbHVlXTtcbiAgICAgICAgdGhpcy4jd2Fsa0FzeW5jKHByb21pc2VzLCB2YWx1ZSwgcHJvY2VzcywgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlBhcmFtVHlwZSoqIGZvciAlJW9iaiUlLlxuICAgICAqXG4gICAgICogIElmICUlYWxsb3dJbmRleGVkJSUgdGhlbiB0aGUgYGBpbmRleGVkYGAga2V5d29yZCBpcyBwZXJtaXR0ZWQsXG4gICAgICogIG90aGVyd2lzZSB0aGUgYGBpbmRleGVkYGAga2V5d29yZCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaiwgYWxsb3dJbmRleGVkKSB7XG4gICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbShsZXgob2JqKSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIHBhcmFtIHR5cGVcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcIlwiLCBiYXNlVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBsZXQgY29tcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJ0dXBsZVwiXSkpLmhhcyhcInR1cGxlXCIpIHx8IG9iai5wZWVrVHlwZShcIk9QRU5fUEFSRU5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZVxuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gXCJ0dXBsZVwiO1xuICAgICAgICAgICAgICAgIGNvbXBzID0gb2JqLnBvcFBhcmFtcygpLm1hcCgodCkgPT4gUGFyYW1UeXBlLmZyb20odCkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdHVwbGUoJHtjb21wcy5tYXAoKGMpID0+IGMuZm9ybWF0KCkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsXG4gICAgICAgICAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoucG9wVHlwZShcIlRZUEVcIikpO1xuICAgICAgICAgICAgICAgIGJhc2VUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBBcnJheVxuICAgICAgICAgICAgbGV0IGFycmF5Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGFycmF5TGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChvYmoubGVuZ3RoICYmIG9iai5wZWVrVHlwZShcIkJSQUNLRVRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ID0gb2JqLnBvcCgpOyAvL2FycmF5c1tpXTtcbiAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuID0gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIFwiXCIsIHR5cGUsIGJhc2VUeXBlLCBudWxsLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoID0gYnJhY2tldC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0eXBlICs9IGJyYWNrZXQudGV4dDtcbiAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgICAgICBjb21wcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhlZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkcyA9IGNvbnN1bWVLZXl3b3JkcyhvYmosIEt3TW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3Jkcy5oYXMoXCJpbmRleGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAob2JqLnBlZWtUeXBlKFwiSURcIikgPyBvYmoucG9wKCkudGV4dCA6IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZWZ0b3ZlciB0b2tlbnNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcmFtVHlwZShfZ3VhcmQsIG5hbWUsIHR5cGUsIGJhc2VUeXBlLCBpbmRleGVkLCBjb21wcywgYXJyYXlMZW5ndGgsIGFycmF5Q2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmoubmFtZTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCFuYW1lIHx8ICh0eXBlb2YgKG5hbWUpID09PSBcInN0cmluZ1wiICYmIG5hbWUubWF0Y2gocmVnZXhJZCkpLCBcImludmFsaWQgbmFtZVwiLCBcIm9iai5uYW1lXCIsIG5hbWUpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IG9iai5pbmRleGVkO1xuICAgICAgICBpZiAoaW5kZXhlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoYWxsb3dJbmRleGVkLCBcInBhcmFtZXRlciBjYW5ub3QgYmUgaW5kZXhlZFwiLCBcIm9iai5pbmRleGVkXCIsIG9iai5pbmRleGVkKTtcbiAgICAgICAgICAgIGluZGV4ZWQgPSAhIWluZGV4ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSBvYmoudHlwZTtcbiAgICAgICAgbGV0IGFycmF5TWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXlUeXBlKTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcGFyc2VJbnQoYXJyYXlNYXRjaFsyXSB8fCBcIi0xXCIpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXlDaGlsZHJlbiA9IFBhcmFtVHlwZS5mcm9tKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhcnJheU1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9iai5jb21wb25lbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcImFycmF5XCIsIGluZGV4ZWQsIG51bGwsIGFycmF5TGVuZ3RoLCBhcnJheUNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHR5cGUuc3RhcnRzV2l0aChcInR1cGxlKFwiIC8qIGZpeDogKSAqLykgfHwgdHlwZS5zdGFydHNXaXRoKFwiKFwiIC8qIGZpeDogKSAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG9iai5jb21wb25lbnRzICE9IG51bGwpID8gb2JqLmNvbXBvbmVudHMubWFwKChjKSA9PiBQYXJhbVR5cGUuZnJvbShjKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgdHVwbGUgPSBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCBcInR1cGxlXCIsIGluZGV4ZWQsIGNvbXBzLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB1c2UgbGV4ZXIgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHVwbGU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHZlcmlmeUJhc2ljVHlwZShvYmoudHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9ndWFyZCwgbmFtZSB8fCBcIlwiLCB0eXBlLCB0eXBlLCBpbmRleGVkLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSAqKlBhcmFtVHlwZSoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BhcmFtVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gUGFyYW1UeXBlSW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyYW1UeXBlID0gUGFyYW1UeXBlO1xuLyoqXG4gKiAgQW4gYWJzdHJhY3QgY2xhc3MgdG8gcmVwcmVzZW50IEFuIGluZGl2aWR1YWwgZnJhZ21lbnQgZnJvbSBhIHBhcnNlIEFCSS5cbiAqL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGlucHV0cyBmb3IgdGhlIGZyYWdtZW50LlxuICAgICAqL1xuICAgIGlucHV0cztcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgaW5wdXRzKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiRnJhZ21lbnRcIik7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHR5cGUsIGlucHV0cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGcmFnbWVudCoqIGZvciAlJW9iaiUlLCB3aWNoIGNhbiBiZSBhbnkgc3VwcG9ydGVkXG4gICAgICogIEFCSSBmcmdhbWVudCB0eXBlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBUcnkgcGFyc2luZyBKU09OLi4uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZyYWdtZW50LmZyb20oSlNPTi5wYXJzZShvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSwgdXNlIHRoZSBodW1hbi1yZWFkYWJsZSBsZXhlclxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgLy8gSHVtYW4tcmVhZGFibGUgQUJJIChhbHJlYWR5IGxleGVkKVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9iai5wZWVrS2V5d29yZChLd1R5cGVzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOiByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHJldHVybiBFcnJvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjogcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWNlaXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWxsYmFja0ZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjogcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJ1Y3RcIjogcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIEpTT04gQUJJXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6IHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20ob2JqKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjogcmV0dXJuIEVycm9yRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOiByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cnVjdFwiOiByZXR1cm4gU3RydWN0RnJhZ21lbnQuZnJvbShvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShmYWxzZSwgYHVuc3VwcG9ydGVkIHR5cGU6ICR7b2JqLnR5cGV9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJGcmFnbWVudC5mcm9tXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBmcmdhbWVudCBvYmplY3RcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSBbW0NvbnN0cnVjdG9yRnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYW4gW1tFcnJvckZyYWdtZW50XV0uXG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEVycm9yRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGFuIFtbRXZlbnRGcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0V2ZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbRnVuY3Rpb25GcmFnbWVudF1dLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIFtbU3RydWN0RnJhZ21lbnRdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJ1Y3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbi8qKlxuICogIEFuIGFic3RyYWN0IGNsYXNzIHRvIHJlcHJlc2VudCBBbiBpbmRpdmlkdWFsIGZyYWdtZW50XG4gKiAgd2hpY2ggaGFzIGEgbmFtZSBmcm9tIGEgcGFyc2UgQUJJLlxuICovXG5jbGFzcyBOYW1lZEZyYWdtZW50IGV4dGVuZHMgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdHlwZSwgbmFtZSwgaW5wdXRzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCB0eXBlLCBpbnB1dHMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiAmJiBuYW1lLm1hdGNoKHJlZ2V4SWQpLCBcImludmFsaWQgaWRlbnRpZmllclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlucHV0cyA9IE9iamVjdC5mcmVlemUoaW5wdXRzLnNsaWNlKCkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IG5hbWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lZEZyYWdtZW50ID0gTmFtZWRGcmFnbWVudDtcbmZ1bmN0aW9uIGpvaW5QYXJhbXMoZm9ybWF0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gXCIoXCIgKyBwYXJhbXMubWFwKChwKSA9PiBwLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IFwiZnVsbFwiKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xufVxuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgLy9DdXN0b20gRXJyb3IvLy5cbiAqL1xuY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZXJyb3JcIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBFcnJvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQ3VzdG9tIEVycm9yIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmlkKSh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnJhZ21lbnQgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipFcnJvckZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChFcnJvckZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRXJyb3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZXJyb3JcIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvckZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbSkgOiBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXJyb3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFcnJvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IEVycm9yRnJhZ21lbnQ7XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYW4gRXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50RnJhZ21lbnQgZXh0ZW5kcyBOYW1lZEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGlzIGV2ZW50IGlzIGFub255bW91cy5cbiAgICAgKi9cbiAgICBhbm9ueW1vdXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIGlucHV0cywgYW5vbnltb3VzKSB7XG4gICAgICAgIHN1cGVyKGd1YXJkLCBcImV2ZW50XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogRXZlbnRGcmFnbWVudEludGVybmFsIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFub255bW91cyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBFdmVudCB0b3BpYyBoYXNoLlxuICAgICAqL1xuICAgIGdldCB0b3BpY0hhc2goKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5pZCkodGhpcy5mb3JtYXQoXCJzaWdoYXNoXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBldmVudCBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcInNpZ2hhc2hcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgICAgICAgICAgYW5vbnltb3VzOiB0aGlzLmFub255bW91cyxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGkpID0+IEpTT04ucGFyc2UoaS5mb3JtYXQoZm9ybWF0KSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5uYW1lICsgam9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKSk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IFwic2lnaGFzaFwiICYmIHRoaXMuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcImFub255bW91c1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSB0b3BpYyBoYXNoIGZvciBhbiBldmVudCB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb3BpY0hhc2gobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IChwYXJhbXMgfHwgW10pLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCkpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgbmFtZSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqRXZlbnRGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoRXZlbnRGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGV2ZW50IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcImV2ZW50XCIsIG9iaik7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBhbm9ueW1vdXMgPSAhIWNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJhbm9ueW1vdXNcIl0pKS5oYXMoXCJhbm9ueW1vdXNcIik7XG4gICAgICAgICAgICBjb25zdW1lRW9pKG9iaik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50RnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBpbnB1dHMsIGFub255bW91cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9ndWFyZCwgb2JqLm5hbWUsIG9iai5pbnB1dHMgPyBvYmouaW5wdXRzLm1hcCgocCkgPT4gUGFyYW1UeXBlLmZyb20ocCwgdHJ1ZSkpIDogW10sICEhb2JqLmFub255bW91cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFuXG4gICAgICogICoqRXZlbnRGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBFdmVudEZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IEV2ZW50RnJhZ21lbnQ7XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBjb25zdHJ1Y3Rvci5cbiAqL1xuY2xhc3MgQ29uc3RydWN0b3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICAgKiAgV2hldGhlciB0aGUgY29uc3RydWN0b3IgY2FuIHJlY2VpdmUgYW4gZW5kb3dtZW50LlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgZm9yIGRlcGxveW1lbnQgb3IgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2FzO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB0eXBlLCBpbnB1dHMsIHBheWFibGUsIGdhcykge1xuICAgICAgICBzdXBlcihndWFyZCwgdHlwZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcGF5YWJsZSwgZ2FzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbnN0cnVjdG9yIGFzICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIsIFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiIH0pO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAodGhpcy5wYXlhYmxlID8gXCJwYXlhYmxlXCIgOiBcInVuZGVmaW5lZFwiKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW2Bjb25zdHJ1Y3RvciR7am9pblBhcmFtcyhmb3JtYXQsIHRoaXMuaW5wdXRzKX1gXTtcbiAgICAgICAgcmVzdWx0LnB1c2goKHRoaXMucGF5YWJsZSkgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBAJHt0aGlzLmdhcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIiBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqQ29uc3RydWN0b3JGcmFnbWVudCoqIGZvciAlJW9iaiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKG9iaikge1xuICAgICAgICBpZiAoQ29uc3RydWN0b3JGcmFnbWVudC5pc0ZyYWdtZW50KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKGxleChvYmopKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGNvbnN0dWN0b3IgZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcImNvbnN0cnVjdG9yXCJdKSk7XG4gICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICBjb25zdCBwYXlhYmxlID0gISFjb25zdW1lS2V5d29yZHMob2JqLCBLd1Zpc2liRGVwbG95KS5oYXMoXCJwYXlhYmxlXCIpO1xuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBpbnB1dHMsIHBheWFibGUsIGdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvckZyYWdtZW50KF9ndWFyZCwgXCJjb25zdHJ1Y3RvclwiLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sICEhb2JqLnBheWFibGUsIChvYmouZ2FzICE9IG51bGwpID8gb2JqLmdhcyA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqQ29uc3RydWN0b3JGcmFnbWVudCoqLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWVbaW50ZXJuYWxdID09PSBDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IENvbnN0cnVjdG9yRnJhZ21lbnQ7XG4vKipcbiAqICBBIEZyYWdtZW50IHdoaWNoIHJlcHJlc2VudHMgYSBtZXRob2QuXG4gKi9cbmNsYXNzIEZhbGxiYWNrRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgICogIElmIHRoZSBmdW5jdGlvbiBjYW4gYmUgc2VudCB2YWx1ZSBkdXJpbmcgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICBwYXlhYmxlO1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBpbnB1dHMsIHBheWFibGUpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZmFsbGJhY2tcIiwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcGF5YWJsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmYWxsYmFjayBhcyAlJWZvcm1hdCUlLlxuICAgICAqL1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwKSA/IFwicmVjZWl2ZVwiIDogXCJmYWxsYmFja1wiKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTXV0YWJpbGl0eSA9ICh0aGlzLnBheWFibGUgPyBcInBheWFibGVcIiA6IFwibm9ucGF5YWJsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IHR5cGUsIHN0YXRlTXV0YWJpbGl0eSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dHlwZX0oKSR7dGhpcy5wYXlhYmxlID8gXCIgcGF5YWJsZVwiIDogXCJcIn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKkZhbGxiYWNrRnJhZ21lbnQqKiBmb3IgJSVvYmolJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShvYmopIHtcbiAgICAgICAgaWYgKEZhbGxiYWNrRnJhZ21lbnQuaXNGcmFnbWVudChvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhbGxiYWNrRnJhZ21lbnQuZnJvbShsZXgob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBmYWxsYmFjayBmcmFnbWVudFwiLCBcIm9ialwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFRva2VuU3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG9iai50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdG9wSXNWYWxpZCA9IG9iai5wZWVrS2V5d29yZChzZXRpZnkoW1wiZmFsbGJhY2tcIiwgXCJyZWNlaXZlXCJdKSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkodG9wSXNWYWxpZCwgXCJ0eXBlIG11c3QgYmUgZmFsbGJhY2sgb3IgcmVjZWl2ZVwiLCBcIm9ialwiLCBlcnJvck9iaik7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gb2JqLnBvcEtleXdvcmQoc2V0aWZ5KFtcImZhbGxiYWNrXCIsIFwicmVjZWl2ZVwiXSkpO1xuICAgICAgICAgICAgLy8gcmVjZWl2ZSgpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBjb25zdW1lUGFyYW1zKG9iaik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGlucHV0cy5sZW5ndGggPT09IDAsIGByZWNlaXZlIGNhbm5vdCBoYXZlIGFyZ3VtZW50c2AsIFwib2JqLmlucHV0c1wiLCBpbnB1dHMpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVLZXl3b3JkcyhvYmosIHNldGlmeShbXCJwYXlhYmxlXCJdKSk7XG4gICAgICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGxiYWNrKCkgW3BheWFibGVdXG4gICAgICAgICAgICAvLyBmYWxsYmFjayhieXRlcykgW3BheWFibGVdIHJldHVybnMgKGJ5dGVzKVxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGlucHV0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRzWzBdLnR5cGUgPT09IFwiYnl0ZXNcIiwgXCJpbnZhbGlkIGZhbGxiYWNrIGlucHV0c1wiLCBcIm9iai5pbnB1dHNcIiwgaW5wdXRzLm1hcCgoaSkgPT4gaS5mb3JtYXQoXCJtaW5pbWFsXCIpKS5qb2luKFwiLCBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXV0YWJpbGl0eSA9IGNvbnN1bWVNdXRhYmlsaXR5KG9iaik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobXV0YWJpbGl0eSA9PT0gXCJub25wYXlhYmxlXCIgfHwgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIsIFwiZmFsbGJhY2sgY2Fubm90IGJlIGNvbnN0YW50c1wiLCBcIm9iai5zdGF0ZU11dGFiaWxpdHlcIiwgbXV0YWJpbGl0eSk7XG4gICAgICAgICAgICBpZiAoY29uc3VtZUtleXdvcmRzKG9iaiwgc2V0aWZ5KFtcInJldHVybnNcIl0pKS5oYXMoXCJyZXR1cm5zXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkob3V0cHV0cy5sZW5ndGggPT09IDEgJiYgb3V0cHV0c1swXS50eXBlID09PSBcImJ5dGVzXCIsIFwiaW52YWxpZCBmYWxsYmFjayBvdXRwdXRzXCIsIFwib2JqLm91dHB1dHNcIiwgb3V0cHV0cy5tYXAoKGkpID0+IGkuZm9ybWF0KFwibWluaW1hbFwiKSkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN1bWVFb2kob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIGlucHV0cywgbXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJyZWNlaXZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFsbGJhY2tGcmFnbWVudChfZ3VhcmQsIFtdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gW1BhcmFtVHlwZS5mcm9tKFwiYnl0ZXNcIildO1xuICAgICAgICAgICAgY29uc3QgcGF5YWJsZSA9IChvYmouc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhbGxiYWNrRnJhZ21lbnQoX2d1YXJkLCBpbnB1dHMsIHBheWFibGUpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIGZhbGxiYWNrIGRlc2NyaXB0aW9uXCIsIFwib2JqXCIsIG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaWYgJSV2YWx1ZSUlIGlzIGFcbiAgICAgKiAgKipGYWxsYmFja0ZyYWdtZW50KiouXG4gICAgICovXG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZVtpbnRlcm5hbF0gPT09IEZhbGxiYWNrRnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GYWxsYmFja0ZyYWdtZW50ID0gRmFsbGJhY2tGcmFnbWVudDtcbi8qKlxuICogIEEgRnJhZ21lbnQgd2hpY2ggcmVwcmVzZW50cyBhIG1ldGhvZC5cbiAqL1xuY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgZnVuY3Rpb24gaXMgY29uc3RhbnQgKGUuZy4gYGBwdXJlYGAgb3IgYGB2aWV3YGAgZnVuY3Rpb25zKS5cbiAgICAgKi9cbiAgICBjb25zdGFudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJldHVybmVkIHR5cGVzIGZvciB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBvdXRwdXRzO1xuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgbXV0YWJpbGl0eSAoZS5nLiBgYHBheWFibGVgYCwgYGBub25wYXlhYmxlYGAsIGBgdmlld2BgXG4gICAgICogIG9yIGBgcHVyZWBgKVxuICAgICAqL1xuICAgIHN0YXRlTXV0YWJpbGl0eTtcbiAgICAvKipcbiAgICAgKiAgSWYgdGhlIGZ1bmN0aW9uIGNhbiBiZSBzZW50IHZhbHVlIGR1cmluZyBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHBheWFibGU7XG4gICAgLyoqXG4gICAgICogIFRoZSByZWNvbW1lbmRlZCBnYXMgbGltaXQgdG8gc2VuZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnYXM7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIG5hbWUsIHN0YXRlTXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwiZnVuY3Rpb25cIiwgbmFtZSwgaW5wdXRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGludGVybmFsLCB7IHZhbHVlOiBGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwgfSk7XG4gICAgICAgIG91dHB1dHMgPSBPYmplY3QuZnJlZXplKG91dHB1dHMuc2xpY2UoKSk7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50ID0gKHN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG4gICAgICAgIGNvbnN0IHBheWFibGUgPSAoc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgY29uc3RhbnQsIGdhcywgb3V0cHV0cywgcGF5YWJsZSwgc3RhdGVNdXRhYmlsaXR5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIEZ1bmN0aW9uIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmlkKSh0aGlzLmZvcm1hdChcInNpZ2hhc2hcIikpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJzaWdoYXNoXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAoKHRoaXMuZ2FzICE9IG51bGwpID8gdGhpcy5nYXMgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMubWFwKChpKSA9PiBKU09OLnBhcnNlKGkuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvKSA9PiBKU09OLnBhcnNlKG8uZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBcInNpZ2hhc2hcIikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5hbWUgKyBqb2luUGFyYW1zKGZvcm1hdCwgdGhpcy5pbnB1dHMpKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gXCJzaWdoYXNoXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnN0YXRlTXV0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRzICYmIHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcInJldHVybnNcIik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goam9pblBhcmFtcyhmb3JtYXQsIHRoaXMub3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgQCR7dGhpcy5nYXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzZWxlY3RvciBmb3IgYSBmdW5jdGlvbiB3aXRoICUlbmFtZSUlIGFuZCAlJXBhcmFtcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3RvcihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkubWFwKChwKSA9PiBQYXJhbVR5cGUuZnJvbShwKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBuYW1lLCBcInZpZXdcIiwgcGFyYW1zLCBbXSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zZWxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgKipGdW5jdGlvbkZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnJhZ21lbnQob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChvYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZnVuY3Rpb24gZnJhZ21lbnRcIiwgXCJvYmpcIiwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBUb2tlblN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbnN1bWVOYW1lKFwiZnVuY3Rpb25cIiwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IGNvbnN1bWVQYXJhbXMob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IG11dGFiaWxpdHkgPSBjb25zdW1lTXV0YWJpbGl0eShvYmopO1xuICAgICAgICAgICAgbGV0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb25zdW1lS2V5d29yZHMob2JqLCBzZXRpZnkoW1wicmV0dXJuc1wiXSkpLmhhcyhcInJldHVybnNcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzID0gY29uc3VtZUdhcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkZyYWdtZW50KF9ndWFyZCwgbmFtZSwgbXV0YWJpbGl0eSwgaW5wdXRzLCBvdXRwdXRzLCBnYXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZU11dGFiaWxpdHkgPSBvYmouc3RhdGVNdXRhYmlsaXR5O1xuICAgICAgICAvLyBVc2UgbGVnYWN5IFNvbGlkaXR5IEFCSSBsb2dpYyBpZiBzdGF0ZU11dGFiaWxpdHkgaXMgbWlzc2luZ1xuICAgICAgICBpZiAoc3RhdGVNdXRhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLmNvbnN0YW50KSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInZpZXdcIjtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHkgPSBcInBheWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqLnBheWFibGUpID09PSBcImJvb2xlYW5cIiAmJiAhb2JqLnBheWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIChvYmoucGF5YWJsZSkgPT09IFwiYm9vbGVhblwiICYmICFvYmoucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiB2ZXJpZnlTdGF0ZSBmb3Igc3RhdGVNdXRhYmlsaXR5IChlLmcuIHRocm93IGlmXG4gICAgICAgIC8vICAgICAgICBwYXlhYmxlOiBmYWxzZSBidXQgc3RhdGVNdXRhYmlsaXR5IGlzIFwibm9ucGF5YWJsZVwiKVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2d1YXJkLCBvYmoubmFtZSwgc3RhdGVNdXRhYmlsaXR5LCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10sIG9iai5vdXRwdXRzID8gb2JqLm91dHB1dHMubWFwKFBhcmFtVHlwZS5mcm9tKSA6IFtdLCAob2JqLmdhcyAhPSBudWxsKSA/IG9iai5nYXMgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpZiAlJXZhbHVlJSUgaXMgYVxuICAgICAqICAqKkZ1bmN0aW9uRnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gRnVuY3Rpb25GcmFnbWVudEludGVybmFsKTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmN0aW9uRnJhZ21lbnQgPSBGdW5jdGlvbkZyYWdtZW50O1xuLyoqXG4gKiAgQSBGcmFnbWVudCB3aGljaCByZXByZXNlbnRzIGEgc3RydWN0dXJlLlxuICovXG5jbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIE5hbWVkRnJhZ21lbnQge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBuYW1lLCBpbnB1dHMpIHtcbiAgICAgICAgc3VwZXIoZ3VhcmQsIFwic3RydWN0XCIsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZTogU3RydWN0RnJhZ21lbnRJbnRlcm5hbCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHJ1Y3QgYXMgJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICBmb3JtYXQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyAqKlN0cnVjdEZyYWdtZW50KiogZm9yICUlb2JqJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20ob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cnVjdEZyYWdtZW50LmZyb20obGV4KG9iaikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgc3RydWN0IGZyYWdtZW50XCIsIFwib2JqXCIsIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgVG9rZW5TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25zdW1lTmFtZShcInN0cnVjdFwiLCBvYmopO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gY29uc3VtZVBhcmFtcyhvYmopO1xuICAgICAgICAgICAgY29uc3VtZUVvaShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG5hbWUsIGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RGcmFnbWVudChfZ3VhcmQsIG9iai5uYW1lLCBvYmouaW5wdXRzID8gb2JqLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb20pIDogW10pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogZml4IHRoaXMgcmV0dXJuIHR5cGVcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlmICUldmFsdWUlJSBpcyBhXG4gICAgICogICoqU3RydWN0RnJhZ21lbnQqKi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlW2ludGVybmFsXSA9PT0gU3RydWN0RnJhZ21lbnRJbnRlcm5hbCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IFN0cnVjdEZyYWdtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0cnVjdEZyYWdtZW50IiwiRnVuY3Rpb25GcmFnbWVudCIsIkZhbGxiYWNrRnJhZ21lbnQiLCJDb25zdHJ1Y3RvckZyYWdtZW50IiwiRXZlbnRGcmFnbWVudCIsIkVycm9yRnJhZ21lbnQiLCJOYW1lZEZyYWdtZW50IiwiRnJhZ21lbnQiLCJQYXJhbVR5cGUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJzZXRpZnkiLCJpdGVtcyIsInJlc3VsdCIsIlNldCIsImZvckVhY2giLCJrIiwiYWRkIiwiZnJlZXplIiwiX2t3VmlzaWJEZXBsb3kiLCJLd1Zpc2liRGVwbG95Iiwic3BsaXQiLCJfa3dWaXNpYiIsIkt3VmlzaWIiLCJfa3dUeXBlcyIsIkt3VHlwZXMiLCJfa3dNb2RpZmllcnMiLCJLd01vZGlmaWVycyIsIl9rd090aGVyIiwiX2tleXdvcmRzIiwiam9pbiIsIktleXdvcmRzIiwiU2ltcGxlVG9rZW5zIiwicmVnZXhXaGl0ZXNwYWNlUHJlZml4IiwiUmVnRXhwIiwicmVnZXhOdW1iZXJQcmVmaXgiLCJyZWdleElkUHJlZml4IiwicmVnZXhJZCIsInJlZ2V4VHlwZSIsIlRva2VuU3RyaW5nIiwib2Zmc2V0IiwidG9rZW5zIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJzbGljZSIsImNsb25lIiwicmVzZXQiLCJzdWJUb2tlblN0cmluZyIsImZyb20iLCJ0byIsIm1hcCIsInQiLCJhc3NpZ24iLCJtYXRjaCIsImxpbmtCYWNrIiwibGlua05leHQiLCJwb3BLZXl3b3JkIiwiYWxsb3dlZCIsInRvcCIsInBlZWsiLCJ0eXBlIiwiaGFzIiwidGV4dCIsIkVycm9yIiwicG9wIiwicG9wVHlwZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwb3BQYXJlbiIsInBvcFBhcmFtcyIsImxpbmsiLCJwdXNoIiwicGVla0tleXdvcmQiLCJwZWVrVHlwZSIsInRvU3RyaW5nIiwiaSIsInRva2VuIiwibGV4IiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJicmFja2V0cyIsImNvbW1hcyIsImN1ciIsInN1YnN0cmluZyIsImRlcHRoIiwic3VmZml4IiwiZ2V0TnVtYmVyIiwiYWxsb3dTaW5nbGUiLCJzZXQiLCJpbmNsdWRlZCIsImtleSIsImtleXMiLCJjb25zdW1lTmFtZSIsImtleXdvcmQiLCJjb25zdW1lS2V5d29yZHMiLCJrZXl3b3JkcyIsImNvbnN1bWVNdXRhYmlsaXR5IiwibW9kaWZpZXJzIiwiY29uc3VtZVBhcmFtcyIsImFsbG93SW5kZXhlZCIsImNvbnN1bWVHYXMiLCJnZXRCaWdJbnQiLCJjb25zdW1lRW9pIiwicmVnZXhBcnJheVR5cGUiLCJ2ZXJpZnlCYXNpY1R5cGUiLCJhc3NlcnRBcmd1bWVudCIsInBhcnNlSW50Iiwic2l6ZSIsIl9ndWFyZCIsImludGVybmFsIiwiU3ltYm9sIiwiZm9yIiwiUGFyYW1UeXBlSW50ZXJuYWwiLCJFcnJvckZyYWdtZW50SW50ZXJuYWwiLCJFdmVudEZyYWdtZW50SW50ZXJuYWwiLCJDb25zdHJ1Y3RvckZyYWdtZW50SW50ZXJuYWwiLCJGYWxsYmFja0ZyYWdtZW50SW50ZXJuYWwiLCJGdW5jdGlvbkZyYWdtZW50SW50ZXJuYWwiLCJTdHJ1Y3RGcmFnbWVudEludGVybmFsIiwiZ3VhcmQiLCJuYW1lIiwiYmFzZVR5cGUiLCJpbmRleGVkIiwiY29tcG9uZW50cyIsImFycmF5TGVuZ3RoIiwiYXJyYXlDaGlsZHJlbiIsImFzc2VydFByaXZhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZm9ybWF0IiwiaXNBcnJheSIsInBhcnNlIiwiU3RyaW5nIiwiaXNUdXBsZSIsImMiLCJjb21wIiwiaXNJbmRleGFibGUiLCJ3YWxrIiwicHJvY2VzcyIsIkFycmF5IiwiX3RoaXMiLCJ2Iiwid2Fsa0FzeW5jIiwicHJvbWlzZXMiLCJzZXRWYWx1ZSIsImNoaWxkVHlwZSIsImluZGV4IiwicGFyYW0iLCJ0aGVuIiwiUHJvbWlzZSIsImFsbCIsIm9iaiIsImlzUGFyYW1UeXBlIiwiZXJyb3IiLCJjb21wcyIsImJyYWNrZXQiLCJhcnJheU1hdGNoIiwic3RhcnRzV2l0aCIsInR1cGxlIiwiaW5wdXRzIiwiZSIsImFzc2VydCIsIm9wZXJhdGlvbiIsImlzQ29uc3RydWN0b3IiLCJpc0ZyYWdtZW50IiwiaXNFcnJvciIsImlzRXZlbnQiLCJpc0Z1bmN0aW9uIiwiaXNTdHJ1Y3QiLCJqb2luUGFyYW1zIiwicGFyYW1zIiwicCIsInNlbGVjdG9yIiwiaWQiLCJpbnB1dCIsImFub255bW91cyIsInRvcGljSGFzaCIsImdldFRvcGljSGFzaCIsImZyYWdtZW50IiwicGF5YWJsZSIsImdhcyIsInN0YXRlTXV0YWJpbGl0eSIsInVuZGVmaW5lZCIsImVycm9yT2JqIiwidG9wSXNWYWxpZCIsIm11dGFiaWxpdHkiLCJvdXRwdXRzIiwiY29uc3RhbnQiLCJvIiwiZ2V0U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/fragments.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The Application Binary Interface (ABI) describes how method input\n *  parameters should be encoded, their results decoded, and how to\n *  decode events and errors.\n *\n *  See [About ABIs](docs-abi) for more details how they are used.\n *\n *  @_section api/abi:Application Binary Interface  [about-abi]\n *  @_navTitle: ABI\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;\n//////\nvar abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\");\nObject.defineProperty(exports, \"AbiCoder\", ({\n    enumerable: true,\n    get: function() {\n        return abi_coder_js_1.AbiCoder;\n    }\n}));\nvar bytes32_js_1 = __webpack_require__(/*! ./bytes32.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/bytes32.js\");\nObject.defineProperty(exports, \"decodeBytes32String\", ({\n    enumerable: true,\n    get: function() {\n        return bytes32_js_1.decodeBytes32String;\n    }\n}));\nObject.defineProperty(exports, \"encodeBytes32String\", ({\n    enumerable: true,\n    get: function() {\n        return bytes32_js_1.encodeBytes32String;\n    }\n}));\nvar fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nObject.defineProperty(exports, \"ConstructorFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.ConstructorFragment;\n    }\n}));\nObject.defineProperty(exports, \"ErrorFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.ErrorFragment;\n    }\n}));\nObject.defineProperty(exports, \"EventFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.EventFragment;\n    }\n}));\nObject.defineProperty(exports, \"FallbackFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.FallbackFragment;\n    }\n}));\nObject.defineProperty(exports, \"Fragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.Fragment;\n    }\n}));\nObject.defineProperty(exports, \"FunctionFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.FunctionFragment;\n    }\n}));\nObject.defineProperty(exports, \"NamedFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.NamedFragment;\n    }\n}));\nObject.defineProperty(exports, \"ParamType\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.ParamType;\n    }\n}));\nObject.defineProperty(exports, \"StructFragment\", ({\n    enumerable: true,\n    get: function() {\n        return fragments_js_1.StructFragment;\n    }\n}));\nvar interface_js_1 = __webpack_require__(/*! ./interface.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/interface.js\");\nObject.defineProperty(exports, \"checkResultErrors\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.checkResultErrors;\n    }\n}));\nObject.defineProperty(exports, \"Indexed\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.Indexed;\n    }\n}));\nObject.defineProperty(exports, \"Interface\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.Interface;\n    }\n}));\nObject.defineProperty(exports, \"ErrorDescription\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.ErrorDescription;\n    }\n}));\nObject.defineProperty(exports, \"LogDescription\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.LogDescription;\n    }\n}));\nObject.defineProperty(exports, \"TransactionDescription\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.TransactionDescription;\n    }\n}));\nObject.defineProperty(exports, \"Result\", ({\n    enumerable: true,\n    get: function() {\n        return interface_js_1.Result;\n    }\n}));\nvar typed_js_1 = __webpack_require__(/*! ./typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\nObject.defineProperty(exports, \"Typed\", ({\n    enumerable: true,\n    get: function() {\n        return typed_js_1.Typed;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7O0NBU0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0EsY0FBYyxHQUFHQSw4QkFBOEIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxpQkFBaUIsR0FBR0EsZUFBZSxHQUFHQSx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0Esd0JBQXdCLEdBQUdBLGdCQUFnQixHQUFHQSx3QkFBd0IsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHQSwyQkFBMkIsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hlLE1BQU07QUFDTixJQUFJc0IsaUJBQWlCQyxtQkFBT0EsQ0FBQyxpRkFBZ0I7QUFDN0N6Qiw0Q0FBMkM7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGVBQWVELFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0SCxJQUFJSyxlQUFlSCxtQkFBT0EsQ0FBQyw2RUFBYztBQUN6Q3pCLHVEQUFzRDtJQUFFMEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsYUFBYU4sbUJBQW1CO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUl0Qix1REFBc0Q7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGFBQWFQLG1CQUFtQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFJLElBQUlRLGlCQUFpQkosbUJBQU9BLENBQUMsaUZBQWdCO0FBQzdDekIsdURBQXNEO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlVCxtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SXBCLGlEQUFnRDtJQUFFMEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsZUFBZVYsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hJbkIsaURBQWdEO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlWCxhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaElsQixvREFBbUQ7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGVBQWVaLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RJakIsNENBQTJDO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlYixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEhoQixvREFBbUQ7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGVBQWVkLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RJZixpREFBZ0Q7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGVBQWVmLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNoSWQsNkNBQTRDO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlaEIsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hIYixrREFBaUQ7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGVBQWVqQixjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEksSUFBSWtCLGlCQUFpQkwsbUJBQU9BLENBQUMsaUZBQWdCO0FBQzdDekIscURBQW9EO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxlQUFlbkIsaUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeElYLDJDQUEwQztJQUFFMEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csZUFBZXBCLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSFYsNkNBQTRDO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxlQUFlckIsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hIVCxvREFBbUQ7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLGVBQWV0QixnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0SVIsa0RBQWlEO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxlQUFldkIsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJUCwwREFBeUQ7SUFBRTBCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLGVBQWV4QixzQkFBc0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSk4sMENBQXlDO0lBQUUwQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxlQUFlekIsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xILElBQUkwQixhQUFhTixtQkFBT0EsQ0FBQyx5RUFBWTtBQUNyQ3pCLHlDQUF3QztJQUFFMEIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksV0FBVzNCLEtBQUs7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUM1RyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW5kZXguanM/OTEzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlIChBQkkpIGRlc2NyaWJlcyBob3cgbWV0aG9kIGlucHV0XG4gKiAgcGFyYW1ldGVycyBzaG91bGQgYmUgZW5jb2RlZCwgdGhlaXIgcmVzdWx0cyBkZWNvZGVkLCBhbmQgaG93IHRvXG4gKiAgZGVjb2RlIGV2ZW50cyBhbmQgZXJyb3JzLlxuICpcbiAqICBTZWUgW0Fib3V0IEFCSXNdKGRvY3MtYWJpKSBmb3IgbW9yZSBkZXRhaWxzIGhvdyB0aGV5IGFyZSB1c2VkLlxuICpcbiAqICBAX3NlY3Rpb24gYXBpL2FiaTpBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlICBbYWJvdXQtYWJpXVxuICogIEBfbmF2VGl0bGU6IEFCSVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGVkID0gZXhwb3J0cy5SZXN1bHQgPSBleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5FcnJvckRlc2NyaXB0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2UgPSBleHBvcnRzLkluZGV4ZWQgPSBleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IGV4cG9ydHMuUGFyYW1UeXBlID0gZXhwb3J0cy5OYW1lZEZyYWdtZW50ID0gZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZXhwb3J0cy5GcmFnbWVudCA9IGV4cG9ydHMuRmFsbGJhY2tGcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuZW5jb2RlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuZGVjb2RlQnl0ZXMzMlN0cmluZyA9IGV4cG9ydHMuQWJpQ29kZXIgPSB2b2lkIDA7XG4vLy8vLy9cbnZhciBhYmlfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2FiaS1jb2Rlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFiaUNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYmlfY29kZXJfanNfMS5BYmlDb2RlcjsgfSB9KTtcbnZhciBieXRlczMyX2pzXzEgPSByZXF1aXJlKFwiLi9ieXRlczMyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQnl0ZXMzMlN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMzMl9qc18xLmRlY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlczMyX2pzXzEuZW5jb2RlQnl0ZXMzMlN0cmluZzsgfSB9KTtcbnZhciBmcmFnbWVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2ZyYWdtZW50cy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0cnVjdG9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkNvbnN0cnVjdG9yRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXZlbnRGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZhbGxiYWNrRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLkZhbGxiYWNrRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRnJhZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmcmFnbWVudHNfanNfMS5GdW5jdGlvbkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZWRGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuTmFtZWRGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcmFtVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhZ21lbnRzX2pzXzEuUGFyYW1UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RydWN0RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyYWdtZW50c19qc18xLlN0cnVjdEZyYWdtZW50OyB9IH0pO1xudmFyIGludGVyZmFjZV9qc18xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tSZXN1bHRFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLmNoZWNrUmVzdWx0RXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5kZXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlX2pzXzEuSW5kZXhlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyZmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlX2pzXzEuSW50ZXJmYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JEZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJmYWNlX2pzXzEuRXJyb3JEZXNjcmlwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ0Rlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcmZhY2VfanNfMS5Mb2dEZXNjcmlwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVyZmFjZV9qc18xLlJlc3VsdDsgfSB9KTtcbnZhciB0eXBlZF9qc18xID0gcmVxdWlyZShcIi4vdHlwZWQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRfanNfMS5UeXBlZDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlR5cGVkIiwiUmVzdWx0IiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsIkxvZ0Rlc2NyaXB0aW9uIiwiRXJyb3JEZXNjcmlwdGlvbiIsIkludGVyZmFjZSIsIkluZGV4ZWQiLCJjaGVja1Jlc3VsdEVycm9ycyIsIlN0cnVjdEZyYWdtZW50IiwiUGFyYW1UeXBlIiwiTmFtZWRGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJGcmFnbWVudCIsIkZhbGxiYWNrRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkNvbnN0cnVjdG9yRnJhZ21lbnQiLCJlbmNvZGVCeXRlczMyU3RyaW5nIiwiZGVjb2RlQnl0ZXMzMlN0cmluZyIsIkFiaUNvZGVyIiwiYWJpX2NvZGVyX2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImJ5dGVzMzJfanNfMSIsImZyYWdtZW50c19qc18xIiwiaW50ZXJmYWNlX2pzXzEiLCJ0eXBlZF9qc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/interface.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/interface.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abi_coder_js_1 = __webpack_require__(/*! ./abi-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/abi-coder.js\");\nconst abstract_coder_js_1 = __webpack_require__(/*! ./coders/abstract-coder.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js\");\nObject.defineProperty(exports, \"checkResultErrors\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_coder_js_1.checkResultErrors;\n    }\n}));\nObject.defineProperty(exports, \"Result\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_coder_js_1.Result;\n    }\n}));\nconst fragments_js_1 = __webpack_require__(/*! ./fragments.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/fragments.js\");\nconst typed_js_1 = __webpack_require__(/*! ./typed.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\");\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */ class LogDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, topic, args){\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment,\n            name,\n            signature,\n            topic,\n            args\n        });\n    }\n}\nexports.LogDescription = LogDescription;\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */ class TransactionDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args, value){\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector,\n            value\n        });\n    }\n}\nexports.TransactionDescription = TransactionDescription;\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */ class ErrorDescription {\n    /**\n     *  @_ignore:\n     */ constructor(fragment, selector, args){\n        const name = fragment.name, signature = fragment.format();\n        (0, index_js_3.defineProperties)(this, {\n            fragment,\n            name,\n            args,\n            signature,\n            selector\n        });\n    }\n}\nexports.ErrorDescription = ErrorDescription;\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */ class Indexed {\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */ static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(hash){\n        (0, index_js_3.defineProperties)(this, {\n            hash,\n            _isIndexed: true\n        });\n    }\n}\nexports.Indexed = Indexed;\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\n            \"string\"\n        ],\n        reason: (message)=>{\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\n            \"uint256\"\n        ],\n        reason: (code)=>{\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */ class Interface {\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */ constructor(fragments){\n        let abi = [];\n        if (typeof fragments === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi){\n            try {\n                frags.push(fragments_js_1.Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n        (0, index_js_3.defineProperties)(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index)=>{\n            let bucket;\n            switch(fragment.type){\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    (0, index_js_3.defineProperties)(this, {\n                        deploy: fragment\n                    });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            (0, index_js_3.defineProperties)(this, {\n                deploy: fragments_js_1.ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        (0, index_js_3.defineProperties)(this, {\n            fallback,\n            receive\n        });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */ format(minimal) {\n        const format = minimal ? \"minimal\" : \"full\";\n        const abi = this.fragments.map((f)=>f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */ formatJson() {\n        const abi = this.fragments.map((f)=>f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j)=>JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */ getAbiCoder() {\n        return abi_coder_js_1.AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if ((0, index_js_3.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = values.length > 0 ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!typed_js_1.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(fragments_js_1.FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */ getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        (0, index_js_3.assertArgument)(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */ hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */ getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */ forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#functions.get(name), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if ((0, index_js_3.isHexString)(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()){\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for(let i = matching.length - 1; i >= 0; i--){\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for(let i = matching.length - 1; i >= 0; i--){\n                    const inputs = matching[i].inputs;\n                    for(let j = 0; j < values.length; j++){\n                        // Not a typed value\n                        if (!typed_js_1.Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(fragments_js_1.EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */ getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        (0, index_js_3.assertArgument)(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */ hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */ getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */ forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#events.get(name), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */ getError(key, values) {\n        if ((0, index_js_3.isHexString)(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()){\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors){\n                if (name.split(\"(\" /* fix:) */ )[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m)=>JSON.stringify(m.format())).join(\", \");\n                (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = fragments_js_1.ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return fragments_js_1.ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return fragments_js_1.ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */ forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b)=>a.localeCompare(b));\n        for(let i = 0; i < names.length; i++){\n            const name = names[i];\n            callback(this.#errors.get(name), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */ // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */ _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */ encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeErrorResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeErrorResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getError(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */ decodeFunctionData(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */ encodeFunctionData(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.concat)([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */ decodeFunctionResult(fragment, data) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = (0, index_js_3.getBytesCopy)(data);\n        if (bytes.length % 32 === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        (0, index_js_3.assert)(false, message, \"BAD_DATA\", {\n            value: (0, index_js_3.hexlify)(bytes),\n            info: {\n                method: fragment.name,\n                signature: fragment.format()\n            }\n        });\n    }\n    makeError(_data, tx) {\n        const data = (0, index_js_3.getBytes)(_data, \"data\");\n        const error = abi_coder_js_1.AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = (0, index_js_3.hexlify)(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name,\n                        signature: ef.format(),\n                        args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */ encodeFunctionResult(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getFunction(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return (0, index_js_3.hexlify)(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */ // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n            count: values.length,\n            expectedCount: fragment.inputs.length\n        });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value)=>{\n            if (param.type === \"string\") {\n                return (0, index_js_2.id)(value);\n            } else if (param.type === \"bytes\") {\n                return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));\n            }\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\n                value = value ? \"0x01\" : \"0x00\";\n            } else if (param.type.match(/^u?int/)) {\n                value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??\n            } else if (param.type.match(/^bytes/)) {\n                value = (0, index_js_3.zeroPadBytes)(value, 32);\n            } else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\n                    \"address\"\n                ], [\n                    value\n                ]);\n            }\n            return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);\n        };\n        values.forEach((value, index)=>{\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                (0, index_js_3.assertArgument)(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                (0, index_js_3.assertArgument)(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value)=>encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while(topics.length && topics[topics.length - 1] === null){\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index)=>{\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push((0, index_js_2.id)(value));\n                } else if (param.type === \"bytes\") {\n                    topics.push((0, index_js_1.keccak256)(value));\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([\n                        param.type\n                    ], [\n                        value\n                    ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof fragment === \"string\") {\n            const f = this.getEvent(fragment);\n            (0, index_js_3.assertArgument)(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index)=>{\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(fragments_js_1.ParamType.from({\n                        type: \"bytes32\",\n                        name: param.name\n                    }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, (0, index_js_3.concat)(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index)=>{\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return abstract_coder_js_1.Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */ parseTransaction(tx) {\n        const data = (0, index_js_3.getBytes)(tx.data, \"tx.data\");\n        const value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */ parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */ parseError(data) {\n        const hexData = (0, index_js_3.hexlify)(data);\n        const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */ static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof value === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof value.format === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n}\nexports.Interface = Interface; //# sourceMappingURL=interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Q0FVQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGVBQWUsR0FBR0Esd0JBQXdCLEdBQUdBLDhCQUE4QixHQUFHQSxzQkFBc0IsR0FBR0EsY0FBYyxHQUFHQSx5QkFBeUIsR0FBRyxLQUFLO0FBQzdLLE1BQU1TLGFBQWFDLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxnRkFBa0I7QUFDN0MsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1HLGlCQUFpQkgsbUJBQU9BLENBQUMsaUZBQWdCO0FBQy9DLE1BQU1JLHNCQUFzQkosbUJBQU9BLENBQUMseUdBQTRCO0FBQ2hFWixxREFBb0Q7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLG9CQUFvQk4saUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0lWLDBDQUF5QztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Ysb0JBQW9CUCxNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkgsTUFBTVUsaUJBQWlCUCxtQkFBT0EsQ0FBQyxpRkFBZ0I7QUFDL0MsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUMseUVBQVk7QUFDdkM7OztDQUdDLEdBQ0QsTUFBTUo7SUFxQkY7O0tBRUMsR0FDRGEsWUFBWUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksQ0FBRTtRQUMvQixNQUFNQyxPQUFPSCxTQUFTRyxJQUFJLEVBQUVDLFlBQVlKLFNBQVNLLE1BQU07UUFDdEQsSUFBR2IsV0FBV2MsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQ25DTjtZQUFVRztZQUFNQztZQUFXSDtZQUFPQztRQUN0QztJQUNKO0FBQ0o7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QkFBaUJDLFdBQVc7WUFDNUIsT0FBT0Q7UUFDWDtRQUNBLE9BQU87UUFDUCxJQUFJLE9BQVFBLFVBQVcsVUFBVTtZQUM3QixPQUFPLElBQUlDLFVBQVVrQyxLQUFLVSxLQUFLLENBQUM3QztRQUNwQztRQUNBLHFFQUFxRTtRQUNyRSxJQUFJLE9BQVFBLE1BQU13QixNQUFNLEtBQU0sWUFBWTtZQUN0QyxPQUFPLElBQUl2QixVQUFVRCxNQUFNd0IsTUFBTSxDQUFDO1FBQ3RDO1FBQ0EscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSXZCLFVBQVVEO0lBQ3pCO0FBQ0o7QUFDQUQsaUJBQWlCLEdBQUdFLFdBQ3BCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FiaS9pbnRlcmZhY2UuanM/ZmZjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBJbnRlcmZhY2UgY2xhc3MgaXMgYSBsb3ctbGV2ZWwgY2xhc3MgdGhhdCBhY2NlcHRzIGFuXG4gKiAgQUJJIGFuZCBwcm92aWRlcyBhbGwgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbmFsaXR5IHRvIGVuY29kZVxuICogIGFuZCBkZWNvZGUgcGFyYW1hdGVycyB0byBhbmQgcmVzdWx0cyBmcm9tIG1ldGhvZHMsIGV2ZW50c1xuICogIGFuZCBlcnJvcnMuXG4gKlxuICogIEl0IGFsc28gcHJvdmlkZXMgc2V2ZXJhbCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGF1dG9tYXRpY2FsbHlcbiAqICBzZWFyY2ggYW5kIGZpbmQgbWF0Y2hpbmcgdHJhbnNhY3Rpb25zIGFuZCBldmVudHMgdG8gcGFyc2UgdGhlbS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9hYmk6SW50ZXJmYWNlcyAgW2ludGVyZmFjZXNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJmYWNlID0gZXhwb3J0cy5JbmRleGVkID0gZXhwb3J0cy5FcnJvckRlc2NyaXB0aW9uID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IGV4cG9ydHMuUmVzdWx0ID0gZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFiaV9jb2Rlcl9qc18xID0gcmVxdWlyZShcIi4vYWJpLWNvZGVyLmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfY29kZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvZGVycy9hYnN0cmFjdC1jb2Rlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrUmVzdWx0RXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLmNoZWNrUmVzdWx0RXJyb3JzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLlJlc3VsdDsgfSB9KTtcbmNvbnN0IGZyYWdtZW50c19qc18xID0gcmVxdWlyZShcIi4vZnJhZ21lbnRzLmpzXCIpO1xuY29uc3QgdHlwZWRfanNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLmpzXCIpO1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VMb2ddXSB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIGEgTG9nIHRvIGl0cyBldmVudFxuICogIGZvciBwYXJzaW5nLCBhICoqTG9nRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuY2xhc3MgTG9nRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQgZm9yIHRoZSBgYHRvcGljMGBgLlxuICAgICAqL1xuICAgIGZyYWdtZW50O1xuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgRXZlbnQuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZ1bGwgRXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIHNpZ25hdHVyZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRvcGljIGhhc2ggZm9yIHRoZSBFdmVudC5cbiAgICAgKi9cbiAgICB0b3BpYztcbiAgICAvKipcbiAgICAgKiAgVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgRXZlbnQgd2l0aCBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgdG9waWMsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgc2lnbmF0dXJlLCB0b3BpYywgYXJnc1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gTG9nRGVzY3JpcHRpb247XG4vKipcbiAqICBXaGVuIHVzaW5nIHRoZSBbW0ludGVyZmFjZS1wYXJzZVRyYW5zYWN0aW9uXV0gdG8gYXV0b21hdGljYWxseSBtYXRjaFxuICogIGEgdHJhbnNhY3Rpb24gZGF0YSB0byBpdHMgZnVuY3Rpb24gZm9yIHBhcnNpbmcsXG4gKiAgYSAqKlRyYW5zYWN0aW9uRGVzY3JpcHRpb24qKiBpcyByZXR1cm5lZC5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBmcmFnbWVudCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIHRyYW5zYWN0aW9uIGBgZGF0YWBgLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZnVsbCBGdW5jdGlvbiBzaWduYXR1cmUgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYGBkYXRhYGAuXG4gICAgICovXG4gICAgc2lnbmF0dXJlO1xuICAgIC8qKlxuICAgICAqICBUaGUgc2VsZWN0b3IgZm9yIHRoZSBGdW5jdGlvbiBmcm9tIHRoZSB0cmFuc2FjdGlvbiBgYGRhdGFgYC5cbiAgICAgKi9cbiAgICBzZWxlY3RvcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdmFsdWVgYCAoaW4gd2VpKSBmcm9tIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnQsIHNlbGVjdG9yLCBhcmdzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGZyYWdtZW50LCBuYW1lLCBhcmdzLCBzaWduYXR1cmUsIHNlbGVjdG9yLCB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuLyoqXG4gKiAgV2hlbiB1c2luZyB0aGUgW1tJbnRlcmZhY2UtcGFyc2VFcnJvcl1dIHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggYW5cbiAqICBlcnJvciBmb3IgYSBjYWxsIHJlc3VsdCBmb3IgcGFyc2luZywgYW4gKipFcnJvckRlc2NyaXB0aW9uKiogaXMgcmV0dXJuZWQuXG4gKi9cbmNsYXNzIEVycm9yRGVzY3JpcHRpb24ge1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF0Y2hpbmcgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZnJhZ21lbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lIG9mIHRoZSBFcnJvci5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgRXJyb3Igd2l0aCBgYHJldmVydGBgLlxuICAgICAqL1xuICAgIGFyZ3M7XG4gICAgLyoqXG4gICAgICogIFRoZSBmdWxsIEVycm9yIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBzZWxlY3RvciBmb3IgdGhlIEVycm9yLlxuICAgICAqL1xuICAgIHNlbGVjdG9yO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudCwgc2VsZWN0b3IsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWUsIHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBmcmFnbWVudCwgbmFtZSwgYXJncywgc2lnbmF0dXJlLCBzZWxlY3RvclxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkVycm9yRGVzY3JpcHRpb24gPSBFcnJvckRlc2NyaXB0aW9uO1xuLyoqXG4gKiAgQW4gKipJbmRleGVkKiogaXMgdXNlZCBhcyBhIHZhbHVlIHdoZW4gYSB2YWx1ZSB0aGF0IGRvZXMgbm90XG4gKiAgZml0IHdpdGhpbiBhIHRvcGljIChpLmUuIG5vdCBhIGZpeGVkLWxlbmd0aCwgMzItYnl0ZSB0eXBlKS4gSXRcbiAqICBpcyB0aGUgYGBrZWNjYWsyNTZgYCBvZiB0aGUgdmFsdWUsIGFuZCB1c2VkIGZvciB0eXBlcyBzdWNoIGFzXG4gKiAgYXJyYXlzLCB0dXBsZXMsIGJ5dGVzIGFuZCBzdHJpbmdzLlxuICovXG5jbGFzcyBJbmRleGVkIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBga2VjY2FrMjU2YGAgb2YgdGhlIHZhbHVlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBoYXNoO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaXNJbmRleGVkO1xuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGlmICUldmFsdWUlJSBpcyBhbiAqKkluZGV4ZWQqKi5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCBmb3IgcHJvcGVydHkgYWNjZXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0luZGV4ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFzaCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGhhc2gsIF9pc0luZGV4ZWQ6IHRydWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbmRleGVkID0gSW5kZXhlZDtcbi8vIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTMvY29udHJvbC1zdHJ1Y3R1cmVzLmh0bWw/aGlnaGxpZ2h0PXBhbmljI3BhbmljLXZpYS1hc3NlcnQtYW5kLWVycm9yLXZpYS1yZXF1aXJlXG5jb25zdCBQYW5pY1JlYXNvbnMgPSB7XG4gICAgXCIwXCI6IFwiZ2VuZXJpYyBwYW5pY1wiLFxuICAgIFwiMVwiOiBcImFzc2VydChmYWxzZSlcIixcbiAgICBcIjE3XCI6IFwiYXJpdGhtZXRpYyBvdmVyZmxvd1wiLFxuICAgIFwiMThcIjogXCJkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiLFxuICAgIFwiMzNcIjogXCJlbnVtIG92ZXJmbG93XCIsXG4gICAgXCIzNFwiOiBcImludmFsaWQgZW5jb2RlZCBzdG9yYWdlIGJ5dGUgYXJyYXkgYWNjZXNzZWRcIixcbiAgICBcIjQ5XCI6IFwib3V0LW9mLWJvdW5kcyBhcnJheSBhY2Nlc3M7IHBvcHBpbmcgb24gYW4gZW1wdHkgYXJyYXlcIixcbiAgICBcIjUwXCI6IFwib3V0LW9mLWJvdW5kcyBhY2Nlc3Mgb2YgYW4gYXJyYXkgb3IgYnl0ZXNOXCIsXG4gICAgXCI2NVwiOiBcIm91dCBvZiBtZW1vcnlcIixcbiAgICBcIjgxXCI6IFwidW5pbml0aWFsaXplZCBmdW5jdGlvblwiLFxufTtcbmNvbnN0IEJ1aWx0aW5FcnJvcnMgPSB7XG4gICAgXCIweDA4YzM3OWEwXCI6IHtcbiAgICAgICAgc2lnbmF0dXJlOiBcIkVycm9yKHN0cmluZylcIixcbiAgICAgICAgbmFtZTogXCJFcnJvclwiLFxuICAgICAgICBpbnB1dHM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgcmVhc29uOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGByZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcgJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlKX1gO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcIjB4NGU0ODdiNzFcIjoge1xuICAgICAgICBzaWduYXR1cmU6IFwiUGFuaWModWludDI1NilcIixcbiAgICAgICAgbmFtZTogXCJQYW5pY1wiLFxuICAgICAgICBpbnB1dHM6IFtcInVpbnQyNTZcIl0sXG4gICAgICAgIHJlYXNvbjogKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGxldCByZWFzb24gPSBcInVua25vd24gcGFuaWMgY29kZVwiO1xuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMCAmJiBjb2RlIDw9IDB4ZmYgJiYgUGFuaWNSZWFzb25zW2NvZGUudG9TdHJpbmcoKV0pIHtcbiAgICAgICAgICAgICAgICByZWFzb24gPSBQYW5pY1JlYXNvbnNbY29kZS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcmV2ZXJ0ZWQgd2l0aCBwYW5pYyBjb2RlIDB4JHtjb2RlLnRvU3RyaW5nKDE2KX0gKCR7cmVhc29ufSlgO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogIEFuIEludGVyZmFjZSBhYnN0cmFjdHMgbWFueSBvZiB0aGUgbG93LWxldmVsIGRldGFpbHMgZm9yXG4gKiAgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHRoZSBkYXRhIG9uIHRoZSBibG9ja2NoYWluLlxuICpcbiAqICBBbiBBQkkgcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGVuY29kZSBkYXRhIHRvIHNlbmQgdG9cbiAqICBhIENvbnRyYWN0LCBob3cgdG8gZGVjb2RlIHRoZSByZXN1bHRzIGFuZCBldmVudHMgYW5kIGhvdyB0b1xuICogIGludGVycHJldCByZXZlcnQgZXJyb3JzLlxuICpcbiAqICBUaGUgQUJJIGNhbiBiZSBzcGVjaWZpZWQgYnkgW2FueSBzdXBwb3J0ZWQgZm9ybWF0XShJbnRlcmZhY2VBYmkpLlxuICovXG5jbGFzcyBJbnRlcmZhY2Uge1xuICAgIC8qKlxuICAgICAqICBBbGwgdGhlIENvbnRyYWN0IEFCSSBtZW1iZXJzIChpLmUuIG1ldGhvZHMsIGV2ZW50cywgZXJyb3JzLCBldGMpLlxuICAgICAqL1xuICAgIGZyYWdtZW50cztcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGRlcGxveTtcbiAgICAvKipcbiAgICAgKiAgVGhlIEZhbGxiYWNrIG1ldGhvZCwgaWYgYW55LlxuICAgICAqL1xuICAgIGZhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqICBJZiByZWNlaXZpbmcgZXRoZXIgaXMgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHJlY2VpdmU7XG4gICAgI2Vycm9ycztcbiAgICAjZXZlbnRzO1xuICAgICNmdW5jdGlvbnM7XG4gICAgLy8gICAgI3N0cnVjdHM6IE1hcDxzdHJpbmcsIFN0cnVjdEZyYWdtZW50PjtcbiAgICAjYWJpQ29kZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBJbnRlcmZhY2UgZm9yIHRoZSAlJWZyYWdtZW50cyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICBsZXQgYWJpID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50cykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFiaSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Vycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAgICAgICAgdGhpcy4jc3RydWN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZnJhZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIGFiaSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFncy5wdXNoKGZyYWdtZW50c19qc18xLkZyYWdtZW50LmZyb20oYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRVwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgZnJhZ21lbnRzOiBPYmplY3QuZnJlZXplKGZyYWdzKVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYWJpQ29kZXIgPSB0aGlzLmdldEFiaUNvZGVyKCk7XG4gICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuICAgICAgICB0aGlzLmZyYWdtZW50cy5mb3JFYWNoKChmcmFnbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBidWNrZXQ7XG4gICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZGVwbG95OiBmcmFnbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWxsYmFja1wiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoIWZhbGxiYWNrIHx8IGZyYWdtZW50LnBheWFibGUgIT09IGZhbGxiYWNrLnBheWFibGUsIFwiY29uZmxpY3RpbmcgZmFsbGJhY2sgZnJhZ21lbnRzXCIsIGBmcmFnbWVudHNbJHtpbmRleH1dYCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmUgPSBmYWxsYmFjay5wYXlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy4jZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2V2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuI2Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHdvIGlkZW50aWNhbCBlbnRyaWVzOyBpZ25vcmUgaXRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC5oYXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1Y2tldC5zZXQoc2lnbmF0dXJlLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB3ZSBkbyBub3QgaGF2ZSBhIGNvbnN0cnVjdG9yIGFkZCBhIGRlZmF1bHRcbiAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgICAgIGRlcGxveTogZnJhZ21lbnRzX2pzXzEuQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKFwiY29uc3RydWN0b3IoKVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBmYWxsYmFjaywgcmVjZWl2ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudGlyZSBIdW1hbi1SZWFkYWJsZSBBQkksIGFzIGFuIGFycmF5IG9mXG4gICAgICogIHNpZ25hdHVyZXMsIG9wdGlvbmFsbHkgYXMgJSVtaW5pbWFsJSUgc3RyaW5ncywgd2hpY2hcbiAgICAgKiAgcmVtb3ZlcyBwYXJhbWV0ZXIgbmFtZXMgYW5kIHVubmVjZWVzYXJ5IHNwYWNlcy5cbiAgICAgKi9cbiAgICBmb3JtYXQobWluaW1hbCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSAobWluaW1hbCA/IFwibWluaW1hbFwiIDogXCJmdWxsXCIpO1xuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGYpID0+IGYuZm9ybWF0KGZvcm1hdCkpO1xuICAgICAgICByZXR1cm4gYWJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBKU09OLWVuY29kZWQgQUJJLiBUaGlzIGlzIHRoZSBmb3JtYXQgU29saWRpeVxuICAgICAqICByZXR1cm5zLlxuICAgICAqL1xuICAgIGZvcm1hdEpzb24oKSB7XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZikgPT4gZi5mb3JtYXQoXCJqc29uXCIpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgQUJJIGNvZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGVuY29kZSBhbmQgZGVjb2RlIGJpbmFyeVxuICAgICAqICBkYXRhLlxuICAgICAqL1xuICAgIGdldEFiaUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gYWJpX2NvZGVyX2pzXzEuQWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyKCk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEZ1bmN0aW9uKGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBTZWxlY3RvclxuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYWdtZW50IG9mIHRoaXMuI2Z1bmN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gZnJhZ21lbnQuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgZnJhZ21lbnRdIG9mIHRoaXMuI2Z1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSAodmFsdWVzLmxlbmd0aCA+IDApID8gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsb3dPcHRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWRfanNfMS5UeXBlZC5pc1R5cGVkKGxhc3RWYWx1ZSkgJiYgbGFzdFZhbHVlLnR5cGUgPT09IFwib3ZlcnJpZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dPcHRpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbWF0Y2hlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wYXRpYmxlIGxlbmd0aC4gVGhlIGFyZ3NcbiAgICAgICAgICAgICAgICAvLyBtYXkgY29udGFpbiBhbiBvdmVycmlkZXMsIHNvIHRoZSBtYXRjaCBtYXkgaGF2ZSBuIG9yIG4gLSAxIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbWF0Y2hpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzID0gbWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cyAhPT0gdmFsdWVMZW5ndGggJiYgKCFhbGxvd09wdGlvbnMgfHwgaW5wdXRzICE9PSB2YWx1ZUxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIFR5cGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBtYXRjaGluZ1tpXS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB0eXBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlZF9qc18xLlR5cGVkLmlzVHlwZWQodmFsdWVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHBhc3QgdGhlIGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPj0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2YWx1ZSB0eXBlIG1hdGNoZXMgdGhlIGlucHV0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbal0udHlwZSAhPT0gaW5wdXRzW2pdLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBzaW5nbGUgbWF0Y2hpbmcgc2lnbmF0dXJlIHdpdGggYW4gb3ZlcnJpZGVzLCBidXQgdGhlXG4gICAgICAgICAgICAvLyBsYXN0IHZhbHVlIGlzIHNvbWV0aGluZyB0aGF0IGNhbm5vdCBwb3NzaWJseSBiZSBhbiBvcHRpb25zXG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAxICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoICE9PSBtYXRjaGluZ1swXS5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEFyZyA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBcmcgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGxhc3RBcmcpIHx8IHR5cGVvZiAobGFzdEFyZykgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPiAxICYmIGZvcmNlVW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgYW1iaWd1b3VzIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIChpLmUuIG1hdGNoZXMgJHttYXRjaFN0cn0pYCwgXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdW5jdGlvbnMuZ2V0KGZyYWdtZW50c19qc18xLkZ1bmN0aW9uRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgZnVuY3Rpb24gbmFtZSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb24gc2VsZWN0b3IsXG4gICAgICogIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uTmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRGdW5jdGlvbihrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGEgZnVuY3Rpb24gc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3JcbiAgICAgKiAgZnVuY3Rpb24gc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYSBmdW5jdGlvbiBuYW1lLCB0aGUgbmFtZSBtYXkgYmUgYW1iaWd1b3VzLCBzb1xuICAgICAqICBhY2Nlc3NpbmcgdGhlIFtbRnVuY3Rpb25GcmFnbWVudF1dIG1heSByZXF1aXJlIHJlZmluZW1lbnQuXG4gICAgICovXG4gICAgaGFzRnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuI2dldEZ1bmN0aW9uKGtleSwgbnVsbCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBbW0Z1bmN0aW9uRnJhZ21lbnRdXSBmb3IgJSVrZXklJSwgd2hpY2ggbWF5IGJlIGEgZnVuY3Rpb25cbiAgICAgKiAgc2VsZWN0b3IsIGZ1bmN0aW9uIG5hbWUgb3IgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmdW5jdGlvbnMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGZ1bmN0aW9uIGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRGdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RnVuY3Rpb24oa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGZ1bmN0aW9ucywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hGdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZnVuY3Rpb25zLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNmdW5jdGlvbnMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgI2dldEV2ZW50KGtleSwgdmFsdWVzLCBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAvLyBFdmVudFRvcGljXG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0hleFN0cmluZykoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb3BpYyA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFnbWVudCBvZiB0aGlzLiNldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUb3BpYyA9PT0gZnJhZ21lbnQudG9waWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGZyYWdtZW50XSBvZiB0aGlzLiNldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBtYXRjaGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBhdGlibGUgbGVuZ3RoLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBtYXRjaGluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdbaV0uaW5wdXRzLmxlbmd0aCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoaW5nLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIG1hdGNoZXMgdGhhdCBkb24ndCBtYXRjaCB0aGUgVHlwZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG1hdGNoaW5nW2ldLmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHR5cGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVkX2pzXzEuVHlwZWQuaXNUeXBlZCh2YWx1ZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZhbHVlIHR5cGUgbWF0Y2hlcyB0aGUgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc1tqXS50eXBlICE9PSBpbnB1dHNbal0uYmFzZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSAmJiBmb3JjZVVuaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoU3RyID0gbWF0Y2hpbmcubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtLmZvcm1hdCgpKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGFtYmlndW91cyBldmVudCBkZXNjcmlwdGlvbiAoaS5lLiBtYXRjaGVzICR7bWF0Y2hTdHJ9KWAsIFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hpbmdbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXZlbnRzLmdldChmcmFnbWVudHNfanNfMS5FdmVudEZyYWdtZW50LmZyb20oa2V5KS5mb3JtYXQoKSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGV2ZW50IG5hbWUgZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqL1xuICAgIGdldEV2ZW50TmFtZShrZXkpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwia2V5XCIsIGtleSk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUla2V5JSUgKGFuIGV2ZW50IHRvcGljIGhhc2gsIGV2ZW50IG5hbWUgb3JcbiAgICAgKiAgZXZlbnQgc2lnbmF0dXJlKSBpcyBwcmVzZW50IGluIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSW4gdGhlIGNhc2Ugb2YgYW4gZXZlbnQgbmFtZSwgdGhlIG5hbWUgbWF5IGJlIGFtYmlndW91cywgc29cbiAgICAgKiAgYWNjZXNzaW5nIHRoZSBbW0V2ZW50RnJhZ21lbnRdXSBtYXkgcmVxdWlyZSByZWZpbmVtZW50LlxuICAgICAqL1xuICAgIGhhc0V2ZW50KGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNnZXRFdmVudChrZXksIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFdmVudEZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhIHRvcGljIGhhc2gsXG4gICAgICogIGV2ZW50IG5hbWUgb3IgZXZlbnQgc2lnbmF0dXJlIHRoYXQgYmVsb25ncyB0byB0aGUgQUJJLlxuICAgICAqXG4gICAgICogIElmICUldmFsdWVzJSUgaXMgcHJvdmlkZWQsIGl0IHdpbGwgdXNlIHRoZSBUeXBlZCBBUEkgdG8gaGFuZGxlXG4gICAgICogIGFtYmlndW91cyBjYXNlcyB3aGVyZSBtdWx0aXBsZSBldmVudHMgbWF0Y2ggYnkgbmFtZS5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVrZXklJSBhbmQgJSV2YWx1ZXMlJSBkbyBub3QgcmVmaW5lIHRvIGEgc2luZ2xlIGV2ZW50IGluXG4gICAgICogIHRoZSBBQkksIHRoaXMgd2lsbCB0aHJvdy5cbiAgICAgKi9cbiAgICBnZXRFdmVudChrZXksIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0RXZlbnQoa2V5LCB2YWx1ZXMgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJdGVyYXRlIG92ZXIgYWxsIGV2ZW50cywgY2FsbGluZyAlJWNhbGxiYWNrJSUsIHNvcnRlZCBieSB0aGVpciBuYW1lLlxuICAgICAqL1xuICAgIGZvckVhY2hFdmVudChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBuYW1lcyA9IEFycmF5LmZyb20odGhpcy4jZXZlbnRzLmtleXMoKSk7XG4gICAgICAgIG5hbWVzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCh0aGlzLiNldmVudHMuZ2V0KG5hbWUpKSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgW1tFcnJvckZyYWdtZW50XV0gZm9yICUla2V5JSUsIHdoaWNoIG1heSBiZSBhbiBlcnJvclxuICAgICAqICBzZWxlY3RvciwgZXJyb3IgbmFtZSBvciBlcnJvciBzaWduYXR1cmUgdGhhdCBiZWxvbmdzIHRvIHRoZSBBQkkuXG4gICAgICpcbiAgICAgKiAgSWYgJSV2YWx1ZXMlJSBpcyBwcm92aWRlZCwgaXQgd2lsbCB1c2UgdGhlIFR5cGVkIEFQSSB0byBoYW5kbGVcbiAgICAgKiAgYW1iaWd1b3VzIGNhc2VzIHdoZXJlIG11bHRpcGxlIGVycm9ycyBtYXRjaCBieSBuYW1lLlxuICAgICAqXG4gICAgICogIElmIHRoZSAlJWtleSUlIGFuZCAlJXZhbHVlcyUlIGRvIG5vdCByZWZpbmUgdG8gYSBzaW5nbGUgZXJyb3IgaW5cbiAgICAgKiAgdGhlIEFCSSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIGdldEVycm9yKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0hleFN0cmluZykoa2V5KSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChCdWlsdGluRXJyb3JzW3NlbGVjdG9yXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oQnVpbHRpbkVycm9yc1tzZWxlY3Rvcl0uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgdGhpcy4jZXJyb3JzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSBmcmFnbWVudC5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBmcmFnbWVudF0gb2YgdGhpcy4jZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgRXJyb3Ioc3RyaW5nKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHNfanNfMS5FcnJvckZyYWdtZW50LmZyb20oXCJlcnJvciBQYW5pYyh1aW50MjU2KVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hTdHIgPSBtYXRjaGluZy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0uZm9ybWF0KCkpKS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgYW1iaWd1b3VzIGVycm9yIGRlc2NyaXB0aW9uIChpLmUuICR7bWF0Y2hTdHJ9KWAsIFwibmFtZVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGtleSA9IGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShrZXkpLmZvcm1hdCgpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIkVycm9yKHN0cmluZylcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50c19qc18xLkVycm9yRnJhZ21lbnQuZnJvbShcImVycm9yIEVycm9yKHN0cmluZylcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gXCJQYW5pYyh1aW50MjU2KVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzX2pzXzEuRXJyb3JGcmFnbWVudC5mcm9tKFwiZXJyb3IgUGFuaWModWludDI1NilcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy4jZXJyb3JzLmdldChrZXkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSXRlcmF0ZSBvdmVyIGFsbCBlcnJvcnMsIGNhbGxpbmcgJSVjYWxsYmFjayUlLCBzb3J0ZWQgYnkgdGhlaXIgbmFtZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuI2Vycm9ycy5rZXlzKCkpO1xuICAgICAgICBuYW1lcy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBjYWxsYmFjaygodGhpcy4jZXJyb3JzLmdldChuYW1lKSksIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgNC1ieXRlIHNlbGVjdG9yIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYSBmdW5jdGlvblxuICAgIC8qXG5nZXRTZWxlY3RvcihmcmFnbWVudDogRXJyb3JGcmFnbWVudCB8IEZ1bmN0aW9uRnJhZ21lbnQpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXM6IEFycmF5PEZyYWdtZW50PiA9IFsgXTtcblxuICAgICAgICB0cnkgeyBtYXRjaGVzLnB1c2godGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCkpOyB9IGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHRyeSB7IG1hdGNoZXMucHVzaCh0aGlzLmdldEVycm9yKDxzdHJpbmc+ZnJhZ21lbnQpKTsgfSBjYXRjaCAoXykgeyB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBmcmFnbWVudFwiLCBcImtleVwiLCBmcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYW1iaWd1b3VzIGZyYWdtZW50IG1hdGNoZXMgZnVuY3Rpb24gYW5kIGVycm9yXCIsIFwia2V5XCIsIGZyYWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYWdtZW50ID0gbWF0Y2hlc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVNsaWNlKGlkKGZyYWdtZW50LmZvcm1hdCgpKSwgMCwgNCk7XG59XG4gICAgKi9cbiAgICAvLyBHZXQgdGhlIDMyLWJ5dGUgdG9waWMgaGFzaCB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGFuIGV2ZW50XG4gICAgLypcbiAgICBnZXRFdmVudFRvcGljKGZyYWdtZW50OiBFdmVudEZyYWdtZW50KTogc3RyaW5nIHtcbiAgICAgICAgLy9pZiAodHlwZW9mKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikgeyBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7IH1cbiAgICAgICAgcmV0dXJuIGlkKGZyYWdtZW50LmZvcm1hdCgpKTtcbiAgICB9XG4gICAgKi9cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIGEgYGB0eC5kYXRhYGAgb2JqZWN0IGZvciBkZXBsb3lpbmcgdGhlIENvbnRyYWN0IHdpdGhcbiAgICAgKiAgdGhlICUldmFsdWVzJSUgYXMgdGhlIGNvbnN0cnVjdG9yIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBlbmNvZGVEZXBsb3kodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVQYXJhbXModGhpcy5kZXBsb3kuaW5wdXRzLCB2YWx1ZXMgfHwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgcmVzdWx0ICUlZGF0YSUlIChlLmcuIGZyb20gYW4gYGBldGhfY2FsbGBgKSBmb3IgdGhlXG4gICAgICogIHNwZWNpZmllZCBlcnJvciAoc2VlIFtbZ2V0RXJyb3JdXSBmb3IgdmFsaWQgdmFsdWVzIGZvclxuICAgICAqICAlJWtleSUlKS5cbiAgICAgKlxuICAgICAqICBNb3N0IGRldmVsb3BlcnMgc2hvdWxkIHByZWZlciB0aGUgW1twYXJzZUNhbGxSZXN1bHRdXSBtZXRob2QgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVjdCBhIGBgQ0FMTF9FWENFUFRJT05gYCBhbmQgdGhyb3cgdGhlXG4gICAgICogIGNvcnJlc3BvbmRpbmcgZXJyb3IuXG4gICAgICovXG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGVycm9yXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSB0cmFuc2FjdGlvbiByZXZlcnQgZGF0YSBmb3IgYSBjYWxsIHJlc3VsdCB0aGF0XG4gICAgICogIHJldmVydGVkIGZyb20gdGhlIHRoZSBDb250cmFjdCB3aXRoIHRoZSBzZXBjaWZpZWQgJSVlcnJvciUlXG4gICAgICogIChzZWUgW1tnZXRFcnJvcl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yICUlZnJhZ21lbnQlJSkgd2l0aCB0aGUgJSV2YWx1ZXMlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGdlbmVyYWxseSBub3QgdXNlZCBieSBtb3N0IGRldmVsb3BlcnMsIHVubGVzcyB0cnlpbmcgdG8gbW9ja1xuICAgICAqICBhIHJlc3VsdCBmcm9tIGEgQ29udHJhY3QuXG4gICAgICovXG4gICAgZW5jb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZXJyb3JcIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW1xuICAgICAgICAgICAgZnJhZ21lbnQuc2VsZWN0b3IsXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlcyB0aGUgJSVkYXRhJSUgZnJvbSBhIHRyYW5zYWN0aW9uIGBgdHguZGF0YWBgIGZvclxuICAgICAqICB0aGUgZnVuY3Rpb24gc3BlY2lmaWVkIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXNcbiAgICAgKiAgZm9yICUlZnJhZ21lbnQlJSkuXG4gICAgICpcbiAgICAgKiAgTW9zdCBkZXZlbG9wZXJzIHNob3VsZCBwcmVmZXIgdGhlIFtbcGFyc2VUcmFuc2FjdGlvbl1dIG1ldGhvZFxuICAgICAqICBpbnN0ZWFkLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGRhdGEsIDAsIDQpID09PSBmcmFnbWVudC5zZWxlY3RvciwgYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgKDAsIGluZGV4X2pzXzMuZGF0YVNsaWNlKShkYXRhLCA0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSBgYHR4LmRhdGFgYCBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGNhbGxzIHRoZSBmdW5jdGlvblxuICAgICAqICBzcGVjaWZpZWQgKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlcyBmb3IgJSVmcmFnbWVudCUlKSB3aXRoXG4gICAgICogIHRoZSAlJXZhbHVlcyUlLlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBmdW5jdGlvblwiLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuY29uY2F0KShbXG4gICAgICAgICAgICBmcmFnbWVudC5zZWxlY3RvcixcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGVzIHRoZSByZXN1bHQgJSVkYXRhJSUgKGUuZy4gZnJvbSBhbiBgYGV0aF9jYWxsYGApIGZvciB0aGVcbiAgICAgKiAgc3BlY2lmaWVkIGZ1bmN0aW9uIChzZWUgW1tnZXRGdW5jdGlvbl1dIGZvciB2YWxpZCB2YWx1ZXMgZm9yXG4gICAgICogICUla2V5JSUpLlxuICAgICAqXG4gICAgICogIE1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcHJlZmVyIHRoZSBbW3BhcnNlQ2FsbFJlc3VsdF1dIG1ldGhvZCBpbnN0ZWFkLFxuICAgICAqICB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IGEgYGBDQUxMX0VYQ0VQVElPTmBgIGFuZCB0aHJvdyB0aGVcbiAgICAgKiAgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBkZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmLCBcInVua25vd24gZnVuY3Rpb25cIiwgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImludmFsaWQgbGVuZ3RoIGZvciByZXN1bHQgZGF0YVwiO1xuICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc18zLmdldEJ5dGVzQ29weSkoZGF0YSk7XG4gICAgICAgIGlmICgoYnl0ZXMubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNhYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQub3V0cHV0cywgYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiY291bGQgbm90IGRlY29kZSByZXN1bHQgZGF0YVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgcmV0dXJuZWQgZGF0YSB3aXRoIG5vIGVycm9yLCBidXQgdGhlIGRhdGEgaXMganVua1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZhbHNlLCBtZXNzYWdlLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShieXRlcyksXG4gICAgICAgICAgICBpbmZvOiB7IG1ldGhvZDogZnJhZ21lbnQubmFtZSwgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYWtlRXJyb3IoX2RhdGEsIHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhYmlfY29kZXJfanNfMS5BYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihcImNhbGxcIiwgdHgsIGRhdGEpO1xuICAgICAgICAvLyBOb3QgYSBidWlsdC1pbiBlcnJvcjsgdHJ5IGZpbmRpbmcgYSBjdXN0b20gZXJyb3JcbiAgICAgICAgY29uc3QgY3VzdG9tUHJlZml4ID0gXCJleGVjdXRpb24gcmV2ZXJ0ZWQgKHVua25vd24gY3VzdG9tIGVycm9yKVwiO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKGN1c3RvbVByZWZpeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YS5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICBjb25zdCBlZiA9IHRoaXMuZ2V0RXJyb3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGVmKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShlZi5pbnB1dHMsIGRhdGEuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5yZXZlcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlZi5uYW1lLCBzaWduYXR1cmU6IGVmLmZvcm1hdCgpLCBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9IGVycm9yLnJldmVydC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgZXhlY3V0aW9uIHJldmVydGVkOiAke2Vycm9yLnJlYXNvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gYGV4ZWN1dGlvbiByZXZlcnRlZCAoY291bHQgbm90IGRlY29kZSBjdXN0b20gZXJyb3IpYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBpbnZvY2F0aW9uLCBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgZXJyb3IuaW52b2NhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHBhcnNlZC5uYW1lLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogcGFyc2VkLnNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJnc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBFbmNvZGVzIHRoZSByZXN1bHQgZGF0YSAoZS5nLiBmcm9tIGFuIGBgZXRoX2NhbGxgYCkgZm9yIHRoZVxuICAgICAqICBzcGVjaWZpZWQgZnVuY3Rpb24gKHNlZSBbW2dldEZ1bmN0aW9uXV0gZm9yIHZhbGlkIHZhbHVlc1xuICAgICAqICBmb3IgJSVmcmFnbWVudCUlKSB3aXRoICUldmFsdWVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWQgYnkgbW9zdCBkZXZlbG9wZXJzLCB1bmxlc3MgdHJ5aW5nIHRvIG1vY2tcbiAgICAgKiAgYSByZXN1bHQgZnJvbSBhIENvbnRyYWN0LlxuICAgICAqL1xuICAgIGVuY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRGdW5jdGlvbihmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGZ1bmN0aW9uXCIsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoZnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8qXG4gICAgICAgIHNwZWx1bmsoaW5wdXRzOiBBcnJheTxQYXJhbVR5cGU+LCB2YWx1ZXM6IFJlYWRvbmx5QXJyYXk8YW55PiwgcHJvY2Vzc2Z1bmM6ICh0eXBlOiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IFByb21pc2U8YW55Pik6IFByb21pc2U8QXJyYXk8YW55Pj4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8Pj4gPSBbIF07XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gZnVuY3Rpb24odHlwZTogUGFyYW1UeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjZW5kKHR5cGUuY2hpbGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCBkZXNjZW5kID0gZnVuY3Rpb24gKGlucHV0czogQXJyYXk8UGFyYW1UeXBlPiwgdmFsdWVzOiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbWlzbWF0Y2hcIik7IH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH07XG4gICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PGFueT4gPSBbIF07XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goZW5jb2RlVG9waWMocGFyYW0sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAqL1xuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSh2YWx1ZXMubGVuZ3RoIDw9IGZyYWdtZW50LmlucHV0cy5sZW5ndGgsIGB0b28gbWFueSBhcmd1bWVudHMgZm9yICR7ZnJhZ21lbnQuZm9ybWF0KCl9YCwgXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCIsIHsgY291bnQ6IHZhbHVlcy5sZW5ndGgsIGV4cGVjdGVkQ291bnQ6IGZyYWdtZW50LmlucHV0cy5sZW5ndGggfSk7XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogVXNlIHRoZSBjb2RlcnMgZm9yIHRoaXM7IHRvIHByb3Blcmx5IHN1cHBvcnQgdHVwbGVzLCBldGMuXG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaWQpKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJib29sXCIgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoMCwgaW5kZXhfanNfMy50b0JlSGV4KSh2YWx1ZSk7IC8vIEBUT0RPOiBTaG91bGQgdGhpcyB0b1R3b3M/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZS5tYXRjaCgvXmJ5dGVzLykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLnplcm9QYWRCeXRlcykodmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMuI2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKCgwLCBpbmRleF9qc18zLmhleGxpZnkpKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkodmFsdWUgPT0gbnVsbCwgXCJjYW5ub3QgZmlsdGVyIG5vbi1pbmRleGVkIHBhcmFtZXRlcnM7IG11c3QgYmUgbnVsbFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0RXZlbnQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGYsIFwidW5rbm93biBldmVudFwiLCBcImV2ZW50RnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2goZnJhZ21lbnQudG9waWNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkodmFsdWVzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goKDAsIGluZGV4X2pzXzIuaWQpKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCgoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ET1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLiNhYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcy4jYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG4gICAgICAgICAgICB0b3BpY3M6IHRvcGljc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuICAgIGRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5nZXRFdmVudChmcmFnbWVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZiwgXCJ1bmtub3duIGV2ZW50XCIsIFwiZXZlbnRGcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VG9waWMgPSBmcmFnbWVudC50b3BpY0hhc2g7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHRvcGljc1swXSwgMzIpICYmIHRvcGljc1swXS50b0xvd2VyQ2FzZSgpID09PSBldmVudFRvcGljLCBcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIFwidG9waWNzWzBdXCIsIHRvcGljc1swXSk7XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhlZCA9IFtdO1xuICAgICAgICBjb25zdCBub25JbmRleGVkID0gW107XG4gICAgICAgIGNvbnN0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuaW5wdXRzLmZvckVhY2goKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChmcmFnbWVudHNfanNfMS5QYXJhbVR5cGUuZnJvbSh7IHR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBwYXJhbS5uYW1lIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub25JbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuI2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCAoMCwgaW5kZXhfanNfMy5jb25jYXQpKHRvcGljcykpIDogbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgLy9jb25zdCByZXN1bHQ6IChBcnJheTxhbnk+ICYgeyBbIGtleTogc3RyaW5nIF06IGFueSB9KSA9IFsgXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG4gICAgICAgIGZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgSW5kZXhlZChyZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyYW0ubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdF9jb2Rlcl9qc18xLlJlc3VsdC5mcm9tSXRlbXModmFsdWVzLCBrZXlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhcnNlcyBhIHRyYW5zYWN0aW9uLCBmaW5kaW5nIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBhbmQgZXh0cmFjdHNcbiAgICAgKiAgdGhlIHBhcmFtZXRlciB2YWx1ZXMgYWxvbmcgd2l0aCBvdGhlciB1c2VmdWwgZnVuY3Rpb24gZGV0YWlscy5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykodHguZGF0YSwgXCJ0eC5kYXRhXCIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkoKHR4LnZhbHVlICE9IG51bGwpID8gdHgudmFsdWUgOiAwLCBcInR4LnZhbHVlXCIpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy4jYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgZGF0YS5zbGljZSg0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbihmcmFnbWVudCwgZnJhZ21lbnQuc2VsZWN0b3IsIGFyZ3MsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsUmVzdWx0KGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE9cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZWNlaXB0IGxvZywgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXZlbnQgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGV2ZW50IGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQgfHwgZnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogSWYgYW5vbnltb3VzLCBhbmQgdGhlIG9ubHkgbWV0aG9kLCBhbmQgdGhlIGlucHV0IGNvdW50IG1hdGNoZXMsIHNob3VsZCB3ZSBwYXJzZT9cbiAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG4gICAgICAgIC8vICAgICAgICBub3QgbWVhbiB3ZSBoYXZlIHRoZSBmdWxsIEFCSTsgbWF5YmUganVzdCBhIGZyYWdtZW50P1xuICAgICAgICByZXR1cm4gbmV3IExvZ0Rlc2NyaXB0aW9uKGZyYWdtZW50LCBmcmFnbWVudC50b3BpY0hhc2gsIHRoaXMuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQYXJzZXMgYSByZXZlcnQgZGF0YSwgZmluZGluZyB0aGUgbWF0Y2hpbmcgZXJyb3IgYW5kIGV4dHJhY3RzXG4gICAgICogIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFsb25nIHdpdGggb3RoZXIgdXNlZnVsIGVycm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIG1hdGNoaW5nIGVycm9yIGNhbm5vdCBiZSBmb3VuZCwgcmV0dXJucyBudWxsLlxuICAgICAqL1xuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZGF0YSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcigoMCwgaW5kZXhfanNfMy5kYXRhU2xpY2UpKGhleERhdGEsIDAsIDQpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuI2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsICgwLCBpbmRleF9qc18zLmRhdGFTbGljZSkoaGV4RGF0YSwgNCkpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oZnJhZ21lbnQsIGZyYWdtZW50LnNlbGVjdG9yLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tJbnRlcmZhY2VdXSBmcm9tIHRoZSBBQkkgJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoZSAlJXZhbHVlJSUgbWF5IGJlIHByb3ZpZGVkIGFzIGFuIGV4aXN0aW5nIFtbSW50ZXJmYWNlXV0gb2JqZWN0LFxuICAgICAqICBhIEpTT04tZW5jb2RlZCBBQkkgb3IgYW55IEh1bWFuLVJlYWRhYmxlIEFCSSBmb3JtYXQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBhbiBJbnRlcmZhY2UsIHdoaWNoIGlzIGltbXV0YWJsZVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcmZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBKU09OXG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIGFuIGludGVyZmFjZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIG9yIGZyb20gYSBzeW1saW5rZWQgY29weVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZS5mb3JtYXQpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlLmZvcm1hdChcImpzb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IG9mIGZyYWdtZW50c1xuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmZhY2UgPSBJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW50ZXJmYWNlIiwiSW5kZXhlZCIsIkVycm9yRGVzY3JpcHRpb24iLCJUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwiTG9nRGVzY3JpcHRpb24iLCJSZXN1bHQiLCJjaGVja1Jlc3VsdEVycm9ycyIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJhYmlfY29kZXJfanNfMSIsImFic3RyYWN0X2NvZGVyX2pzXzEiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZnJhZ21lbnRzX2pzXzEiLCJ0eXBlZF9qc18xIiwiY29uc3RydWN0b3IiLCJmcmFnbWVudCIsInRvcGljIiwiYXJncyIsIm5hbWUiLCJzaWduYXR1cmUiLCJmb3JtYXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwic2VsZWN0b3IiLCJpc0luZGV4ZWQiLCJfaXNJbmRleGVkIiwiaGFzaCIsIlBhbmljUmVhc29ucyIsIkJ1aWx0aW5FcnJvcnMiLCJpbnB1dHMiLCJyZWFzb24iLCJtZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvZGUiLCJ0b1N0cmluZyIsImVycm9ycyIsImV2ZW50cyIsImZ1bmN0aW9ucyIsImFiaUNvZGVyIiwiZnJhZ21lbnRzIiwiYWJpIiwicGFyc2UiLCJNYXAiLCJmcmFncyIsImEiLCJwdXNoIiwiRnJhZ21lbnQiLCJmcm9tIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiZnJlZXplIiwiZmFsbGJhY2siLCJyZWNlaXZlIiwiZ2V0QWJpQ29kZXIiLCJmb3JFYWNoIiwiaW5kZXgiLCJidWNrZXQiLCJ0eXBlIiwiZGVwbG95IiwibGVuZ3RoIiwiYXNzZXJ0QXJndW1lbnQiLCJwYXlhYmxlIiwiaGFzIiwic2V0IiwiQ29uc3RydWN0b3JGcmFnbWVudCIsIm1pbmltYWwiLCJtYXAiLCJmIiwiZm9ybWF0SnNvbiIsImoiLCJBYmlDb2RlciIsImRlZmF1bHRBYmlDb2RlciIsImdldEZ1bmN0aW9uIiwia2V5IiwidmFsdWVzIiwiZm9yY2VVbmlxdWUiLCJpc0hleFN0cmluZyIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsIm1hdGNoaW5nIiwic3BsaXQiLCJsYXN0VmFsdWUiLCJ2YWx1ZUxlbmd0aCIsImFsbG93T3B0aW9ucyIsIlR5cGVkIiwiaXNUeXBlZCIsImkiLCJzcGxpY2UiLCJiYXNlVHlwZSIsImxhc3RBcmciLCJBcnJheSIsImlzQXJyYXkiLCJtYXRjaFN0ciIsIm0iLCJqb2luIiwicmVzdWx0IiwiRnVuY3Rpb25GcmFnbWVudCIsImdldEZ1bmN0aW9uTmFtZSIsImhhc0Z1bmN0aW9uIiwiZm9yRWFjaEZ1bmN0aW9uIiwiY2FsbGJhY2siLCJuYW1lcyIsImtleXMiLCJzb3J0IiwiYiIsImxvY2FsZUNvbXBhcmUiLCJnZXRFdmVudCIsImV2ZW50VG9waWMiLCJ0b3BpY0hhc2giLCJFdmVudEZyYWdtZW50IiwiZ2V0RXZlbnROYW1lIiwiaGFzRXZlbnQiLCJmb3JFYWNoRXZlbnQiLCJnZXRFcnJvciIsIkVycm9yRnJhZ21lbnQiLCJmb3JFYWNoRXJyb3IiLCJfZGVjb2RlUGFyYW1zIiwicGFyYW1zIiwiZGF0YSIsImRlY29kZSIsIl9lbmNvZGVQYXJhbXMiLCJlbmNvZGUiLCJlbmNvZGVEZXBsb3kiLCJkZWNvZGVFcnJvclJlc3VsdCIsImRhdGFTbGljZSIsImVuY29kZUVycm9yUmVzdWx0IiwiY29uY2F0IiwiZGVjb2RlRnVuY3Rpb25EYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJieXRlcyIsImdldEJ5dGVzQ29weSIsIm91dHB1dHMiLCJhc3NlcnQiLCJoZXhsaWZ5IiwiaW5mbyIsIm1ldGhvZCIsIm1ha2VFcnJvciIsIl9kYXRhIiwidHgiLCJnZXRCeXRlcyIsImdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uIiwiY3VzdG9tUHJlZml4Iiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZWYiLCJyZXZlcnQiLCJlIiwicGFyc2VkIiwicGFyc2VUcmFuc2FjdGlvbiIsImludm9jYXRpb24iLCJlbmNvZGVGdW5jdGlvblJlc3VsdCIsImVuY29kZUZpbHRlclRvcGljcyIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsInRvcGljcyIsImFub255bW91cyIsImVuY29kZVRvcGljIiwicGFyYW0iLCJpZCIsImtlY2NhazI1NiIsIm1hdGNoIiwidG9CZUhleCIsInplcm9QYWRCeXRlcyIsInplcm9QYWRWYWx1ZSIsImluZGV4ZWQiLCJwb3AiLCJlbmNvZGVFdmVudExvZyIsImRhdGFUeXBlcyIsImRhdGFWYWx1ZXMiLCJFcnJvciIsImRlY29kZUV2ZW50TG9nIiwibm9uSW5kZXhlZCIsImR5bmFtaWMiLCJQYXJhbVR5cGUiLCJyZXN1bHRJbmRleGVkIiwicmVzdWx0Tm9uSW5kZXhlZCIsIm5vbkluZGV4ZWRJbmRleCIsImluZGV4ZWRJbmRleCIsImZyb21JdGVtcyIsImdldEJpZ0ludCIsInBhcnNlQ2FsbFJlc3VsdCIsInBhcnNlTG9nIiwicGFyc2VFcnJvciIsImhleERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/abi/typed.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Typed = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\n        signed,\n        width\n    });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\n        size\n    });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */ class Typed {\n    #options;\n    /**\n     *  @_ignore:\n     */ constructor(gaurd, type, value, options){\n        if (options == null) {\n            options = null;\n        }\n        (0, index_js_1.assertPrivate)(_gaurd, gaurd, \"Typed\");\n        (0, index_js_1.defineProperties)(this, {\n            _typedSymbol,\n            type,\n            value\n        });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */ format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        } else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        } else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v)=>v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */ defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */ minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */ maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */ isBigInt() {\n        return !!this.type.match(/^u?int[0-9]+$/);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */ isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */ isString() {\n        return this.type === \"string\";\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */ get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */ get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return this.value.length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */ static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static uint8(v) {\n        return n(v, 8);\n    }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */ static uint16(v) {\n        return n(v, 16);\n    }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */ static uint24(v) {\n        return n(v, 24);\n    }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */ static uint32(v) {\n        return n(v, 32);\n    }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */ static uint40(v) {\n        return n(v, 40);\n    }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */ static uint48(v) {\n        return n(v, 48);\n    }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */ static uint56(v) {\n        return n(v, 56);\n    }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */ static uint64(v) {\n        return n(v, 64);\n    }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */ static uint72(v) {\n        return n(v, 72);\n    }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */ static uint80(v) {\n        return n(v, 80);\n    }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */ static uint88(v) {\n        return n(v, 88);\n    }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */ static uint96(v) {\n        return n(v, 96);\n    }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */ static uint104(v) {\n        return n(v, 104);\n    }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */ static uint112(v) {\n        return n(v, 112);\n    }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */ static uint120(v) {\n        return n(v, 120);\n    }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */ static uint128(v) {\n        return n(v, 128);\n    }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */ static uint136(v) {\n        return n(v, 136);\n    }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */ static uint144(v) {\n        return n(v, 144);\n    }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */ static uint152(v) {\n        return n(v, 152);\n    }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */ static uint160(v) {\n        return n(v, 160);\n    }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */ static uint168(v) {\n        return n(v, 168);\n    }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */ static uint176(v) {\n        return n(v, 176);\n    }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */ static uint184(v) {\n        return n(v, 184);\n    }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */ static uint192(v) {\n        return n(v, 192);\n    }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */ static uint200(v) {\n        return n(v, 200);\n    }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */ static uint208(v) {\n        return n(v, 208);\n    }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */ static uint216(v) {\n        return n(v, 216);\n    }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */ static uint224(v) {\n        return n(v, 224);\n    }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */ static uint232(v) {\n        return n(v, 232);\n    }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */ static uint240(v) {\n        return n(v, 240);\n    }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */ static uint248(v) {\n        return n(v, 248);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint256(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */ static uint(v) {\n        return n(v, 256);\n    }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */ static int8(v) {\n        return n(v, -8);\n    }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */ static int16(v) {\n        return n(v, -16);\n    }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */ static int24(v) {\n        return n(v, -24);\n    }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */ static int32(v) {\n        return n(v, -32);\n    }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */ static int40(v) {\n        return n(v, -40);\n    }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */ static int48(v) {\n        return n(v, -48);\n    }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */ static int56(v) {\n        return n(v, -56);\n    }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */ static int64(v) {\n        return n(v, -64);\n    }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */ static int72(v) {\n        return n(v, -72);\n    }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */ static int80(v) {\n        return n(v, -80);\n    }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */ static int88(v) {\n        return n(v, -88);\n    }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */ static int96(v) {\n        return n(v, -96);\n    }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */ static int104(v) {\n        return n(v, -104);\n    }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */ static int112(v) {\n        return n(v, -112);\n    }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */ static int120(v) {\n        return n(v, -120);\n    }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */ static int128(v) {\n        return n(v, -128);\n    }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */ static int136(v) {\n        return n(v, -136);\n    }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */ static int144(v) {\n        return n(v, -144);\n    }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */ static int152(v) {\n        return n(v, -152);\n    }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */ static int160(v) {\n        return n(v, -160);\n    }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */ static int168(v) {\n        return n(v, -168);\n    }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */ static int176(v) {\n        return n(v, -176);\n    }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */ static int184(v) {\n        return n(v, -184);\n    }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */ static int192(v) {\n        return n(v, -192);\n    }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */ static int200(v) {\n        return n(v, -200);\n    }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */ static int208(v) {\n        return n(v, -208);\n    }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */ static int216(v) {\n        return n(v, -216);\n    }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */ static int224(v) {\n        return n(v, -224);\n    }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */ static int232(v) {\n        return n(v, -232);\n    }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */ static int240(v) {\n        return n(v, -240);\n    }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */ static int248(v) {\n        return n(v, -248);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int256(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */ static int(v) {\n        return n(v, -256);\n    }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */ static bytes1(v) {\n        return b(v, 1);\n    }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */ static bytes2(v) {\n        return b(v, 2);\n    }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */ static bytes3(v) {\n        return b(v, 3);\n    }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */ static bytes4(v) {\n        return b(v, 4);\n    }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */ static bytes5(v) {\n        return b(v, 5);\n    }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */ static bytes6(v) {\n        return b(v, 6);\n    }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */ static bytes7(v) {\n        return b(v, 7);\n    }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */ static bytes8(v) {\n        return b(v, 8);\n    }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */ static bytes9(v) {\n        return b(v, 9);\n    }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */ static bytes10(v) {\n        return b(v, 10);\n    }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */ static bytes11(v) {\n        return b(v, 11);\n    }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */ static bytes12(v) {\n        return b(v, 12);\n    }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */ static bytes13(v) {\n        return b(v, 13);\n    }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */ static bytes14(v) {\n        return b(v, 14);\n    }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */ static bytes15(v) {\n        return b(v, 15);\n    }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */ static bytes16(v) {\n        return b(v, 16);\n    }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */ static bytes17(v) {\n        return b(v, 17);\n    }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */ static bytes18(v) {\n        return b(v, 18);\n    }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */ static bytes19(v) {\n        return b(v, 19);\n    }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */ static bytes20(v) {\n        return b(v, 20);\n    }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */ static bytes21(v) {\n        return b(v, 21);\n    }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */ static bytes22(v) {\n        return b(v, 22);\n    }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */ static bytes23(v) {\n        return b(v, 23);\n    }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */ static bytes24(v) {\n        return b(v, 24);\n    }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */ static bytes25(v) {\n        return b(v, 25);\n    }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */ static bytes26(v) {\n        return b(v, 26);\n    }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */ static bytes27(v) {\n        return b(v, 27);\n    }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */ static bytes28(v) {\n        return b(v, 28);\n    }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */ static bytes29(v) {\n        return b(v, 29);\n    }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */ static bytes30(v) {\n        return b(v, 30);\n    }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */ static bytes31(v) {\n        return b(v, 31);\n    }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */ static bytes32(v) {\n        return b(v, 32);\n    }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */ static address(v) {\n        return new Typed(_gaurd, \"address\", v);\n    }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */ static bool(v) {\n        return new Typed(_gaurd, \"bool\", !!v);\n    }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */ static bytes(v) {\n        return new Typed(_gaurd, \"bytes\", v);\n    }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */ static string(v) {\n        return new Typed(_gaurd, \"string\", v);\n    }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */ static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */ static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */ static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */ static isTyped(value) {\n        return value && typeof value === \"object\" && \"_typedSymbol\" in value && value._typedSymbol === _typedSymbol;\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */ static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\nexports.Typed = Typed; //# sourceMappingURL=typed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvdHlwZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUcsS0FBSztBQUNyQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMsU0FBUyxDQUFDO0FBQ2hCLFNBQVNDLEVBQUVMLEtBQUssRUFBRU0sS0FBSztJQUNuQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsUUFBUSxHQUFHO1FBQ1hDLFNBQVM7UUFDVEQsU0FBUyxDQUFDO0lBQ2Q7SUFDQSx3Q0FBd0M7SUFDeEMsT0FBTyxJQUFJTCxNQUFNRyxRQUFRLENBQUMsRUFBRUcsU0FBUyxLQUFLLElBQUksR0FBRyxFQUFFRCxNQUFNLENBQUMsRUFBRU4sT0FBTztRQUFFTztRQUFRRDtJQUFNO0FBQ3ZGO0FBQ0EsU0FBU0UsRUFBRVIsS0FBSyxFQUFFUyxJQUFJO0lBQ2xCLHdDQUF3QztJQUN4QyxPQUFPLElBQUlSLE1BQU1HLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBU0ssT0FBTyxHQUFHLENBQUMsRUFBRVQsT0FBTztRQUFFUztJQUFLO0FBQ3pFO0FBQ0EsTUFBTUMsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQ2hDOztDQUVDLEdBQ0QsTUFBTVg7SUFTRixDQUFDWSxPQUFPLENBQUM7SUFLVDs7S0FFQyxHQUNEQyxZQUFZQyxLQUFLLEVBQUVDLElBQUksRUFBRWhCLEtBQUssRUFBRWEsT0FBTyxDQUFFO1FBQ3JDLElBQUlBLFdBQVcsTUFBTTtZQUNqQkEsVUFBVTtRQUNkO1FBQ0MsSUFBR1gsV0FBV2UsYUFBYSxFQUFFYixRQUFRVyxPQUFPO1FBQzVDLElBQUdiLFdBQVdnQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRVI7WUFBY007WUFBTWhCO1FBQU07UUFDbkUsSUFBSSxDQUFD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O0lBQ2xDO0lBQ0E7Ozs7OztLQU1DLEdBQ0QsT0FBT3dJLFlBQVlsSixLQUFLLEVBQUVnQixJQUFJLEVBQUU7UUFDNUIsSUFBSWYsTUFBTWdKLE9BQU8sQ0FBQ2pKLFFBQVE7WUFDdEIsSUFBSUEsTUFBTWdCLElBQUksS0FBS0EsTUFBTTtnQkFDckIsTUFBTSxJQUFJSSxNQUFNLENBQUMsdUJBQXVCLEVBQUVKLEtBQUssTUFBTSxFQUFFaEIsTUFBTWdCLElBQUksQ0FBQyxDQUFDO1lBQ3ZFO1lBQ0EsT0FBT2hCLE1BQU1BLEtBQUs7UUFDdEI7UUFDQSxPQUFPQTtJQUNYO0FBQ0o7QUFDQUQsYUFBYSxHQUFHRSxPQUNoQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hYmkvdHlwZWQuanM/ZDY1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgVHlwZWQgb2JqZWN0IGFsbG93cyBhIHZhbHVlIHRvIGhhdmUgaXRzIHR5cGUgZXhwbGljaXRseVxuICogIHNwZWNpZmllZC5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGluIFNvbGlkaXR5LCB0aGUgdmFsdWUgYGA0NWBgIGNvdWxkIHJlcHJlc2VudCBhXG4gKiAgYGB1aW50OGBgIG9yIGEgYGB1aW50MjU2YGAuIFRoZSB2YWx1ZSBgYDB4MTIzNGBgIGNvdWxkIHJlcHJlc2VudFxuICogIGEgYGBieXRlczJgYCBvciBgYGJ5dGVzYGAuXG4gKlxuICogIFNpbmNlIEphdmFTY3JpcHQgaGFzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGV4cGxpY2l0bHkgaW5mb3JtIGFueVxuICogIEFQSXMgd2hpY2ggd2hhdCB0aGUgdHlwZSBpcywgdGhpcyBhbGxvd3MgdHJhbnNwYXJlbnQgaW50ZXJvcGVyYXRpb25cbiAqICB3aXRoIFNvbGRpdHkuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2FiaTpUeXBlZCBWYWx1ZXNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBfZ2F1cmQgPSB7fTtcbmZ1bmN0aW9uIG4odmFsdWUsIHdpZHRoKSB7XG4gICAgbGV0IHNpZ25lZCA9IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgd2lkdGggKj0gLTE7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBDaGVjayByYW5nZSBpcyB2YWxpZCBmb3IgdmFsdWVcbiAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgYCR7c2lnbmVkID8gXCJcIiA6IFwidVwifWludCR7d2lkdGh9YCwgdmFsdWUsIHsgc2lnbmVkLCB3aWR0aCB9KTtcbn1cbmZ1bmN0aW9uIGIodmFsdWUsIHNpemUpIHtcbiAgICAvLyBAVE9ETzogQ2hlY2sgcmFuZ2UgaXMgdmFsaWQgZm9yIHZhbHVlXG4gICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIGBieXRlcyR7KHNpemUpID8gc2l6ZSA6IFwiXCJ9YCwgdmFsdWUsIHsgc2l6ZSB9KTtcbn1cbmNvbnN0IF90eXBlZFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJfZXRoZXJzX3R5cGVkXCIpO1xuLyoqXG4gKiAgVGhlICoqVHlwZWQqKiBjbGFzcyB0byB3cmFwIHZhbHVlcyBwcm92aWRpbmcgZXhwbGljaXQgdHlwZSBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgVHlwZWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZSwgYXMgYSBTb2xpZGl0eS1jb21wYXRpYmxlIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YWx1ZTtcbiAgICAjb3B0aW9ucztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgX3R5cGVkU3ltYm9sO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihnYXVyZCwgdHlwZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0UHJpdmF0ZSkoX2dhdXJkLCBnYXVyZCwgXCJUeXBlZFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBfdHlwZWRTeW1ib2wsIHR5cGUsIHZhbHVlIH0pO1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbHVlIGlzIHZhbGlkXG4gICAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBGb3JtYXQgdGhlIHR5cGUgYXMgYSBIdW1hbi1SZWFkYWJsZSB0eXBlLlxuICAgICAqL1xuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcImR5bmFtaWNBcnJheVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgdHVwbGUoJHt0aGlzLnZhbHVlLm1hcCgodikgPT4gdi5mb3JtYXQoKSkuam9pbihcIixcIil9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGJ5IHRoaXMgdHlwZS5cbiAgICAgKi9cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1pbmltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWluVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIG1heGltdW0gdmFsdWUgZm9yIG51bWVyaWMgdHlwZXMuXG4gICAgICovXG4gICAgbWF4VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRydWVgYCBhbmQgcHJvdmlkZXMgYSB0eXBlIGd1YXJkIGlzIHRoaXMgaXMgYSBbW1R5cGVkQmlnSW50XV0uXG4gICAgICovXG4gICAgaXNCaWdJbnQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLnR5cGUubWF0Y2goL151P2ludFswLTldKyQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGBgdHJ1ZWBgIGFuZCBwcm92aWRlcyBhIHR5cGUgZ3VhcmQgaXMgdGhpcyBpcyBhIFtbVHlwZWREYXRhXV0uXG4gICAgICovXG4gICAgaXNEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgYW5kIHByb3ZpZGVzIGEgdHlwZSBndWFyZCBpcyB0aGlzIGlzIGEgW1tUeXBlZFN0cmluZ11dLlxuICAgICAqL1xuICAgIGlzU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0dXBsZSBuYW1lLCBpZiB0aGlzIGlzIGEgdHVwbGUuIFRocm93cyBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IHR1cGxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJub3QgYSB0dXBsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9ucztcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgdHlwZSBhcyBhbiBhcnJheVxuICAgIC8vIC0gYG51bGxgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIHVuZm9yY2VkLCBpdCBjb3VsZCBiZSBkeW5hbWljXG4gICAgLy8gLSBgLTFgIGluZGljYXRlcyB0aGUgbGVuZ3RoIGlzIGR5bmFtaWNcbiAgICAvLyAtIGFueSBvdGhlciB2YWx1ZSBpbmRpY2F0ZXMgaXQgaXMgYSBzdGF0aWMgYXJyYXkgYW5kIGlzIGl0cyBsZW5ndGhcbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB0eXBlIG9yIGBgLTFgYCBpZiBpdCBpcyBkeW5hbWljLlxuICAgICAqXG4gICAgICogIFRocm93cyBpZiB0aGUgdHlwZSBpcyBub3QgYW4gYXJyYXkuXG4gICAgICovXG4gICAgZ2V0IGFycmF5TGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jb3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3ICoqVHlwZWQqKiBvZiAlJXR5cGUlJSB3aXRoIHRoZSAlJXZhbHVlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4KHYpIHsgcmV0dXJuIG4odiwgOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNih2KSB7IHJldHVybiBuKHYsIDE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0KHYpIHsgcmV0dXJuIG4odiwgMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MzIodikgeyByZXR1cm4gbih2LCAzMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ0MCh2KSB7IHJldHVybiBuKHYsIDQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDQ4KHYpIHsgcmV0dXJuIG4odiwgNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50NTYodikgeyByZXR1cm4gbih2LCA1Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDY0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ2NCh2KSB7IHJldHVybiBuKHYsIDY0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDcyKHYpIHsgcmV0dXJuIG4odiwgNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50ODAodikgeyByZXR1cm4gbih2LCA4MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDg4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQ4OCh2KSB7IHJldHVybiBuKHYsIDg4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDk2KHYpIHsgcmV0dXJuIG4odiwgOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMDRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEwNCh2KSB7IHJldHVybiBuKHYsIDEwNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDExMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTEyKHYpIHsgcmV0dXJuIG4odiwgMTEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxMjAodikgeyByZXR1cm4gbih2LCAxMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxMjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDEyOCh2KSB7IHJldHVybiBuKHYsIDEyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDEzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTM2KHYpIHsgcmV0dXJuIG4odiwgMTM2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNDQodikgeyByZXR1cm4gbih2LCAxNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE1Mih2KSB7IHJldHVybiBuKHYsIDE1Mik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTYwKHYpIHsgcmV0dXJuIG4odiwgMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTY4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxNjgodikgeyByZXR1cm4gbih2LCAxNjgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQxNzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDE3Nih2KSB7IHJldHVybiBuKHYsIDE3Nik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MTg0KHYpIHsgcmV0dXJuIG4odiwgMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MTkyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQxOTIodikgeyByZXR1cm4gbih2LCAxOTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIwMCh2KSB7IHJldHVybiBuKHYsIDIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIwOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjA4KHYpIHsgcmV0dXJuIG4odiwgMjA4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyMTYodikgeyByZXR1cm4gbih2LCAyMTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDIyNCh2KSB7IHJldHVybiBuKHYsIDIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDIzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjMyKHYpIHsgcmV0dXJuIG4odiwgMjMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjQwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQyNDAodikgeyByZXR1cm4gbih2LCAyNDApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdWludDI0OCh2KSB7IHJldHVybiBuKHYsIDI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgdWludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyB1aW50MjU2KHYpIHsgcmV0dXJuIG4odiwgMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB1aW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHVpbnQodikgeyByZXR1cm4gbih2LCAyNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OCh2KSB7IHJldHVybiBuKHYsIC04KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNih2KSB7IHJldHVybiBuKHYsIC0xNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQodikgeyByZXR1cm4gbih2LCAtMjQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDMyKHYpIHsgcmV0dXJuIG4odiwgLTMyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ0MCh2KSB7IHJldHVybiBuKHYsIC00MCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NDgodikgeyByZXR1cm4gbih2LCAtNDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDU2KHYpIHsgcmV0dXJuIG4odiwgLTU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ2NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ2NCh2KSB7IHJldHVybiBuKHYsIC02NCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50NzJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50NzIodikgeyByZXR1cm4gbih2LCAtNzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDgwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDgwKHYpIHsgcmV0dXJuIG4odiwgLTgwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ4OGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQ4OCh2KSB7IHJldHVybiBuKHYsIC04OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50OTZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50OTYodikgeyByZXR1cm4gbih2LCAtOTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEwNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMDQodikgeyByZXR1cm4gbih2LCAtMTA0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTEyKHYpIHsgcmV0dXJuIG4odiwgLTExMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTIwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDEyMCh2KSB7IHJldHVybiBuKHYsIC0xMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDEyOGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxMjgodikgeyByZXR1cm4gbih2LCAtMTI4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxMzZgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTM2KHYpIHsgcmV0dXJuIG4odiwgLTEzNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTQ0YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE0NCh2KSB7IHJldHVybiBuKHYsIC0xNDQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDUyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE1Mih2KSB7IHJldHVybiBuKHYsIC0xNTIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE2MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxNjAodikgeyByZXR1cm4gbih2LCAtMTYwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQxNjhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MTY4KHYpIHsgcmV0dXJuIG4odiwgLTE2OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MTc2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDE3Nih2KSB7IHJldHVybiBuKHYsIC0xNzYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDE4NGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxODQodikgeyByZXR1cm4gbih2LCAtMTg0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQ5MmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQxOTIodikgeyByZXR1cm4gbih2LCAtMTkyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMDBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjAwKHYpIHsgcmV0dXJuIG4odiwgLTIwMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjA4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIwOCh2KSB7IHJldHVybiBuKHYsIC0yMDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDIxNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyMTYodikgeyByZXR1cm4gbih2LCAtMjE2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjI0KHYpIHsgcmV0dXJuIG4odiwgLTIyNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDIzMih2KSB7IHJldHVybiBuKHYsIC0yMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI0MGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQyNDAodikgeyByZXR1cm4gbih2LCAtMjQwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBpbnQyNDhgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MjQ4KHYpIHsgcmV0dXJuIG4odiwgLTI0OCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgaW50MjU2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGludDI1Nih2KSB7IHJldHVybiBuKHYsIC0yNTYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGludDI1NmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbnQodikgeyByZXR1cm4gbih2LCAtMjU2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxKHYpIHsgcmV0dXJuIGIodiwgMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMih2KSB7IHJldHVybiBiKHYsIDIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczModikgeyByZXR1cm4gYih2LCAzKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM0KHYpIHsgcmV0dXJuIGIodiwgNCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzNSh2KSB7IHJldHVybiBiKHYsIDUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczYodikgeyByZXR1cm4gYih2LCA2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXM3KHYpIHsgcmV0dXJuIGIodiwgNyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXM4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzOCh2KSB7IHJldHVybiBiKHYsIDgpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczkodikgeyByZXR1cm4gYih2LCA5KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEwYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTAodikgeyByZXR1cm4gYih2LCAxMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxMWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczExKHYpIHsgcmV0dXJuIGIodiwgMTEpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTJgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxMih2KSB7IHJldHVybiBiKHYsIDEyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczEzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTModikgeyByZXR1cm4gYih2LCAxMyk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxNGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE0KHYpIHsgcmV0dXJuIGIodiwgMTQpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMTVgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxNSh2KSB7IHJldHVybiBiKHYsIDE1KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE2YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTYodikgeyByZXR1cm4gYih2LCAxNik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMxN2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczE3KHYpIHsgcmV0dXJuIGIodiwgMTcpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMThgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMxOCh2KSB7IHJldHVybiBiKHYsIDE4KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczE5YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMTkodikgeyByZXR1cm4gYih2LCAxOSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyMGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIwKHYpIHsgcmV0dXJuIGIodiwgMjApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjFgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyMSh2KSB7IHJldHVybiBiKHYsIDIxKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczIyYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjIodikgeyByZXR1cm4gYih2LCAyMik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyM2BgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczIzKHYpIHsgcmV0dXJuIGIodiwgMjMpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjRgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNCh2KSB7IHJldHVybiBiKHYsIDI0KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI1YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjUodikgeyByZXR1cm4gYih2LCAyNSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyNmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI2KHYpIHsgcmV0dXJuIGIodiwgMjYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMjdgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMyNyh2KSB7IHJldHVybiBiKHYsIDI3KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczI4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMjgodikgeyByZXR1cm4gYih2LCAyOCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMyOWBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczI5KHYpIHsgcmV0dXJuIGIodiwgMjkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzMzBgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnl0ZXMzMCh2KSB7IHJldHVybiBiKHYsIDMwKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBieXRlczMxYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzMzEodikgeyByZXR1cm4gYih2LCAzMSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYnl0ZXMzMmBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBieXRlczMyKHYpIHsgcmV0dXJuIGIodiwgMzIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGFkZHJlc3NgYCB0eXBlIGZvciAlJXYlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkcmVzcyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcImFkZHJlc3NcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgYm9vbGBgIHR5cGUgZm9yICUldiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBib29sKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYm9vbFwiLCAhIXYpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYGJ5dGVzYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ5dGVzKHYpIHsgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYnl0ZXNcIiwgdik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IGBgc3RyaW5nYGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmluZyh2KSB7IHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcInN0cmluZ1wiLCB2KTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGBhcnJheWBgIHR5cGUgZm9yICUldiUlLCBhbGxvd2luZyAlJWR5bmFtaWMlJSBsZW5ndGguXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5KHYsIGR5bmFtaWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZChfZ2F1cmQsIFwiYXJyYXlcIiwgdiwgZHluYW1pYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgYGB0dXBsZWBgIHR5cGUgZm9yICUldiUlLCB3aXRoIHRoZSBvcHRpb25hbCAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgdHVwbGUodiwgbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkKF9nYXVyZCwgXCJ0dXBsZVwiLCB2LCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBgYHVpbnQ4YGAgdHlwZSBmb3IgJSV2JSUuXG4gICAgICovXG4gICAgc3RhdGljIG92ZXJyaWRlcyh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWQoX2dhdXJkLCBcIm92ZXJyaWRlc1wiLCBPYmplY3QuYXNzaWduKHt9LCB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb25seSBpZiAlJXZhbHVlJSUgaXMgYSBbW1R5cGVkXV0gaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGlzVHlwZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZVxuICAgICAgICAgICAgJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICYmIFwiX3R5cGVkU3ltYm9sXCIgaW4gdmFsdWVcbiAgICAgICAgICAgICYmIHZhbHVlLl90eXBlZFN5bWJvbCA9PT0gX3R5cGVkU3ltYm9sKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIHRoZSB2YWx1ZSBpcyBhIFtbVHlwZWRdXSBpbnN0YW5jZSwgdmFsaWRhdGVzIHRoZSB1bmRlcmx5aW5nIHZhbHVlXG4gICAgICogIGFuZCByZXR1cm5zIGl0LCBvdGhlcndpc2UgcmV0dXJucyB2YWx1ZSBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHRoYXQgd2l0aCB0byBhY2NlcHQgZWl0aGVyIGEgW1tUeXBlZF1dXG4gICAgICogIG9iamVjdCBvciB2YWx1ZXMuXG4gICAgICovXG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmIChUeXBlZC5pc1R5cGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZTogZXhwZWNldGQgJHt0eXBlfSwgZ290ICR7dmFsdWUudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZCA9IFR5cGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHlwZWQiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsIl9nYXVyZCIsIm4iLCJ3aWR0aCIsInNpZ25lZCIsImIiLCJzaXplIiwiX3R5cGVkU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwib3B0aW9ucyIsImNvbnN0cnVjdG9yIiwiZ2F1cmQiLCJ0eXBlIiwiYXNzZXJ0UHJpdmF0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJmb3JtYXQiLCJFcnJvciIsIm1hcCIsInYiLCJqb2luIiwiZGVmYXVsdFZhbHVlIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImlzQmlnSW50IiwibWF0Y2giLCJpc0RhdGEiLCJzdGFydHNXaXRoIiwiaXNTdHJpbmciLCJ0dXBsZU5hbWUiLCJUeXBlRXJyb3IiLCJhcnJheUxlbmd0aCIsImxlbmd0aCIsImZyb20iLCJ1aW50OCIsInVpbnQxNiIsInVpbnQyNCIsInVpbnQzMiIsInVpbnQ0MCIsInVpbnQ0OCIsInVpbnQ1NiIsInVpbnQ2NCIsInVpbnQ3MiIsInVpbnQ4MCIsInVpbnQ4OCIsInVpbnQ5NiIsInVpbnQxMDQiLCJ1aW50MTEyIiwidWludDEyMCIsInVpbnQxMjgiLCJ1aW50MTM2IiwidWludDE0NCIsInVpbnQxNTIiLCJ1aW50MTYwIiwidWludDE2OCIsInVpbnQxNzYiLCJ1aW50MTg0IiwidWludDE5MiIsInVpbnQyMDAiLCJ1aW50MjA4IiwidWludDIxNiIsInVpbnQyMjQiLCJ1aW50MjMyIiwidWludDI0MCIsInVpbnQyNDgiLCJ1aW50MjU2IiwidWludCIsImludDgiLCJpbnQxNiIsImludDI0IiwiaW50MzIiLCJpbnQ0MCIsImludDQ4IiwiaW50NTYiLCJpbnQ2NCIsImludDcyIiwiaW50ODAiLCJpbnQ4OCIsImludDk2IiwiaW50MTA0IiwiaW50MTEyIiwiaW50MTIwIiwiaW50MTI4IiwiaW50MTM2IiwiaW50MTQ0IiwiaW50MTUyIiwiaW50MTYwIiwiaW50MTY4IiwiaW50MTc2IiwiaW50MTg0IiwiaW50MTkyIiwiaW50MjAwIiwiaW50MjA4IiwiaW50MjE2IiwiaW50MjI0IiwiaW50MjMyIiwiaW50MjQwIiwiaW50MjQ4IiwiaW50MjU2IiwiaW50IiwiYnl0ZXMxIiwiYnl0ZXMyIiwiYnl0ZXMzIiwiYnl0ZXM0IiwiYnl0ZXM1IiwiYnl0ZXM2IiwiYnl0ZXM3IiwiYnl0ZXM4IiwiYnl0ZXM5IiwiYnl0ZXMxMCIsImJ5dGVzMTEiLCJieXRlczEyIiwiYnl0ZXMxMyIsImJ5dGVzMTQiLCJieXRlczE1IiwiYnl0ZXMxNiIsImJ5dGVzMTciLCJieXRlczE4IiwiYnl0ZXMxOSIsImJ5dGVzMjAiLCJieXRlczIxIiwiYnl0ZXMyMiIsImJ5dGVzMjMiLCJieXRlczI0IiwiYnl0ZXMyNSIsImJ5dGVzMjYiLCJieXRlczI3IiwiYnl0ZXMyOCIsImJ5dGVzMjkiLCJieXRlczMwIiwiYnl0ZXMzMSIsImJ5dGVzMzIiLCJhZGRyZXNzIiwiYm9vbCIsImJ5dGVzIiwic3RyaW5nIiwiYXJyYXkiLCJkeW5hbWljIiwidHVwbGUiLCJuYW1lIiwib3ZlcnJpZGVzIiwiYXNzaWduIiwiaXNUeXBlZCIsImRlcmVmZXJlbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/abi/typed.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/address/address.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/address.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getIcapAddress = exports.getAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = function() {\n    ;\n    const result = {};\n    for(let i = 0; i < 36; i++){\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n}();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */ function getAddress(address) {\n    (0, index_js_2.assertArgument)(typeof address === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    (0, index_js_2.assertArgument)(false, \"invalid address\", \"address\", address);\n}\nexports.getAddress = getAddress;\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */ function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexports.getIcapAddress = getIcapAddress; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ25ELE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixzQ0FBc0M7SUFDdEMsMkVBQTJFO0lBQzNFLE9BQU87SUFDUEEsVUFBVUEsUUFBUUMsV0FBVztJQUM3QixNQUFNQyxRQUFRRixRQUFRRyxTQUFTLENBQUMsR0FBR0MsS0FBSyxDQUFDO0lBQ3pDLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztJQUNoQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3pCRixRQUFRLENBQUNFLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxFQUFFLENBQUNDLFVBQVUsQ0FBQztJQUN0QztJQUNBLE1BQU1DLFNBQVMsQ0FBQyxHQUFHZCxXQUFXZSxRQUFRLEVBQUUsQ0FBQyxHQUFHakIsV0FBV2tCLFNBQVMsRUFBRU47SUFDbEUsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0ssV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0gsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFD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QixRQUFRRyxTQUFTLENBQUMsSUFBSTZCLFFBQVEsQ0FBQztRQUN2RCxNQUFPTixPQUFPTCxNQUFNLEdBQUcsR0FBSTtZQUN2QkssU0FBUyxNQUFNQTtRQUNuQjtRQUNBLE9BQU8zQixtQkFBbUIsT0FBTzJCO0lBQ3JDO0lBQ0MsSUFBRy9CLFdBQVdrQyxjQUFjLEVBQUUsT0FBTyxtQkFBbUIsV0FBVzdCO0FBQ3hFO0FBQ0FYLGtCQUFrQixHQUFHRztBQUNyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTRCxlQUFlUyxPQUFPO0lBQzNCLDJFQUEyRTtJQUMzRSxJQUFJaUMsU0FBU3BDLE9BQU9MLFdBQVdRLFVBQVVnQyxRQUFRLENBQUMsSUFBSXBCLFdBQVc7SUFDakUsTUFBT3FCLE9BQU9aLE1BQU0sR0FBRyxHQUFJO1FBQ3ZCWSxTQUFTLE1BQU1BO0lBQ25CO0lBQ0EsT0FBTyxPQUFPZixhQUFhLFNBQVNlLFVBQVVBO0FBQ2xEO0FBQ0E1QyxzQkFBc0IsR0FBR0UsZ0JBQ3pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2FkZHJlc3MvYWRkcmVzcy5qcz8wNzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGV4cG9ydHMuZ2V0QWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8zNiA9IEJpZ0ludCgzNik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIC8vICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG4gICAgLy8gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIC8vICAgIH1cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18xLmtlY2NhazI1NikoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuLy8gaS5lLiBNYXRoLmZsb29yKE1hdGgubG9nMTAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbmNvbnN0IHNhZmVEaWdpdHMgPSAxNTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5jb25zdCBCYXNlMzYgPSAoZnVuY3Rpb24gKCkge1xuICAgIDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIltpXTtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBCaWdJbnQoaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuZnVuY3Rpb24gZnJvbUJhc2UzNih2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAqIEJOXzM2ICsgQmFzZTM2W3ZhbHVlW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogIFJldHVybnMgYSBub3JtYWxpemVkIGFuZCBjaGVja3N1bWVkIGFkZHJlc3MgZm9yICUlYWRkcmVzcyUlLlxuICogIFRoaXMgYWNjZXB0cyBub24tY2hlY2tzdW0gYWRkcmVzc2VzLCBjaGVja3N1bSBhZGRyZXNzZXMgYW5kXG4gKiAgW1tnZXRJY2FwQWRkcmVzc11dIGZvcm1hdHMuXG4gKlxuICogIFRoZSBjaGVja3N1bSBpbiBFdGhlcmV1bSB1c2VzIHRoZSBjYXBpdGFsaXphdGlvbiAodXBwZXItY2FzZVxuICogIHZzIGxvd2VyLWNhc2UpIG9mIHRoZSBjaGFyYWN0ZXJzIHdpdGhpbiBhbiBhZGRyZXNzIHRvIGVuY29kZVxuICogIGl0cyBjaGVja3N1bSwgd2hpY2ggb2ZmZXJzLCBvbiBhdmVyYWdlLCBhIGNoZWNrc3VtIG9mIDE1LWJpdHMuXG4gKlxuICogIElmICUlYWRkcmVzcyUlIGNvbnRhaW5zIGJvdGggdXBwZXItY2FzZSBhbmQgbG93ZXItY2FzZSwgaXQgaXNcbiAqICBhc3N1bWVkIHRvIGFscmVhZHkgYmUgYSBjaGVja3N1bSBhZGRyZXNzIGFuZCBpdHMgY2hlY2tzdW0gaXNcbiAqICB2YWxpZGF0ZWQsIGFuZCBpZiB0aGUgYWRkcmVzcyBmYWlscyBpdHMgZXhwZWN0ZWQgY2hlY2tzdW0gYW5cbiAqICBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIElmIHlvdSB3aXNoIHRoZSBjaGVja3N1bSBvZiAlJWFkZHJlc3MlJSB0byBiZSBpZ25vcmUsIGl0IHNob3VsZFxuICogIGJlIGNvbnZlcnRlZCB0byBsb3dlci1jYXNlIChpLmUuIGBgLnRvTG93ZXJjYXNlKClgYCkgYmVmb3JlXG4gKiAgYmVpbmcgcGFzc2VkIGluLiBUaGlzIHNob3VsZCBiZSBhIHZlcnkgcmFyZSBzaXR1YXRpb24gdGhvdWdoLFxuICogIHRoYXQgeW91IHdpc2ggdG8gYnlwYXNzIHRoZSBzYWZlZ2F1cmRzIGluIHBsYWNlIHRvIHByb3RlY3RcbiAqICBhZ2FpbnN0IGFuIGFkZHJlc3MgdGhhdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBjb3BpZWQgZnJvbSBhbm90aGVyXG4gKiAgc291cmNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEFkZHMgdGhlIGNoZWNrc3VtICh2aWEgdXBwZXItY2FzaW5nIHNwZWNpZmljIGxldHRlcnMpXG4gKiAgICBnZXRBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQ29udmVydHMgSUNBUCBhZGRyZXNzIGFuZCBhZGRzIGNoZWNrc3VtXG4gKiAgICBnZXRBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIGFkZHJlc3MgY29udGFpbnMgbWl4ZWQgY2FzZSxcbiAqICAgIC8vIGJ1dCB0aGUgY2hlY2tzdW0gZmFpbHNcbiAqICAgIGdldEFkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJBNzJcIilcbiAqICAgIC8vX2Vycm9yOlxuICovXG5mdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChhZGRyZXNzKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmICghYWRkcmVzcy5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKCFhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pIHx8IHJlc3VsdCA9PT0gYWRkcmVzcywgXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShhZGRyZXNzLnN1YnN0cmluZygyLCA0KSA9PT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpLCBcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZyb21CYXNlMzYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbn1cbmV4cG9ydHMuZ2V0QWRkcmVzcyA9IGdldEFkZHJlc3M7XG4vKipcbiAqICBUaGUgW0lDQVAgQWRkcmVzcyBmb3JtYXRdKGxpbmstaWNhcCkgZm9ybWF0IGlzIGFuIGVhcmx5IGNoZWNrc3VtXG4gKiAgZm9ybWF0IHdoaWNoIGF0dGVtcHRzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFua2luZ1xuICogIGluZHVzdHJ5IFtJQkFOIGZvcm1hdF0obGluay13aWtpLWliYW4pIGZvciBiYW5rIGFjY291bnRzLlxuICpcbiAqICBJdCBpcyBubyBsb25nZXIgY29tbW9uIG9yIGEgcmVjb21tZW5kZWQgZm9ybWF0LlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCIpO1xuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIGdldEljYXBBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIik7XG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBJQ0FQIGNoZWNrc3VtIGlzIHdyb25nXG4gKiAgICBnZXRJY2FwQWRkcmVzcyhcIlhFNjVHQjZMRE5YWU9GVFgwTlNWM0ZVV0tPV0lYQU1KSzM3XCIpO1xuICogICAgLy9fZXJyb3I6XG4gKi9cbmZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAvL2xldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgYmFzZTM2ID0gQmlnSW50KGdldEFkZHJlc3MoYWRkcmVzcykpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGdldEljYXBBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRJY2FwQWRkcmVzcyIsImdldEFkZHJlc3MiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJCTl8wIiwiQmlnSW50IiwiQk5fMzYiLCJnZXRDaGVja3N1bUFkZHJlc3MiLCJhZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJjaGFycyIsInN1YnN0cmluZyIsInNwbGl0IiwiZXhwYW5kZWQiLCJVaW50OEFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJoYXNoZWQiLCJnZXRCeXRlcyIsImtlY2NhazI1NiIsInRvVXBwZXJDYXNlIiwiam9pbiIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiaWJhbkNoZWNrc3VtIiwibWFwIiwiYyIsImxlbmd0aCIsImJsb2NrIiwicGFyc2VJbnQiLCJjaGVja3N1bSIsIkJhc2UzNiIsInJlc3VsdCIsImtleSIsImZyb21CYXNlMzYiLCJhc3NlcnRBcmd1bWVudCIsIm1hdGNoIiwic3RhcnRzV2l0aCIsInRvU3RyaW5nIiwiYmFzZTM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/address/address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/address/checks.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/checks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/address.js\");\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */ function isAddressable(value) {\n    return value && typeof value.getAddress === \"function\";\n}\nexports.isAddressable = isAddressable;\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */ function isAddress(value) {\n    try {\n        (0, address_js_1.getAddress)(value);\n        return true;\n    } catch (error) {}\n    return false;\n}\nexports.isAddress = isAddress;\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        (0, index_js_1.assert)(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n            value: target\n        });\n        (0, index_js_1.assertArgument)(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return (0, address_js_1.getAddress)(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */ function resolveAddress(target, resolver) {\n    if (typeof target === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return (0, address_js_1.getAddress)(target);\n        }\n        (0, index_js_1.assert)(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n        });\n        return checkAddress(target, resolver.resolveName(target));\n    } else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    } else if (target && typeof target.then === \"function\") {\n        return checkAddress(target, target);\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported addressable value\", \"target\", target);\n}\nexports.resolveAddress = resolveAddress; //# sourceMappingURL=checks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NoZWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFFLE1BQU1LLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxpRkFBYztBQUMzQzs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU0YsY0FBY0gsS0FBSztJQUN4QixPQUFRQSxTQUFTLE9BQVFBLE1BQU1PLFVBQVUsS0FBTTtBQUNuRDtBQUNBUixxQkFBcUIsR0FBR0k7QUFDeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNELFNBQVNELFVBQVVGLEtBQUs7SUFDcEIsSUFBSTtRQUNDLElBQUdNLGFBQWFDLFVBQVUsRUFBRVA7UUFDN0IsT0FBTztJQUNYLEVBQ0EsT0FBT1EsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNBVCxpQkFBaUIsR0FBR0c7QUFDcEIsZUFBZU8sYUFBYUMsTUFBTSxFQUFFQyxPQUFPO0lBQ3ZDLE1BQU1DLFNBQVMsTUFBTUQ7SUFDckIsSUFBSUMsVUFBVSxRQUFRQSxXQUFXLDhDQUE4QztRQUMxRSxJQUFHUixXQUFXUyxNQUFNLEVBQUUsT0FBUUgsV0FBWSxVQUFVLHFCQUFxQixxQkFBcUI7WUFBRVYsT0FBT1U7UUFBTztRQUM5RyxJQUFHTixXQUFXVSxjQUFjLEVBQUUsT0FBTyxpRUFBaUUsVUFBVUo7SUFDckg7SUFDQSxPQUFPLENBQUMsR0FBR0osYUFBYUMsVUFBVSxFQUFFSztBQUN4QztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDRCxTQUFTWCxlQUFlUyxNQUFNLEVBQUVLLFFBQVE7SUFDcEMsSUFBSSxPQUFRTCxXQUFZLFVBQVU7UUFDOUIsSUFBSUEsT0FBT00sS0FBSyxDQUFDLHNCQUFzQjtZQUNuQyxPQUFPLENBQUMsR0FBR1YsYUFBYUMsVUFBVSxFQUFFRztRQUN4QztRQUNDLElBQUdOLFdBQVdTLE1BQU0sRUFBRUUsWUFBWSxNQUFNLHNDQUFzQyx5QkFBeUI7WUFBRUUsV0FBVztRQUFjO1FBQ25JLE9BQU9SLGFBQWFDLFFBQVFLLFNBQVNHLFdBQVcsQ0FBQ1I7SUFDckQsT0FDSyxJQUFJUCxjQUFjTyxTQUFTO1FBQzVCLE9BQU9ELGFBQWFDLFFBQVFBLE9BQU9ILFVBQVU7SUFDakQsT0FDSyxJQUFJRyxVQUFVLE9BQVFBLE9BQU9TLElBQUksS0FBTSxZQUFZO1FBQ3BELE9BQU9WLGFBQWFDLFFBQVFBO0lBQ2hDO0lBQ0MsSUFBR04sV0FBV1UsY0FBYyxFQUFFLE9BQU8saUNBQWlDLFVBQVVKO0FBQ3JGO0FBQ0FYLHNCQUFzQixHQUFHRSxnQkFDekIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9jaGVja3MuanM/MjYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZUFkZHJlc3MgPSBleHBvcnRzLmlzQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzYWJsZSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLmpzXCIpO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhbiBvYmplY3Qgd2hpY2ggaW1wbGVtZW50cyB0aGVcbiAqICBbW0FkZHJlc3NhYmxlXV0gaW50ZXJmYWNlLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFdhbGxldHMgYW5kIEFic3RyYWN0U2lnbmVyIHN1Yi1jbGFzc2VzXG4gKiAgICBpc0FkZHJlc3NhYmxlKFdhbGxldC5jcmVhdGVSYW5kb20oKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBDb250cmFjdHNcbiAqICAgIGNvbnRyYWN0ID0gbmV3IENvbnRyYWN0KFwiZGFpLnRva2Vucy5ldGhlcnMuZXRoXCIsIFsgXSwgcHJvdmlkZXIpXG4gKiAgICBpc0FkZHJlc3NhYmxlKGNvbnRyYWN0KVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBpc0FkZHJlc3NhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gaXNBZGRyZXNzYWJsZTtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJXZhbHVlJSUgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFZhbGlkIGFkZHJlc3NcbiAqICAgIGlzQWRkcmVzcyhcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFZhbGlkIElDQVAgYWRkcmVzc1xuICogICAgaXNBZGRyZXNzKFwiWEU2NUdCNkxETlhZT0ZUWDBOU1YzRlVXS09XSVhBTUpLMzZcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBJbnZhbGlkIGNoZWNrc3VtXG4gKiAgICBpc0FkZHJlc3MoXCIweDhCYTFmMTA5NTUxYkQ0MzI4MDMwMTI2NDVBYzEzNmRkZDY0REJhNzJcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBJbnZhbGlkIElDQVAgY2hlY2tzdW1cbiAqICAgIGlzQWRkcmVzcyhcIjB4OEJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIE5vdCBhbiBhZGRyZXNzIChhbiBFTlMgbmFtZSByZXF1aXJlcyBhIHByb3ZpZGVkIGFuZCBhblxuICogICAgLy8gYXN5bmNocm9ub3VzIEFQSSB0byBhY2Nlc3MpXG4gKiAgICBpc0FkZHJlc3MoXCJyaWNtb28uZXRoXCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGlzQWRkcmVzcyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBhZGRyZXNzX2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzQWRkcmVzcyA9IGlzQWRkcmVzcztcbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWRkcmVzcyh0YXJnZXQsIHByb21pc2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQgPT09IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0eXBlb2YgKHRhcmdldCkgIT09IFwic3RyaW5nXCIsIFwidW5jb25maWd1cmVkIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7IHZhbHVlOiB0YXJnZXQgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIEFkZHJlc3NMaWtlIHZhbHVlOyBkaWQgbm90IHJlc29sdmUgdG8gYSB2YWx1ZSBhZGRyZXNzXCIsIFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKHJlc3VsdCk7XG59XG4vKipcbiAqICBSZXNvbHZlcyB0byBhbiBhZGRyZXNzIGZvciB0aGUgJSV0YXJnZXQlJSwgd2hpY2ggbWF5IGJlIGFueVxuICogIHN1cHBvcnRlZCBhZGRyZXNzIHR5cGUsIGFuIFtbQWRkcmVzc2FibGVdXSBvciBhIFByb21pc2Ugd2hpY2hcbiAqICByZXNvbHZlcyB0byBhbiBhZGRyZXNzLlxuICpcbiAqICBJZiBhbiBFTlMgbmFtZSBpcyBwcm92aWRlZCwgYnV0IHRoYXQgbmFtZSBoYXMgbm90IGJlZW4gY29ycmVjdGx5XG4gKiAgY29uZmlndXJlZCBhIFtbVW5jb25maWd1cmVkTmFtZUVycm9yXV0gaXMgdGhyb3duLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGFkZHIgPSBcIjB4NkIxNzU0NzRFODkwOTRDNDREYTk4Yjk1NEVlZGVBQzQ5NTI3MWQwRlwiXG4gKlxuICogICAgLy8gQWRkcmVzc2VzIGFyZSByZXR1cm4gc3luY2hyb25vdXNseVxuICogICAgcmVzb2x2ZUFkZHJlc3MoYWRkciwgcHJvdmlkZXIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gQWRkcmVzcyBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgYXN5bmNocm9ub3VzbHlcbiAqICAgIHJlc29sdmVBZGRyZXNzKFByb21pc2UucmVzb2x2ZShhZGRyKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBFTlMgbmFtZXMgYXJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5XG4gKiAgICByZXNvbHZlQWRkcmVzcyhcImRhaS50b2tlbnMuZXRoZXJzLmV0aFwiLCBwcm92aWRlcilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBBZGRyZXNzYWJsZSBvYmplY3RzIGFyZSByZXNvbHZlZCBhc3luY2hyb25vdXNseVxuICogICAgY29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkciwgWyBdKVxuICogICAgcmVzb2x2ZUFkZHJlc3MoY29udHJhY3QsIHByb3ZpZGVyKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIFVuY29uZmlndXJlZCBFTlMgbmFtZXMgcmVqZWN0XG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIsIHByb3ZpZGVyKVxuICogICAgLy9fZXJyb3I6XG4gKlxuICogICAgLy8gRU5TIG5hbWVzIHJlcXVpcmUgYSBOYW1lUmVzb2x2ZXIgb2JqZWN0IHBhc3NlZCBpblxuICogICAgLy8gKG5vdGljZSB0aGUgcHJvdmlkZXIgd2FzIG9taXR0ZWQpXG4gKiAgICByZXNvbHZlQWRkcmVzcyhcIm5vdGhpbmctaGVyZS5yaWNtb28uZXRoXCIpXG4gKiAgICAvL19lcnJvcjpcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3ModGFyZ2V0LCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5tYXRjaCgvXjB4WzAtOWEtZl17NDB9JC9pKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBhZGRyZXNzX2pzXzEuZ2V0QWRkcmVzcykodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHJlc29sdmVyICE9IG51bGwsIFwiRU5TIHJlc29sdXRpb24gcmVxdWlyZXMgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgcmVzb2x2ZXIucmVzb2x2ZU5hbWUodGFyZ2V0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWRkcmVzc2FibGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gY2hlY2tBZGRyZXNzKHRhcmdldCwgdGFyZ2V0LmdldEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgKHRhcmdldC50aGVuKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBjaGVja0FkZHJlc3ModGFyZ2V0LCB0YXJnZXQpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgYWRkcmVzc2FibGUgdmFsdWVcIiwgXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcbn1cbmV4cG9ydHMucmVzb2x2ZUFkZHJlc3MgPSByZXNvbHZlQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZXNvbHZlQWRkcmVzcyIsImlzQWRkcmVzcyIsImlzQWRkcmVzc2FibGUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImFkZHJlc3NfanNfMSIsImdldEFkZHJlc3MiLCJlcnJvciIsImNoZWNrQWRkcmVzcyIsInRhcmdldCIsInByb21pc2UiLCJyZXN1bHQiLCJhc3NlcnQiLCJhc3NlcnRBcmd1bWVudCIsInJlc29sdmVyIiwibWF0Y2giLCJvcGVyYXRpb24iLCJyZXNvbHZlTmFtZSIsInRoZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/address/checks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/address/contract-address.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/contract-address.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getCreate2Address = exports.getCreateAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/address.js\");\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */ function getCreateAddress(tx) {\n    const from = (0, address_js_1.getAddress)(tx.from);\n    const nonce = (0, index_js_2.getBigInt)(tx.nonce, \"tx.nonce\");\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([\n        from,\n        nonceHex\n    ])), 12));\n}\nexports.getCreateAddress = getCreateAddress;\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */ function getCreate2Address(_from, _salt, _initCodeHash) {\n    const from = (0, address_js_1.getAddress)(_from);\n    const salt = (0, index_js_2.getBytes)(_salt, \"salt\");\n    const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, \"initCodeHash\");\n    (0, index_js_2.assertArgument)(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n    (0, index_js_2.assertArgument)(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n    return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)([\n        \"0xff\",\n        from,\n        salt,\n        initCodeHash\n    ])), 12));\n}\nexports.getCreate2Address = getCreate2Address; //# sourceMappingURL=contract-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2NvbnRyYWN0LWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQzVELE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsaUZBQWM7QUFDM0Msc0dBQXNHO0FBQ3RHOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNELFNBQVNGLGlCQUFpQkssRUFBRTtJQUN4QixNQUFNQyxPQUFPLENBQUMsR0FBR0YsYUFBYUcsVUFBVSxFQUFFRixHQUFHQyxJQUFJO0lBQ2pELE1BQU1FLFFBQVEsQ0FBQyxHQUFHTCxXQUFXTSxTQUFTLEVBQUVKLEdBQUdHLEtBQUssRUFBRTtJQUNsRCxJQUFJRSxXQUFXRixNQUFNRyxRQUFRLENBQUM7SUFDOUIsSUFBSUQsYUFBYSxLQUFLO1FBQ2xCQSxXQUFXO0lBQ2YsT0FDSyxJQUFJQSxTQUFTRSxNQUFNLEdBQUcsR0FBRztRQUMxQkYsV0FBVyxRQUFRQTtJQUN2QixPQUNLO1FBQ0RBLFdBQVcsT0FBT0E7SUFDdEI7SUFDQSxPQUFPLENBQUMsR0FBR04sYUFBYUcsVUFBVSxFQUFFLENBQUMsR0FBR0osV0FBV1UsU0FBUyxFQUFFLENBQUMsR0FBR1osV0FBV2EsU0FBUyxFQUFFLENBQUMsR0FBR1gsV0FBV1ksU0FBUyxFQUFFO1FBQUNUO1FBQU1JO0tBQVMsSUFBSTtBQUMxSTtBQUNBYix3QkFBd0IsR0FBR0c7QUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTRCxrQkFBa0JpQixLQUFLLEVBQUVDLEtBQUssRUFBRUMsYUFBYTtJQUNsRCxNQUFNWixPQUFPLENBQUMsR0FBR0YsYUFBYUcsVUFBVSxFQUFFUztJQUMxQyxNQUFNRyxPQUFPLENBQUMsR0FBR2hCLFdBQVdpQixRQUFRLEVBQUVILE9BQU87SUFDN0MsTUFBTUksZUFBZSxDQUFDLEdBQUdsQixXQUFXaUIsUUFBUSxFQUFFRixlQUFlO0lBQzVELElBQUdmLFdBQVdtQixjQUFjLEVBQUVILEtBQUtQLE1BQU0sS0FBSyxJQUFJLHlCQUF5QixRQUFRSztJQUNuRixJQUFHZCxXQUFXbUIsY0FBYyxFQUFFRCxhQUFhVCxNQUFNLEtBQUssSUFBSSxpQ0FBaUMsZ0JBQWdCTTtJQUM1RyxPQUFPLENBQUMsR0FBR2QsYUFBYUcsVUFBVSxFQUFFLENBQUMsR0FBR0osV0FBV1UsU0FBUyxFQUFFLENBQUMsR0FBR1osV0FBV2EsU0FBUyxFQUFFLENBQUMsR0FBR1gsV0FBV29CLE1BQU0sRUFBRTtRQUFDO1FBQVFqQjtRQUFNYTtRQUFNRTtLQUFhLElBQUk7QUFDeko7QUFDQXhCLHlCQUF5QixHQUFHRSxtQkFDNUIsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9jb250cmFjdC1hZGRyZXNzLmpzP2IyYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZXhwb3J0cy5nZXRDcmVhdGVBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy5qc1wiKTtcbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuLyoqXG4gKiAgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIGEgYGBDUkVBVEVgYCBmb3IgJSV0eCUlLlxuICpcbiAqICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGFkZHJlc3MgYSBjb250cmFjdCB3aWxsIGJlXG4gKiAgZGVwbG95ZWQgdG8gYnkgYW4gRU9BIHdoZW4gc2VuZGluZyBhIGRlcGxveW1lbnQgdHJhbnNhY3Rpb24gKGkuZS5cbiAqICB3aGVuIHRoZSBgYHRvYGAgYWRkcmVzcyBpcyBgYG51bGxgYCkuXG4gKlxuICogIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21wdXRlIHRoZSBhZGRyZXNzIGEgY29udHJhY3Qgd2lsbCBiZVxuICogIGRlcGxveWVkIHRvIGJ5IGEgY29udHJhY3QsIGJ5IHVzaW5nIHRoZSBjb250cmFjdCdzIGFkZHJlc3MgYXMgdGhlXG4gKiAgYGB0b2BgIGFuZCB0aGUgY29udHJhY3QncyBub25jZS5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiO1xuICogICAgbm9uY2UgPSA1O1xuICpcbiAqICAgIGdldENyZWF0ZUFkZHJlc3MoeyBmcm9tLCBub25jZSB9KTtcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gZ2V0Q3JlYXRlQWRkcmVzcyh0eCkge1xuICAgIGNvbnN0IGZyb20gPSAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKHR4LmZyb20pO1xuICAgIGNvbnN0IG5vbmNlID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KSh0eC5ub25jZSwgXCJ0eC5ub25jZVwiKTtcbiAgICBsZXQgbm9uY2VIZXggPSBub25jZS50b1N0cmluZygxNik7XG4gICAgaWYgKG5vbmNlSGV4ID09PSBcIjBcIikge1xuICAgICAgICBub25jZUhleCA9IFwiMHhcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9uY2VIZXgubGVuZ3RoICUgMikge1xuICAgICAgICBub25jZUhleCA9IFwiMHgwXCIgKyBub25jZUhleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vbmNlSGV4ID0gXCIweFwiICsgbm9uY2VIZXg7XG4gICAgfVxuICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKCgwLCBpbmRleF9qc18yLmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi5lbmNvZGVSbHApKFtmcm9tLCBub25jZUhleF0pKSwgMTIpKTtcbn1cbmV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGdldENyZWF0ZUFkZHJlc3M7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgd291bGQgcmVzdWx0IGZyb20gYSBgYENSRUFURTJgYCBvcGVyYXRpb25cbiAqICB3aXRoIHRoZSBnaXZlbiAlJWZyb20lJSwgJSVzYWx0JSUgYW5kICUlaW5pdENvZGVIYXNoJSUuXG4gKlxuICogIFRvIGNvbXB1dGUgdGhlICUlaW5pdENvZGVIYXNoJSUgZnJvbSBhIGNvbnRyYWN0J3MgaW5pdCBjb2RlLCB1c2VcbiAqICB0aGUgW1trZWNjYWsyNTZdXSBmdW5jdGlvbi5cbiAqXG4gKiAgRm9yIGEgcXVpY2sgb3ZlcnZpZXcgYW5kIGV4YW1wbGUgb2YgYGBDUkVBVEUyYGAsIHNlZSBbW2xpbmstcmljbW9vLXdpc3BzXV0uXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAvLyBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3RcbiAqICAgIGZyb20gPSBcIjB4OGJhMWYxMDk1NTFiRDQzMjgwMzAxMjY0NUFjMTM2ZGRkNjREQkE3MlwiXG4gKlxuICogICAgLy8gVGhlIHNhbHRcbiAqICAgIHNhbHQgPSBpZChcIkhlbGxvV29ybGRcIilcbiAqXG4gKiAgICAvLyBUaGUgaGFzaCBvZiB0aGUgaW5pdENvZGVcbiAqICAgIGluaXRDb2RlID0gXCIweDYzOTQxOThkZjE2MDAwNTI2MTAzZmY2MDIwNjAwNDYwMWMzMzVhZmE2MDQwNTE2MDYwZjNcIjtcbiAqICAgIGluaXRDb2RlSGFzaCA9IGtlY2NhazI1Nihpbml0Q29kZSlcbiAqXG4gKiAgICBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKF9mcm9tLCBfc2FsdCwgX2luaXRDb2RlSGFzaCkge1xuICAgIGNvbnN0IGZyb20gPSAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKF9mcm9tKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9zYWx0LCBcInNhbHRcIik7XG4gICAgY29uc3QgaW5pdENvZGVIYXNoID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKF9pbml0Q29kZUhhc2gsIFwiaW5pdENvZGVIYXNoXCIpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShzYWx0Lmxlbmd0aCA9PT0gMzIsIFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBfc2FsdCk7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluaXRDb2RlSGFzaC5sZW5ndGggPT09IDMyLCBcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIF9pbml0Q29kZUhhc2gpO1xuICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLmdldEFkZHJlc3MpKCgwLCBpbmRleF9qc18yLmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi5jb25jYXQpKFtcIjB4ZmZcIiwgZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGdldENyZWF0ZTJBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJhY3QtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRDcmVhdGUyQWRkcmVzcyIsImdldENyZWF0ZUFkZHJlc3MiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJhZGRyZXNzX2pzXzEiLCJ0eCIsImZyb20iLCJnZXRBZGRyZXNzIiwibm9uY2UiLCJnZXRCaWdJbnQiLCJub25jZUhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZGF0YVNsaWNlIiwia2VjY2FrMjU2IiwiZW5jb2RlUmxwIiwiX2Zyb20iLCJfc2FsdCIsIl9pbml0Q29kZUhhc2giLCJzYWx0IiwiZ2V0Qnl0ZXMiLCJpbml0Q29kZUhhc2giLCJhc3NlcnRBcmd1bWVudCIsImNvbmNhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/address/contract-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/address/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/address/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Addresses are a fundamental part of interacting with Ethereum. They\n *  represent the gloabal identity of Externally Owned Accounts (accounts\n *  backed by a private key) and contracts.\n *\n *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem\n *  of contracts, standards and libraries which enable looking up an\n *  address for an ENS name.\n *\n *  These functions help convert between various formats, validate\n *  addresses and safely resolve ENS names.\n *\n *  @_section: api/address:Addresses  [about-addresses]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;\nnull;\nvar address_js_1 = __webpack_require__(/*! ./address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/address.js\");\nObject.defineProperty(exports, \"getAddress\", ({\n    enumerable: true,\n    get: function() {\n        return address_js_1.getAddress;\n    }\n}));\nObject.defineProperty(exports, \"getIcapAddress\", ({\n    enumerable: true,\n    get: function() {\n        return address_js_1.getIcapAddress;\n    }\n}));\nvar contract_address_js_1 = __webpack_require__(/*! ./contract-address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/contract-address.js\");\nObject.defineProperty(exports, \"getCreateAddress\", ({\n    enumerable: true,\n    get: function() {\n        return contract_address_js_1.getCreateAddress;\n    }\n}));\nObject.defineProperty(exports, \"getCreate2Address\", ({\n    enumerable: true,\n    get: function() {\n        return contract_address_js_1.getCreate2Address;\n    }\n}));\nvar checks_js_1 = __webpack_require__(/*! ./checks.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/checks.js\");\nObject.defineProperty(exports, \"isAddressable\", ({\n    enumerable: true,\n    get: function() {\n        return checks_js_1.isAddressable;\n    }\n}));\nObject.defineProperty(exports, \"isAddress\", ({\n    enumerable: true,\n    get: function() {\n        return checks_js_1.isAddress;\n    }\n}));\nObject.defineProperty(exports, \"resolveAddress\", ({\n    enumerable: true,\n    get: function() {\n        return checks_js_1.resolveAddress;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9hZGRyZXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0EseUJBQXlCLEdBQUdBLHdCQUF3QixHQUFHQSxzQkFBc0IsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUMvSztBQUNBLElBQUlTLGVBQWVDLG1CQUFPQSxDQUFDLGlGQUFjO0FBQ3pDWiw4Q0FBNkM7SUFBRWEsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsYUFBYUQsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hIVixrREFBaUQ7SUFBRWEsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsYUFBYUYsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hJLElBQUlNLHdCQUF3QkgsbUJBQU9BLENBQUMsbUdBQXVCO0FBQzNEWixvREFBbUQ7SUFBRWEsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0Msc0JBQXNCUCxnQkFBZ0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SVIscURBQW9EO0lBQUVhLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLHNCQUFzQlIsaUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0ksSUFBSVMsY0FBY0osbUJBQU9BLENBQUMsK0VBQWE7QUFDdkNaLGlEQUFnRDtJQUFFYSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxZQUFZVixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0hOLDZDQUE0QztJQUFFYSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxZQUFZWCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckhMLGtEQUFpRDtJQUFFYSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxZQUFZWixjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDL0gsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvYWRkcmVzcy9pbmRleC5qcz82NTkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQWRkcmVzc2VzIGFyZSBhIGZ1bmRhbWVudGFsIHBhcnQgb2YgaW50ZXJhY3Rpbmcgd2l0aCBFdGhlcmV1bS4gVGhleVxuICogIHJlcHJlc2VudCB0aGUgZ2xvYWJhbCBpZGVudGl0eSBvZiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnRzIChhY2NvdW50c1xuICogIGJhY2tlZCBieSBhIHByaXZhdGUga2V5KSBhbmQgY29udHJhY3RzLlxuICpcbiAqICBUaGUgRXRoZXJldW0gTmFtaW5nIFNlcnZpY2UgKEVOUykgcHJvdmlkZXMgYW4gaW50ZXJjb25uZWN0ZWQgZWNvc3lzdGVtXG4gKiAgb2YgY29udHJhY3RzLCBzdGFuZGFyZHMgYW5kIGxpYnJhcmllcyB3aGljaCBlbmFibGUgbG9va2luZyB1cCBhblxuICogIGFkZHJlc3MgZm9yIGFuIEVOUyBuYW1lLlxuICpcbiAqICBUaGVzZSBmdW5jdGlvbnMgaGVscCBjb252ZXJ0IGJldHdlZW4gdmFyaW91cyBmb3JtYXRzLCB2YWxpZGF0ZVxuICogIGFkZHJlc3NlcyBhbmQgc2FmZWx5IHJlc29sdmUgRU5TIG5hbWVzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9hZGRyZXNzOkFkZHJlc3NlcyAgW2Fib3V0LWFkZHJlc3Nlc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5udWxsO1xudmFyIGFkZHJlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEuZ2V0QWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEljYXBBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEuZ2V0SWNhcEFkZHJlc3M7IH0gfSk7XG52YXIgY29udHJhY3RfYWRkcmVzc19qc18xID0gcmVxdWlyZShcIi4vY29udHJhY3QtYWRkcmVzcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2FkZHJlc3NfanNfMS5nZXRDcmVhdGVBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q3JlYXRlMkFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2FkZHJlc3NfanNfMS5nZXRDcmVhdGUyQWRkcmVzczsgfSB9KTtcbnZhciBjaGVja3NfanNfMSA9IHJlcXVpcmUoXCIuL2NoZWNrcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQWRkcmVzc2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc19qc18xLmlzQWRkcmVzc2FibGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0FkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc19qc18xLmlzQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVja3NfanNfMS5yZXNvbHZlQWRkcmVzczsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlc29sdmVBZGRyZXNzIiwiaXNBZGRyZXNzIiwiaXNBZGRyZXNzYWJsZSIsImdldENyZWF0ZTJBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsImdldEljYXBBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImFkZHJlc3NfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiY29udHJhY3RfYWRkcmVzc19qc18xIiwiY2hlY2tzX2pzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/constants/addresses.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/addresses.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ZeroAddress = void 0;\n/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */ exports.ZeroAddress = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCOzs7O0NBSUMsR0FDREEsbUJBQW1CLEdBQUcsOENBQ3RCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9hZGRyZXNzZXMuanM/N2ExOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWmVyb0FkZHJlc3MgPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBhZGRyZXNzLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydHMuWmVyb0FkZHJlc3MgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlplcm9BZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/constants/addresses.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/constants/hashes.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/hashes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ZeroHash = void 0;\n/**\n *  A constant for the zero hash.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000000000000000000000000000\"``)\n */ exports.ZeroHash = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvaGFzaGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCOzs7O0NBSUMsR0FDREEsZ0JBQWdCLEdBQUcsc0VBQ25CLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9oYXNoZXMuanM/ZDc0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWmVyb0hhc2ggPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgemVybyBoYXNoLlxuICpcbiAqICAoKippLmUuKiogYGBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiYGApXG4gKi9cbmV4cG9ydHMuWmVyb0hhc2ggPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlplcm9IYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/constants/hashes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Some common constants useful for Ethereum.\n *\n *  @_section: api/constants: Constants  [about-constants]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;\nvar addresses_js_1 = __webpack_require__(/*! ./addresses.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/addresses.js\");\nObject.defineProperty(exports, \"ZeroAddress\", ({\n    enumerable: true,\n    get: function() {\n        return addresses_js_1.ZeroAddress;\n    }\n}));\nvar hashes_js_1 = __webpack_require__(/*! ./hashes.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/hashes.js\");\nObject.defineProperty(exports, \"ZeroHash\", ({\n    enumerable: true,\n    get: function() {\n        return hashes_js_1.ZeroHash;\n    }\n}));\nvar numbers_js_1 = __webpack_require__(/*! ./numbers.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/numbers.js\");\nObject.defineProperty(exports, \"N\", ({\n    enumerable: true,\n    get: function() {\n        return numbers_js_1.N;\n    }\n}));\nObject.defineProperty(exports, \"WeiPerEther\", ({\n    enumerable: true,\n    get: function() {\n        return numbers_js_1.WeiPerEther;\n    }\n}));\nObject.defineProperty(exports, \"MaxUint256\", ({\n    enumerable: true,\n    get: function() {\n        return numbers_js_1.MaxUint256;\n    }\n}));\nObject.defineProperty(exports, \"MinInt256\", ({\n    enumerable: true,\n    get: function() {\n        return numbers_js_1.MinInt256;\n    }\n}));\nObject.defineProperty(exports, \"MaxInt256\", ({\n    enumerable: true,\n    get: function() {\n        return numbers_js_1.MaxInt256;\n    }\n}));\nvar strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/strings.js\");\nObject.defineProperty(exports, \"EtherSymbol\", ({\n    enumerable: true,\n    get: function() {\n        return strings_js_1.EtherSymbol;\n    }\n}));\nObject.defineProperty(exports, \"MessagePrefix\", ({\n    enumerable: true,\n    get: function() {\n        return strings_js_1.MessagePrefix;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7OztDQUlDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxTQUFTLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQzNMLElBQUlXLGlCQUFpQkMsbUJBQU9BLENBQUMsdUZBQWdCO0FBQzdDZCwrQ0FBOEM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsZUFBZUQsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVILElBQUlLLGNBQWNILG1CQUFPQSxDQUFDLGlGQUFhO0FBQ3ZDZCw0Q0FBMkM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsWUFBWU4sUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25ILElBQUlPLGVBQWVKLG1CQUFPQSxDQUFDLG1GQUFjO0FBQ3pDZCxxQ0FBb0M7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsYUFBYVIsQ0FBQztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RHViwrQ0FBOEM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsYUFBYVQsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFIVCw4Q0FBNkM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsYUFBYVYsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hIUiw2Q0FBNEM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsYUFBYVgsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RIUCw2Q0FBNEM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsYUFBYVosU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RILElBQUlhLGVBQWVMLG1CQUFPQSxDQUFDLG1GQUFjO0FBQ3pDZCwrQ0FBOEM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csYUFBYWQsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFITCxpREFBZ0Q7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csYUFBYWYsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQzlILGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9pbmRleC5qcz83OTBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgU29tZSBjb21tb24gY29uc3RhbnRzIHVzZWZ1bCBmb3IgRXRoZXJldW0uXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2NvbnN0YW50czogQ29uc3RhbnRzICBbYWJvdXQtY29uc3RhbnRzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VQcmVmaXggPSBleHBvcnRzLkV0aGVyU3ltYm9sID0gZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLk4gPSBleHBvcnRzLlplcm9IYXNoID0gZXhwb3J0cy5aZXJvQWRkcmVzcyA9IHZvaWQgMDtcbnZhciBhZGRyZXNzZXNfanNfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3Nlcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlplcm9BZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzZXNfanNfMS5aZXJvQWRkcmVzczsgfSB9KTtcbnZhciBoYXNoZXNfanNfMSA9IHJlcXVpcmUoXCIuL2hhc2hlcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlplcm9IYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfanNfMS5aZXJvSGFzaDsgfSB9KTtcbnZhciBudW1iZXJzX2pzXzEgPSByZXF1aXJlKFwiLi9udW1iZXJzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXZWlQZXJFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLldlaVBlckV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWF4VWludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVtYmVyc19qc18xLk1heFVpbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaW5JbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bWJlcnNfanNfMS5NaW5JbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYXhJbnQyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bWJlcnNfanNfMS5NYXhJbnQyNTY7IH0gfSk7XG52YXIgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4vc3RyaW5ncy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyU3ltYm9sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuRXRoZXJTeW1ib2w7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlUHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdzX2pzXzEuTWVzc2FnZVByZWZpeDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1lc3NhZ2VQcmVmaXgiLCJFdGhlclN5bWJvbCIsIk1heEludDI1NiIsIk1pbkludDI1NiIsIk1heFVpbnQyNTYiLCJXZWlQZXJFdGhlciIsIk4iLCJaZXJvSGFzaCIsIlplcm9BZGRyZXNzIiwiYWRkcmVzc2VzX2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImhhc2hlc19qc18xIiwibnVtYmVyc19qc18xIiwic3RyaW5nc19qc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/constants/numbers.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/numbers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;\n/**\n *  A constant for the order N for the secp256k1 curve.\n *\n *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)\n */ exports.N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n/**\n *  A constant for the number of wei in a single ether.\n *\n *  (**i.e.** ``1000000000000000000n``)\n */ exports.WeiPerEther = BigInt(\"1000000000000000000\");\n/**\n *  A constant for the maximum value for a ``uint256``.\n *\n *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */ exports.MaxUint256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  A constant for the minimum value for an ``int256``.\n *\n *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)\n */ exports.MinInt256 = BigInt(\"0x8000000000000000000000000000000000000000000000000000000000000000\") * BigInt(-1);\n/**\n *  A constant for the maximum value for an ``int256``.\n *\n *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)\n */ exports.MaxInt256 = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"); //# sourceMappingURL=numbers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLFNBQVMsR0FBRyxLQUFLO0FBQ3BHOzs7O0NBSUMsR0FDREEsU0FBUyxHQUFHTyxPQUFPO0FBQ25COzs7O0NBSUMsR0FDRFAsbUJBQW1CLEdBQUdPLE9BQU87QUFDN0I7Ozs7Q0FJQyxHQUNEUCxrQkFBa0IsR0FBR08sT0FBTztBQUM1Qjs7OztDQUlDLEdBQ0RQLGlCQUFpQixHQUFHTyxPQUFPLHdFQUF3RUEsT0FBTyxDQUFDO0FBQzNHOzs7O0NBSUMsR0FDRFAsaUJBQWlCLEdBQUdPLE9BQU8sdUVBQzNCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnN0YW50cy9udW1iZXJzLmpzPzI0YjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heEludDI1NiA9IGV4cG9ydHMuTWluSW50MjU2ID0gZXhwb3J0cy5NYXhVaW50MjU2ID0gZXhwb3J0cy5XZWlQZXJFdGhlciA9IGV4cG9ydHMuTiA9IHZvaWQgMDtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBvcmRlciBOIGZvciB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqICAoKippLmUuKiogYGAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFuYGApXG4gKi9cbmV4cG9ydHMuTiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBudW1iZXIgb2Ygd2VpIGluIGEgc2luZ2xlIGV0aGVyLlxuICpcbiAqICAoKippLmUuKiogYGAxMDAwMDAwMDAwMDAwMDAwMDAwbmBgKVxuICovXG5leHBvcnRzLldlaVBlckV0aGVyID0gQmlnSW50KFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhIGBgdWludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuYGApXG4gKi9cbmV4cG9ydHMuTWF4VWludDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbi8qKlxuICogIEEgY29uc3RhbnQgZm9yIHRoZSBtaW5pbXVtIHZhbHVlIGZvciBhbiBgYGludDI1NmBgLlxuICpcbiAqICAoKippLmUuKiogYGAtODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMG5gYClcbiAqL1xuZXhwb3J0cy5NaW5JbnQyNTYgPSBCaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikgKiBCaWdJbnQoLTEpO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIG1heGltdW0gdmFsdWUgZm9yIGFuIGBgaW50MjU2YGAuXG4gKlxuICogICgqKmkuZS4qKiBgYDB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm5gYClcbiAqL1xuZXhwb3J0cy5NYXhJbnQyNTYgPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1heEludDI1NiIsIk1pbkludDI1NiIsIk1heFVpbnQyNTYiLCJXZWlQZXJFdGhlciIsIk4iLCJCaWdJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/constants/numbers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/constants/strings.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/constants/strings.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// NFKC (composed)             // (decomposed)\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MessagePrefix = exports.EtherSymbol = void 0;\n/**\n *  A constant for the ether symbol (normalized using NFKC).\n *\n *  (**i.e.** ``\"\\\\u039e\"``)\n */ exports.EtherSymbol = \"Ξ\"; // \"\\uD835\\uDF63\";\n/**\n *  A constant for the [[link-eip-191]] personal message prefix.\n *\n *  (**i.e.** ``\"\\\\x19Ethereum Signed Message:\\\\n\"``)\n */ exports.MessagePrefix = \"\\x19Ethereum Signed Message:\\n\"; //# sourceMappingURL=strings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb25zdGFudHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QztBQUM5Q0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQ25EOzs7O0NBSUMsR0FDREEsbUJBQW1CLEdBQUcsS0FBVSxrQkFBa0I7QUFDbEQ7Ozs7Q0FJQyxHQUNEQSxxQkFBcUIsR0FBRyxrQ0FDeEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY29uc3RhbnRzL3N0cmluZ3MuanM/MTgwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE5GS0MgKGNvbXBvc2VkKSAgICAgICAgICAgICAvLyAoZGVjb21wb3NlZClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IGV4cG9ydHMuRXRoZXJTeW1ib2wgPSB2b2lkIDA7XG4vKipcbiAqICBBIGNvbnN0YW50IGZvciB0aGUgZXRoZXIgc3ltYm9sIChub3JtYWxpemVkIHVzaW5nIE5GS0MpLlxuICpcbiAqICAoKippLmUuKiogYGBcIlxcXFx1MDM5ZVwiYGApXG4gKi9cbmV4cG9ydHMuRXRoZXJTeW1ib2wgPSBcIlxcdTAzOWVcIjsgLy8gXCJcXHVEODM1XFx1REY2M1wiO1xuLyoqXG4gKiAgQSBjb25zdGFudCBmb3IgdGhlIFtbbGluay1laXAtMTkxXV0gcGVyc29uYWwgbWVzc2FnZSBwcmVmaXguXG4gKlxuICogICgqKmkuZS4qKiBgYFwiXFxcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcXFxuXCJgYClcbiAqL1xuZXhwb3J0cy5NZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNZXNzYWdlUHJlZml4IiwiRXRoZXJTeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/constants/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/contract/contract.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/contract.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\");\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n    return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n    return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n    return value && typeof value.sendTransaction === \"function\";\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    constructor(contract, fragment, args){\n        (0, index_js_3.defineProperties)(this, {\n            fragment\n        });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index)=>{\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value)=>{\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v)=>(0, index_js_2.resolveAddress)(v, resolver)));\n                        }\n                        return (0, index_js_2.resolveAddress)(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        }();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value[feature] === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof value.provider[feature] === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */ async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = index_js_1.Typed.dereference(arg, \"overrides\");\n    (0, index_js_3.assertArgument)(typeof _overrides === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = (0, provider_js_1.copyRequest)(_overrides);\n    (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\nexports.copyOverrides = copyOverrides;\n/**\n *  @_ignore:\n */ async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index)=>{\n        return param.walkAsync(args[index], (type, value)=>{\n            value = index_js_1.Typed.dereference(value, type);\n            if (type === \"address\") {\n                return (0, index_js_2.resolveAddress)(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nexports.resolveArgs = resolveArgs;\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function(overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = await copyOverrides(overrides, [\n            \"data\"\n        ]);\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, \"overrides.value\") === BN_0;\n        const noData = (tx.data || \"0x\") === \"0x\";\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            (0, index_js_3.assertArgument)(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || iface.fallback && iface.fallback.payable;\n        (0, index_js_3.assertArgument)(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        (0, index_js_3.assertArgument)(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function(overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        } catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function(overrides) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides)=>{\n        return await send(overrides);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function(...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function(...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function(...args) {\n        const runner = contract.runner;\n        (0, index_js_3.assert)(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function(...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        (0, index_js_3.assert)(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"estimateGas\"\n        });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function(...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        (0, index_js_3.assert)(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"call\"\n        });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error) {\n            if ((0, index_js_3.isCallException)(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args)=>{\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract,\n        _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send,\n        staticCall,\n        staticCallResult\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getFunction(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function(...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: {\n                key,\n                args\n            }\n        });\n        return fragment;\n    };\n    const method = function(...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    (0, index_js_3.defineProperties)(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract,\n        _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: ()=>{\n            const fragment = contract.interface.getEvent(key);\n            (0, index_js_3.assert)(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: {\n                    key\n                }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function(name) {\n            if ((0, index_js_3.isHexString)(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e)=>{\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    } else if (event === \"*\") {\n        topics = [\n            null\n        ];\n    } else if (typeof event === \"string\") {\n        if ((0, index_js_3.isHexString)(event, 32)) {\n            // Topic Hash\n            topics = [\n                event\n            ];\n        } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            (0, index_js_3.assertArgument)(fragment, \"unknown fragment\", \"event\", event);\n            topics = [\n                fragment.topicHash\n            ];\n        }\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [\n            fragment.topicHash\n        ];\n    } else {\n        (0, index_js_3.assertArgument)(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t)=>{\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t)=>t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t)=>{\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return {\n        fragment,\n        tag,\n        topics\n    };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    (0, index_js_3.assert)(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = addr ? addr : contract;\n        const filter = {\n            address,\n            topics\n        };\n        const listener = (log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener)=>{\n                    return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [], (listener)=>{\n                    return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = ()=>{\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async ()=>{\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = {\n            tag,\n            listeners: [],\n            start,\n            stop\n        };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once })=>{\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) {}\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return count > 0;\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    } catch (error) {}\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\n    \"then\"\n];\nclass BaseContract {\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */ constructor(target, abi, runner, _deployTx){\n        (0, index_js_3.assertArgument)(typeof target === \"string\" || (0, index_js_2.isAddressable)(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = index_js_1.Interface.from(abi);\n        (0, index_js_3.defineProperties)(this, {\n            target,\n            runner,\n            interface: iface\n        });\n        Object.defineProperty(this, internal, {\n            value: {}\n        });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof target === \"string\") {\n            if ((0, index_js_3.isHexString)(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw (0, index_js_3.makeError)(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr)=>{\n                    if (addr == null) {\n                        throw (0, index_js_3.makeError)(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr)=>{\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, {\n            addrPromise,\n            addr,\n            deployTx,\n            subs\n        });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (typeof prop === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                } catch (error) {\n                    if (!(0, index_js_3.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        (0, index_js_3.defineProperties)(this, {\n            filters\n        });\n        (0, index_js_3.defineProperties)(this, {\n            fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                } catch (error) {\n                    if (!(0, index_js_3.isError)(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop)=>{\n                if (typeof prop === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */ connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */ attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */ async getAddress() {\n        return await getInternal(this).addrPromise;\n    }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */ async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getDeployedCode\"\n        });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */ async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"waitForDeployment\"\n        });\n        return new Promise((resolve, reject)=>{\n            const checkCode = async ()=>{\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */ deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getFunction(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */ getEvent(key) {\n        if (typeof key !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */ async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */ /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */ async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = addr ? addr : await addrPromise;\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = {\n            address,\n            topics,\n            fromBlock,\n            toBlock\n        };\n        const provider = getProvider(this.runner);\n        (0, index_js_3.assert)(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"queryFilter\"\n        });\n        return (await provider.getLogs(filter)).map((log)=>{\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n            }\n            if (foundFragment) {\n                try {\n                    return new wrappers_js_1.EventLog(log, this.interface, foundFragment);\n                } catch (error) {\n                    return new wrappers_js_1.UndecodedEventLog(log, error);\n                }\n            }\n            return new provider_js_1.Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */ async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */ async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */ async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */ async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */ async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */ async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */ async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()){\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */ async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */ async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */ static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null){\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */ static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nexports.BaseContract = BaseContract;\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */ class Contract extends _ContractBase() {\n}\nexports.Contract = Contract; //# sourceMappingURL=contract.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUM3RixNQUFNTSxhQUFhQyxtQkFBT0EsQ0FBQyw4RUFBaUI7QUFDNUMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsc0ZBQXFCO0FBQ2hELHNFQUFzRTtBQUN0RSx5QkFBeUI7QUFDekIsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyxnR0FBMEI7QUFDeEQsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1JLGdCQUFnQkosbUJBQU9BLENBQUMsb0ZBQWU7QUFDN0MsTUFBTUssT0FBT0MsT0FBTztBQUNwQixTQUFTQyxRQUFRYixLQUFLO0lBQ2xCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTWMsSUFBSSxLQUFNO0FBQzdDO0FBQ0EsU0FBU0MsWUFBWWYsS0FBSztJQUN0QixPQUFRQSxTQUFTLE9BQVFBLE1BQU1nQixXQUFXLEtBQU07QUFDcEQ7QUFDQSxTQUFTQyxXQUFXakIsS0FBSztJQUNyQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1rQixXQUFXLEtBQU07QUFDcEQ7QUFDQSxTQUFTQyxRQUFRbkIsS0FBSztJQUNsQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1vQixlQUFlLEtBQU07QUFDeEQ7QUFDQSxTQUFTQyxZQUFZckIsS0FBSztJQUN0QixJQUFJQSxTQUFTLE1BQU07UUFDZixJQUFJaUIsV0FBV2pCLFFBQVE7WUFDbkIsT0FBT0E7UUFDWDtRQUNBLElBQUlBLE1BQU1zQixRQUFRLEVBQUU7WUFDaEIsT0FBT3RCLE1BQU1zQixRQUFRO1FBQ3pCO0lBQ0o7SUFDQSxPQUFPQztBQUNYO0FBQ0EsTUFBTUM7SUFDRixDQUFD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USxFQUFFO1FBQy9CLE9BQU8sTUFBTSxJQUFJLENBQUNXLEVBQUUsQ0FBQzlCLE9BQU9tQjtJQUNoQztJQUNBOztLQUVDLEdBQ0QsTUFBTXlFLGVBQWU1RixLQUFLLEVBQUVtQixRQUFRLEVBQUU7UUFDbEMsT0FBTyxNQUFNLElBQUksQ0FBQ2MsR0FBRyxDQUFDakMsT0FBT21CO0lBQ2pDO0lBQ0E7O0tBRUMsR0FDRCxPQUFPMEUsV0FBVy9DLEdBQUcsRUFBRTtRQUNuQixNQUFNZ0QsdUJBQXVCck47WUFDekJ3QixZQUFZaUgsT0FBTyxFQUFFekcsU0FBUyxJQUFJLENBQUU7Z0JBQ2hDLEtBQUssQ0FBQ3lHLFNBQVM0QixLQUFLckk7WUFDeEI7UUFDSjtRQUNBLE9BQU9xTDtJQUNYO0lBRUE7O0tBRUMsR0FDRCxPQUFPdEosS0FBS3FHLE1BQU0sRUFBRUMsR0FBRyxFQUFFckksTUFBTSxFQUFFO1FBQzdCLElBQUlBLFVBQVUsTUFBTTtZQUNoQkEsU0FBUztRQUNiO1FBQ0EsTUFBTVAsV0FBVyxJQUFJLElBQUksQ0FBQzJJLFFBQVFDLEtBQUtySTtRQUN2QyxPQUFPUDtJQUNYO0FBQ0o7QUFDQTVCLG9CQUFvQixHQUFHRztBQUN2QixTQUFTc047SUFDTCxPQUFPdE47QUFDWDtBQUNBOztDQUVDLEdBQ0QsTUFBTUQsaUJBQWlCdU47QUFDdkI7QUFDQXpOLGdCQUFnQixHQUFHRSxVQUNuQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9jb250cmFjdC5qcz83NGFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gZXhwb3J0cy5yZXNvbHZlQXJncyA9IGV4cG9ydHMuY29weU92ZXJyaWRlcyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWJpL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuLy8gaW1wb3J0IGZyb20gcHJvdmlkZXIudHMgaW5zdGVhZCBvZiBpbmRleC50cyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcFxuLy8gZnJvbSBFdGhlcnNjYW5Qcm92aWRlclxuY29uc3QgcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9wcm92aWRlcnMvcHJvdmlkZXIuanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgd3JhcHBlcnNfanNfMSA9IHJlcXVpcmUoXCIuL3dyYXBwZXJzLmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGNhbkNhbGwodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuY2FsbCkgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5Fc3RpbWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5lc3RpbWF0ZUdhcykgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBjYW5SZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlc29sdmVOYW1lKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGNhblNlbmQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNhblJlc29sdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFByZXBhcmVkVG9waWNGaWx0ZXIge1xuICAgICNmaWx0ZXI7XG4gICAgZnJhZ21lbnQ7XG4gICAgY29uc3RydWN0b3IoY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZnJhZ21lbnQgfSk7XG4gICAgICAgIGlmIChmcmFnbWVudC5pbnB1dHMubGVuZ3RoIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBkZXNjZW5kIGludG8gYXJncyBhbmQgcmVzb2x2ZSBhbnkgYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gKGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IFByb21pc2UuYWxsKGZyYWdtZW50LmlucHV0cy5tYXAoKHBhcmFtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtLndhbGtBc3luYyhhcmdzW2luZGV4XSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHYsIHJlc29sdmVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKSh2YWx1ZSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRmlsdGVyVG9waWNzKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRUb3BpY0ZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZpbHRlcjtcbiAgICB9XG59XG4vLyBBID0gQXJndW1lbnRzIHBhc3NlZCBpbiBhcyBhIHR1cGxlXG4vLyBSID0gVGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBjYWxsIChpLmUuIGlmIG9ubHkgb25lIHJldHVybiB0eXBlLFxuLy8gICAgIHRoZSBxdWFsaWZpZWQgdHlwZSwgb3RoZXJ3aXNlIFJlc3VsdClcbi8vIEQgPSBUaGUgdHlwZSB0aGUgZGVmYXVsdCBjYWxsIHdpbGwgcmV0dXJuIChpLmUuIFIgZm9yIHZpZXcvcHVyZSxcbi8vICAgICBUcmFuc2FjdGlvblJlc3BvbnNlIG90aGVyd2lzZSlcbi8vZXhwb3J0IGludGVyZmFjZSBDb250cmFjdE1ldGhvZDxBIGV4dGVuZHMgQXJyYXk8YW55PiA9IEFycmF5PGFueT4sIFIgPSBhbnksIEQgZXh0ZW5kcyBSIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlPiB7XG5mdW5jdGlvbiBnZXRSdW5uZXIodmFsdWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWVbZmVhdHVyZV0pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUucHJvdmlkZXIgJiYgdHlwZW9mICh2YWx1ZS5wcm92aWRlcltmZWF0dXJlXSkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUucHJvdmlkZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJvdmlkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnByb3ZpZGVyIHx8IG51bGw7XG59XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weU92ZXJyaWRlcyhhcmcsIGFsbG93ZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG92ZXJyaWRlcyBwYXNzZWQgaW4gYXJlIGEgdmFsaWQgb3ZlcnJpZGVzIG9iamVjdFxuICAgIGNvbnN0IF9vdmVycmlkZXMgPSBpbmRleF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKGFyZywgXCJvdmVycmlkZXNcIik7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAoX292ZXJyaWRlcykgPT09IFwib2JqZWN0XCIsIFwiaW52YWxpZCBvdmVycmlkZXMgcGFyYW1ldGVyXCIsIFwib3ZlcnJpZGVzXCIsIGFyZyk7XG4gICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5ICh3ZSdsbCBkZWVwLWlmeSBhbnl0aGluZyBuZWVkZWQgZHVyaW5nIG5vcm1hbGl6aW5nKVxuICAgIGNvbnN0IG92ZXJyaWRlcyA9ICgwLCBwcm92aWRlcl9qc18xLmNvcHlSZXF1ZXN0KShfb3ZlcnJpZGVzKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkob3ZlcnJpZGVzLnRvID09IG51bGwgfHwgKGFsbG93ZWQgfHwgW10pLmluZGV4T2YoXCJ0b1wiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSB0b1wiLCBcIm92ZXJyaWRlcy50b1wiLCBvdmVycmlkZXMudG8pO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShvdmVycmlkZXMuZGF0YSA9PSBudWxsIHx8IChhbGxvd2VkIHx8IFtdKS5pbmRleE9mKFwiZGF0YVwiKSA+PSAwLCBcImNhbm5vdCBvdmVycmlkZSBkYXRhXCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgb3ZlcnJpZGVzLmRhdGEpO1xuICAgIC8vIFJlc29sdmUgYW55IGZyb21cbiAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBvdmVycmlkZXMuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJyaWRlcztcbn1cbmV4cG9ydHMuY29weU92ZXJyaWRlcyA9IGNvcHlPdmVycmlkZXM7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFyZ3MoX3J1bm5lciwgaW5wdXRzLCBhcmdzKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVzY2VuZCBpbnRvIGFyZ3MgYW5kIHJlc29sdmUgYW55IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihfcnVubmVyLCBcInJlc29sdmVOYW1lXCIpO1xuICAgIGNvbnN0IHJlc29sdmVyID0gY2FuUmVzb2x2ZShydW5uZXIpID8gcnVubmVyIDogbnVsbDtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaW5wdXRzLm1hcCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBwYXJhbS53YWxrQXN5bmMoYXJnc1tpbmRleF0sICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSBpbmRleF9qc18xLlR5cGVkLmRlcmVmZXJlbmNlKHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodmFsdWUsIHJlc29sdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufVxuZXhwb3J0cy5yZXNvbHZlQXJncyA9IHJlc29sdmVBcmdzO1xuZnVuY3Rpb24gYnVpbGRXcmFwcGVkRmFsbGJhY2soY29udHJhY3QpIHtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICAvLyBJZiBhbiBvdmVycmlkZXMgd2FzIHBhc3NlZCBpbiwgY29weSBpdCBhbmQgbm9ybWFsaXplIHRoZSB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHggPSAoYXdhaXQgY29weU92ZXJyaWRlcyhvdmVycmlkZXMsIFtcImRhdGFcIl0pKTtcbiAgICAgICAgdHgudG8gPSBhd2FpdCBjb250cmFjdC5nZXRBZGRyZXNzKCk7XG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gYXdhaXQgKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKHR4LmZyb20sIGdldFJlc29sdmVyKGNvbnRyYWN0LnJ1bm5lcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlmYWNlID0gY29udHJhY3QuaW50ZXJmYWNlO1xuICAgICAgICBjb25zdCBub1ZhbHVlID0gKCgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkoKHR4LnZhbHVlIHx8IEJOXzApLCBcIm92ZXJyaWRlcy52YWx1ZVwiKSA9PT0gQk5fMCk7XG4gICAgICAgIGNvbnN0IG5vRGF0YSA9ICgodHguZGF0YSB8fCBcIjB4XCIpID09PSBcIjB4XCIpO1xuICAgICAgICBpZiAoaWZhY2UuZmFsbGJhY2sgJiYgIWlmYWNlLmZhbGxiYWNrLnBheWFibGUgJiYgaWZhY2UucmVjZWl2ZSAmJiAhbm9EYXRhICYmICFub1ZhbHVlKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiY2Fubm90IHNlbmQgZGF0YSB0byByZWNlaXZlIG9yIHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZmFsbGJhY2tcIiwgXCJvdmVycmlkZXNcIiwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgcGF5YWJsZSBjb250cmFjdHMgdG8gc2V0IG5vbi16ZXJvIHZhbHVlXG4gICAgICAgIGNvbnN0IHBheWFibGUgPSBpZmFjZS5yZWNlaXZlIHx8IChpZmFjZS5mYWxsYmFjayAmJiBpZmFjZS5mYWxsYmFjay5wYXlhYmxlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHBheWFibGUgfHwgbm9WYWx1ZSwgXCJjYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBmYWxsYmFja1wiLCBcIm92ZXJyaWRlcy52YWx1ZVwiLCB0eC52YWx1ZSk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgZmFsbGJhY2sgY29udHJhY3RzIHRvIHNldCBub24tZW1wdHkgZGF0YVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoaWZhY2UuZmFsbGJhY2sgfHwgbm9EYXRhLCBcImNhbm5vdCBzZW5kIGRhdGEgdG8gcmVjZWl2ZS1vbmx5IGNvbnRyYWN0XCIsIFwib3ZlcnJpZGVzLmRhdGFcIiwgdHguZGF0YSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbihvdmVycmlkZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0NhbGxFeGNlcHRpb24pKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gY29udHJhY3QucnVubmVyO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGNhblNlbmQocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBzZW5kaW5nIHRyYW5zYWN0aW9uc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIiB9KTtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBydW5uZXIuc2VuZFRyYW5zYWN0aW9uKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoY29udHJhY3QucnVubmVyKTtcbiAgICAgICAgLy8gQFRPRE86IHRoZSBwcm92aWRlciBjYW4gYmUgbnVsbDsgbWFrZSBhIGN1c3RvbSBkdW1teSBwcm92aWRlciB0aGF0IHdpbGwgdGhyb3cgYVxuICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UoY29udHJhY3QuaW50ZXJmYWNlLCBwcm92aWRlciwgdHgpO1xuICAgIH07XG4gICAgY29uc3QgZXN0aW1hdGVHYXMgPSBhc3luYyBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24ob3ZlcnJpZGVzKSk7XG4gICAgfTtcbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyAob3ZlcnJpZGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kKG92ZXJyaWRlcyk7XG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKShtZXRob2QsIHtcbiAgICAgICAgX2NvbnRyYWN0OiBjb250cmFjdCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24sXG4gICAgICAgIHNlbmQsIHN0YXRpY0NhbGxcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxuZnVuY3Rpb24gYnVpbGRXcmFwcGVkTWV0aG9kKGNvbnRyYWN0LCBrZXkpIHtcbiAgICBjb25zdCBnZXRGcmFnbWVudCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSwgYXJncyk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICBpbmZvOiB7IGtleSwgYXJncyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfTtcbiAgICBjb25zdCBwb3B1bGF0ZVRyYW5zYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgLy8gSWYgYW4gb3ZlcnJpZGVzIHdhcyBwYXNzZWQgaW4sIGNvcHkgaXQgYW5kIG5vcm1hbGl6ZSB0aGUgdmFsdWVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxID09PSBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gYXdhaXQgY29weU92ZXJyaWRlcyhhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gYXdhaXQgKDAsIGluZGV4X2pzXzIucmVzb2x2ZUFkZHJlc3MpKG92ZXJyaWRlcy5mcm9tLCBnZXRSZXNvbHZlcihjb250cmFjdC5ydW5uZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsIGVycm9yOiBmcmFnbWVudCBpbnB1dHMgZG9lc24ndCBtYXRjaCBhcmd1bWVudHM7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0IHJlc29sdmVBcmdzKGNvbnRyYWN0LnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywgYXdhaXQgKDAsIGluZGV4X2pzXzMucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIHRvOiBjb250cmFjdC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBkYXRhOiBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZEFyZ3MpXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0aWNDYWxsUmVzdWx0KC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgc2VuZCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGNvbnRyYWN0LnJ1bm5lcjtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShjYW5TZW5kKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwic2VuZFRyYW5zYWN0aW9uXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcnVubmVyLnNlbmRUcmFuc2FjdGlvbihhd2FpdCBwb3B1bGF0ZVRyYW5zYWN0aW9uKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgIC8vIG1lYW5pbmdmdWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIG5ldyB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZShjb250cmFjdC5pbnRlcmZhY2UsIHByb3ZpZGVyLCB0eCk7XG4gICAgfTtcbiAgICBjb25zdCBlc3RpbWF0ZUdhcyA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoY2FuRXN0aW1hdGUocnVubmVyKSwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCBnYXMgZXN0aW1hdGlvblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJlc3RpbWF0ZUdhc1wiIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVubmVyLmVzdGltYXRlR2FzKGF3YWl0IHBvcHVsYXRlVHJhbnNhY3Rpb24oLi4uYXJncykpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQ2FsbFJlc3VsdCA9IGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGdldFJ1bm5lcihjb250cmFjdC5ydW5uZXIsIFwiY2FsbFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShjYW5DYWxsKHJ1bm5lciksIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZ1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJjYWxsXCIgfSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcG9wdWxhdGVUcmFuc2FjdGlvbiguLi5hcmdzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bm5lci5jYWxsKHR4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0NhbGxFeGNlcHRpb24pKGVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJhY3QuaW50ZXJmYWNlLm1ha2VFcnJvcihlcnJvci5kYXRhLCB0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGdldEZyYWdtZW50KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBnZXRGcmFnbWVudCguLi5hcmdzKTtcbiAgICAgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc3RhdGljQ2FsbCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc2VuZCguLi5hcmdzKTtcbiAgICB9O1xuICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKG1ldGhvZCwge1xuICAgICAgICBuYW1lOiBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RnVuY3Rpb25OYW1lKGtleSksXG4gICAgICAgIF9jb250cmFjdDogY29udHJhY3QsIF9rZXk6IGtleSxcbiAgICAgICAgZ2V0RnJhZ21lbnQsXG4gICAgICAgIGVzdGltYXRlR2FzLFxuICAgICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kLCBzdGF0aWNDYWxsLCBzdGF0aWNDYWxsUmVzdWx0LFxuICAgIH0pO1xuICAgIC8vIE9ubHkgd29ya3Mgb24gbm9uLWFtYmlndW91cyBrZXlzIChyZWZpbmVkIGZyYWdtZW50IGlzIGFsd2F5cyBub24tYW1iaWd1b3VzKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXRob2QsIFwiZnJhZ21lbnRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gY29udHJhY3QuaW50ZXJmYWNlLmdldEZ1bmN0aW9uKGtleSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJhZ21lbnRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IGtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5mdW5jdGlvbiBidWlsZFdyYXBwZWRFdmVudChjb250cmFjdCwga2V5KSB7XG4gICAgY29uc3QgZ2V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChrZXksIGFyZ3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZyYWdtZW50LCBcIm5vIG1hdGNoaW5nIGZyYWdtZW50XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgaW5mbzogeyBrZXksIGFyZ3MgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH07XG4gICAgY29uc3QgbWV0aG9kID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFRvcGljRmlsdGVyKGNvbnRyYWN0LCBnZXRGcmFnbWVudCguLi5hcmdzKSwgYXJncyk7XG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKShtZXRob2QsIHtcbiAgICAgICAgbmFtZTogY29udHJhY3QuaW50ZXJmYWNlLmdldEV2ZW50TmFtZShrZXkpLFxuICAgICAgICBfY29udHJhY3Q6IGNvbnRyYWN0LCBfa2V5OiBrZXksXG4gICAgICAgIGdldEZyYWdtZW50XG4gICAgfSk7XG4gICAgLy8gT25seSB3b3JrcyBvbiBub24tYW1iaWd1b3VzIGtleXMgKHJlZmluZWQgZnJhZ21lbnQgaXMgYWx3YXlzIG5vbi1hbWJpZ3VvdXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1ldGhvZCwgXCJmcmFnbWVudFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQoa2V5KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZnJhZ21lbnQsIFwibm8gbWF0Y2hpbmcgZnJhZ21lbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmcmFnbWVudFwiLFxuICAgICAgICAgICAgICAgIGluZm86IHsga2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8vIFRoZSBjb21iaW5hdGlvbiBvZiBUeXBlU2NyeXBlLCBQcml2YXRlIEZpZWxkcyBhbmQgUHJveGllcyBtYWtlc1xuLy8gdGhlIHdvcmxkIGdvIGJvb207IHNvIHdlIGhpZGUgdmFyaWFibGVzIHdpdGggc29tZSB0cmlja2VyeSBrZWVwaW5nXG4vLyBhIHN5bWJvbCBhdHRhY2hlZCB0byBlYWNoIEJhc2VDb250cmFjdCB3aGljaCBpdHMgc3ViLWNsYXNzIChldmVuXG4vLyB2aWEgYSBQcm94eSkgY2FuIHJlYWNoIGFuZCB1c2UgdG8gbG9vayB1cCBpdHMgaW50ZXJuYWwgdmFsdWVzLlxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2wuZm9yKFwiX2V0aGVyc0ludGVybmFsX2NvbnRyYWN0XCIpO1xuY29uc3QgaW50ZXJuYWxWYWx1ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0SW50ZXJuYWwoY29udHJhY3QsIHZhbHVlcykge1xuICAgIGludGVybmFsVmFsdWVzLnNldChjb250cmFjdFtpbnRlcm5hbF0sIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbChjb250cmFjdCkge1xuICAgIHJldHVybiBpbnRlcm5hbFZhbHVlcy5nZXQoY29udHJhY3RbaW50ZXJuYWxdKTtcbn1cbmZ1bmN0aW9uIGlzRGVmZXJyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmIChcImdldFRvcGljRmlsdGVyXCIgaW4gdmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgKHZhbHVlLmdldFRvcGljRmlsdGVyKSA9PT0gXCJmdW5jdGlvblwiKSAmJiB2YWx1ZS5mcmFnbWVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkge1xuICAgIGxldCB0b3BpY3M7XG4gICAgbGV0IGZyYWdtZW50ID0gbnVsbDtcbiAgICAvLyBDb252ZXJ0IG5hbWVkIGV2ZW50cyB0byB0b3BpY0hhc2ggYW5kIGdldCB0aGUgZnJhZ21lbnQgZm9yXG4gICAgLy8gZXZlbnRzIHdoaWNoIG5lZWQgZGVjb25zdHJ1Y3RpbmcuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRvcGljSGFzaGlmeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKG5hbWUsIDMyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBjb250cmFjdC5pbnRlcmZhY2UuZ2V0RXZlbnQobmFtZSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnQudG9waWNIYXNoO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBcnJheSBvZiBUb3BpY3MgYW5kIE5hbWVzOyBlLmcuIGBbIFwiMHgxMjM0Li4uODlhYlwiLCBcIlRyYW5zZmVyKGFkZHJlc3MpXCIgXWBcbiAgICAgICAgdG9waWNzID0gZXZlbnQubWFwKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLm1hcCh0b3BpY0hhc2hpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvcGljSGFzaGlmeShlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSBcIipcIikge1xuICAgICAgICB0b3BpY3MgPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXZlbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfMy5pc0hleFN0cmluZykoZXZlbnQsIDMyKSkge1xuICAgICAgICAgICAgLy8gVG9waWMgSGFzaFxuICAgICAgICAgICAgdG9waWNzID0gW2V2ZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5hbWUgb3IgU2lnbmF0dXJlOyBlLmcuIGBcIlRyYW5zZmVyXCIsIGBcIlRyYW5zZmVyKGFkZHJlc3MpXCJgXG4gICAgICAgICAgICBmcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChldmVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZnJhZ21lbnQsIFwidW5rbm93biBmcmFnbWVudFwiLCBcImV2ZW50XCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRvcGljcyA9IFtmcmFnbWVudC50b3BpY0hhc2hdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVmZXJyZWQoZXZlbnQpKSB7XG4gICAgICAgIC8vIERlZmVycmVkIFRvcGljIEZpbHRlcjsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyKGZyb20pYFxuICAgICAgICB0b3BpY3MgPSBhd2FpdCBldmVudC5nZXRUb3BpY0ZpbHRlcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChcImZyYWdtZW50XCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gQ29udHJhY3RFdmVudDsgZS5nLiBgY29udHJhY3QuZmlsdGVyLlRyYW5zZmVyYFxuICAgICAgICBmcmFnbWVudCA9IGV2ZW50LmZyYWdtZW50O1xuICAgICAgICB0b3BpY3MgPSBbZnJhZ21lbnQudG9waWNIYXNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bmtub3duIGV2ZW50IG5hbWVcIiwgXCJldmVudFwiLCBldmVudCk7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB0b3BpY3MgYW5kIHNvcnQgVG9waWNTZXRzXG4gICAgdG9waWNzID0gdG9waWNzLm1hcCgodCkgPT4ge1xuICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgICBjb25zdCB0YWcgPSB0b3BpY3MubWFwKCh0KSA9PiB7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSkuam9pbihcIiZcIik7XG4gICAgcmV0dXJuIHsgZnJhZ21lbnQsIHRhZywgdG9waWNzIH07XG59XG5hc3luYyBmdW5jdGlvbiBoYXNTdWIoY29udHJhY3QsIGV2ZW50KSB7XG4gICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbChjb250cmFjdCk7XG4gICAgcmV0dXJuIHN1YnMuZ2V0KChhd2FpdCBnZXRTdWJJbmZvKGNvbnRyYWN0LCBldmVudCkpLnRhZykgfHwgbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN1Yihjb250cmFjdCwgb3BlcmF0aW9uLCBldmVudCkge1xuICAgIC8vIE1ha2Ugc3VyZSBvdXIgcnVubmVyIGNhbiBhY3R1YWxseSBzdWJzY3JpYmUgdG8gZXZlbnRzXG4gICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb250cmFjdC5ydW5uZXIpO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkocHJvdmlkZXIsIFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc3Vic2NyaWJpbmdcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgdGFnLCB0b3BpY3MgfSA9IGF3YWl0IGdldFN1YkluZm8oY29udHJhY3QsIGV2ZW50KTtcbiAgICBjb25zdCB7IGFkZHIsIHN1YnMgfSA9IGdldEludGVybmFsKGNvbnRyYWN0KTtcbiAgICBsZXQgc3ViID0gc3Vicy5nZXQodGFnKTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGFkZHIgPyBhZGRyIDogY29udHJhY3QpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGFkZHJlc3MsIHRvcGljcyB9O1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChsb2cpID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZEZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGcmFnbWVudCA9IGNvbnRyYWN0LmludGVyZmFjZS5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZyYWdtZW50IGlzIG51bGwsIHdlIGRvIG5vdCBkZWNvbnN0cnVjdCB0aGUgYXJncyB0byBlbWl0XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mb3VuZEZyYWdtZW50ID0gZm91bmRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gZnJhZ21lbnQgPyBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2coZnJhZ21lbnQsIGxvZy5kYXRhLCBsb2cudG9waWNzKSA6IFtdO1xuICAgICAgICAgICAgICAgIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3cmFwcGVyc19qc18xLkNvbnRyYWN0RXZlbnRQYXlsb2FkKGNvbnRyYWN0LCBsaXN0ZW5lciwgZXZlbnQsIF9mb3VuZEZyYWdtZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW1pdChjb250cmFjdCwgZXZlbnQsIFtdLCAobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3cmFwcGVyc19qc18xLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZChjb250cmFjdCwgbGlzdGVuZXIsIGV2ZW50LCBsb2cpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmcucHVzaChwcm92aWRlci5vbihmaWx0ZXIsIGxpc3RlbmVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0b3AgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHN0YXJ0aW5nO1xuICAgICAgICAgICAgc3RhcnRpbmcgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN0YXJ0ZWQpO1xuICAgICAgICAgICAgcHJvdmlkZXIub2ZmKGZpbHRlciwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICBzdWIgPSB7IHRhZywgbGlzdGVuZXJzOiBbXSwgc3RhcnQsIHN0b3AgfTtcbiAgICAgICAgc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgIH1cbiAgICByZXR1cm4gc3ViO1xufVxuLy8gV2UgdXNlIHRoaXMgdG8gZW5zdXJlIG9uZSBlbWl0IHJlc29sdmVzIGJlZm9yZSBmaXJpbmcgdGhlIG5leHQgdG9cbi8vIGVuc3VyZSBjb3JyZWN0IG9yZGVyaW5nIChub3RlIHRoaXMgY2Fubm90IHRocm93IGFuZCBqdXN0IGFkZHMgdGhlXG4vLyBub3RpY2UgdG8gdGhlIGV2ZW50IHF1ZXUgdXNpbmcgc2V0VGltZW91dCkuXG5sZXQgbGFzdEVtaXQgPSBQcm9taXNlLnJlc29sdmUoKTtcbmFzeW5jIGZ1bmN0aW9uIF9lbWl0KGNvbnRyYWN0LCBldmVudCwgYXJncywgcGF5bG9hZEZ1bmMpIHtcbiAgICBhd2FpdCBsYXN0RW1pdDtcbiAgICBjb25zdCBzdWIgPSBhd2FpdCBoYXNTdWIoY29udHJhY3QsIGV2ZW50KTtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgY29uc3QgcGFzc0FyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpO1xuICAgICAgICBpZiAocGF5bG9hZEZ1bmMpIHtcbiAgICAgICAgICAgIHBhc3NBcmdzLnB1c2gocGF5bG9hZEZ1bmMob25jZSA/IG51bGwgOiBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKGNvbnRyYWN0LCAuLi5wYXNzQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgIH0pO1xuICAgIGlmIChzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICBnZXRJbnRlcm5hbChjb250cmFjdCkuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgfVxuICAgIHJldHVybiAoY291bnQgPiAwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVtaXQoY29udHJhY3QsIGV2ZW50LCBhcmdzLCBwYXlsb2FkRnVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGxhc3RFbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHJlc3VsdFByb21pc2UgPSBfZW1pdChjb250cmFjdCwgZXZlbnQsIGFyZ3MsIHBheWxvYWRGdW5jKTtcbiAgICBsYXN0RW1pdCA9IHJlc3VsdFByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3VsdFByb21pc2U7XG59XG5jb25zdCBwYXNzUHJvcGVydGllcyA9IFtcInRoZW5cIl07XG5jbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqICBUaGUgdGFyZ2V0IHRvIGNvbm5lY3QgdG8uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gYmUgYW4gYWRkcmVzcywgRU5TIG5hbWUgb3IgYW55IFtbQWRkcmVzc2FibGVdXSwgc3VjaCBhc1xuICAgICAqICBhbm90aGVyIGNvbnRyYWN0LiBUbyBnZXQgdGhlIHJlc292bGVkIGFkZHJlc3MsIHVzZSB0aGUgYGBnZXRBZGRyZXNzYGBcbiAgICAgKiAgbWV0aG9kLlxuICAgICAqL1xuICAgIHRhcmdldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBjb25uZWN0ZWQgcnVubmVyLiBUaGlzIGlzIGdlbmVyYWxseSBhIFtbUHJvdmlkZXJdXSBvciBhXG4gICAgICogIFtbU2lnbmVyXV0sIHdoaWNoIGRpY3RhdGVzIHdoYXQgb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBhICoqQ29udHJhY3QqKiBjb25uZWN0ZWQgdG8gYSBbW1Byb3ZpZGVyXV0gbWF5XG4gICAgICogIG9ubHkgZXhlY3V0ZSByZWFkLW9ubHkgb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBydW5uZXI7XG4gICAgLyoqXG4gICAgICogIEFsbCB0aGUgRXZlbnRzIGF2YWlsYWJsZSBvbiB0aGlzIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGZpbHRlcnM7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIFtpbnRlcm5hbF07XG4gICAgLyoqXG4gICAgICogIFRoZSBmYWxsYmFjayBvciByZWNlaXZlIGZ1bmN0aW9uIGlmIGFueS5cbiAgICAgKi9cbiAgICBmYWxsYmFjaztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBjb250cmFjdCBjb25uZWN0ZWQgdG8gJSV0YXJnZXQlJSB3aXRoIHRoZSAlJWFiaSUlIGFuZFxuICAgICAqICBvcHRpb25hbGx5IGNvbm5lY3RlZCB0byBhICUlcnVubmVyJSUgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGJlaGFsZlxuICAgICAqICBvZi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGFiaSwgcnVubmVyLCBfZGVwbG95VHgpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAodGFyZ2V0KSA9PT0gXCJzdHJpbmdcIiB8fCAoMCwgaW5kZXhfanNfMi5pc0FkZHJlc3NhYmxlKSh0YXJnZXQpLCBcImludmFsaWQgdmFsdWUgZm9yIENvbnRyYWN0IHRhcmdldFwiLCBcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWZhY2UgPSBpbmRleF9qc18xLkludGVyZmFjZS5mcm9tKGFiaSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgdGFyZ2V0LCBydW5uZXIsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbnRlcm5hbCwgeyB2YWx1ZToge30gfSk7XG4gICAgICAgIGxldCBhZGRyUHJvbWlzZTtcbiAgICAgICAgbGV0IGFkZHIgPSBudWxsO1xuICAgICAgICBsZXQgZGVwbG95VHggPSBudWxsO1xuICAgICAgICBpZiAoX2RlcGxveVR4KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHJ1bm5lcik7XG4gICAgICAgICAgICAvLyBAVE9ETzogdGhlIHByb3ZpZGVyIGNhbiBiZSBudWxsOyBtYWtlIGEgY3VzdG9tIGR1bW15IHByb3ZpZGVyIHRoYXQgd2lsbCB0aHJvdyBhXG4gICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGVycm9yXG4gICAgICAgICAgICBkZXBsb3lUeCA9IG5ldyB3cmFwcGVyc19qc18xLkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLmludGVyZmFjZSwgcHJvdmlkZXIsIF9kZXBsb3lUeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIHRhcmdldCBhcyB0aGUgYWRkcmVzc1xuICAgICAgICBpZiAodHlwZW9mICh0YXJnZXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzMuaXNIZXhTdHJpbmcpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBhZGRyID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGFkZHJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGdldFJ1bm5lcihydW5uZXIsIFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5SZXNvbHZlKHJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgaW5kZXhfanNfMy5tYWtlRXJyb3IpKFwiY29udHJhY3QgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgbmFtZSByZXNvbHV0aW9uXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHJlc29sdmVyLnJlc29sdmVOYW1lKHRhcmdldCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgaW5kZXhfanNfMy5tYWtlRXJyb3IpKFwiYW4gRU5TIG5hbWUgdXNlZCBmb3IgYSBjb250cmFjdCB0YXJnZXQgbXVzdCBiZSBjb3JyZWN0bHkgY29uZmlndXJlZFwiLCBcIlVOQ09ORklHVVJFRF9OQU1FXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnRlcm5hbCh0aGlzKS5hZGRyID0gYWRkcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyUHJvbWlzZSA9IHRhcmdldC5nZXRBZGRyZXNzKCkudGhlbigoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuYWRkciA9IGFkZHI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3VyIHByaXZhdGUgdmFsdWVzXG4gICAgICAgIHNldEludGVybmFsKHRoaXMsIHsgYWRkclByb21pc2UsIGFkZHIsIGRlcGxveVR4LCBzdWJzIH0pO1xuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGZpbHRlcnNcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBhc3MgaW1wb3J0YW50IGNoZWNrcyAobGlrZSBgdGhlbmAgZm9yIFByb21pc2UpIHRocm91Z2hcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGluZGV4X2pzXzMuaXNFcnJvcikoZXJyb3IsIFwiSU5WQUxJRF9BUkdVTUVOVFwiKSB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIGltcG9ydGFudCBjaGVja3MgKGxpa2UgYHRoZW5gIGZvciBQcm9taXNlKSB0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgfHwgdGhpcy5pbnRlcmZhY2UuaGFzRXZlbnQoU3RyaW5nKHByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgZmlsdGVycyB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgZmFsbGJhY2s6ICgoaWZhY2UucmVjZWl2ZSB8fCBpZmFjZS5mYWxsYmFjaykgPyAoYnVpbGRXcmFwcGVkRmFsbGJhY2sodGhpcykpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJldHVybiBhIFByb3h5IHRoYXQgd2lsbCByZXNwb25kIHRvIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChwcm9wKSA9PT0gXCJzeW1ib2xcIiB8fCBwcm9wIGluIHRhcmdldCB8fCBwYXNzUHJvcGVydGllcy5pbmRleE9mKHByb3ApID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgcHJvcGVydGllcyBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZ2V0RnVuY3Rpb24ocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBpbmRleF9qc18zLmlzRXJyb3IpKGVycm9yLCBcIklOVkFMSURfQVJHVU1FTlRcIikgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvcCkgPT09IFwic3ltYm9sXCIgfHwgcHJvcCBpbiB0YXJnZXQgfHwgcGFzc1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmludGVyZmFjZS5oYXNGdW5jdGlvbihwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgQ29udHJhY3QgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSB0YXJnZXQgYW5kIEFCSSwgYnV0XG4gICAgICogIGEgZGlmZmVyZW50ICUlcnVubmVyJSUuXG4gICAgICovXG4gICAgY29ubmVjdChydW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGhpcy50YXJnZXQsIHRoaXMuaW50ZXJmYWNlLCBydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgbmV3IENvbnRyYWN0IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgQUJJIGFuZCBydW5uZXIsIGJ1dFxuICAgICAqICBhIGRpZmZlcmVudCAlJXRhcmdldCUlLlxuICAgICAqL1xuICAgIGF0dGFjaCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSByZXNvbHZlZCBhZGRyZXNzIG9mIHRoaXMgQ29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHsgcmV0dXJuIGF3YWl0IGdldEludGVybmFsKHRoaXMpLmFkZHJQcm9taXNlOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZGVwbG95ZWQgYnl0ZWNvZGUgb3IgbnVsbCBpZiBubyBieXRlY29kZSBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXBsb3llZENvZGUoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIodGhpcy5ydW5uZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHByb3ZpZGVyLCBcInJ1bm5lciBkb2VzIG5vdCBzdXBwb3J0IC5wcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJnZXREZXBsb3llZENvZGVcIiB9KTtcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHByb3ZpZGVyLmdldENvZGUoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmUgdG8gdGhpcyBDb250cmFjdCBvbmNlIHRoZSBieXRlY29kZSBoYXMgYmVlbiBkZXBsb3llZCwgb3JcbiAgICAgKiAgcmVzb2x2ZSBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGRlcGxveWVkLlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JEZXBsb3ltZW50KCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRoZSBkZXBsb3llbWVudCB0cmFuc2FjdGlvbjsganVzdCB1c2UgdGhhdCAodGhyb3dzIGlmIGRlcGxveWVtZW50IGZhaWxzKVxuICAgICAgICBjb25zdCBkZXBsb3lUeCA9IHRoaXMuZGVwbG95bWVudFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmIChkZXBsb3lUeCkge1xuICAgICAgICAgICAgYXdhaXQgZGVwbG95VHgud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGVcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHRoaXMuZ2V0RGVwbG95ZWRDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjYW4gc3Vic2NyaWJlIHRvIGEgcHJvdmlkZXIgZXZlbnRcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkocHJvdmlkZXIgIT0gbnVsbCwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3Qgc3VwcG9ydCAucHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwid2FpdEZvckRlcGxveW1lbnRcIiB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrQ29kZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgdGhpcy5nZXREZXBsb3llZENvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub25jZShcImJsb2NrXCIsIGNoZWNrQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja0NvZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHRyYW5zYWN0aW9uIHVzZWQgdG8gZGVwbG95IHRoaXMgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpZiB0aGlzIGluc3RhbmNlIHdhcyByZXR1cm5lZCBmcm9tIGFcbiAgICAgKiAgW1tDb250cmFjdEZhY3RvcnldXS5cbiAgICAgKi9cbiAgICBkZXBsb3ltZW50VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbCh0aGlzKS5kZXBsb3lUeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIG1ldGhvZCBuYW1lIGNvbmZsaWN0cyB3aXRoIGEgSmF2YVNjcmlwdCBuYW1lIHN1Y2ggYXMgYGBwcm90b3R5cGVgYCBvclxuICAgICAqICB3aGVuIHVzaW5nIGEgQ29udHJhY3QgcHJvZ3JhbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGdldEZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIChrZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuZm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuYyA9IGJ1aWxkV3JhcHBlZE1ldGhvZCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZXZlbnQgZm9yIGEgZ2l2ZW4gbmFtZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIGNvbnRyYWN0XG4gICAgICogIGV2ZW50IG5hbWUgY29uZmxpY3RzIHdpdGggYSBKYXZhU2NyaXB0IG5hbWUgc3VjaCBhcyBgYHByb3RvdHlwZWBgIG9yXG4gICAgICogIHdoZW4gdXNpbmcgYSBDb250cmFjdCBwcm9ncmFtYXRpY2FsbHkuXG4gICAgICovXG4gICAgZ2V0RXZlbnQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5mb3JtYXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRXcmFwcGVkRXZlbnQodGhpcywga2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGFzeW5jIHF1ZXJ5VHJhbnNhY3Rpb24oaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICB9XG4gICAgLypcbiAgICAvLyBAVE9ETzogdGhpcyBpcyBhIG5vbi1iYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2UsIGJ1dCB3aWxsIGJlIGFkZGVkXG4gICAgLy8gICAgICAgIGluIHY3IGFuZCBpbiBhIHBvdGVudGlhbCBTbWFydENvbnRyYWN0IGNsYXNzIGluIGFuIHVwY29taW5nXG4gICAgLy8gICAgICAgIHY2IHJlbGVhc2VcbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaDogc3RyaW5nKTogUHJvbWlzZTxudWxsIHwgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcih0aGlzLnJ1bm5lcik7XG4gICAgICAgIGFzc2VydChwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsXG4gICAgICAgICAgICBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJxdWVyeVRyYW5zYWN0aW9uXCIgfSk7XG5cbiAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQodGhpcy5pbnRlcmZhY2UsIHByb3ZpZGVyLCByZWNlaXB0KTtcbiAgICB9XG4gICAgKi9cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZSBoaXN0b3JpYyBhY2Nlc3MgdG8gZXZlbnQgZGF0YSBmb3IgJSVldmVudCUlIGluIHRoZSByYW5nZVxuICAgICAqICAlJWZyb21CbG9jayUlIChkZWZhdWx0OiBgYDBgYCkgdG8gJSV0b0Jsb2NrJSUgKGRlZmF1bHQ6IGBgXCJsYXRlc3RcImBgKVxuICAgICAqICBpbmNsdXNpdmUuXG4gICAgICovXG4gICAgYXN5bmMgcXVlcnlGaWx0ZXIoZXZlbnQsIGZyb21CbG9jaywgdG9CbG9jaykge1xuICAgICAgICBpZiAoZnJvbUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGZyb21CbG9jayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvQmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9CbG9jayA9IFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhZGRyLCBhZGRyUHJvbWlzZSB9ID0gZ2V0SW50ZXJuYWwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoYWRkciA/IGFkZHIgOiAoYXdhaXQgYWRkclByb21pc2UpKTtcbiAgICAgICAgY29uc3QgeyBmcmFnbWVudCwgdG9waWNzIH0gPSBhd2FpdCBnZXRTdWJJbmZvKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0geyBhZGRyZXNzLCB0b3BpY3MsIGZyb21CbG9jaywgdG9CbG9jayB9O1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGdldFByb3ZpZGVyKHRoaXMucnVubmVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShwcm92aWRlciwgXCJjb250cmFjdCBydW5uZXIgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInF1ZXJ5RmlsdGVyXCIgfSk7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpKS5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChmb3VuZEZyYWdtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5FdmVudExvZyhsb2csIHRoaXMuaW50ZXJmYWNlLCBmb3VuZEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd3JhcHBlcnNfanNfMS5VbmRlY29kZWRFdmVudExvZyhsb2csIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuTG9nKGxvZywgcHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFkZCBhbiBldmVudCAlJWxpc3RlbmVyJSUgZm9yIHRoZSAlJWV2ZW50JSUuXG4gICAgICovXG4gICAgYXN5bmMgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uXCIsIGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IGZhbHNlIH0pO1xuICAgICAgICBzdWIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBBZGQgYW4gZXZlbnQgJSVsaXN0ZW5lciUlIGZvciB0aGUgJSVldmVudCUlLCBidXQgcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICAgICAqICBhZnRlciBpdCBpcyBmaXJlZCBvbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGdldFN1Yih0aGlzLCBcIm9uY2VcIiwgZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRW1pdCBhbiAlJWV2ZW50JSUgY2FsbGluZyBhbGwgbGlzdGVuZXJzIHdpdGggJSVhcmdzJSUuXG4gICAgICpcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgYW55IGxpc3RlbmVycyB3ZXJlIGNhbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbWl0KHRoaXMsIGV2ZW50LCBhcmdzLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIG9mICUlZXZlbnQlJSBvciB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogIG9mIGxpc3RlbmVycyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViLmxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCB7IGxpc3RlbmVycyB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvICUlZXZlbnQlJSBvciBhbGwgbGlzdGVuZXJzXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IGhhc1N1Yih0aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdWJzIH0gPSBnZXRJbnRlcm5hbCh0aGlzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2Ygc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlbW92ZSB0aGUgJSVsaXN0ZW5lciUlIGZyb20gdGhlIGxpc3RlbmVycyBmb3IgJSVldmVudCUlIG9yIHJlbW92ZVxuICAgICAqICBhbGwgbGlzdGVuZXJzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFzeW5jIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcikuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHN1Yi5saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgICAgICAgIGdldEludGVybmFsKHRoaXMpLnN1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVtb3ZlIGFsbCB0aGUgbGlzdGVuZXJzIGZvciAlJWV2ZW50JSUgb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaWZcbiAgICAgKiAgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgaGFzU3ViKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3ViKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIuc3RvcCgpO1xuICAgICAgICAgICAgZ2V0SW50ZXJuYWwodGhpcykuc3Vicy5kZWxldGUoc3ViLnRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnMgfSA9IGdldEludGVybmFsKHRoaXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhZywgc3RvcCB9IG9mIHN1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3Vicy5kZWxldGUodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEFsaWFzIGZvciBbb25dLlxuICAgICAqL1xuICAgIGFzeW5jIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxpYXMgZm9yIFtvZmZdLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBDbGFzcyBmb3IgdGhlICUlYWJpJSUuXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkQ2xhc3MoYWJpKSB7XG4gICAgICAgIGNsYXNzIEN1c3RvbUNvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHJ1bm5lciA9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihhZGRyZXNzLCBhYmksIHJ1bm5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN1c3RvbUNvbnRyYWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyBCYXNlQ29udHJhY3Qgd2l0aCBhIHNwZWNpZmllZCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odGFyZ2V0LCBhYmksIHJ1bm5lcikge1xuICAgICAgICBpZiAocnVubmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgdGhpcyh0YXJnZXQsIGFiaSwgcnVubmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gQmFzZUNvbnRyYWN0O1xuZnVuY3Rpb24gX0NvbnRyYWN0QmFzZSgpIHtcbiAgICByZXR1cm4gQmFzZUNvbnRyYWN0O1xufVxuLyoqXG4gKiAgQSBbW0Jhc2VDb250cmFjdF1dIHdpdGggbm8gdHlwZSBndWFyZHMgb24gaXRzIG1ldGhvZHMgb3IgZXZlbnRzLlxuICovXG5jbGFzcyBDb250cmFjdCBleHRlbmRzIF9Db250cmFjdEJhc2UoKSB7XG59XG5leHBvcnRzLkNvbnRyYWN0ID0gQ29udHJhY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cmFjdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb250cmFjdCIsIkJhc2VDb250cmFjdCIsInJlc29sdmVBcmdzIiwiY29weU92ZXJyaWRlcyIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsInByb3ZpZGVyX2pzXzEiLCJpbmRleF9qc18zIiwid3JhcHBlcnNfanNfMSIsIkJOXzAiLCJCaWdJbnQiLCJjYW5DYWxsIiwiY2FsbCIsImNhbkVzdGltYXRlIiwiZXN0aW1hdGVHYXMiLCJjYW5SZXNvbHZlIiwicmVzb2x2ZU5hbWUiLCJjYW5TZW5kIiwic2VuZFRyYW5zYWN0aW9uIiwiZ2V0UmVzb2x2ZXIiLCJwcm92aWRlciIsInVuZGVmaW5lZCIsIlByZXBhcmVkVG9waWNGaWx0ZXIiLCJmaWx0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRyYWN0IiwiZnJhZ21lbnQiLCJhcmdzIiwiZGVmaW5lUHJvcGVydGllcyIsImlucHV0cyIsImxlbmd0aCIsIkVycm9yIiwicnVubmVyIiwiZ2V0UnVubmVyIiwicmVzb2x2ZXIiLCJyZXNvbHZlZEFyZ3MiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicGFyYW0iLCJpbmRleCIsImFyZyIsIndhbGtBc3luYyIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwicmVzb2x2ZUFkZHJlc3MiLCJpbnRlcmZhY2UiLCJlbmNvZGVGaWx0ZXJUb3BpY3MiLCJnZXRUb3BpY0ZpbHRlciIsImZlYXR1cmUiLCJnZXRQcm92aWRlciIsImFsbG93ZWQiLCJfb3ZlcnJpZGVzIiwiVHlwZWQiLCJkZXJlZmVyZW5jZSIsImFzc2VydEFyZ3VtZW50Iiwib3ZlcnJpZGVzIiwiY29weVJlcXVlc3QiLCJ0byIsImluZGV4T2YiLCJkYXRhIiwiZnJvbSIsIl9ydW5uZXIiLCJidWlsZFdyYXBwZWRGYWxsYmFjayIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJ0eCIsImdldEFkZHJlc3MiLCJpZmFjZSIsIm5vVmFsdWUiLCJnZXRCaWdJbnQiLCJub0RhdGEiLCJmYWxsYmFjayIsInBheWFibGUiLCJyZWNlaXZlIiwic3RhdGljQ2FsbCIsImFzc2VydCIsIm9wZXJhdGlvbiIsImVycm9yIiwiaXNDYWxsRXhjZXB0aW9uIiwibWFrZUVycm9yIiwic2VuZCIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSIsIm1ldGhvZCIsIl9jb250cmFjdCIsImJ1aWxkV3JhcHBlZE1ldGhvZCIsImtleSIsImdldEZyYWdtZW50IiwiZ2V0RnVuY3Rpb24iLCJpbmZvIiwicG9wIiwiYXNzaWduIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJyZXN1bHQiLCJzdGF0aWNDYWxsUmVzdWx0IiwiZGVjb2RlRnVuY3Rpb25SZXN1bHQiLCJjb25zdGFudCIsIm5hbWUiLCJnZXRGdW5jdGlvbk5hbWUiLCJfa2V5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImJ1aWxkV3JhcHBlZEV2ZW50IiwiZ2V0RXZlbnQiLCJnZXRFdmVudE5hbWUiLCJpbnRlcm5hbCIsIlN5bWJvbCIsImZvciIsImludGVybmFsVmFsdWVzIiwiV2Vha01hcCIsInNldEludGVybmFsIiwidmFsdWVzIiwic2V0IiwiZ2V0SW50ZXJuYWwiLCJpc0RlZmVycmVkIiwiZ2V0U3ViSW5mbyIsImV2ZW50IiwidG9waWNzIiwidG9waWNIYXNoaWZ5IiwiaXNIZXhTdHJpbmciLCJ0b3BpY0hhc2giLCJlIiwidCIsIml0ZW1zIiwiU2V0IiwidG9Mb3dlckNhc2UiLCJzb3J0IiwidGFnIiwiam9pbiIsImhhc1N1YiIsInN1YnMiLCJnZXRTdWIiLCJhZGRyIiwic3ViIiwiYWRkcmVzcyIsImxpc3RlbmVyIiwibG9nIiwiZm91bmRGcmFnbWVudCIsIl9mb3VuZEZyYWdtZW50IiwiZGVjb2RlRXZlbnRMb2ciLCJlbWl0IiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJzdGFydGluZyIsInN0YXJ0IiwicHVzaCIsIm9uIiwic3RvcCIsInN0YXJ0ZWQiLCJvZmYiLCJsaXN0ZW5lcnMiLCJsYXN0RW1pdCIsInJlc29sdmUiLCJfZW1pdCIsInBheWxvYWRGdW5jIiwiY291bnQiLCJvbmNlIiwicGFzc0FyZ3MiLCJkZWxldGUiLCJyZXN1bHRQcm9taXNlIiwicGFzc1Byb3BlcnRpZXMiLCJ0YXJnZXQiLCJhYmkiLCJfZGVwbG95VHgiLCJpc0FkZHJlc3NhYmxlIiwiSW50ZXJmYWNlIiwiYWRkclByb21pc2UiLCJkZXBsb3lUeCIsIk1hcCIsInRoZW4iLCJmaWx0ZXJzIiwiUHJveHkiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiaXNFcnJvciIsImFyZ3VtZW50IiwiaGFzIiwiaGFzRXZlbnQiLCJTdHJpbmciLCJoYXNGdW5jdGlvbiIsImNvbm5lY3QiLCJhdHRhY2giLCJnZXREZXBsb3llZENvZGUiLCJjb2RlIiwiZ2V0Q29kZSIsIndhaXRGb3JEZXBsb3ltZW50IiwiZGVwbG95bWVudFRyYW5zYWN0aW9uIiwid2FpdCIsInJlamVjdCIsImNoZWNrQ29kZSIsImZvcm1hdCIsImZ1bmMiLCJxdWVyeVRyYW5zYWN0aW9uIiwiaGFzaCIsInF1ZXJ5RmlsdGVyIiwiZnJvbUJsb2NrIiwidG9CbG9jayIsImdldExvZ3MiLCJFdmVudExvZyIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiTG9nIiwibGlzdGVuZXJDb3VudCIsInRvdGFsIiwiY29uY2F0Iiwic3BsaWNlIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsImJ1aWxkQ2xhc3MiLCJDdXN0b21Db250cmFjdCIsIl9Db250cmFjdEJhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/contract/contract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/contract/factory.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/factory.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ContractFactory = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst contract_js_1 = __webpack_require__(/*! ./contract.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/contract.js\");\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\n/**\n *  A **ContractFactory** is used to deploy a Contract to the blockchain.\n */ class ContractFactory {\n    /**\n     *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,\n     *  optionally connected to %%runner%%.\n     *\n     *  The %%bytecode%% may be the ``bytecode`` property within the\n     *  standard Solidity JSON output.\n     */ constructor(abi, bytecode, runner){\n        const iface = index_js_1.Interface.from(abi);\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        } else {\n            if (typeof bytecode === \"object\") {\n                bytecode = bytecode.object;\n            }\n            if (!bytecode.startsWith(\"0x\")) {\n                bytecode = \"0x\" + bytecode;\n            }\n            bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));\n        }\n        (0, index_js_3.defineProperties)(this, {\n            bytecode,\n            interface: iface,\n            runner: runner || null\n        });\n    }\n    attach(target) {\n        return new contract_js_1.BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Resolves to the transaction to deploy the contract, passing %%args%%\n     *  into the constructor.\n     */ async getDeployTransaction(...args) {\n        let overrides = {};\n        const fragment = this.interface.deploy;\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await (0, contract_js_1.copyOverrides)(args.pop());\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);\n        const data = (0, index_js_3.concat)([\n            this.bytecode,\n            this.interface.encodeDeploy(resolvedArgs)\n        ]);\n        return Object.assign({}, overrides, {\n            data\n        });\n    }\n    /**\n     *  Resolves to the Contract deployed by passing %%args%% into the\n     *  constructor.\n     *\n     *  This will resovle to the Contract before it has been deployed to the\n     *  network, so the [[BaseContract-waitForDeployment]] should be used before\n     *  sending any transactions to it.\n     */ async deploy(...args) {\n        const tx = await this.getDeployTransaction(...args);\n        (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\"\n        });\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = (0, index_js_2.getCreateAddress)(sentTx);\n        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);\n    }\n    /**\n     *  Return a new **ContractFactory** with the same ABI and bytecode,\n     *  but connected to %%runner%%.\n     */ connect(runner) {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n    /**\n     *  Create a new **ContractFactory** from the standard Solidity JSON output.\n     */ static fromSolidity(output, runner) {\n        (0, index_js_3.assertArgument)(output != null, \"bad compiler output\", \"output\", output);\n        if (typeof output === \"string\") {\n            output = JSON.parse(output);\n        }\n        const abi = output.abi;\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        } else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n        return new this(abi, bytecode, runner);\n    }\n}\nexports.ContractFactory = ContractFactory; //# sourceMappingURL=factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1QkFBdUIsR0FBRyxLQUFLO0FBQy9CLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDhFQUFpQjtBQUM1QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1HLGdCQUFnQkgsbUJBQU9BLENBQUMsb0ZBQWU7QUFDN0MsbUNBQW1DO0FBQ25DLHNDQUFzQztBQUN0Qzs7Q0FFQyxHQUNELE1BQU1GO0lBYUY7Ozs7OztLQU1DLEdBQ0RNLFlBQVlDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLENBQUU7UUFDL0IsTUFBTUMsUUFBUVQsV0FBV1UsU0FBUyxDQUFDQyxJQUFJLENBQUNMO1FBQ3hDLHdFQUF3RTtRQUN4RSxJQUFJQyxvQkFBb0JLLFlBQVk7WUFDaENMLFdBQVcsQ0FBQyxHQUFHSixXQUFXVSxPQUFPLEVBQUUsQ0FBQyxHQUFHVixXQUFXVyxRQUFRLEVBQUVQO1FBQ2hFLE9BQ0s7WUFDRCxJQUFJLE9BQVFBLGFBQWMsVUFBVTtnQkFDaENBLFdBQVdBLFNBQVNRLE1BQU07WUFDOUI7WUFDQSxJQUFJLENBQUNSLFNBQVNTLFVBQVUsQ0FBQyxPQUFPO2dCQUM1QlQsV0FBVyxPQUFPQTtZQUN0QjtZQUNBQSxXQUFXLENBQUMsR0FBR0osV0FBV1UsT0FBTyxFQUFFLENBQUMsR0FBR1YsV0FBV1csUUFBUSxFQUFFUDtRQUNoRTtRQUNDLElBQUdKLFdBQVdjLGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUNuQ1Y7WUFBVVcsV0FBV1Q7WUFBT0QsUUFBU0EsVUFBVTtRQUNuRDtJQUNKO0lBQ0FXLE9BQU9DLE1BQU0sRUFBRTtRQUNYLE9BQU8sSUFBSWhCLGNBQWNpQixZQUFZLENBQUNELFFBQVEsSUFBSSxDQUFDRixTQUFTLEVBQUUsSUFBSSxDQUFDVixNQUFNO0lBQzdFO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTWMscUJBQXFCLEdBQUdDLElBQUksRUFBRTtRQUNoQyxJQUFJQyxZQUFZLENBQUM7UUFDakIsTUFBTUMsV0FBVyxJQUFJLENBQUNQLFNBQVMsQ0FBQ1EsTUFBTTtRQUN0QyxJQUFJRCxTQUFTRSxNQUFNLENBQUNDLE1BQU0sR0FBRyxNQUFNTCxLQUFLSyxNQUFNLEVBQUU7WUFDNUNKLFlBQVksTUFBTSxDQUFDLEdBQUdwQixjQUFjeUIsYUFBYSxFQUFFTixLQUFLTyxHQUFHO1FBQy9EO1FBQ0EsSUFBSUwsU0FBU0UsTUFBTSxDQUFDQyxNQUFNLEtBQUtMLEtBQUtLLE1BQU0sRUFBRTtZQUN4QyxNQUFNLElBQUlHLE1BQU07UUFDcEI7UUFDQSxNQUFNQyxlQUFlLE1BQU0sQ0FBQyxHQUFHNUIsY0FBYzZCLFdBQVcsRUFBRSxJQUFJLENBQUN6QixNQUFNLEVBQUVpQixTQUFTRSxNQUFNLEVBQUVKO1FBQ3hGLE1BQU1XLE9BQU8sQ0FBQyxHQUFHL0IsV0FBV2dDLE1BQU0sRUFBRTtZQUFDLElBQUksQ0FBQzVCLFFBQVE7WUFBRSxJQUFJLENBQUNXLFNBQVMsQ0FBQ2tCLFlBQVksQ0FBQ0o7U0FBYztRQUM5RixPQUFPckMsT0FBTzBDLE1BQU0sQ0FBQyxDQUFDLEdBQUdiLFdBQVc7WUFBRVU7UUFBSztJQUMvQztJQUNBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNUixPQUFPLEdBQUdILElBQUksRUFBRTtRQUNsQixNQUFNZSxLQUFLLE1BQU0sSUFBSSxDQUFDaEIsb0JBQW9CLElBQUlDO1FBQzdDLElBQUdwQixXQUFXb0MsTUFBTSxFQUFFLElBQUksQ0FBQy9CLE1BQU0sSUFBSSxPQUFRLElBQUksQ0FBQ0EsTUFBTSxDQUFDZ0MsZUFBZSxLQUFNLFlBQVksd0RBQXdELHlCQUF5QjtZQUN4S0MsV0FBVztRQUNmO1FBQ0EsTUFBTUMsU0FBUyxNQUFNLElBQUksQ0FBQ2xDLE1BQU0sQ0FBQ2dDLGVBQWUsQ0FBQ0Y7UUFDakQsTUFBTUssVUFBVSxDQUFDLEdBQUd6QyxXQUFXMEMsZ0JBQWdCLEVBQUVGO1FBQ2pELE9BQU8sSUFBSXRDLGNBQWNpQixZQUFZLENBQUNzQixTQUFTLElBQUksQ0FBQ3pCLFNBQVMsRUFBRSxJQUFJLENBQUNWLE1BQU0sRUFBRWtDO0lBQ2hGO0lBQ0E7OztLQUdDLEdBQ0RHLFFBQVFyQyxNQUFNLEVBQUU7UUFDWixPQUFPLElBQUlULGdCQUFnQixJQUFJLENBQUNtQixTQUFTLEVBQUUsSUFBSSxDQUFDWCxRQUFRLEVBQUVDO0lBQzlEO0lBQ0E7O0tBRUMsR0FDRCxPQUFPc0MsYUFBYUMsTUFBTSxFQUFFdkMsTUFBTSxFQUFFO1FBQy9CLElBQUdMLFdBQVc2QyxjQUFjLEVBQUVELFVBQVUsTUFBTSx1QkFBdUIsVUFBVUE7UUFDaEYsSUFBSSxPQUFRQSxXQUFZLFVBQVU7WUFDOUJBLFNBQVNFLEtBQUtDLEtBQUssQ0FBQ0g7UUFDeEI7UUFDQSxNQUFNekMsTUFBTXlDLE9BQU96QyxHQUFHO1FBQ3RCLElBQUlDLFdBQVc7UUFDZixJQUFJd0MsT0FBT3hDLFFBQVEsRUFBRTtZQUNqQkEsV0FBV3dDLE9BQU94QyxRQUFRO1FBQzlCLE9BQ0ssSUFBSXdDLE9BQU9JLEdBQUcsSUFBSUosT0FBT0ksR0FBRyxDQUFDNUMsUUFBUSxFQUFFO1lBQ3hDQSxXQUFXd0MsT0FBT0ksR0FBRyxDQUFDNUMsUUFBUTtRQUNsQztRQUNBLE9BQU8sSUFBSSxJQUFJLENBQUNELEtBQUtDLFVBQVVDO0lBQ25DO0FBQ0o7QUFDQVgsdUJBQXVCLEdBQUdFLGlCQUMxQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9mYWN0b3J5LmpzPzFjOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWJpL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbnRyYWN0X2pzXzEgPSByZXF1aXJlKFwiLi9jb250cmFjdC5qc1wiKTtcbi8vIEEgPSBBcmd1bWVudHMgdG8gdGhlIGNvbnN0cnVjdG9yXG4vLyBJID0gSW50ZXJmYWNlIG9mIGRlcGxveWVkIGNvbnRyYWN0c1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0RmFjdG9yeSoqIGlzIHVzZWQgdG8gZGVwbG95IGEgQ29udHJhY3QgdG8gdGhlIGJsb2NrY2hhaW4uXG4gKi9cbmNsYXNzIENvbnRyYWN0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogIFRoZSBDb250cmFjdCBJbnRlcmZhY2UuXG4gICAgICovXG4gICAgaW50ZXJmYWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgQ29udHJhY3QgZGVwbG95bWVudCBieXRlY29kZS4gT2Z0ZW4gY2FsbGVkIHRoZSBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBieXRlY29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0UnVubmVyIHRvIGRlcGxveSB0aGUgQ29udHJhY3QgYXMuXG4gICAgICovXG4gICAgcnVubmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoICUlYWJpJSUgYW5kICUlYnl0ZWNvZGUlJSxcbiAgICAgKiAgb3B0aW9uYWxseSBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVieXRlY29kZSUlIG1heSBiZSB0aGUgYGBieXRlY29kZWBgIHByb3BlcnR5IHdpdGhpbiB0aGVcbiAgICAgKiAgc3RhbmRhcmQgU29saWRpdHkgSlNPTiBvdXRwdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWJpLCBieXRlY29kZSwgcnVubmVyKSB7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gaW5kZXhfanNfMS5JbnRlcmZhY2UuZnJvbShhYmkpO1xuICAgICAgICAvLyBEZXJlZmVyZW5jZSBTb2xpZGl0eSBieXRlY29kZSBvYmplY3RzIGFuZCBhbGxvdyBhIG1pc3NpbmcgYDB4YC1wcmVmaXhcbiAgICAgICAgaWYgKGJ5dGVjb2RlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGJ5dGVjb2RlID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFieXRlY29kZS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgICAgICBieXRlY29kZSA9IFwiMHhcIiArIGJ5dGVjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZWNvZGUgPSAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoYnl0ZWNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBieXRlY29kZSwgaW50ZXJmYWNlOiBpZmFjZSwgcnVubmVyOiAocnVubmVyIHx8IG51bGwpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29udHJhY3RfanNfMS5CYXNlQ29udHJhY3QodGFyZ2V0LCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRvIGRlcGxveSB0aGUgY29udHJhY3QsIHBhc3NpbmcgJSVhcmdzJSVcbiAgICAgKiAgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RGVwbG95VHJhbnNhY3Rpb24oLi4uYXJncykge1xuICAgICAgICBsZXQgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZGVwbG95O1xuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgPT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdmVycmlkZXMgPSBhd2FpdCAoMCwgY29udHJhY3RfanNfMS5jb3B5T3ZlcnJpZGVzKShhcmdzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQXJncyA9IGF3YWl0ICgwLCBjb250cmFjdF9qc18xLnJlc29sdmVBcmdzKSh0aGlzLnJ1bm5lciwgZnJhZ21lbnQuaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW3RoaXMuYnl0ZWNvZGUsIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShyZXNvbHZlZEFyZ3MpXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHsgZGF0YSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBDb250cmFjdCBkZXBsb3llZCBieSBwYXNzaW5nICUlYXJncyUlIGludG8gdGhlXG4gICAgICogIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXNvdmxlIHRvIHRoZSBDb250cmFjdCBiZWZvcmUgaXQgaGFzIGJlZW4gZGVwbG95ZWQgdG8gdGhlXG4gICAgICogIG5ldHdvcmssIHNvIHRoZSBbW0Jhc2VDb250cmFjdC13YWl0Rm9yRGVwbG95bWVudF1dIHNob3VsZCBiZSB1c2VkIGJlZm9yZVxuICAgICAqICBzZW5kaW5nIGFueSB0cmFuc2FjdGlvbnMgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLmdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMucnVubmVyICYmIHR5cGVvZiAodGhpcy5ydW5uZXIuc2VuZFRyYW5zYWN0aW9uKSA9PT0gXCJmdW5jdGlvblwiLCBcImZhY3RvcnkgcnVubmVyIGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyB0cmFuc2FjdGlvbnNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW50VHggPSBhd2FpdCB0aGlzLnJ1bm5lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzIuZ2V0Q3JlYXRlQWRkcmVzcykoc2VudFR4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb250cmFjdF9qc18xLkJhc2VDb250cmFjdChhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5ydW5uZXIsIHNlbnRUeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgKipDb250cmFjdEZhY3RvcnkqKiB3aXRoIHRoZSBzYW1lIEFCSSBhbmQgYnl0ZWNvZGUsXG4gICAgICogIGJ1dCBjb25uZWN0ZWQgdG8gJSVydW5uZXIlJS5cbiAgICAgKi9cbiAgICBjb25uZWN0KHJ1bm5lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RmFjdG9yeSh0aGlzLmludGVyZmFjZSwgdGhpcy5ieXRlY29kZSwgcnVubmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkNvbnRyYWN0RmFjdG9yeSoqIGZyb20gdGhlIHN0YW5kYXJkIFNvbGlkaXR5IEpTT04gb3V0cHV0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU29saWRpdHkob3V0cHV0LCBydW5uZXIpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKG91dHB1dCAhPSBudWxsLCBcImJhZCBjb21waWxlciBvdXRwdXRcIiwgXCJvdXRwdXRcIiwgb3V0cHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiAob3V0cHV0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgb3V0cHV0ID0gSlNPTi5wYXJzZShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IG91dHB1dC5hYmk7XG4gICAgICAgIGxldCBieXRlY29kZSA9IFwiXCI7XG4gICAgICAgIGlmIChvdXRwdXQuYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gb3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dC5ldm0gJiYgb3V0cHV0LmV2bS5ieXRlY29kZSkge1xuICAgICAgICAgICAgYnl0ZWNvZGUgPSBvdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBydW5uZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gQ29udHJhY3RGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb250cmFjdEZhY3RvcnkiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiY29udHJhY3RfanNfMSIsImNvbnN0cnVjdG9yIiwiYWJpIiwiYnl0ZWNvZGUiLCJydW5uZXIiLCJpZmFjZSIsIkludGVyZmFjZSIsImZyb20iLCJVaW50OEFycmF5IiwiaGV4bGlmeSIsImdldEJ5dGVzIiwib2JqZWN0Iiwic3RhcnRzV2l0aCIsImRlZmluZVByb3BlcnRpZXMiLCJpbnRlcmZhY2UiLCJhdHRhY2giLCJ0YXJnZXQiLCJCYXNlQ29udHJhY3QiLCJnZXREZXBsb3lUcmFuc2FjdGlvbiIsImFyZ3MiLCJvdmVycmlkZXMiLCJmcmFnbWVudCIsImRlcGxveSIsImlucHV0cyIsImxlbmd0aCIsImNvcHlPdmVycmlkZXMiLCJwb3AiLCJFcnJvciIsInJlc29sdmVkQXJncyIsInJlc29sdmVBcmdzIiwiZGF0YSIsImNvbmNhdCIsImVuY29kZURlcGxveSIsImFzc2lnbiIsInR4IiwiYXNzZXJ0Iiwic2VuZFRyYW5zYWN0aW9uIiwib3BlcmF0aW9uIiwic2VudFR4IiwiYWRkcmVzcyIsImdldENyZWF0ZUFkZHJlc3MiLCJjb25uZWN0IiwiZnJvbVNvbGlkaXR5Iiwib3V0cHV0IiwiYXNzZXJ0QXJndW1lbnQiLCJKU09OIiwicGFyc2UiLCJldm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/contract/factory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;\n/**\n *  A **Contract** object is a meta-class (a class whose definition is\n *  defined at runtime), which communicates with a deployed smart contract\n *  on the blockchain and provides a simple JavaScript interface to call\n *  methods, send transaction, query historic logs and listen for its events.\n *\n *  @_section: api/contract:Contracts  [about-contracts]\n */ var contract_js_1 = __webpack_require__(/*! ./contract.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/contract.js\");\nObject.defineProperty(exports, \"BaseContract\", ({\n    enumerable: true,\n    get: function() {\n        return contract_js_1.BaseContract;\n    }\n}));\nObject.defineProperty(exports, \"Contract\", ({\n    enumerable: true,\n    get: function() {\n        return contract_js_1.Contract;\n    }\n}));\nvar factory_js_1 = __webpack_require__(/*! ./factory.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/factory.js\");\nObject.defineProperty(exports, \"ContractFactory\", ({\n    enumerable: true,\n    get: function() {\n        return factory_js_1.ContractFactory;\n    }\n}));\nvar wrappers_js_1 = __webpack_require__(/*! ./wrappers.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\");\nObject.defineProperty(exports, \"ContractEventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.ContractEventPayload;\n    }\n}));\nObject.defineProperty(exports, \"ContractUnknownEventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.ContractUnknownEventPayload;\n    }\n}));\nObject.defineProperty(exports, \"ContractTransactionReceipt\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.ContractTransactionReceipt;\n    }\n}));\nObject.defineProperty(exports, \"ContractTransactionResponse\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.ContractTransactionResponse;\n    }\n}));\nObject.defineProperty(exports, \"EventLog\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.EventLog;\n    }\n}));\nObject.defineProperty(exports, \"UndecodedEventLog\", ({\n    enumerable: true,\n    get: function() {\n        return wrappers_js_1.UndecodedEventLog;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLGdCQUFnQixHQUFHQSxtQ0FBbUMsR0FBR0Esa0NBQWtDLEdBQUdBLG1DQUFtQyxHQUFHQSw0QkFBNEIsR0FBR0EsdUJBQXVCLEdBQUdBLGdCQUFnQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQ3hROzs7Ozs7O0NBT0MsR0FDRCxJQUFJVyxnQkFBZ0JDLG1CQUFPQSxDQUFDLG9GQUFlO0FBQzNDZCxnREFBK0M7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsY0FBY0QsWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdIWiw0Q0FBMkM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsY0FBY0YsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JILElBQUlNLGVBQWVILG1CQUFPQSxDQUFDLGtGQUFjO0FBQ3pDZCxtREFBa0Q7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsYUFBYVAsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJLElBQUlRLGdCQUFnQkosbUJBQU9BLENBQUMsb0ZBQWU7QUFDM0NkLHdEQUF1RDtJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxjQUFjVCxvQkFBb0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SVQsK0RBQThEO0lBQUVlLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGNBQWNWLDJCQUEyQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNKUiw4REFBNkQ7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsY0FBY1gsMEJBQTBCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekpQLCtEQUE4RDtJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxjQUFjWiwyQkFBMkI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSk4sNENBQTJDO0lBQUVlLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGNBQWNiLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySEwscURBQW9EO0lBQUVlLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGNBQWNkLGlCQUFpQjtJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQ3ZJLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NvbnRyYWN0L2luZGV4LmpzP2NiNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuZGVjb2RlZEV2ZW50TG9nID0gZXhwb3J0cy5FdmVudExvZyA9IGV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5Db250cmFjdEV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdCA9IGV4cG9ydHMuQmFzZUNvbnRyYWN0ID0gdm9pZCAwO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0Kiogb2JqZWN0IGlzIGEgbWV0YS1jbGFzcyAoYSBjbGFzcyB3aG9zZSBkZWZpbml0aW9uIGlzXG4gKiAgZGVmaW5lZCBhdCBydW50aW1lKSwgd2hpY2ggY29tbXVuaWNhdGVzIHdpdGggYSBkZXBsb3llZCBzbWFydCBjb250cmFjdFxuICogIG9uIHRoZSBibG9ja2NoYWluIGFuZCBwcm92aWRlcyBhIHNpbXBsZSBKYXZhU2NyaXB0IGludGVyZmFjZSB0byBjYWxsXG4gKiAgbWV0aG9kcywgc2VuZCB0cmFuc2FjdGlvbiwgcXVlcnkgaGlzdG9yaWMgbG9ncyBhbmQgbGlzdGVuIGZvciBpdHMgZXZlbnRzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9jb250cmFjdDpDb250cmFjdHMgIFthYm91dC1jb250cmFjdHNdXG4gKi9cbnZhciBjb250cmFjdF9qc18xID0gcmVxdWlyZShcIi4vY29udHJhY3QuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2pzXzEuQmFzZUNvbnRyYWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0X2pzXzEuQ29udHJhY3Q7IH0gfSk7XG52YXIgZmFjdG9yeV9qc18xID0gcmVxdWlyZShcIi4vZmFjdG9yeS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFjdG9yeV9qc18xLkNvbnRyYWN0RmFjdG9yeTsgfSB9KTtcbnZhciB3cmFwcGVyc19qc18xID0gcmVxdWlyZShcIi4vd3JhcHBlcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdEV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlcnNfanNfMS5Db250cmFjdEV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlcnNfanNfMS5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlcnNfanNfMS5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudExvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlcnNfanNfMS5FdmVudExvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZGVjb2RlZEV2ZW50TG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3cmFwcGVyc19qc18xLlVuZGVjb2RlZEV2ZW50TG9nOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVW5kZWNvZGVkRXZlbnRMb2ciLCJFdmVudExvZyIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZSIsIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0IiwiQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJDb250cmFjdEZhY3RvcnkiLCJDb250cmFjdCIsIkJhc2VDb250cmFjdCIsImNvbnRyYWN0X2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImZhY3RvcnlfanNfMSIsIndyYXBwZXJzX2pzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/contract/wrappers.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/contract/wrappers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = __webpack_require__(/*! ../providers/provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class EventLog extends provider_js_1.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, iface, fragment){\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        (0, index_js_1.defineProperties)(this, {\n            args,\n            fragment,\n            interface: iface\n        });\n    }\n    /**\n     *  The name of the event.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The signature of the event.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\nexports.EventLog = EventLog;\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */ class UndecodedEventLog extends provider_js_1.Log {\n    /**\n     * @_ignore:\n     */ constructor(log, error){\n        super(log, log.provider);\n        (0, index_js_1.defineProperties)(this, {\n            error\n        });\n    }\n}\nexports.UndecodedEventLog = UndecodedEventLog;\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */ class ContractTransactionReceipt extends provider_js_1.TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */ get logs() {\n        return super.logs.map((log)=>{\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                } catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\nexports.ContractTransactionReceipt = ContractTransactionReceipt;\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */ class ContractTransactionResponse extends provider_js_1.TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */ constructor(iface, provider, tx){\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(confirms) {\n        const receipt = await super.wait(confirms);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\nexports.ContractTransactionResponse = ContractTransactionResponse;\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */ class ContractUnknownEventPayload extends index_js_1.EventPayload {\n    /**\n     *  @_event:\n     */ constructor(contract, listener, filter, log){\n        super(contract, listener, filter);\n        (0, index_js_1.defineProperties)(this, {\n            log\n        });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */ async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */ async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */ async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\nexports.ContractUnknownEventPayload = ContractUnknownEventPayload;\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */ class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */ constructor(contract, listener, filter, fragment, _log){\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        (0, index_js_1.defineProperties)(this, {\n            args,\n            fragment\n        });\n    }\n    /**\n     *  The event name.\n     */ get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */ get eventSignature() {\n        return this.fragment.format();\n    }\n}\nexports.ContractEventPayload = ContractEventPayload; //# sourceMappingURL=wrappers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC93cmFwcGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUdBLG1DQUFtQyxHQUFHQSxtQ0FBbUMsR0FBR0Esa0NBQWtDLEdBQUdBLHlCQUF5QixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3BNLHNFQUFzRTtBQUN0RSx5QkFBeUI7QUFDekIsTUFBTVEsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxnR0FBMEI7QUFDeEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDOztDQUVDLEdBQ0QsTUFBTUYsaUJBQWlCQyxjQUFjRyxHQUFHO0lBYXBDOztLQUVDLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDOUIsS0FBSyxDQUFDRixLQUFLQSxJQUFJRyxRQUFRO1FBQ3ZCLE1BQU1DLE9BQU9ILE1BQU1JLGNBQWMsQ0FBQ0gsVUFBVUYsSUFBSU0sSUFBSSxFQUFFTixJQUFJTyxNQUFNO1FBQy9ELElBQUdWLFdBQVdXLGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUFFSjtZQUFNRjtZQUFVTyxXQUFXUjtRQUFNO0lBQzlFO0lBQ0E7O0tBRUMsR0FDRCxJQUFJUyxZQUFZO1FBQUUsT0FBTyxJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsSUFBSTtJQUFFO0lBQzdDOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQUUsT0FBTyxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csTUFBTTtJQUFJO0FBQzFEO0FBQ0ExQixnQkFBZ0IsR0FBR087QUFDbkI7O0NBRUMsR0FDRCxNQUFNRCwwQkFBMEJFLGNBQWNHLEdBQUc7SUFLN0M7O0tBRUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFYyxLQUFLLENBQUU7UUFDcEIsS0FBSyxDQUFDZCxLQUFLQSxJQUFJRyxRQUFRO1FBQ3RC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R0FBRyxDQUFDTyxNQUFNO1FBQ3RGLElBQUdWLFdBQVdXLGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUFFSjtZQUFNRjtRQUFTO0lBQzVEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJUSxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNSLFFBQVEsQ0FBQ1MsSUFBSTtJQUM3QjtJQUNBOztLQUVDLEdBQ0QsSUFBSUMsaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDVixRQUFRLENBQUNXLE1BQU07SUFDL0I7QUFDSjtBQUNBMUIsNEJBQTRCLEdBQUdFLHNCQUMvQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jb250cmFjdC93cmFwcGVycy5qcz8wZjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdEV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZXhwb3J0cy5VbmRlY29kZWRFdmVudExvZyA9IGV4cG9ydHMuRXZlbnRMb2cgPSB2b2lkIDA7XG4vLyBpbXBvcnQgZnJvbSBwcm92aWRlci50cyBpbnN0ZWFkIG9mIGluZGV4LnRzIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwXG4vLyBmcm9tIEV0aGVyc2NhblByb3ZpZGVyXG5jb25zdCBwcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4uL3Byb3ZpZGVycy9wcm92aWRlci5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5jbGFzcyBFdmVudExvZyBleHRlbmRzIHByb3ZpZGVyX2pzXzEuTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIENvbnRyYWN0IEludGVyZmFjZS5cbiAgICAgKi9cbiAgICBpbnRlcmZhY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXRjaGluZyBldmVudC5cbiAgICAgKi9cbiAgICBmcmFnbWVudDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhcnNlZCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBldmVudCBieSBgYGVtaXRgYC5cbiAgICAgKi9cbiAgICBhcmdzO1xuICAgIC8qKlxuICAgICAqIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvZywgaWZhY2UsIGZyYWdtZW50KSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGlmYWNlLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcyk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYXJncywgZnJhZ21lbnQsIGludGVyZmFjZTogaWZhY2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgZ2V0IGV2ZW50TmFtZSgpIHsgcmV0dXJuIHRoaXMuZnJhZ21lbnQubmFtZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgc2lnbmF0dXJlIG9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRTaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLmZyYWdtZW50LmZvcm1hdCgpOyB9XG59XG5leHBvcnRzLkV2ZW50TG9nID0gRXZlbnRMb2c7XG4vKipcbiAqICBBbiAqKkV2ZW50TG9nKiogY29udGFpbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHBhcnNlZCBmcm9tIHRoZSBbW0xvZ11dLlxuICovXG5jbGFzcyBVbmRlY29kZWRFdmVudExvZyBleHRlbmRzIHByb3ZpZGVyX2pzXzEuTG9nIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGVycm9yIGVuY291bnRlZCB3aGVuIHRyeWluZyB0byBkZWNvZGUgdGhlIGxvZy5cbiAgICAgKi9cbiAgICBlcnJvcjtcbiAgICAvKipcbiAgICAgKiBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGxvZywgbG9nLnByb3ZpZGVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBlcnJvciB9KTtcbiAgICB9XG59XG5leHBvcnRzLlVuZGVjb2RlZEV2ZW50TG9nID0gVW5kZWNvZGVkRXZlbnRMb2c7XG4vKipcbiAqICBBICoqQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQqKiBpbmNsdWRlcyB0aGUgcGFyc2VkIGxvZ3MgZnJvbSBhXG4gKiAgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAqL1xuY2xhc3MgQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQgZXh0ZW5kcyBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgI2lmYWNlO1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSwgcHJvdmlkZXIsIHR4KSB7XG4gICAgICAgIHN1cGVyKHR4LCBwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2lmYWNlID0gaWZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcGFyc2VkIGxvZ3MgZm9yIGFueSBbW0xvZ11dIHdoaWNoIGhhcyBhIG1hdGNoaW5nIGV2ZW50IGluIHRoZVxuICAgICAqICBDb250cmFjdCBBQkkuXG4gICAgICovXG4gICAgZ2V0IGxvZ3MoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGxvZy50b3BpY3MubGVuZ3RoID8gdGhpcy4jaWZhY2UuZ2V0RXZlbnQobG9nLnRvcGljc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudExvZyhsb2csIHRoaXMuI2lmYWNlLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuZGVjb2RlZEV2ZW50TG9nKGxvZywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2c7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlY2VpcHQgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdDtcbi8qKlxuICogIEEgKipDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UqKiB3aWxsIHJldHVybiBhXG4gKiAgW1tDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdF1dIHdoZW4gd2FpdGVkIG9uLlxuICovXG5jbGFzcyBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgZXh0ZW5kcyBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVzcG9uc2Uge1xuICAgICNpZmFjZTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWZhY2UsIHByb3ZpZGVyLCB0eCkge1xuICAgICAgICBzdXBlcih0eCwgcHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNpZmFjZSA9IGlmYWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgb25jZSB0aGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFuZCBoYXNcbiAgICAgKiAgJSVjb25maXJtcyUlIGJsb2NrcyBpbmNsdWRpbmcgaXQgKGRlZmF1bHQ6IGBgMWBgKSB3aXRoIGFuXG4gICAgICogIG9wdGlvbmFsICUldGltZW91dCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIHJlc29sdmUgdG8gYGBudWxsYGAgb25seSBpZiAlJWNvbmZpcm1zJSUgaXMgYGAwYGBcbiAgICAgKiAgYW5kIHRoZSB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQsIG90aGVyd2lzZSB0aGlzIHdpbGxcbiAgICAgKiAgd2FpdCB1bnRpbCBlbm91Z2ggY29uZmlybWF0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KGNvbmZpcm1zKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBzdXBlci53YWl0KGNvbmZpcm1zKTtcbiAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLiNpZmFjZSwgdGhpcy5wcm92aWRlciwgcmVjZWlwdCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2U7XG4vKipcbiAqICBBICoqQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGRvZXMgbm90IG1hdGNoIGFueSBldmVudHMgaW4gdGhlIEFCSS5cbiAqL1xuY2xhc3MgQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkIGV4dGVuZHMgaW5kZXhfanNfMS5FdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgbG9nIHdpdGggbm8gbWF0Y2hpbmcgZXZlbnRzLlxuICAgICAqL1xuICAgIGxvZztcbiAgICAvKipcbiAgICAgKiAgQF9ldmVudDpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbG9nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBsb2cgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhlIGV2ZW50IG9jY3VyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmxvZy5nZXRCbG9jaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2cuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHRoZSBldmVudCBvY2N1cmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9nLmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkID0gQ29udHJhY3RVbmtub3duRXZlbnRQYXlsb2FkO1xuLyoqXG4gKiAgQSAqKkNvbnRyYWN0RXZlbnRQYXlsb2FkKiogaXMgaW5jbHVkZWQgYXMgdGhlIGxhc3QgcGFyYW1ldGVyIHRvXG4gKiAgQ29udHJhY3QgRXZlbnRzIHdoZW4gdGhlIGV2ZW50IGlzIGtub3duLlxuICovXG5jbGFzcyBDb250cmFjdEV2ZW50UGF5bG9hZCBleHRlbmRzIENvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0LCBsaXN0ZW5lciwgZmlsdGVyLCBmcmFnbWVudCwgX2xvZykge1xuICAgICAgICBzdXBlcihjb250cmFjdCwgbGlzdGVuZXIsIGZpbHRlciwgbmV3IEV2ZW50TG9nKF9sb2csIGNvbnRyYWN0LmludGVyZmFjZSwgZnJhZ21lbnQpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgdGhpcy5sb2cuZGF0YSwgdGhpcy5sb2cudG9waWNzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhcmdzLCBmcmFnbWVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBldmVudCBuYW1lLlxuICAgICAqL1xuICAgIGdldCBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGdldCBldmVudFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdEV2ZW50UGF5bG9hZCA9IENvbnRyYWN0RXZlbnRQYXlsb2FkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JhcHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29udHJhY3RFdmVudFBheWxvYWQiLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiRXZlbnRMb2ciLCJwcm92aWRlcl9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzEiLCJMb2ciLCJjb25zdHJ1Y3RvciIsImxvZyIsImlmYWNlIiwiZnJhZ21lbnQiLCJwcm92aWRlciIsImFyZ3MiLCJkZWNvZGVFdmVudExvZyIsImRhdGEiLCJ0b3BpY3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiaW50ZXJmYWNlIiwiZXZlbnROYW1lIiwibmFtZSIsImV2ZW50U2lnbmF0dXJlIiwiZm9ybWF0IiwiZXJyb3IiLCJUcmFuc2FjdGlvblJlY2VpcHQiLCJ0eCIsImxvZ3MiLCJtYXAiLCJsZW5ndGgiLCJnZXRFdmVudCIsIlRyYW5zYWN0aW9uUmVzcG9uc2UiLCJ3YWl0IiwiY29uZmlybXMiLCJyZWNlaXB0IiwiRXZlbnRQYXlsb2FkIiwiY29udHJhY3QiLCJsaXN0ZW5lciIsImZpbHRlciIsImdldEJsb2NrIiwiZ2V0VHJhbnNhY3Rpb24iLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJfbG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/contract/wrappers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/crypto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;\nvar crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nObject.defineProperty(exports, \"createHash\", ({\n    enumerable: true,\n    get: function() {\n        return crypto_1.createHash;\n    }\n}));\nObject.defineProperty(exports, \"createHmac\", ({\n    enumerable: true,\n    get: function() {\n        return crypto_1.createHmac;\n    }\n}));\nObject.defineProperty(exports, \"pbkdf2Sync\", ({\n    enumerable: true,\n    get: function() {\n        return crypto_1.pbkdf2Sync;\n    }\n}));\nObject.defineProperty(exports, \"randomBytes\", ({\n    enumerable: true,\n    get: function() {\n        return crypto_1.randomBytes;\n    }\n})); //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzFGLElBQUlNLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CVCw4Q0FBNkM7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsU0FBU0QsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BIUCw4Q0FBNkM7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsU0FBU0YsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BITiw4Q0FBNkM7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsU0FBU0gsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BITCwrQ0FBOEM7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsU0FBU0osV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQ3RILGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9jcnlwdG8uanM/YTZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBia2RmMlN5bmMgPSBleHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLmNyZWF0ZUhhc2ggPSB2b2lkIDA7XG52YXIgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY3J5cHRvXzEuY3JlYXRlSGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUhtYWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLmNyZWF0ZUhtYWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYmtkZjJTeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjcnlwdG9fMS5wYmtkZjJTeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmFuZG9tQnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyeXB0b18xLnJhbmRvbUJ5dGVzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJhbmRvbUJ5dGVzIiwicGJrZGYyU3luYyIsImNyZWF0ZUhtYWMiLCJjcmVhdGVIYXNoIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/hmac.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/hmac.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.computeHmac = void 0;\n/**\n *  An **HMAC** enables verification that a given key was used\n *  to authenticate a payload.\n *\n *  See: [[link-wiki-hmac]]\n *\n *  @_subsection: api/crypto:HMAC  [about-hmac]\n */ const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _computeHmac = function(algorithm, key, data) {\n    return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();\n};\nlet __computeHmac = _computeHmac;\n/**\n *  Return the HMAC for %%data%% using the %%key%% key with the underlying\n *  %%algo%% used for compression.\n *\n *  @example:\n *    key = id(\"some-secret\")\n *\n *    // Compute the HMAC\n *    computeHmac(\"sha256\", key, \"0x1337\")\n *    //_result:\n *\n *    // To compute the HMAC of UTF-8 data, the data must be\n *    // converted to UTF-8 bytes\n *    computeHmac(\"sha256\", key, toUtf8Bytes(\"Hello World\"))\n *    //_result:\n *\n */ function computeHmac(algorithm, _key, _data) {\n    const key = (0, index_js_1.getBytes)(_key, \"key\");\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));\n}\nexports.computeHmac = computeHmac;\ncomputeHmac._ = _computeHmac;\ncomputeHmac.lock = function() {\n    locked = true;\n};\ncomputeHmac.register = function(func) {\n    if (locked) {\n        throw new Error(\"computeHmac is locked\");\n    }\n    __computeHmac = func;\n};\nObject.freeze(computeHmac); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUcsY0FBY0MsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLElBQUlFLFNBQVM7QUFDYixNQUFNQyxlQUFlLFNBQVVDLFNBQVMsRUFBRUMsR0FBRyxFQUFFQyxJQUFJO0lBQy9DLE9BQU8sQ0FBQyxHQUFHUCxZQUFZUSxVQUFVLEVBQUVILFdBQVdDLEtBQUtHLE1BQU0sQ0FBQ0YsTUFBTUcsTUFBTTtBQUMxRTtBQUNBLElBQUlDLGdCQUFnQlA7QUFDcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRCxTQUFTTCxZQUFZTSxTQUFTLEVBQUVPLElBQUksRUFBRUMsS0FBSztJQUN2QyxNQUFNUCxNQUFNLENBQUMsR0FBR0osV0FBV1ksUUFBUSxFQUFFRixNQUFNO0lBQzNDLE1BQU1MLE9BQU8sQ0FBQyxHQUFHTCxXQUFXWSxRQUFRLEVBQUVELE9BQU87SUFDN0MsT0FBTyxDQUFDLEdBQUdYLFdBQVdhLE9BQU8sRUFBRUosY0FBY04sV0FBV0MsS0FBS0M7QUFDakU7QUFDQVYsbUJBQW1CLEdBQUdFO0FBQ3RCQSxZQUFZaUIsQ0FBQyxHQUFHWjtBQUNoQkwsWUFBWWtCLElBQUksR0FBRztJQUFjZCxTQUFTO0FBQU07QUFDaERKLFlBQVltQixRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUNqQyxJQUFJaEIsUUFBUTtRQUNSLE1BQU0sSUFBSWlCLE1BQU07SUFDcEI7SUFDQVQsZ0JBQWdCUTtBQUNwQjtBQUNBeEIsT0FBTzBCLE1BQU0sQ0FBQ3RCLGNBQ2QsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL2htYWMuanM/NzllZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZUhtYWMgPSB2b2lkIDA7XG4vKipcbiAqICBBbiAqKkhNQUMqKiBlbmFibGVzIHZlcmlmaWNhdGlvbiB0aGF0IGEgZ2l2ZW4ga2V5IHdhcyB1c2VkXG4gKiAgdG8gYXV0aGVudGljYXRlIGEgcGF5bG9hZC5cbiAqXG4gKiAgU2VlOiBbW2xpbmstd2lraS1obWFjXV1cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvY3J5cHRvOkhNQUMgIFthYm91dC1obWFjXVxuICovXG5jb25zdCBjcnlwdG9fanNfMSA9IHJlcXVpcmUoXCIuL2NyeXB0by5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfY29tcHV0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUhtYWMpKGFsZ29yaXRobSwga2V5KS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59O1xubGV0IF9fY29tcHV0ZUhtYWMgPSBfY29tcHV0ZUhtYWM7XG4vKipcbiAqICBSZXR1cm4gdGhlIEhNQUMgZm9yICUlZGF0YSUlIHVzaW5nIHRoZSAlJWtleSUlIGtleSB3aXRoIHRoZSB1bmRlcmx5aW5nXG4gKiAgJSVhbGdvJSUgdXNlZCBmb3IgY29tcHJlc3Npb24uXG4gKlxuICogIEBleGFtcGxlOlxuICogICAga2V5ID0gaWQoXCJzb21lLXNlY3JldFwiKVxuICpcbiAqICAgIC8vIENvbXB1dGUgdGhlIEhNQUNcbiAqICAgIGNvbXB1dGVIbWFjKFwic2hhMjU2XCIsIGtleSwgXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBUbyBjb21wdXRlIHRoZSBITUFDIG9mIFVURi04IGRhdGEsIHRoZSBkYXRhIG11c3QgYmVcbiAqICAgIC8vIGNvbnZlcnRlZCB0byBVVEYtOCBieXRlc1xuICogICAgY29tcHV0ZUhtYWMoXCJzaGEyNTZcIiwga2V5LCB0b1V0ZjhCeXRlcyhcIkhlbGxvIFdvcmxkXCIpKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSkge1xuICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfa2V5LCBcImtleVwiKTtcbiAgICBjb25zdCBkYXRhID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9kYXRhLCBcImRhdGFcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKF9fY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpKTtcbn1cbmV4cG9ydHMuY29tcHV0ZUhtYWMgPSBjb21wdXRlSG1hYztcbmNvbXB1dGVIbWFjLl8gPSBfY29tcHV0ZUhtYWM7XG5jb21wdXRlSG1hYy5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQgPSB0cnVlOyB9O1xuY29tcHV0ZUhtYWMucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcHV0ZUhtYWMgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX2NvbXB1dGVIbWFjID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKGNvbXB1dGVIbWFjKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY29tcHV0ZUhtYWMiLCJjcnlwdG9fanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwibG9ja2VkIiwiX2NvbXB1dGVIbWFjIiwiYWxnb3JpdGhtIiwia2V5IiwiZGF0YSIsImNyZWF0ZUhtYWMiLCJ1cGRhdGUiLCJkaWdlc3QiLCJfX2NvbXB1dGVIbWFjIiwiX2tleSIsIl9kYXRhIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A fundamental building block of Ethereum is the underlying\n *  cryptographic primitives.\n *\n *  @_section: api/crypto:Cryptographic Functions   [about-crypto]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;\nnull;\n// We import all these so we can export lock()\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/hmac.js\");\nObject.defineProperty(exports, \"computeHmac\", ({\n    enumerable: true,\n    get: function() {\n        return hmac_js_1.computeHmac;\n    }\n}));\nconst keccak_js_1 = __webpack_require__(/*! ./keccak.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/keccak.js\");\nObject.defineProperty(exports, \"keccak256\", ({\n    enumerable: true,\n    get: function() {\n        return keccak_js_1.keccak256;\n    }\n}));\nconst ripemd160_js_1 = __webpack_require__(/*! ./ripemd160.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js\");\nObject.defineProperty(exports, \"ripemd160\", ({\n    enumerable: true,\n    get: function() {\n        return ripemd160_js_1.ripemd160;\n    }\n}));\nconst pbkdf2_js_1 = __webpack_require__(/*! ./pbkdf2.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js\");\nObject.defineProperty(exports, \"pbkdf2\", ({\n    enumerable: true,\n    get: function() {\n        return pbkdf2_js_1.pbkdf2;\n    }\n}));\nconst random_js_1 = __webpack_require__(/*! ./random.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/random.js\");\nObject.defineProperty(exports, \"randomBytes\", ({\n    enumerable: true,\n    get: function() {\n        return random_js_1.randomBytes;\n    }\n}));\nconst scrypt_js_1 = __webpack_require__(/*! ./scrypt.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js\");\nObject.defineProperty(exports, \"scrypt\", ({\n    enumerable: true,\n    get: function() {\n        return scrypt_js_1.scrypt;\n    }\n}));\nObject.defineProperty(exports, \"scryptSync\", ({\n    enumerable: true,\n    get: function() {\n        return scrypt_js_1.scryptSync;\n    }\n}));\nconst sha2_js_1 = __webpack_require__(/*! ./sha2.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/sha2.js\");\nObject.defineProperty(exports, \"sha256\", ({\n    enumerable: true,\n    get: function() {\n        return sha2_js_1.sha256;\n    }\n}));\nObject.defineProperty(exports, \"sha512\", ({\n    enumerable: true,\n    get: function() {\n        return sha2_js_1.sha512;\n    }\n}));\nvar signing_key_js_1 = __webpack_require__(/*! ./signing-key.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js\");\nObject.defineProperty(exports, \"SigningKey\", ({\n    enumerable: true,\n    get: function() {\n        return signing_key_js_1.SigningKey;\n    }\n}));\nvar signature_js_1 = __webpack_require__(/*! ./signature.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/signature.js\");\nObject.defineProperty(exports, \"Signature\", ({\n    enumerable: true,\n    get: function() {\n        return signature_js_1.Signature;\n    }\n}));\n/**\n *  Once called, prevents any future change to the underlying cryptographic\n *  primitives using the ``.register`` feature for hooks.\n */ function lock() {\n    hmac_js_1.computeHmac.lock();\n    keccak_js_1.keccak256.lock();\n    pbkdf2_js_1.pbkdf2.lock();\n    random_js_1.randomBytes.lock();\n    ripemd160_js_1.ripemd160.lock();\n    scrypt_js_1.scrypt.lock();\n    scrypt_js_1.scryptSync.lock();\n    sha2_js_1.sha256.lock();\n    sha2_js_1.sha512.lock();\n    random_js_1.randomBytes.lock();\n}\nexports.lock = lock; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Q0FLQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDMU87QUFDQSw4Q0FBOEM7QUFDOUMsTUFBTWMsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckNqQiwrQ0FBOEM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFVBQVVELFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SCxNQUFNSyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Q2pCLDZDQUE0QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsWUFBWVAsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JILE1BQU1RLGlCQUFpQkosbUJBQU9BLENBQUMsb0ZBQWdCO0FBQy9DakIsNkNBQTRDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlVCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEgsTUFBTVUsY0FBY0wsbUJBQU9BLENBQUMsOEVBQWE7QUFDekNqQiwwQ0FBeUM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLFlBQVliLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRyxNQUFNYyxjQUFjTixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Q2pCLCtDQUE4QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksWUFBWVQsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3pILE1BQU1VLGNBQWNQLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDakIsMENBQXlDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxZQUFZaEIsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9HUiw4Q0FBNkM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLFlBQVlqQixVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkgsTUFBTWtCLFlBQVlSLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDakIsMENBQXlDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTSxVQUFVZCxNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0dYLDBDQUF5QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT00sVUFBVWYsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdHLElBQUlnQixtQkFBbUJULG1CQUFPQSxDQUFDLHdGQUFrQjtBQUNqRGpCLDhDQUE2QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT08saUJBQWlCcEIsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVILElBQUlxQixpQkFBaUJWLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3Q2pCLDZDQUE0QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1EsZUFBZXRCLFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SDs7O0NBR0MsR0FDRCxTQUFTRDtJQUNMWSxVQUFVRCxXQUFXLENBQUNYLElBQUk7SUFDMUJnQixZQUFZUCxTQUFTLENBQUNULElBQUk7SUFDMUJrQixZQUFZYixNQUFNLENBQUNMLElBQUk7SUFDdkJtQixZQUFZVCxXQUFXLENBQUNWLElBQUk7SUFDNUJpQixlQUFlVCxTQUFTLENBQUNSLElBQUk7SUFDN0JvQixZQUFZaEIsTUFBTSxDQUFDSixJQUFJO0lBQ3ZCb0IsWUFBWWpCLFVBQVUsQ0FBQ0gsSUFBSTtJQUMzQnFCLFVBQVVkLE1BQU0sQ0FBQ1AsSUFBSTtJQUNyQnFCLFVBQVVmLE1BQU0sQ0FBQ04sSUFBSTtJQUNyQm1CLFlBQVlULFdBQVcsQ0FBQ1YsSUFBSTtBQUNoQztBQUNBRixZQUFZLEdBQUdFLE1BQ2YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL2luZGV4LmpzPzRhYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrIG9mIEV0aGVyZXVtIGlzIHRoZSB1bmRlcmx5aW5nXG4gKiAgY3J5cHRvZ3JhcGhpYyBwcmltaXRpdmVzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9jcnlwdG86Q3J5cHRvZ3JhcGhpYyBGdW5jdGlvbnMgICBbYWJvdXQtY3J5cHRvXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvY2sgPSBleHBvcnRzLlNpZ25hdHVyZSA9IGV4cG9ydHMuU2lnbmluZ0tleSA9IGV4cG9ydHMuc2NyeXB0U3luYyA9IGV4cG9ydHMuc2NyeXB0ID0gZXhwb3J0cy5wYmtkZjIgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLmNvbXB1dGVIbWFjID0gdm9pZCAwO1xubnVsbDtcbi8vIFdlIGltcG9ydCBhbGwgdGhlc2Ugc28gd2UgY2FuIGV4cG9ydCBsb2NrKClcbmNvbnN0IGhtYWNfanNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaG1hY19qc18xLmNvbXB1dGVIbWFjOyB9IH0pO1xuY29uc3Qga2VjY2FrX2pzXzEgPSByZXF1aXJlKFwiLi9rZWNjYWsuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJrZWNjYWsyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtlY2Nha19qc18xLmtlY2NhazI1NjsgfSB9KTtcbmNvbnN0IHJpcGVtZDE2MF9qc18xID0gcmVxdWlyZShcIi4vcmlwZW1kMTYwLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmlwZW1kMTYwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByaXBlbWQxNjBfanNfMS5yaXBlbWQxNjA7IH0gfSk7XG5jb25zdCBwYmtkZjJfanNfMSA9IHJlcXVpcmUoXCIuL3Bia2RmMi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBia2RmMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGJrZGYyX2pzXzEucGJrZGYyOyB9IH0pO1xuY29uc3QgcmFuZG9tX2pzXzEgPSByZXF1aXJlKFwiLi9yYW5kb20uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmFuZG9tX2pzXzEucmFuZG9tQnl0ZXM7IH0gfSk7XG5jb25zdCBzY3J5cHRfanNfMSA9IHJlcXVpcmUoXCIuL3NjcnlwdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNjcnlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NyeXB0X2pzXzEuc2NyeXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyeXB0U3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NyeXB0X2pzXzEuc2NyeXB0U3luYzsgfSB9KTtcbmNvbnN0IHNoYTJfanNfMSA9IHJlcXVpcmUoXCIuL3NoYTIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTJfanNfMS5zaGEyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGE1MTJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYTJfanNfMS5zaGE1MTI7IH0gfSk7XG52YXIgc2lnbmluZ19rZXlfanNfMSA9IHJlcXVpcmUoXCIuL3NpZ25pbmcta2V5LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmluZ0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ19rZXlfanNfMS5TaWduaW5nS2V5OyB9IH0pO1xudmFyIHNpZ25hdHVyZV9qc18xID0gcmVxdWlyZShcIi4vc2lnbmF0dXJlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmF0dXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduYXR1cmVfanNfMS5TaWduYXR1cmU7IH0gfSk7XG4vKipcbiAqICBPbmNlIGNhbGxlZCwgcHJldmVudHMgYW55IGZ1dHVyZSBjaGFuZ2UgdG8gdGhlIHVuZGVybHlpbmcgY3J5cHRvZ3JhcGhpY1xuICogIHByaW1pdGl2ZXMgdXNpbmcgdGhlIGBgLnJlZ2lzdGVyYGAgZmVhdHVyZSBmb3IgaG9va3MuXG4gKi9cbmZ1bmN0aW9uIGxvY2soKSB7XG4gICAgaG1hY19qc18xLmNvbXB1dGVIbWFjLmxvY2soKTtcbiAgICBrZWNjYWtfanNfMS5rZWNjYWsyNTYubG9jaygpO1xuICAgIHBia2RmMl9qc18xLnBia2RmMi5sb2NrKCk7XG4gICAgcmFuZG9tX2pzXzEucmFuZG9tQnl0ZXMubG9jaygpO1xuICAgIHJpcGVtZDE2MF9qc18xLnJpcGVtZDE2MC5sb2NrKCk7XG4gICAgc2NyeXB0X2pzXzEuc2NyeXB0LmxvY2soKTtcbiAgICBzY3J5cHRfanNfMS5zY3J5cHRTeW5jLmxvY2soKTtcbiAgICBzaGEyX2pzXzEuc2hhMjU2LmxvY2soKTtcbiAgICBzaGEyX2pzXzEuc2hhNTEyLmxvY2soKTtcbiAgICByYW5kb21fanNfMS5yYW5kb21CeXRlcy5sb2NrKCk7XG59XG5leHBvcnRzLmxvY2sgPSBsb2NrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9jayIsIlNpZ25hdHVyZSIsIlNpZ25pbmdLZXkiLCJzY3J5cHRTeW5jIiwic2NyeXB0IiwicGJrZGYyIiwic2hhNTEyIiwic2hhMjU2IiwicmlwZW1kMTYwIiwia2VjY2FrMjU2IiwicmFuZG9tQnl0ZXMiLCJjb21wdXRlSG1hYyIsImhtYWNfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwia2VjY2FrX2pzXzEiLCJyaXBlbWQxNjBfanNfMSIsInBia2RmMl9qc18xIiwicmFuZG9tX2pzXzEiLCJzY3J5cHRfanNfMSIsInNoYTJfanNfMSIsInNpZ25pbmdfa2V5X2pzXzEiLCJzaWduYXR1cmVfanNfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/keccak.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/keccak.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.keccak256 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(rsc)/./node_modules/@noble/hashes/sha3.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _keccak256 = function(data) {\n    return (0, sha3_1.keccak_256)(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */ function keccak256(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__keccak256(data));\n}\nexports.keccak256 = keccak256;\nkeccak256._ = _keccak256;\nkeccak256.lock = function() {\n    locked = true;\n};\nkeccak256.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256); //# sourceMappingURL=keccak.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8va2VjY2FrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxzRUFBb0I7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLElBQUlFLFNBQVM7QUFDYixNQUFNQyxhQUFhLFNBQVVDLElBQUk7SUFDN0IsT0FBTyxDQUFDLEdBQUdMLE9BQU9NLFVBQVUsRUFBRUQ7QUFDbEM7QUFDQSxJQUFJRSxjQUFjSDtBQUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QsU0FBU0wsVUFBVVMsS0FBSztJQUNwQixNQUFNSCxPQUFPLENBQUMsR0FBR0gsV0FBV08sUUFBUSxFQUFFRCxPQUFPO0lBQzdDLE9BQU8sQ0FBQyxHQUFHTixXQUFXUSxPQUFPLEVBQUVILFlBQVlGO0FBQy9DO0FBQ0FSLGlCQUFpQixHQUFHRTtBQUNwQkEsVUFBVVksQ0FBQyxHQUFHUDtBQUNkTCxVQUFVYSxJQUFJLEdBQUc7SUFBY1QsU0FBUztBQUFNO0FBQzlDSixVQUFVYyxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJWCxRQUFRO1FBQ1IsTUFBTSxJQUFJWSxVQUFVO0lBQ3hCO0lBQ0FSLGNBQWNPO0FBQ2xCO0FBQ0FuQixPQUFPcUIsTUFBTSxDQUFDakIsWUFDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8va2VjY2FrLmpzP2U1MGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBDcnlwdG9ncmFwaGljIGhhc2hpbmcgZnVuY3Rpb25zXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpIYXNoIEZ1bmN0aW9ucyBbYWJvdXQtY3J5cHRvLWhhc2hpbmddXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5sZXQgbG9ja2VkID0gZmFsc2U7XG5jb25zdCBfa2VjY2FrMjU2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gKDAsIHNoYTNfMS5rZWNjYWtfMjU2KShkYXRhKTtcbn07XG5sZXQgX19rZWNjYWsyNTYgPSBfa2VjY2FrMjU2O1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBLRUNDQUsyNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgVGhlICUlZGF0YSUlICoqbXVzdCoqIGJlIGEgZGF0YSByZXByZXNlbnRhdGlvbiwgdG8gY29tcHV0ZSB0aGVcbiAqICBoYXNoIG9mIFVURi04IGRhdGEgdXNlIHRoZSBbW2lkXV0gZnVuY3Rpb24uXG4gKlxuICogIEByZXR1cm5zIERhdGFIZXhzdHJpbmdcbiAqICBAZXhhbXBsZTpcbiAqICAgIGtlY2NhazI1NihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAga2VjY2FrMjU2KG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvIGJlIERhdGFIZXhTdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsXG4gKiAgICAvLyB0aHJvdy4gVG8gaGFzaCBVVEYtOCBkYXRhLCBzZWUgdGhlIG5vdGUgYWJvdmUuXG4gKiAgICBrZWNjYWsyNTYoXCJIZWxsbyBXb3JsZFwiKVxuICogICAgLy9fZXJyb3I6XG4gKi9cbmZ1bmN0aW9uIGtlY2NhazI1NihfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19rZWNjYWsyNTYoZGF0YSkpO1xufVxuZXhwb3J0cy5rZWNjYWsyNTYgPSBrZWNjYWsyNTY7XG5rZWNjYWsyNTYuXyA9IF9rZWNjYWsyNTY7XG5rZWNjYWsyNTYubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbmtlY2NhazI1Ni5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2VjY2FrMjU2IGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19rZWNjYWsyNTYgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUoa2VjY2FrMjU2KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlY2Nhay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJrZWNjYWsyNTYiLCJzaGEzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMSIsImxvY2tlZCIsIl9rZWNjYWsyNTYiLCJkYXRhIiwia2VjY2FrXzI1NiIsIl9fa2VjY2FrMjU2IiwiX2RhdGEiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIlR5cGVFcnJvciIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/keccak.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Password-Based Key-Derivation Function** is designed to create\n *  a sequence of bytes suitible as a **key** from a human-rememberable\n *  password.\n *\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pbkdf2 = void 0;\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _pbkdf2 = function(password, salt, iterations, keylen, algo) {\n    return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);\n};\nlet __pbkdf2 = _pbkdf2;\n/**\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\n *  the %%salt%% and using %%iterations%% of %%algo%%.\n *\n *  This PBKDF is outdated and should not be used in new projects, but is\n *  required to decrypt older files.\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the PBKDF2\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n *    //_result:\n */ function pbkdf2(_password, _salt, iterations, keylen, algo) {\n    const password = (0, index_js_1.getBytes)(_password, \"password\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));\n}\nexports.pbkdf2 = pbkdf2;\npbkdf2._ = _pbkdf2;\npbkdf2.lock = function() {\n    locked = true;\n};\npbkdf2.register = function(func) {\n    if (locked) {\n        throw new Error(\"pbkdf2 is locked\");\n    }\n    __pbkdf2 = func;\n};\nObject.freeze(pbkdf2); //# sourceMappingURL=pbkdf2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcGJrZGYyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7OztDQU1DLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsSUFBSUUsU0FBUztBQUNiLE1BQU1DLFVBQVUsU0FBVUMsUUFBUSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQzlELE9BQU8sQ0FBQyxHQUFHVCxZQUFZVSxVQUFVLEVBQUVMLFVBQVVDLE1BQU1DLFlBQVlDLFFBQVFDO0FBQzNFO0FBQ0EsSUFBSUUsV0FBV1A7QUFDZjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNMLE9BQU9hLFNBQVMsRUFBRUMsS0FBSyxFQUFFTixVQUFVLEVBQUVDLE1BQU0sRUFBRUMsSUFBSTtJQUN0RCxNQUFNSixXQUFXLENBQUMsR0FBR0gsV0FBV1ksUUFBUSxFQUFFRixXQUFXO0lBQ3JELE1BQU1OLE9BQU8sQ0FBQyxHQUFHSixXQUFXWSxRQUFRLEVBQUVELE9BQU87SUFDN0MsT0FBTyxDQUFDLEdBQUdYLFdBQVdhLE9BQU8sRUFBRUosU0FBU04sVUFBVUMsTUFBTUMsWUFBWUMsUUFBUUM7QUFDaEY7QUFDQVosY0FBYyxHQUFHRTtBQUNqQkEsT0FBT2lCLENBQUMsR0FBR1o7QUFDWEwsT0FBT2tCLElBQUksR0FBRztJQUFjZCxTQUFTO0FBQU07QUFDM0NKLE9BQU9tQixRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUM1QixJQUFJaEIsUUFBUTtRQUNSLE1BQU0sSUFBSWlCLE1BQU07SUFDcEI7SUFDQVQsV0FBV1E7QUFDZjtBQUNBeEIsT0FBTzBCLE1BQU0sQ0FBQ3RCLFNBQ2Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3Bia2RmMi5qcz80MDIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQSAqKlBhc3N3b3JkLUJhc2VkIEtleS1EZXJpdmF0aW9uIEZ1bmN0aW9uKiogaXMgZGVzaWduZWQgdG8gY3JlYXRlXG4gKiAgYSBzZXF1ZW5jZSBvZiBieXRlcyBzdWl0aWJsZSBhcyBhICoqa2V5KiogZnJvbSBhIGh1bWFuLXJlbWVtYmVyYWJsZVxuICogIHBhc3N3b3JkLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86UGFzc3dvcmRzICBbYWJvdXQtcGJrZGZdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGJrZGYyID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvX2pzXzEgPSByZXF1aXJlKFwiLi9jcnlwdG8uanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3Bia2RmMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKSB7XG4gICAgcmV0dXJuICgwLCBjcnlwdG9fanNfMS5wYmtkZjJTeW5jKShwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKTtcbn07XG5sZXQgX19wYmtkZjIgPSBfcGJrZGYyO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW2xpbmstcGJrZGYyXV0gZm9yICUla2V5bGVuJSUgYnl0ZXMgZm9yICUlcGFzc3dvcmQlJSB1c2luZ1xuICogIHRoZSAlJXNhbHQlJSBhbmQgdXNpbmcgJSVpdGVyYXRpb25zJSUgb2YgJSVhbGdvJSUuXG4gKlxuICogIFRoaXMgUEJLREYgaXMgb3V0ZGF0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBpbiBuZXcgcHJvamVjdHMsIGJ1dCBpc1xuICogIHJlcXVpcmVkIHRvIGRlY3J5cHQgb2xkZXIgZmlsZXMuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcbiAqXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBQQktERjJcbiAqICAgIHBia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCAxMDI0LCAxNiwgXCJzaGEyNTZcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gcGJrZGYyKF9wYXNzd29yZCwgX3NhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgYWxnbykge1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9wYXNzd29yZCwgXCJwYXNzd29yZFwiKTtcbiAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9zYWx0LCBcInNhbHRcIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmhleGxpZnkpKF9fcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pKTtcbn1cbmV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xucGJrZGYyLl8gPSBfcGJrZGYyO1xucGJrZGYyLmxvY2sgPSBmdW5jdGlvbiAoKSB7IGxvY2tlZCA9IHRydWU7IH07XG5wYmtkZjIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGJrZGYyIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19wYmtkZjIgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocGJrZGYyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYmtkZjIiLCJjcnlwdG9fanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwibG9ja2VkIiwiX3Bia2RmMiIsInBhc3N3b3JkIiwic2FsdCIsIml0ZXJhdGlvbnMiLCJrZXlsZW4iLCJhbGdvIiwicGJrZGYyU3luYyIsIl9fcGJrZGYyIiwiX3Bhc3N3b3JkIiwiX3NhbHQiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIkVycm9yIiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/random.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/random.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = void 0;\n/**\n *  A **Cryptographically Secure Random Value** is one that has been\n *  generated with additional care take to prevent side-channels\n *  from allowing others to detect it and prevent others from through\n *  coincidence generate the same values.\n *\n *  @_subsection: api/crypto:Random Values  [about-crypto-random]\n */ const crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nlet locked = false;\nconst _randomBytes = function(length) {\n    return new Uint8Array((0, crypto_js_1.randomBytes)(length));\n};\nlet __randomBytes = _randomBytes;\n/**\n *  Return %%length%% bytes of cryptographically secure random data.\n *\n *  @example:\n *    randomBytes(8)\n *    //_result:\n */ function randomBytes(length) {\n    return __randomBytes(length);\n}\nexports.randomBytes = randomBytes;\nrandomBytes._ = _randomBytes;\nrandomBytes.lock = function() {\n    locked = true;\n};\nrandomBytes.register = function(func) {\n    if (locked) {\n        throw new Error(\"randomBytes is locked\");\n    }\n    __randomBytes = func;\n};\nObject.freeze(randomBytes); //# sourceMappingURL=random.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmFuZG9tLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCOzs7Ozs7O0NBT0MsR0FDRCxNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxJQUFJQyxTQUFTO0FBQ2IsTUFBTUMsZUFBZSxTQUFVQyxNQUFNO0lBQ2pDLE9BQU8sSUFBSUMsV0FBVyxDQUFDLEdBQUdMLFlBQVlELFdBQVcsRUFBRUs7QUFDdkQ7QUFDQSxJQUFJRSxnQkFBZ0JIO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNELFNBQVNKLFlBQVlLLE1BQU07SUFDdkIsT0FBT0UsY0FBY0Y7QUFDekI7QUFDQVAsbUJBQW1CLEdBQUdFO0FBQ3RCQSxZQUFZUSxDQUFDLEdBQUdKO0FBQ2hCSixZQUFZUyxJQUFJLEdBQUc7SUFBY04sU0FBUztBQUFNO0FBQ2hESCxZQUFZVSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUNqQyxJQUFJUixRQUFRO1FBQ1IsTUFBTSxJQUFJUyxNQUFNO0lBQ3BCO0lBQ0FMLGdCQUFnQkk7QUFDcEI7QUFDQWYsT0FBT2lCLE1BQU0sQ0FBQ2IsY0FDZCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmFuZG9tLmpzP2I4NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gdm9pZCAwO1xuLyoqXG4gKiAgQSAqKkNyeXB0b2dyYXBoaWNhbGx5IFNlY3VyZSBSYW5kb20gVmFsdWUqKiBpcyBvbmUgdGhhdCBoYXMgYmVlblxuICogIGdlbmVyYXRlZCB3aXRoIGFkZGl0aW9uYWwgY2FyZSB0YWtlIHRvIHByZXZlbnQgc2lkZS1jaGFubmVsc1xuICogIGZyb20gYWxsb3dpbmcgb3RoZXJzIHRvIGRldGVjdCBpdCBhbmQgcHJldmVudCBvdGhlcnMgZnJvbSB0aHJvdWdoXG4gKiAgY29pbmNpZGVuY2UgZ2VuZXJhdGUgdGhlIHNhbWUgdmFsdWVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9jcnlwdG86UmFuZG9tIFZhbHVlcyAgW2Fib3V0LWNyeXB0by1yYW5kb21dXG4gKi9cbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4vY3J5cHRvLmpzXCIpO1xubGV0IGxvY2tlZCA9IGZhbHNlO1xuY29uc3QgX3JhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgoMCwgY3J5cHRvX2pzXzEucmFuZG9tQnl0ZXMpKGxlbmd0aCkpO1xufTtcbmxldCBfX3JhbmRvbUJ5dGVzID0gX3JhbmRvbUJ5dGVzO1xuLyoqXG4gKiAgUmV0dXJuICUlbGVuZ3RoJSUgYnl0ZXMgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBkYXRhLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJhbmRvbUJ5dGVzKDgpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIHJldHVybiBfX3JhbmRvbUJ5dGVzKGxlbmd0aCk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG5yYW5kb21CeXRlcy5fID0gX3JhbmRvbUJ5dGVzO1xucmFuZG9tQnl0ZXMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJhbmRvbUJ5dGVzLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhbmRvbUJ5dGVzIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yYW5kb21CeXRlcyA9IGZ1bmM7XG59O1xuT2JqZWN0LmZyZWV6ZShyYW5kb21CeXRlcyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmFuZG9tQnl0ZXMiLCJjcnlwdG9fanNfMSIsInJlcXVpcmUiLCJsb2NrZWQiLCJfcmFuZG9tQnl0ZXMiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwiX19yYW5kb21CeXRlcyIsIl8iLCJsb2NrIiwicmVnaXN0ZXIiLCJmdW5jIiwiRXJyb3IiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/random.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/ripemd160.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ripemd160 = void 0;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(rsc)/./node_modules/@noble/hashes/ripemd160.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet locked = false;\nconst _ripemd160 = function(data) {\n    return (0, ripemd160_1.ripemd160)(data);\n};\nlet __ripemd160 = _ripemd160;\n/**\n *  Compute the cryptographic RIPEMD-160 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    ripemd160(\"0x\")\n *    //_result:\n *\n *    ripemd160(\"0x1337\")\n *    //_result:\n *\n *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function ripemd160(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__ripemd160(data));\n}\nexports.ripemd160 = ripemd160;\nripemd160._ = _ripemd160;\nripemd160.lock = function() {\n    locked = true;\n};\nripemd160.register = function(func) {\n    if (locked) {\n        throw new TypeError(\"ripemd160 is locked\");\n    }\n    __ripemd160 = func;\n};\nObject.freeze(ripemd160); //# sourceMappingURL=ripemd160.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmlwZW1kMTYwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLGdGQUF5QjtBQUNyRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsSUFBSUUsU0FBUztBQUNiLE1BQU1DLGFBQWEsU0FBVUMsSUFBSTtJQUM3QixPQUFPLENBQUMsR0FBR0wsWUFBWUQsU0FBUyxFQUFFTTtBQUN0QztBQUNBLElBQUlDLGNBQWNGO0FBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsU0FBU0wsVUFBVVEsS0FBSztJQUNwQixNQUFNRixPQUFPLENBQUMsR0FBR0gsV0FBV00sUUFBUSxFQUFFRCxPQUFPO0lBQzdDLE9BQU8sQ0FBQyxHQUFHTCxXQUFXTyxPQUFPLEVBQUVILFlBQVlEO0FBQy9DO0FBQ0FSLGlCQUFpQixHQUFHRTtBQUNwQkEsVUFBVVcsQ0FBQyxHQUFHTjtBQUNkTCxVQUFVWSxJQUFJLEdBQUc7SUFBY1IsU0FBUztBQUFNO0FBQzlDSixVQUFVYSxRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUMvQixJQUFJVixRQUFRO1FBQ1IsTUFBTSxJQUFJVyxVQUFVO0lBQ3hCO0lBQ0FSLGNBQWNPO0FBQ2xCO0FBQ0FsQixPQUFPb0IsTUFBTSxDQUFDaEIsWUFDZCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vcmlwZW1kMTYwLmpzPzY4YTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IHZvaWQgMDtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmxldCBsb2NrZWQgPSBmYWxzZTtcbmNvbnN0IF9yaXBlbWQxNjAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKShkYXRhKTtcbn07XG5sZXQgX19yaXBlbWQxNjAgPSBfcmlwZW1kMTYwO1xuLyoqXG4gKiAgQ29tcHV0ZSB0aGUgY3J5cHRvZ3JhcGhpYyBSSVBFTUQtMTYwIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJpcGVtZDE2MChcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgcmlwZW1kMTYwKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKi9cbmZ1bmN0aW9uIHJpcGVtZDE2MChfZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19yaXBlbWQxNjAoZGF0YSkpO1xufVxuZXhwb3J0cy5yaXBlbWQxNjAgPSByaXBlbWQxNjA7XG5yaXBlbWQxNjAuXyA9IF9yaXBlbWQxNjA7XG5yaXBlbWQxNjAubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkID0gdHJ1ZTsgfTtcbnJpcGVtZDE2MC5yZWdpc3RlciA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmlwZW1kMTYwIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19yaXBlbWQxNjAgPSBmdW5jO1xufTtcbk9iamVjdC5mcmVlemUocmlwZW1kMTYwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyaXBlbWQxNjAiLCJyaXBlbWQxNjBfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwibG9ja2VkIiwiX3JpcGVtZDE2MCIsImRhdGEiLCJfX3JpcGVtZDE2MCIsIl9kYXRhIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJUeXBlRXJyb3IiLCJmcmVlemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/ripemd160.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/scrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.scryptSync = exports.scrypt = void 0;\nconst scrypt_1 = __webpack_require__(/*! @noble/hashes/scrypt */ \"(rsc)/./node_modules/@noble/hashes/scrypt.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nlet lockedSync = false, lockedAsync = false;\nconst _scryptAsync = async function(passwd, salt, N, r, p, dkLen, onProgress) {\n    return await (0, scrypt_1.scryptAsync)(passwd, salt, {\n        N,\n        r,\n        p,\n        dkLen,\n        onProgress\n    });\n};\nconst _scryptSync = function(passwd, salt, N, r, p, dkLen) {\n    return (0, scrypt_1.scrypt)(passwd, salt, {\n        N,\n        r,\n        p,\n        dkLen\n    });\n};\nlet __scryptAsync = _scryptAsync;\nlet __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */ async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\n    const passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nexports.scrypt = scrypt;\nscrypt._ = _scryptAsync;\nscrypt.lock = function() {\n    lockedAsync = true;\n};\nscrypt.register = function(func) {\n    if (lockedAsync) {\n        throw new Error(\"scrypt is locked\");\n    }\n    __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */ function scryptSync(_passwd, _salt, N, r, p, dkLen) {\n    const passwd = (0, index_js_1.getBytes)(_passwd, \"passwd\");\n    const salt = (0, index_js_1.getBytes)(_salt, \"salt\");\n    return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nexports.scryptSync = scryptSync;\nscryptSync._ = _scryptSync;\nscryptSync.lock = function() {\n    lockedSync = true;\n};\nscryptSync.register = function(func) {\n    if (lockedSync) {\n        throw new Error(\"scryptSync is locked\");\n    }\n    __scryptSync = func;\n};\nObject.freeze(scryptSync); //# sourceMappingURL=scrypt.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2NyeXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDM0MsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMsMEVBQXNCO0FBQy9DLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxJQUFJRSxhQUFhLE9BQU9DLGNBQWM7QUFDdEMsTUFBTUMsZUFBZSxlQUFnQkMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUssRUFBRUMsVUFBVTtJQUN6RSxPQUFPLE1BQU0sQ0FBQyxHQUFHWixTQUFTYSxXQUFXLEVBQUVQLFFBQVFDLE1BQU07UUFBRUM7UUFBR0M7UUFBR0M7UUFBR0M7UUFBT0M7SUFBVztBQUN0RjtBQUNBLE1BQU1FLGNBQWMsU0FBVVIsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7SUFDdEQsT0FBTyxDQUFDLEdBQUdYLFNBQVNELE1BQU0sRUFBRU8sUUFBUUMsTUFBTTtRQUFFQztRQUFHQztRQUFHQztRQUFHQztJQUFNO0FBQy9EO0FBQ0EsSUFBSUksZ0JBQWdCVjtBQUNwQixJQUFJVyxlQUFlRjtBQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0NDLEdBQ0QsZUFBZWYsT0FBT2tCLE9BQU8sRUFBRUMsS0FBSyxFQUFFVixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVRLFFBQVE7SUFDMUQsTUFBTWIsU0FBUyxDQUFDLEdBQUdKLFdBQVdrQixRQUFRLEVBQUVILFNBQVM7SUFDakQsTUFBTVYsT0FBTyxDQUFDLEdBQUdMLFdBQVdrQixRQUFRLEVBQUVGLE9BQU87SUFDN0MsT0FBTyxDQUFDLEdBQUdoQixXQUFXbUIsT0FBTyxFQUFFLE1BQU1OLGNBQWNULFFBQVFDLE1BQU1DLEdBQUdDLEdBQUdDLEdBQUdDLE9BQU9RO0FBQ3JGO0FBQ0F2QixjQUFjLEdBQUdHO0FBQ2pCQSxPQUFPdUIsQ0FBQyxHQUFHakI7QUFDWE4sT0FBT3dCLElBQUksR0FBRztJQUFjbkIsY0FBYztBQUFNO0FBQ2hETCxPQUFPeUIsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSXJCLGFBQWE7UUFDYixNQUFNLElBQUlzQixNQUFNO0lBQ3BCO0lBQ0FYLGdCQUFnQlU7QUFDcEI7QUFDQS9CLE9BQU9pQyxNQUFNLENBQUM1QjtBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxTQUFTRCxXQUFXbUIsT0FBTyxFQUFFQyxLQUFLLEVBQUVWLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7SUFDOUMsTUFBTUwsU0FBUyxDQUFDLEdBQUdKLFdBQVdrQixRQUFRLEVBQUVILFNBQVM7SUFDakQsTUFBTVYsT0FBTyxDQUFDLEdBQUdMLFdBQVdrQixRQUFRLEVBQUVGLE9BQU87SUFDN0MsT0FBTyxDQUFDLEdBQUdoQixXQUFXbUIsT0FBTyxFQUFFTCxhQUFhVixRQUFRQyxNQUFNQyxHQUFHQyxHQUFHQyxHQUFHQztBQUN2RTtBQUNBZixrQkFBa0IsR0FBR0U7QUFDckJBLFdBQVd3QixDQUFDLEdBQUdSO0FBQ2ZoQixXQUFXeUIsSUFBSSxHQUFHO0lBQWNwQixhQUFhO0FBQU07QUFDbkRMLFdBQVcwQixRQUFRLEdBQUcsU0FBVUMsSUFBSTtJQUNoQyxJQUFJdEIsWUFBWTtRQUNaLE1BQU0sSUFBSXVCLE1BQU07SUFDcEI7SUFDQVYsZUFBZVM7QUFDbkI7QUFDQS9CLE9BQU9pQyxNQUFNLENBQUM3QixhQUNkLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2NyeXB0by9zY3J5cHQuanM/MTc0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2NyeXB0U3luYyA9IGV4cG9ydHMuc2NyeXB0ID0gdm9pZCAwO1xuY29uc3Qgc2NyeXB0XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zY3J5cHRcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xubGV0IGxvY2tlZFN5bmMgPSBmYWxzZSwgbG9ja2VkQXN5bmMgPSBmYWxzZTtcbmNvbnN0IF9zY3J5cHRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzKSB7XG4gICAgcmV0dXJuIGF3YWl0ICgwLCBzY3J5cHRfMS5zY3J5cHRBc3luYykocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuLCBvblByb2dyZXNzIH0pO1xufTtcbmNvbnN0IF9zY3J5cHRTeW5jID0gZnVuY3Rpb24gKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pIHtcbiAgICByZXR1cm4gKDAsIHNjcnlwdF8xLnNjcnlwdCkocGFzc3dkLCBzYWx0LCB7IE4sIHIsIHAsIGRrTGVuIH0pO1xufTtcbmxldCBfX3NjcnlwdEFzeW5jID0gX3NjcnlwdEFzeW5jO1xubGV0IF9fc2NyeXB0U3luYyA9IF9zY3J5cHRTeW5jO1xuLyoqXG4gKiAgVGhlIFtbbGluay13aWtpLXNjcnlwdF1dIHVzZXMgYSBtZW1vcnkgYW5kIGNwdSBoYXJkIG1ldGhvZCBvZlxuICogIGRlcml2YXRpb24gdG8gaW5jcmVhc2UgdGhlIHJlc291cmNlIGNvc3QgdG8gYnJ1dGUtZm9yY2UgYSBwYXNzd29yZFxuICogIGZvciBhIGdpdmVuIGtleS5cbiAqXG4gKiAgVGhpcyBtZWFucyB0aGlzIGFsZ29yaXRobSBpcyBpbnRlbnRpb25hbGx5IHNsb3csIGFuZCBjYW4gYmUgdHVuZWQgdG9cbiAqICBiZWNvbWUgc2xvd2VyLiBBcyBjb21wdXRhdGlvbiBhbmQgbWVtb3J5IHNwZWVkIGltcHJvdmUgb3ZlciB0aW1lLFxuICogIGluY3JlYXNpbmcgdGhlIGRpZmZpY3VsdHkgbWFpbnRhaW5zIHRoZSBjb3N0IG9mIGFuIGF0dGFja2VyLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSB0YXJnZXQgdGltZSBvZiA1IHNlY29uZHMgaXMgdXNlZCwgYSBsZWdpdGltYXRlIHVzZXJcbiAqICB3aGljaCBrbm93cyB0aGVpciBwYXNzd29yZCByZXF1aXJlcyBvbmx5IDUgc2Vjb25kcyB0byB1bmxvY2sgdGhlaXJcbiAqICBhY2NvdW50LiBBIDYgY2hhcmFjdGVyIHBhc3N3b3JkIGhhcyA2OCBiaWxsaW9uIHBvc3NpYmlsaXRpZXMsIHdoaWNoXG4gKiAgd291bGQgcmVxdWlyZSBhbiBhdHRhY2tlciB0byBpbnZlc3Qgb3ZlciAxMCwwMDAgeWVhcnMgb2YgQ1BVIHRpbWUuIFRoaXNcbiAqICBpcyBvZiBjb3Vyc2UgYSBjcnVkZSBleGFtcGxlIChhcyBwYXNzd29yZCBnZW5lcmFsbHkgYXJlbid0IHJhbmRvbSksXG4gKiAgYnV0IGRlbW9uc3RyYXRlcyB0byB2YWx1ZSBvZiBpbXBvc2luZyBsYXJnZSBjb3N0cyB0byBkZWNyeXB0aW9uLlxuICpcbiAqICBGb3IgdGhpcyByZWFzb24sIGlmIGJ1aWxkaW5nIGEgVUkgd2hpY2ggaW52b2x2ZWQgZGVjcnlwdGluZyBvclxuICogIGVuY3J5cHRpbmcgZGF0c2EgdXNpbmcgc2NyeXB0LCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYVxuICogIFtbUHJvZ3Jlc3NDYWxsYmFja11dIChhcyBldmVudCBzaG9ydCBwZXJpb2RzIGNhbiBzZWVtIGxpayBhbiBldGVybml0eVxuICogIGlmIHRoZSBVSSBmcmVlemVzKS4gSW5jbHVkaW5nIHRoZSBwaHJhc2UgLy9cImRlY3J5cHRpbmdcIi8vIGluIHRoZSBVSVxuICogIGNhbiBhbHNvIGhlbHAsIGFzc3VyaW5nIHRoZSB1c2VyIHRoZWlyIHdhaXRpbmcgaXMgZm9yIGEgZ29vZCByZWFzb24uXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOlBhc3N3b3Jkc1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIFRoZSBwYXNzd29yZCBtdXN0IGJlIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIGl0IGlzIGdlbmVyYWxseVxuICogICAgLy8gYmVzdCBwcmFjdGljZXMgdG8gZW5zdXJlIHRoZSBzdHJpbmcgaGFzIGJlZW4gbm9ybWFsaXplZC4gTWFueVxuICogICAgLy8gZm9ybWF0cyBleHBsaWNpdGx5IGluZGljYXRlIHRoZSBub3JtYWxpemF0aW9uIGZvcm0gdG8gdXNlLlxuICogICAgcGFzc3dvcmQgPSBcImhlbGxvXCJcbiAqICAgIHBhc3N3b3JkQnl0ZXMgPSB0b1V0ZjhCeXRlcyhwYXNzd29yZCwgXCJORktDXCIpXG4gKlxuICogICAgc2FsdCA9IGlkKFwic29tZS1zYWx0XCIpXG4gKlxuICogICAgLy8gQ29tcHV0ZSB0aGUgc2NyeXB0XG4gKiAgICBzY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjcnlwdChfcGFzc3dkLCBfc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzKSB7XG4gICAgY29uc3QgcGFzc3dkID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoYXdhaXQgX19zY3J5cHRBc3luYyhwYXNzd2QsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzcykpO1xufVxuZXhwb3J0cy5zY3J5cHQgPSBzY3J5cHQ7XG5zY3J5cHQuXyA9IF9zY3J5cHRBc3luYztcbnNjcnlwdC5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWRBc3luYyA9IHRydWU7IH07XG5zY3J5cHQucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmIChsb2NrZWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHQgaXMgbG9ja2VkXCIpO1xuICAgIH1cbiAgICBfX3NjcnlwdEFzeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdCk7XG4vKipcbiAqICBQcm92aWRlcyBhIHN5bmNocm9ub3VzIHZhcmlhbnQgb2YgW1tzY3J5cHRdXS5cbiAqXG4gKiAgVGhpcyB3aWxsIGNvbXBsZXRlbHkgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBpbiBhIGJyb3dzZXIgYW5kIHdpbGxcbiAqICBwcmV2ZW50IGFueSBldmVudCBsb29wIGZyb20gcHJvZ3Jlc3NpbmcuIEZvciB0aGlzIHJlYXNvbiwgaXQgaXNcbiAqICBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmFyaWFudF0oc2NyeXB0KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86UGFzc3dvcmRzXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gVGhlIHBhc3N3b3JkIG11c3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLCBhbmQgaXQgaXMgZ2VuZXJhbGx5XG4gKiAgICAvLyBiZXN0IHByYWN0aWNlcyB0byBlbnN1cmUgdGhlIHN0cmluZyBoYXMgYmVlbiBub3JtYWxpemVkLiBNYW55XG4gKiAgICAvLyBmb3JtYXRzIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhlIG5vcm1hbGl6YXRpb24gZm9ybSB0byB1c2UuXG4gKiAgICBwYXNzd29yZCA9IFwiaGVsbG9cIlxuICogICAgcGFzc3dvcmRCeXRlcyA9IHRvVXRmOEJ5dGVzKHBhc3N3b3JkLCBcIk5GS0NcIilcbiAqXG4gKiAgICBzYWx0ID0gaWQoXCJzb21lLXNhbHRcIilcbiAqXG4gKiAgICAvLyBDb21wdXRlIHRoZSBzY3J5cHRcbiAqICAgIHNjcnlwdFN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgMTAyNCwgOCwgMSwgMTYpXG4gKiAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNjcnlwdFN5bmMoX3Bhc3N3ZCwgX3NhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgY29uc3QgcGFzc3dkID0gKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXMpKF9wYXNzd2QsIFwicGFzc3dkXCIpO1xuICAgIGNvbnN0IHNhbHQgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoX3NhbHQsIFwic2FsdFwiKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkoX19zY3J5cHRTeW5jKHBhc3N3ZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcbn1cbmV4cG9ydHMuc2NyeXB0U3luYyA9IHNjcnlwdFN5bmM7XG5zY3J5cHRTeW5jLl8gPSBfc2NyeXB0U3luYztcbnNjcnlwdFN5bmMubG9jayA9IGZ1bmN0aW9uICgpIHsgbG9ja2VkU3luYyA9IHRydWU7IH07XG5zY3J5cHRTeW5jLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkU3luYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3J5cHRTeW5jIGlzIGxvY2tlZFwiKTtcbiAgICB9XG4gICAgX19zY3J5cHRTeW5jID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNjcnlwdFN5bmMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NyeXB0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNjcnlwdFN5bmMiLCJzY3J5cHQiLCJzY3J5cHRfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwibG9ja2VkU3luYyIsImxvY2tlZEFzeW5jIiwiX3NjcnlwdEFzeW5jIiwicGFzc3dkIiwic2FsdCIsIk4iLCJyIiwicCIsImRrTGVuIiwib25Qcm9ncmVzcyIsInNjcnlwdEFzeW5jIiwiX3NjcnlwdFN5bmMiLCJfX3NjcnlwdEFzeW5jIiwiX19zY3J5cHRTeW5jIiwiX3Bhc3N3ZCIsIl9zYWx0IiwicHJvZ3Jlc3MiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJfIiwibG9jayIsInJlZ2lzdGVyIiwiZnVuYyIsIkVycm9yIiwiZnJlZXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/scrypt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/sha2.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/sha2.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha512 = exports.sha256 = void 0;\nconst crypto_js_1 = __webpack_require__(/*! ./crypto.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/crypto.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst _sha256 = function(data) {\n    return (0, crypto_js_1.createHash)(\"sha256\").update(data).digest();\n};\nconst _sha512 = function(data) {\n    return (0, crypto_js_1.createHash)(\"sha512\").update(data).digest();\n};\nlet __sha256 = _sha256;\nlet __sha512 = _sha512;\nlet locked256 = false, locked512 = false;\n/**\n *  Compute the cryptographic SHA2-256 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha256(\"0x\")\n *    //_result:\n *\n *    sha256(\"0x1337\")\n *    //_result:\n *\n *    sha256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n */ function sha256(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__sha256(data));\n}\nexports.sha256 = sha256;\nsha256._ = _sha256;\nsha256.lock = function() {\n    locked256 = true;\n};\nsha256.register = function(func) {\n    if (locked256) {\n        throw new Error(\"sha256 is locked\");\n    }\n    __sha256 = func;\n};\nObject.freeze(sha256);\n/**\n *  Compute the cryptographic SHA2-512 hash of %%data%%.\n *\n *  @_docloc: api/crypto:Hash Functions\n *  @returns DataHexstring\n *\n *  @example:\n *    sha512(\"0x\")\n *    //_result:\n *\n *    sha512(\"0x1337\")\n *    //_result:\n *\n *    sha512(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n */ function sha512(_data) {\n    const data = (0, index_js_1.getBytes)(_data, \"data\");\n    return (0, index_js_1.hexlify)(__sha512(data));\n}\nexports.sha512 = sha512;\nsha512._ = _sha512;\nsha512.lock = function() {\n    locked512 = true;\n};\nsha512.register = function(func) {\n    if (locked512) {\n        throw new Error(\"sha512 is locked\");\n    }\n    __sha512 = func;\n};\nObject.freeze(sha256); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2hhMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN2QyxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsVUFBVSxTQUFVQyxJQUFJO0lBQzFCLE9BQU8sQ0FBQyxHQUFHSixZQUFZSyxVQUFVLEVBQUUsVUFBVUMsTUFBTSxDQUFDRixNQUFNRyxNQUFNO0FBQ3BFO0FBQ0EsTUFBTUMsVUFBVSxTQUFVSixJQUFJO0lBQzFCLE9BQU8sQ0FBQyxHQUFHSixZQUFZSyxVQUFVLEVBQUUsVUFBVUMsTUFBTSxDQUFDRixNQUFNRyxNQUFNO0FBQ3BFO0FBQ0EsSUFBSUUsV0FBV047QUFDZixJQUFJTyxXQUFXRjtBQUNmLElBQUlHLFlBQVksT0FBT0MsWUFBWTtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELFNBQVNiLE9BQU9jLEtBQUs7SUFDakIsTUFBTVQsT0FBTyxDQUFDLEdBQUdGLFdBQVdZLFFBQVEsRUFBRUQsT0FBTztJQUM3QyxPQUFPLENBQUMsR0FBR1gsV0FBV2EsT0FBTyxFQUFFTixTQUFTTDtBQUM1QztBQUNBUixjQUFjLEdBQUdHO0FBQ2pCQSxPQUFPaUIsQ0FBQyxHQUFHYjtBQUNYSixPQUFPa0IsSUFBSSxHQUFHO0lBQWNOLFlBQVk7QUFBTTtBQUM5Q1osT0FBT21CLFFBQVEsR0FBRyxTQUFVQyxJQUFJO0lBQzVCLElBQUlSLFdBQVc7UUFDWCxNQUFNLElBQUlTLE1BQU07SUFDcEI7SUFDQVgsV0FBV1U7QUFDZjtBQUNBekIsT0FBTzJCLE1BQU0sQ0FBQ3RCO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsU0FBU0QsT0FBT2UsS0FBSztJQUNqQixNQUFNVCxPQUFPLENBQUMsR0FBR0YsV0FBV1ksUUFBUSxFQUFFRCxPQUFPO0lBQzdDLE9BQU8sQ0FBQyxHQUFHWCxXQUFXYSxPQUFPLEVBQUVMLFNBQVNOO0FBQzVDO0FBQ0FSLGNBQWMsR0FBR0U7QUFDakJBLE9BQU9rQixDQUFDLEdBQUdSO0FBQ1hWLE9BQU9tQixJQUFJLEdBQUc7SUFBY0wsWUFBWTtBQUFNO0FBQzlDZCxPQUFPb0IsUUFBUSxHQUFHLFNBQVVDLElBQUk7SUFDNUIsSUFBSVAsV0FBVztRQUNYLE1BQU0sSUFBSVEsTUFBTTtJQUNwQjtJQUNBVixXQUFXUztBQUNmO0FBQ0F6QixPQUFPMkIsTUFBTSxDQUFDdEIsU0FDZCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2hhMi5qcz8wMjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTI1NiA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b19qc18xID0gcmVxdWlyZShcIi4vY3J5cHRvLmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IF9zaGEyNTYgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAoMCwgY3J5cHRvX2pzXzEuY3JlYXRlSGFzaCkoXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmNvbnN0IF9zaGE1MTIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAoMCwgY3J5cHRvX2pzXzEuY3JlYXRlSGFzaCkoXCJzaGE1MTJcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufTtcbmxldCBfX3NoYTI1NiA9IF9zaGEyNTY7XG5sZXQgX19zaGE1MTIgPSBfc2hhNTEyO1xubGV0IGxvY2tlZDI1NiA9IGZhbHNlLCBsb2NrZWQ1MTIgPSBmYWxzZTtcbi8qKlxuICogIENvbXB1dGUgdGhlIGNyeXB0b2dyYXBoaWMgU0hBMi0yNTYgaGFzaCBvZiAlJWRhdGElJS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86SGFzaCBGdW5jdGlvbnNcbiAqICBAcmV0dXJucyBEYXRhSGV4c3RyaW5nXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgc2hhMjU2KFwiMHhcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYoXCIweDEzMzdcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICBzaGEyNTYobmV3IFVpbnQ4QXJyYXkoWyAweDEzLCAweDM3IF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZnVuY3Rpb24gc2hhMjU2KF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX3NoYTI1NihkYXRhKSk7XG59XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcbnNoYTI1Ni5fID0gX3NoYTI1NjtcbnNoYTI1Ni5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQyNTYgPSB0cnVlOyB9O1xuc2hhMjU2LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkMjU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTI1NiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhMjU2ID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vKipcbiAqICBDb21wdXRlIHRoZSBjcnlwdG9ncmFwaGljIFNIQTItNTEyIGhhc2ggb2YgJSVkYXRhJSUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvY3J5cHRvOkhhc2ggRnVuY3Rpb25zXG4gKiAgQHJldHVybnMgRGF0YUhleHN0cmluZ1xuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHNoYTUxMihcIjB4XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKFwiMHgxMzM3XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgc2hhNTEyKG5ldyBVaW50OEFycmF5KFsgMHgxMywgMHgzNyBdKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gc2hhNTEyKF9kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9ICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShfZGF0YSwgXCJkYXRhXCIpO1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShfX3NoYTUxMihkYXRhKSk7XG59XG5leHBvcnRzLnNoYTUxMiA9IHNoYTUxMjtcbnNoYTUxMi5fID0gX3NoYTUxMjtcbnNoYTUxMi5sb2NrID0gZnVuY3Rpb24gKCkgeyBsb2NrZWQ1MTIgPSB0cnVlOyB9O1xuc2hhNTEyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICBpZiAobG9ja2VkNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYTUxMiBpcyBsb2NrZWRcIik7XG4gICAgfVxuICAgIF9fc2hhNTEyID0gZnVuYztcbn07XG5PYmplY3QuZnJlZXplKHNoYTI1Nik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYTUxMiIsInNoYTI1NiIsImNyeXB0b19qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzEiLCJfc2hhMjU2IiwiZGF0YSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJfc2hhNTEyIiwiX19zaGEyNTYiLCJfX3NoYTUxMiIsImxvY2tlZDI1NiIsImxvY2tlZDUxMiIsIl9kYXRhIiwiZ2V0Qnl0ZXMiLCJoZXhsaWZ5IiwiXyIsImxvY2siLCJyZWdpc3RlciIsImZ1bmMiLCJFcnJvciIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/sha2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/signature.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/signature.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Signature = void 0;\nconst index_js_1 = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// Constants\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst _guard = {};\nfunction toUint256(value) {\n    return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);\n}\n/**\n *  A Signature  @TODO\n *\n *\n *  @_docloc: api/crypto:Signing\n */ class Signature {\n    #r;\n    #s;\n    #v;\n    #networkV;\n    /**\n     *  The ``r`` value for a signautre.\n     *\n     *  This represents the ``x`` coordinate of a \"reference\" or\n     *  challenge point, from which the ``y`` can be computed.\n     */ get r() {\n        return this.#r;\n    }\n    set r(value) {\n        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, \"invalid r\", \"value\", value);\n        this.#r = (0, index_js_2.hexlify)(value);\n    }\n    /**\n     *  The ``s`` value for a signature.\n     */ get s() {\n        return this.#s;\n    }\n    set s(_value) {\n        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, \"invalid s\", \"value\", _value);\n        const value = (0, index_js_2.hexlify)(_value);\n        (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, \"non-canonical s\", \"value\", value);\n        this.#s = value;\n    }\n    /**\n     *  The ``v`` value for a signature.\n     *\n     *  Since a given ``x`` value for ``r`` has two possible values for\n     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``\n     *  values to use.\n     *\n     *  It is normalized to the values ``27`` or ``28`` for legacy\n     *  purposes.\n     */ get v() {\n        return this.#v;\n    }\n    set v(value) {\n        const v = (0, index_js_2.getNumber)(value, \"value\");\n        (0, index_js_2.assertArgument)(v === 27 || v === 28, \"invalid v\", \"v\", value);\n        this.#v = v;\n    }\n    /**\n     *  The EIP-155 ``v`` for legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get networkV() {\n        return this.#networkV;\n    }\n    /**\n     *  The chain ID for EIP-155 legacy transactions. For non-legacy\n     *  transactions, this value is ``null``.\n     */ get legacyChainId() {\n        const v = this.networkV;\n        if (v == null) {\n            return null;\n        }\n        return Signature.getChainId(v);\n    }\n    /**\n     *  The ``yParity`` for the signature.\n     *\n     *  See ``v`` for more details on how this value is used.\n     */ get yParity() {\n        return this.v === 27 ? 0 : 1;\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation of the ``yParity``\n     *  and ``s`` compacted into a single ``bytes32``.\n     */ get yParityAndS() {\n        // The EIP-2098 compact representation\n        const yParityAndS = (0, index_js_2.getBytes)(this.s);\n        if (this.yParity) {\n            yParityAndS[0] |= 0x80;\n        }\n        return (0, index_js_2.hexlify)(yParityAndS);\n    }\n    /**\n     *  The [[link-eip-2098]] compact representation.\n     */ get compactSerialized() {\n        return (0, index_js_2.concat)([\n            this.r,\n            this.yParityAndS\n        ]);\n    }\n    /**\n     *  The serialized representation.\n     */ get serialized() {\n        return (0, index_js_2.concat)([\n            this.r,\n            this.s,\n            this.yParity ? \"0x1c\" : \"0x1b\"\n        ]);\n    }\n    /**\n     *  @private\n     */ constructor(guard, r, s, v){\n        (0, index_js_2.assertPrivate)(guard, _guard, \"Signature\");\n        this.#r = r;\n        this.#s = s;\n        this.#v = v;\n        this.#networkV = null;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`;\n    }\n    /**\n     *  Returns a new identical [[Signature]].\n     */ clone() {\n        const clone = new Signature(_guard, this.r, this.s, this.v);\n        if (this.networkV) {\n            clone.#networkV = this.networkV;\n        }\n        return clone;\n    }\n    /**\n     *  Returns a representation that is compatible with ``JSON.stringify``.\n     */ toJSON() {\n        const networkV = this.networkV;\n        return {\n            _type: \"signature\",\n            networkV: networkV != null ? networkV.toString() : null,\n            r: this.r,\n            s: this.s,\n            v: this.v\n        };\n    }\n    /**\n     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.\n     *\n     *  @example:\n     *    Signature.getChainId(45)\n     *    //_result:\n     *\n     *    Signature.getChainId(46)\n     *    //_result:\n     */ static getChainId(v) {\n        const bv = (0, index_js_2.getBigInt)(v, \"v\");\n        // The v is not an EIP-155 v, so it is the unspecified chain ID\n        if (bv == BN_27 || bv == BN_28) {\n            return BN_0;\n        }\n        // Bad value for an EIP-155 v\n        (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid EIP-155 v\", \"v\", v);\n        return (bv - BN_35) / BN_2;\n    }\n    /**\n     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.\n     *\n     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``\n     *  property to include the chain ID.\n     *\n     *  @example:\n     *    Signature.getChainIdV(5, 27)\n     *    //_result:\n     *\n     *    Signature.getChainIdV(5, 28)\n     *    //_result:\n     *\n     */ static getChainIdV(chainId, v) {\n        return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);\n    }\n    /**\n     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,\n     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.\n     *\n     *  @example:\n     *    // The values 0 and 1 imply v is actually yParity\n     *    Signature.getNormalizedV(0)\n     *    //_result:\n     *\n     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)\n     *    Signature.getNormalizedV(27)\n     *    //_result:\n     *\n     *    // Legacy EIP-155 transaction (i.e. >= 35)\n     *    Signature.getNormalizedV(46)\n     *    //_result:\n     *\n     *    // Invalid values throw\n     *    Signature.getNormalizedV(5)\n     *    //_error:\n     */ static getNormalizedV(v) {\n        const bv = (0, index_js_2.getBigInt)(v);\n        if (bv === BN_0 || bv === BN_27) {\n            return 27;\n        }\n        if (bv === BN_1 || bv === BN_28) {\n            return 28;\n        }\n        (0, index_js_2.assertArgument)(bv >= BN_35, \"invalid v\", \"v\", v);\n        // Otherwise, EIP-155 v means odd is 27 and even is 28\n        return bv & BN_1 ? 27 : 28;\n    }\n    /**\n     *  Creates a new [[Signature]].\n     *\n     *  If no %%sig%% is provided, a new [[Signature]] is created\n     *  with default values.\n     *\n     *  If %%sig%% is a string, it is parsed.\n     */ static from(sig) {\n        function assertError(check, message) {\n            (0, index_js_2.assertArgument)(check, message, \"signature\", sig);\n        }\n        ;\n        if (sig == null) {\n            return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);\n        }\n        if (typeof sig === \"string\") {\n            const bytes = (0, index_js_2.getBytes)(sig, \"signature\");\n            if (bytes.length === 64) {\n                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                const v = s[0] & 0x80 ? 28 : 27;\n                s[0] &= 0x7f;\n                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);\n            }\n            if (bytes.length === 65) {\n                const r = (0, index_js_2.hexlify)(bytes.slice(0, 32));\n                const s = bytes.slice(32, 64);\n                assertError((s[0] & 0x80) === 0, \"non-canonical s\");\n                const v = Signature.getNormalizedV(bytes[64]);\n                return new Signature(_guard, r, (0, index_js_2.hexlify)(s), v);\n            }\n            assertError(false, \"invalid raw signature length\");\n        }\n        if (sig instanceof Signature) {\n            return sig.clone();\n        }\n        // Get r\n        const _r = sig.r;\n        assertError(_r != null, \"missing r\");\n        const r = toUint256(_r);\n        // Get s; by any means necessary (we check consistency below)\n        const s = function(s, yParityAndS) {\n            if (s != null) {\n                return toUint256(s);\n            }\n            if (yParityAndS != null) {\n                assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                const bytes = (0, index_js_2.getBytes)(yParityAndS);\n                bytes[0] &= 0x7f;\n                return (0, index_js_2.hexlify)(bytes);\n            }\n            assertError(false, \"missing s\");\n        }(sig.s, sig.yParityAndS);\n        assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, \"non-canonical s\");\n        // Get v; by any means necessary (we check consistency below)\n        const { networkV, v } = function(_v, yParityAndS, yParity) {\n            if (_v != null) {\n                const v = (0, index_js_2.getBigInt)(_v);\n                return {\n                    networkV: v >= BN_35 ? v : undefined,\n                    v: Signature.getNormalizedV(v)\n                };\n            }\n            if (yParityAndS != null) {\n                assertError((0, index_js_2.isHexString)(yParityAndS, 32), \"invalid yParityAndS\");\n                return {\n                    v: (0, index_js_2.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27\n                };\n            }\n            if (yParity != null) {\n                switch((0, index_js_2.getNumber)(yParity, \"sig.yParity\")){\n                    case 0:\n                        return {\n                            v: 27\n                        };\n                    case 1:\n                        return {\n                            v: 28\n                        };\n                }\n                assertError(false, \"invalid yParity\");\n            }\n            assertError(false, \"missing v\");\n        }(sig.v, sig.yParityAndS, sig.yParity);\n        const result = new Signature(_guard, r, s, v);\n        if (networkV) {\n            result.#networkV = networkV;\n        }\n        // If multiple of v, yParity, yParityAndS we given, check they match\n        assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, \"sig.yParity\") === result.yParity, \"yParity mismatch\");\n        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, \"yParityAndS mismatch\");\n        return result;\n    }\n}\nexports.Signature = Signature; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDBGQUF1QjtBQUNsRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsWUFBWTtBQUNaLE1BQU1FLE9BQU9DLE9BQU87QUFDcEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLFFBQVFILE9BQU87QUFDckIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxRQUFRTCxPQUFPO0FBQ3JCLE1BQU1NLFNBQVMsQ0FBQztBQUNoQixTQUFTQyxVQUFVYixLQUFLO0lBQ3BCLE9BQU8sQ0FBQyxHQUFHSSxXQUFXVSxZQUFZLEVBQUUsQ0FBQyxHQUFHVixXQUFXVyxTQUFTLEVBQUVmLFFBQVE7QUFDMUU7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU1DO0lBQ0YsQ0FBQ2UsQ0FBQyxDQUFDO0lBQ0gsQ0FBQ0MsQ0FBQyxDQUFDO0lBQ0gsQ0FBQ0MsQ0FBQyxDQUFDO0lBQ0gsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1Y7Ozs7O0tBS0MsR0FDRCxJQUFJSCxJQUFJO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsQ0FBQztJQUFFO0lBQzFCLElBQUlBLEVBQUVoQixLQUFLLEVBQUU7UUFDUixJQUFHSSxXQUFXZ0IsY0FBYyxFQUFFLENBQUMsR0FBR2hCLFdBQVdpQixVQUFVLEVBQUVyQixXQUFXLElBQUksYUFBYSxTQUFTQTtRQUMvRixJQUFJLENBQUMsQ0FBQ2dCLENBQUMsR0FBRyxDQUFDLEdBQUdaLFdBQVdrQixPQUFPLEVBQUV0QjtJQUN0QztJQUNBOztLQUVDLEdBQ0QsSUFBSWlCLElBQUk7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxDQUFDO0lBQUU7SUFDMUIsSUFBSUEsRUFBRU0sTUFBTSxFQUFFO1FBQ1QsSUFBR25CLFdBQVdnQixjQUFjLEVBQUUsQ0FBQyxHQUFHaEIsV0FBV2lCLFVBQVUsRUFBRUUsWUFBWSxJQUFJLGFBQWEsU0FBU0E7UUFDaEcsTUFBTXZCLFFBQVEsQ0FBQyxHQUFHSSxXQUFXa0IsT0FBTyxFQUFFQztRQUNyQyxJQUFHbkIsV0FBV2dCLGNBQWMsRUFBRUksU0FBU3hCLE1BQU15QixTQUFTLENBQUMsR0FBRyxNQUFNLEdBQUcsbUJBQW1CLFNBQVN6QjtRQUNoRyxJQUFJLENBQUMsQ0FBQ2lCLENBQUMsR0FBR2pCO0lBQ2Q7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDRCxJQUFJa0IsSUFBSTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLENBQUM7SUFBRTtJQUMxQixJQUFJQSxFQUFFbEIsS0FBSyxFQUFFO1FBQ1QsTUFBTWtCLElBQUksQ0FBQyxHQUFHZCxXQUFXc0IsU0FBUyxFQUFFMUIsT0FBTztRQUMxQyxJQUFHSSxXQUFXZ0IsY0FBYyxFQUFFRixNQUFNLE1BQU1BLE1BQU0sSUFBSSxhQUFhLEtBQUtsQjtRQUN2RSxJQUFJLENBQUMsQ0FBQ2tCLENBQUMsR0FBR0E7SUFDZDtJQUNBOzs7S0FHQyxHQUNELElBQUlDLFdBQVc7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxRQUFRO0lBQUU7SUFDeEM7OztLQUdDLEdBQ0QsSUFBSVEsZ0JBQWdCO1FBQ2hCLE1BQU1ULElBQUksSUFBSSxDQUFDQyxRQUFRO1FBQ3ZCLElBQUlELEtBQUssTUFBTTtZQUNYLE9BQU87UUFDWDtRQUNBLE9BQU9qQixVQUFVMkIsVUFBVSxDQUFDVjtJQUNoQztJQUNBOzs7O0tBSUMsR0FDRCxJQUFJVyxVQUFVO1FBQ1YsT0FBTyxJQUFLLENBQUNYLENBQUMsS0FBSyxLQUFNLElBQUk7SUFDakM7SUFDQTs7O0tBR0MsR0FDRCxJQUFJWSxjQUFjO1FBQ2Qsc0NBQXNDO1FBQ3RDLE1BQU1BLGNBQWMsQ0FBQyxHQUFHMUIsV0FBVzJCLFFBQVEsRUFBRSxJQUFJLENBQUNkLENBQUM7UUFDbkQsSUFBSSxJQUFJLENBQUNZLE9BQU8sRUFBRTtZQUNkQyxXQUFXLENBQUMsRUFBRSxJQUFJO1FBQ3RCO1FBQ0EsT0FBTyxDQUFDLEdBQUcxQixXQUFXa0IsT0FBTyxFQUFFUTtJQUNuQztJQUNBOztLQUVDLEdBQ0QsSUFBSUUsb0JBQW9CO1FBQ3BCLE9BQU8sQ0FBQyxHQUFHNUIsV0FBVzZCLE1BQU0sRUFBRTtZQUFDLElBQUksQ0FBQ2pCLENBQUM7WUFBRSxJQUFJLENBQUNjLFdBQVc7U0FBQztJQUM1RDtJQUNBOztLQUVDLEdBQ0QsSUFBSUksYUFBYTtRQUNiLE9BQU8sQ0FBQyxHQUFHOUIsV0FBVzZCLE1BQU0sRUFBRTtZQUFDLElBQUksQ0FBQ2pCLENBQUM7WUFBRSxJQUFJLENBQUNDLENBQUM7WUFBRyxJQUFJLENBQUNZLE9BQU8sR0FBRyxTQUFTO1NBQVE7SUFDcEY7SUFDQTs7S0FFQyxHQUNETSxZQUFZQyxLQUFLLEVBQUVwQixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxDQUFFO1FBQ3ZCLElBQUdkLFdBQVdpQyxhQUFhLEVBQUVELE9BQU94QixRQUFRO1FBQzdDLElBQUksQ0FBQyxDQUFDSSxDQUFDLEdBQUdBO1FBQ1YsSUFBSSxDQUFDLENBQUNDLENBQUMsR0FBR0E7UUFDVixJQUFJLENBQUMsQ0FBQ0MsQ0FBQyxHQUFHQTtRQUNWLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUc7SUFDckI7SUFDQSxDQUFDbUIsT0FBT0MsR0FBRyxDQUFDLDhCQUE4QixHQUFHO1FBQ3pDLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUN2QixDQUFDLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQ0MsQ0FBQyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUNZLE9BQU8sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDVixRQUFRLENBQUMsRUFBRSxDQUFDO0lBQy9HO0lBQ0E7O0tBRUMsR0FDRHFCLFFBQVE7UUFDSixNQUFNQSxRQUFRLElBQUl2QyxVQUFVVyxRQUFRLElBQUksQ0FBQ0ksQ0FBQyxFQUFFLElBQUksQ0FBQ0MsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsQ0FBQztRQUMxRCxJQUFJLElBQUksQ0FBQ0MsUUFBUSxFQUFFO1lBQ2ZxQixNQUFNLENBQUNyQixRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO1FBQ25DO1FBQ0EsT0FBT3FCO0lBQ1g7SUFDQTs7S0FFQyxHQUNEQyxTQUFTO1FBQ0wsTUFBTXRCLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE9BQU87WUFDSHVCLE9BQU87WUFDUHZCLFVBQVcsWUFBYSxPQUFRQSxTQUFTd0IsUUFBUSxLQUFLO1lBQ3REM0IsR0FBRyxJQUFJLENBQUNBLENBQUM7WUFBRUMsR0FBRyxJQUFJLENBQUNBLENBQUM7WUFBRUMsR0FBRyxJQUFJLENBQUNBLENBQUM7UUFDbkM7SUFDSjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELE9BQU9VLFdBQVdWLENBQUMsRUFBRTtRQUNqQixNQUFNMEIsS0FBSyxDQUFDLEdBQUd4QyxXQUFXeUMsU0FBUyxFQUFFM0IsR0FBRztRQUN4QywrREFBK0Q7UUFDL0QsSUFBSSxNQUFPVCxTQUFXbUMsTUFBTWxDLE9BQVE7WUFDaEMsT0FBT0w7UUFDWDtRQUNBLDZCQUE2QjtRQUM1QixJQUFHRCxXQUFXZ0IsY0FBYyxFQUFFd0IsTUFBTWpDLE9BQU8scUJBQXFCLEtBQUtPO1FBQ3RFLE9BQU8sQ0FBQzBCLEtBQUtqQyxLQUFJLElBQUtIO0lBQzFCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7S0FhQyxHQUNELE9BQU9zQyxZQUFZQyxPQUFPLEVBQUU3QixDQUFDLEVBQUU7UUFDM0IsT0FBTyxDQUFFLEdBQUdkLFdBQVd5QyxTQUFTLEVBQUVFLFdBQVd2QyxPQUFRRixPQUFPLEtBQUtZLElBQUk7SUFDekU7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRCxPQUFPOEIsZUFBZTlCLENBQUMsRUFBRTtRQUNyQixNQUFNMEIsS0FBSyxDQUFDLEdBQUd4QyxXQUFXeUMsU0FBUyxFQUFFM0I7UUFDckMsSUFBSTBCLE9BQU92QyxRQUFRdUMsT0FBT25DLE9BQU87WUFDN0IsT0FBTztRQUNYO1FBQ0EsSUFBSW1DLE9BQU9yQyxRQUFRcUMsT0FBT2xDLE9BQU87WUFDN0IsT0FBTztRQUNYO1FBQ0MsSUFBR04sV0FBV2dCLGNBQWMsRUFBRXdCLE1BQU1qQyxPQUFPLGFBQWEsS0FBS087UUFDOUQsc0RBQXNEO1FBQ3RELE9BQU8sS0FBTVgsT0FBUSxLQUFLO0lBQzlCO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE9BQU8wQyxLQUFLQyxHQUFHLEVBQUU7UUFDYixTQUFTQyxZQUFZQyxLQUFLLEVBQUVDLE9BQU87WUFDOUIsSUFBR2pELFdBQVdnQixjQUFjLEVBQUVnQyxPQUFPQyxTQUFTLGFBQWFIO1FBQ2hFOztRQUVBLElBQUlBLE9BQU8sTUFBTTtZQUNiLE9BQU8sSUFBSWpELFVBQVVXLFFBQVFWLFdBQVdvRCxRQUFRLEVBQUVwRCxXQUFXb0QsUUFBUSxFQUFFO1FBQzNFO1FBQ0EsSUFBSSxPQUFRSixRQUFTLFVBQVU7WUFDM0IsTUFBTUssUUFBUSxDQUFDLEdBQUduRCxXQUFXMkIsUUFBUSxFQUFFbUIsS0FBSztZQUM1QyxJQUFJSyxNQUFNQyxNQUFNLEtBQUssSUFBSTtnQkFDckIsTUFBTXhDLElBQUksQ0FBQyxHQUFHWixXQUFXa0IsT0FBTyxFQUFFaUMsTUFBTUUsS0FBSyxDQUFDLEdBQUc7Z0JBQ2pELE1BQU14QyxJQUFJc0MsTUFBTUUsS0FBSyxDQUFDLElBQUk7Z0JBQzFCLE1BQU12QyxJQUFJLENBQUUsQ0FBQyxFQUFFLEdBQUcsT0FBUSxLQUFLO2dCQUMvQkQsQ0FBQyxDQUFDLEVBQUUsSUFBSTtnQkFDUixPQUFPLElBQUloQixVQUFVVyxRQUFRSSxHQUFHLENBQUMsR0FBR1osV0FBV2tCLE9BQU8sRUFBRUwsSUFBSUM7WUFDaEU7WUFDQSxJQUFJcUMsTUFBTUMsTUFBTSxLQUFLLElBQUk7Z0JBQ3JCLE1BQU14QyxJQUFJLENBQUMsR0FBR1osV0FBV2tCLE9BQU8sRUFBRWlDLE1BQU1FLEtBQUssQ0FBQyxHQUFHO2dCQUNqRCxNQUFNeEMsSUFBSXNDLE1BQU1FLEtBQUssQ0FBQyxJQUFJO2dCQUMxQk4sWUFBWSxDQUFDbEMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFHLE1BQU8sR0FBRztnQkFDakMsTUFBTUMsSUFBSWpCLFVBQVUrQyxjQUFjLENBQUNPLEtBQUssQ0FBQyxHQUFHO2dCQUM1QyxPQUFPLElBQUl0RCxVQUFVVyxRQUFRSSxHQUFHLENBQUMsR0FBR1osV0FBV2tCLE9BQU8sRUFBRUwsSUFBSUM7WUFDaEU7WUFDQWlDLFlBQVksT0FBTztRQUN2QjtRQUNBLElBQUlELGVBQWVqRCxXQUFXO1lBQzFCLE9BQU9pRCxJQUFJVixLQUFLO1FBQ3BCO1FBQ0EsUUFBUTtRQUNSLE1BQU1rQixLQUFLUixJQUFJbEMsQ0FBQztRQUNoQm1DLFlBQVlPLE1BQU0sTUFBTTtRQUN4QixNQUFNMUMsSUFBSUgsVUFBVTZDO1FBQ3BCLDZEQUE2RDtRQUM3RCxNQUFNekMsSUFBSSxTQUFXQSxDQUFDLEVBQUVhLFdBQVc7WUFDL0IsSUFBSWIsS0FBSyxNQUFNO2dCQUNYLE9BQU9KLFVBQVVJO1lBQ3JCO1lBQ0EsSUFBSWEsZUFBZSxNQUFNO2dCQUNyQnFCLFlBQVksQ0FBQyxHQUFHL0MsV0FBV3VELFdBQVcsRUFBRTdCLGFBQWEsS0FBSztnQkFDMUQsTUFBTXlCLFFBQVEsQ0FBQyxHQUFHbkQsV0FBVzJCLFFBQVEsRUFBRUQ7Z0JBQ3ZDeUIsS0FBSyxDQUFDLEVBQUUsSUFBSTtnQkFDWixPQUFPLENBQUMsR0FBR25ELFdBQVdrQixPQUFPLEVBQUVpQztZQUNuQztZQUNBSixZQUFZLE9BQU87UUFDdkIsRUFBR0QsSUFBSWpDLENBQUMsRUFBRWlDLElBQUlwQixXQUFXO1FBQ3pCcUIsWUFBWSxDQUFDLENBQUMsR0FBRy9DLFdBQVcyQixRQUFRLEVBQUVkLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBRyxLQUFNLEdBQUc7UUFDMUQsNkRBQTZEO1FBQzdELE1BQU0sRUFBRUUsUUFBUSxFQUFFRCxDQUFDLEVBQUUsR0FBRyxTQUFXMEMsRUFBRSxFQUFFOUIsV0FBVyxFQUFFRCxPQUFPO1lBQ3ZELElBQUkrQixNQUFNLE1BQU07Z0JBQ1osTUFBTTFDLElBQUksQ0FBQyxHQUFHZCxXQUFXeUMsU0FBUyxFQUFFZTtnQkFDcEMsT0FBTztvQkFDSHpDLFVBQVcsS0FBTVIsUUFBU08sSUFBSTJDO29CQUM5QjNDLEdBQUdqQixVQUFVK0MsY0FBYyxDQUFDOUI7Z0JBQ2hDO1lBQ0o7WUFDQSxJQUFJWSxlQUFlLE1BQU07Z0JBQ3JCcUIsWUFBWSxDQUFDLEdBQUcvQyxXQUFXdUQsV0FBVyxFQUFFN0IsYUFBYSxLQUFLO2dCQUMxRCxPQUFPO29CQUFFWixHQUFJLENBQUUsR0FBR2QsV0FBVzJCLFFBQVEsRUFBRUQsWUFBWSxDQUFDLEVBQUUsR0FBRyxPQUFRLEtBQUs7Z0JBQUk7WUFDOUU7WUFDQSxJQUFJRCxXQUFXLE1BQU07Z0JBQ2pCLE9BQVEsQ0FBQyxHQUFHekIsV0FBV3NCLFNBQVMsRUFBRUcsU0FBUztvQkFDdkMsS0FBSzt3QkFBRyxPQUFPOzRCQUFFWCxHQUFHO3dCQUFHO29CQUN2QixLQUFLO3dCQUFHLE9BQU87NEJBQUVBLEdBQUc7d0JBQUc7Z0JBQzNCO2dCQUNBaUMsWUFBWSxPQUFPO1lBQ3ZCO1lBQ0FBLFlBQVksT0FBTztRQUN2QixFQUFHRCxJQUFJaEMsQ0FBQyxFQUFFZ0MsSUFBSXBCLFdBQVcsRUFBRW9CLElBQUlyQixPQUFPO1FBQ3RDLE1BQU1pQyxTQUFTLElBQUk3RCxVQUFVVyxRQUFRSSxHQUFHQyxHQUFHQztRQUMzQyxJQUFJQyxVQUFVO1lBQ1YyQyxPQUFPLENBQUMzQyxRQUFRLEdBQUdBO1FBQ3ZCO1FBQ0Esb0VBQW9FO1FBQ3BFZ0MsWUFBWUQsSUFBSXJCLE9BQU8sSUFBSSxRQUFRLENBQUMsR0FBR3pCLFdBQVdzQixTQUFTLEVBQUV3QixJQUFJckIsT0FBTyxFQUFFLG1CQUFtQmlDLE9BQU9qQyxPQUFPLEVBQUU7UUFDN0dzQixZQUFZRCxJQUFJcEIsV0FBVyxJQUFJLFFBQVFvQixJQUFJcEIsV0FBVyxLQUFLZ0MsT0FBT2hDLFdBQVcsRUFBRTtRQUMvRSxPQUFPZ0M7SUFDWDtBQUNKO0FBQ0EvRCxpQkFBaUIsR0FBR0UsV0FDcEIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3NpZ25hdHVyZS5qcz84NGJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vLyBDb25zdGFudHNcbmNvbnN0IEJOXzAgPSBCaWdJbnQoMCk7XG5jb25zdCBCTl8xID0gQmlnSW50KDEpO1xuY29uc3QgQk5fMiA9IEJpZ0ludCgyKTtcbmNvbnN0IEJOXzI3ID0gQmlnSW50KDI3KTtcbmNvbnN0IEJOXzI4ID0gQmlnSW50KDI4KTtcbmNvbnN0IEJOXzM1ID0gQmlnSW50KDM1KTtcbmNvbnN0IF9ndWFyZCA9IHt9O1xuZnVuY3Rpb24gdG9VaW50MjU2KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnplcm9QYWRWYWx1ZSkoKDAsIGluZGV4X2pzXzIudG9CZUFycmF5KSh2YWx1ZSksIDMyKTtcbn1cbi8qKlxuICogIEEgU2lnbmF0dXJlICBAVE9ET1xuICpcbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9jcnlwdG86U2lnbmluZ1xuICovXG5jbGFzcyBTaWduYXR1cmUge1xuICAgICNyO1xuICAgICNzO1xuICAgICN2O1xuICAgICNuZXR3b3JrVjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGBgcmBgIHZhbHVlIGZvciBhIHNpZ25hdXRyZS5cbiAgICAgKlxuICAgICAqICBUaGlzIHJlcHJlc2VudHMgdGhlIGBgeGBgIGNvb3JkaW5hdGUgb2YgYSBcInJlZmVyZW5jZVwiIG9yXG4gICAgICogIGNoYWxsZW5nZSBwb2ludCwgZnJvbSB3aGljaCB0aGUgYGB5YGAgY2FuIGJlIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGdldCByKCkgeyByZXR1cm4gdGhpcy4jcjsgfVxuICAgIHNldCByKHZhbHVlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMi5kYXRhTGVuZ3RoKSh2YWx1ZSkgPT09IDMyLCBcImludmFsaWQgclwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jciA9ICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHNgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IHMoKSB7IHJldHVybiB0aGlzLiNzOyB9XG4gICAgc2V0IHMoX3ZhbHVlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMi5kYXRhTGVuZ3RoKShfdmFsdWUpID09PSAzMiwgXCJpbnZhbGlkIHNcIiwgXCJ2YWx1ZVwiLCBfdmFsdWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc18yLmhleGxpZnkpKF92YWx1ZSk7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMCwgMykpIDwgOCwgXCJub24tY2Fub25pY2FsIHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuI3MgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBgYHZgYCB2YWx1ZSBmb3IgYSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2luY2UgYSBnaXZlbiBgYHhgYCB2YWx1ZSBmb3IgYGByYGAgaGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMgZm9yXG4gICAgICogIGl0cyBjb3JyZXNwb25kaW4gYGB5YGAsIHRoZSBgYHZgYCBpbmRpY2F0ZXMgd2hpY2ggb2YgdGhlIHR3byBgYHlgYFxuICAgICAqICB2YWx1ZXMgdG8gdXNlLlxuICAgICAqXG4gICAgICogIEl0IGlzIG5vcm1hbGl6ZWQgdG8gdGhlIHZhbHVlcyBgYDI3YGAgb3IgYGAyOGBgIGZvciBsZWdhY3lcbiAgICAgKiAgcHVycG9zZXMuXG4gICAgICovXG4gICAgZ2V0IHYoKSB7IHJldHVybiB0aGlzLiN2OyB9XG4gICAgc2V0IHYodmFsdWUpIHtcbiAgICAgICAgY29uc3QgdiA9ICgwLCBpbmRleF9qc18yLmdldE51bWJlcikodmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSh2ID09PSAyNyB8fCB2ID09PSAyOCwgXCJpbnZhbGlkIHZcIiwgXCJ2XCIsIHZhbHVlKTtcbiAgICAgICAgdGhpcy4jdiA9IHY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgRUlQLTE1NSBgYHZgYCBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucy4gRm9yIG5vbi1sZWdhY3lcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCB0aGlzIHZhbHVlIGlzIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBuZXR3b3JrVigpIHsgcmV0dXJuIHRoaXMuI25ldHdvcmtWOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbiBJRCBmb3IgRUlQLTE1NSBsZWdhY3kgdHJhbnNhY3Rpb25zLiBGb3Igbm9uLWxlZ2FjeVxuICAgICAqICB0cmFuc2FjdGlvbnMsIHRoaXMgdmFsdWUgaXMgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGxlZ2FjeUNoYWluSWQoKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmdldENoYWluSWQodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgYGB5UGFyaXR5YGAgZm9yIHRoZSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiAgU2VlIGBgdmBgIGZvciBtb3JlIGRldGFpbHMgb24gaG93IHRoaXMgdmFsdWUgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnYgPT09IDI3KSA/IDAgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjA5OF1dIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBgeVBhcml0eWBgXG4gICAgICogIGFuZCBgYHNgYCBjb21wYWN0ZWQgaW50byBhIHNpbmdsZSBgYGJ5dGVzMzJgYC5cbiAgICAgKi9cbiAgICBnZXQgeVBhcml0eUFuZFMoKSB7XG4gICAgICAgIC8vIFRoZSBFSVAtMjA5OCBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGNvbnN0IHlQYXJpdHlBbmRTID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnlQYXJpdHkpIHtcbiAgICAgICAgICAgIHlQYXJpdHlBbmRTWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHlQYXJpdHlBbmRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTIwOThdXSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGdldCBjb21wYWN0U2VyaWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmNvbmNhdCkoW3RoaXMuciwgdGhpcy55UGFyaXR5QW5kU10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZ2V0IHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5jb25jYXQpKFt0aGlzLnIsIHRoaXMucywgKHRoaXMueVBhcml0eSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCByLCBzLCB2KSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiU2lnbmF0dXJlXCIpO1xuICAgICAgICB0aGlzLiNyID0gcjtcbiAgICAgICAgdGhpcy4jcyA9IHM7XG4gICAgICAgIHRoaXMuI3YgPSB2O1xuICAgICAgICB0aGlzLiNuZXR3b3JrViA9IG51bGw7XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSgpIHtcbiAgICAgICAgcmV0dXJuIGBTaWduYXR1cmUgeyByOiBcIiR7dGhpcy5yfVwiLCBzOiBcIiR7dGhpcy5zfVwiLCB5UGFyaXR5OiAke3RoaXMueVBhcml0eX0sIG5ldHdvcmtWOiAke3RoaXMubmV0d29ya1Z9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBpZGVudGljYWwgW1tTaWduYXR1cmVdXS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgdGhpcy5yLCB0aGlzLnMsIHRoaXMudik7XG4gICAgICAgIGlmICh0aGlzLm5ldHdvcmtWKSB7XG4gICAgICAgICAgICBjbG9uZS4jbmV0d29ya1YgPSB0aGlzLm5ldHdvcmtWO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBgYEpTT04uc3RyaW5naWZ5YGAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrViA9IHRoaXMubmV0d29ya1Y7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJzaWduYXR1cmVcIixcbiAgICAgICAgICAgIG5ldHdvcmtWOiAoKG5ldHdvcmtWICE9IG51bGwpID8gbmV0d29ya1YudG9TdHJpbmcoKSA6IG51bGwpLFxuICAgICAgICAgICAgcjogdGhpcy5yLCBzOiB0aGlzLnMsIHY6IHRoaXMudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGNoYWluIElEIGZyb20gdGhlIGBgdmBgIGluIGEgbGVnYWN5IEVJUC0xNTUgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ1KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkKDQ2KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZCh2KSB7XG4gICAgICAgIGNvbnN0IGJ2ID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KSh2LCBcInZcIik7XG4gICAgICAgIC8vIFRoZSB2IGlzIG5vdCBhbiBFSVAtMTU1IHYsIHNvIGl0IGlzIHRoZSB1bnNwZWNpZmllZCBjaGFpbiBJRFxuICAgICAgICBpZiAoKGJ2ID09IEJOXzI3KSB8fCAoYnYgPT0gQk5fMjgpKSB7XG4gICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWQgdmFsdWUgZm9yIGFuIEVJUC0xNTUgdlxuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoYnYgPj0gQk5fMzUsIFwiaW52YWxpZCBFSVAtMTU1IHZcIiwgXCJ2XCIsIHYpO1xuICAgICAgICByZXR1cm4gKGJ2IC0gQk5fMzUpIC8gQk5fMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENvbXB1dGUgdGhlIGBgdmBgIGZvciBhIGNoYWluIElEIGZvciBhIGxlZ2FjeSBFSVAtMTU1IHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqICBMZWdhY3kgdHJhbnNhY3Rpb25zIHdoaWNoIHVzZSBbW2xpbmstZWlwLTE1NV1dIGhpamFjayB0aGUgYGB2YGBcbiAgICAgKiAgcHJvcGVydHkgdG8gaW5jbHVkZSB0aGUgY2hhaW4gSUQuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgU2lnbmF0dXJlLmdldENoYWluSWRWKDUsIDI3KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIFNpZ25hdHVyZS5nZXRDaGFpbklkVig1LCAyOClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2hhaW5JZFYoY2hhaW5JZCwgdikge1xuICAgICAgICByZXR1cm4gKCgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkoY2hhaW5JZCkgKiBCTl8yKSArIEJpZ0ludCgzNSArIHYgLSAyNyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDb21wdXRlIHRoZSBub3JtYWxpemVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBmcm9tIGEgYGB5UGFyaXJ0eWBgLFxuICAgICAqICBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBgYHZgYCBvciBhIGxlZ2FjeSBbW2xpbmstZWlwLTE1NV1dIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIC8vIFRoZSB2YWx1ZXMgMCBhbmQgMSBpbXBseSB2IGlzIGFjdHVhbGx5IHlQYXJpdHlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoMClcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgbm9uLUVJUC0xNTU5IHRyYW5zYWN0aW9uIChpLmUuIDI3IG9yIDI4KVxuICAgICAqICAgIFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVigyNylcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBMZWdhY3kgRUlQLTE1NSB0cmFuc2FjdGlvbiAoaS5lLiA+PSAzNSlcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNDYpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gSW52YWxpZCB2YWx1ZXMgdGhyb3dcbiAgICAgKiAgICBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYoNSlcbiAgICAgKiAgICAvL19lcnJvcjpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Tm9ybWFsaXplZFYodikge1xuICAgICAgICBjb25zdCBidiA9ICgwLCBpbmRleF9qc18yLmdldEJpZ0ludCkodik7XG4gICAgICAgIGlmIChidiA9PT0gQk5fMCB8fCBidiA9PT0gQk5fMjcpIHtcbiAgICAgICAgICAgIHJldHVybiAyNztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnYgPT09IEJOXzEgfHwgYnYgPT09IEJOXzI4KSB7XG4gICAgICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGJ2ID49IEJOXzM1LCBcImludmFsaWQgdlwiLCBcInZcIiwgdik7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgRUlQLTE1NSB2IG1lYW5zIG9kZCBpcyAyNyBhbmQgZXZlbiBpcyAyOFxuICAgICAgICByZXR1cm4gKGJ2ICYgQk5fMSkgPyAyNyA6IDI4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW1NpZ25hdHVyZV1dLlxuICAgICAqXG4gICAgICogIElmIG5vICUlc2lnJSUgaXMgcHJvdmlkZWQsIGEgbmV3IFtbU2lnbmF0dXJlXV0gaXMgY3JlYXRlZFxuICAgICAqICB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIElmICUlc2lnJSUgaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzaWcpIHtcbiAgICAgICAgZnVuY3Rpb24gYXNzZXJ0RXJyb3IoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShjaGVjaywgbWVzc2FnZSwgXCJzaWduYXR1cmVcIiwgc2lnKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChzaWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoX2d1YXJkLCBpbmRleF9qc18xLlplcm9IYXNoLCBpbmRleF9qc18xLlplcm9IYXNoLCAyNyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoc2lnKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoc2lnLCBcInNpZ25hdHVyZVwiKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9ICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IChzWzBdICYgMHg4MCkgPyAyOCA6IDI3O1xuICAgICAgICAgICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShfZ3VhcmQsIHIsICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHMpLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9ICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGJ5dGVzLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKHNbMF0gJiAweDgwKSA9PT0gMCwgXCJub24tY2Fub25pY2FsIHNcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IFNpZ25hdHVyZS5nZXROb3JtYWxpemVkVihieXRlc1s2NF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKF9ndWFyZCwgciwgKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkocyksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCByYXcgc2lnbmF0dXJlIGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJcbiAgICAgICAgY29uc3QgX3IgPSBzaWcucjtcbiAgICAgICAgYXNzZXJ0RXJyb3IoX3IgIT0gbnVsbCwgXCJtaXNzaW5nIHJcIik7XG4gICAgICAgIGNvbnN0IHIgPSB0b1VpbnQyNTYoX3IpO1xuICAgICAgICAvLyBHZXQgczsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHMgPSAoZnVuY3Rpb24gKHMsIHlQYXJpdHlBbmRTKSB7XG4gICAgICAgICAgICBpZiAocyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvVWludDI1NihzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5QW5kUyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoKDAsIGluZGV4X2pzXzIuaXNIZXhTdHJpbmcpKHlQYXJpdHlBbmRTLCAzMiksIFwiaW52YWxpZCB5UGFyaXR5QW5kU1wiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc18yLmdldEJ5dGVzKSh5UGFyaXR5QW5kUyk7XG4gICAgICAgICAgICAgICAgYnl0ZXNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyBzXCIpO1xuICAgICAgICB9KShzaWcucywgc2lnLnlQYXJpdHlBbmRTKTtcbiAgICAgICAgYXNzZXJ0RXJyb3IoKCgwLCBpbmRleF9qc18yLmdldEJ5dGVzKShzKVswXSAmIDB4ODApID09IDAsIFwibm9uLWNhbm9uaWNhbCBzXCIpO1xuICAgICAgICAvLyBHZXQgdjsgYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAod2UgY2hlY2sgY29uc2lzdGVuY3kgYmVsb3cpXG4gICAgICAgIGNvbnN0IHsgbmV0d29ya1YsIHYgfSA9IChmdW5jdGlvbiAoX3YsIHlQYXJpdHlBbmRTLCB5UGFyaXR5KSB7XG4gICAgICAgICAgICBpZiAoX3YgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKF92KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrVjogKCh2ID49IEJOXzM1KSA/IHYgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB2OiBTaWduYXR1cmUuZ2V0Tm9ybWFsaXplZFYodilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlQYXJpdHlBbmRTICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcigoMCwgaW5kZXhfanNfMi5pc0hleFN0cmluZykoeVBhcml0eUFuZFMsIDMyKSwgXCJpbnZhbGlkIHlQYXJpdHlBbmRTXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHY6ICgoKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKHlQYXJpdHlBbmRTKVswXSAmIDB4ODApID8gMjggOiAyNykgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5UGFyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKCgwLCBpbmRleF9qc18yLmdldE51bWJlcikoeVBhcml0eSwgXCJzaWcueVBhcml0eVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiB7IHY6IDI3IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHsgdjogMjggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwiaW52YWxpZCB5UGFyaXR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0RXJyb3IoZmFsc2UsIFwibWlzc2luZyB2XCIpO1xuICAgICAgICB9KShzaWcudiwgc2lnLnlQYXJpdHlBbmRTLCBzaWcueVBhcml0eSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaWduYXR1cmUoX2d1YXJkLCByLCBzLCB2KTtcbiAgICAgICAgaWYgKG5ldHdvcmtWKSB7XG4gICAgICAgICAgICByZXN1bHQuI25ldHdvcmtWID0gbmV0d29ya1Y7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbXVsdGlwbGUgb2YgdiwgeVBhcml0eSwgeVBhcml0eUFuZFMgd2UgZ2l2ZW4sIGNoZWNrIHRoZXkgbWF0Y2hcbiAgICAgICAgYXNzZXJ0RXJyb3Ioc2lnLnlQYXJpdHkgPT0gbnVsbCB8fCAoMCwgaW5kZXhfanNfMi5nZXROdW1iZXIpKHNpZy55UGFyaXR5LCBcInNpZy55UGFyaXR5XCIpID09PSByZXN1bHQueVBhcml0eSwgXCJ5UGFyaXR5IG1pc21hdGNoXCIpO1xuICAgICAgICBhc3NlcnRFcnJvcihzaWcueVBhcml0eUFuZFMgPT0gbnVsbCB8fCBzaWcueVBhcml0eUFuZFMgPT09IHJlc3VsdC55UGFyaXR5QW5kUywgXCJ5UGFyaXR5QW5kUyBtaXNtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTaWduYXR1cmUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIkJOXzIiLCJCTl8yNyIsIkJOXzI4IiwiQk5fMzUiLCJfZ3VhcmQiLCJ0b1VpbnQyNTYiLCJ6ZXJvUGFkVmFsdWUiLCJ0b0JlQXJyYXkiLCJyIiwicyIsInYiLCJuZXR3b3JrViIsImFzc2VydEFyZ3VtZW50IiwiZGF0YUxlbmd0aCIsImhleGxpZnkiLCJfdmFsdWUiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImdldE51bWJlciIsImxlZ2FjeUNoYWluSWQiLCJnZXRDaGFpbklkIiwieVBhcml0eSIsInlQYXJpdHlBbmRTIiwiZ2V0Qnl0ZXMiLCJjb21wYWN0U2VyaWFsaXplZCIsImNvbmNhdCIsInNlcmlhbGl6ZWQiLCJjb25zdHJ1Y3RvciIsImd1YXJkIiwiYXNzZXJ0UHJpdmF0ZSIsIlN5bWJvbCIsImZvciIsImNsb25lIiwidG9KU09OIiwiX3R5cGUiLCJ0b1N0cmluZyIsImJ2IiwiZ2V0QmlnSW50IiwiZ2V0Q2hhaW5JZFYiLCJjaGFpbklkIiwiZ2V0Tm9ybWFsaXplZFYiLCJmcm9tIiwic2lnIiwiYXNzZXJ0RXJyb3IiLCJjaGVjayIsIm1lc3NhZ2UiLCJaZXJvSGFzaCIsImJ5dGVzIiwibGVuZ3RoIiwic2xpY2UiLCJfciIsImlzSGV4U3RyaW5nIiwiX3YiLCJ1bmRlZmluZWQiLCJyZXN1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/signature.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/crypto/signing-key.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SigningKey = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/./node_modules/@noble/curves/secp256k1.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst signature_js_1 = __webpack_require__(/*! ./signature.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/signature.js\");\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */ class SigningKey {\n    #privateKey;\n    /**\n     *  Creates a new **SigningKey** for %%privateKey%%.\n     */ constructor(privateKey){\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n        this.#privateKey = (0, index_js_1.hexlify)(privateKey);\n    }\n    /**\n     *  The private key.\n     */ get privateKey() {\n        return this.#privateKey;\n    }\n    /**\n     *  The uncompressed public key.\n     *\n     * This will always begin with the prefix ``0x04`` and be 132\n     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n     */ get publicKey() {\n        return SigningKey.computePublicKey(this.#privateKey);\n    }\n    /**\n     *  The compressed public key.\n     *\n     *  This will always begin with either the prefix ``0x02`` or ``0x03``\n     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n     *  nibbles)\n     */ get compressedPublicKey() {\n        return SigningKey.computePublicKey(this.#privateKey, true);\n    }\n    /**\n     *  Return the signature of the signed %%digest%%.\n     */ sign(digest) {\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(this.#privateKey), {\n            lowS: true\n        });\n        return signature_js_1.Signature.from({\n            r: (0, index_js_1.toBeHex)(sig.r, 32),\n            s: (0, index_js_1.toBeHex)(sig.s, 32),\n            v: sig.recovery ? 0x1c : 0x1b\n        });\n    }\n    /**\n     *  Returns the [[link-wiki-ecdh]] shared secret between this\n     *  private key and the %%other%% key.\n     *\n     *  The %%other%% key may be any type of key, a raw public key,\n     *  a compressed/uncompressed pubic key or aprivate key.\n     *\n     *  Best practice is usually to use a cryptographic hash on the\n     *  returned value before using it as a symetric secret.\n     *\n     *  @example:\n     *    sign1 = new SigningKey(id(\"some-secret-1\"))\n     *    sign2 = new SigningKey(id(\"some-secret-2\"))\n     *\n     *    // Notice that privA.computeSharedSecret(pubB)...\n     *    sign1.computeSharedSecret(sign2.publicKey)\n     *    //_result:\n     *\n     *    // ...is equal to privB.computeSharedSecret(pubA).\n     *    sign2.computeSharedSecret(sign1.publicKey)\n     *    //_result:\n     */ computeSharedSecret(other) {\n        const pubKey = SigningKey.computePublicKey(other);\n        return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(this.#privateKey), (0, index_js_1.getBytes)(pubKey), false));\n    }\n    /**\n     *  Compute the public key for %%key%%, optionally %%compressed%%.\n     *\n     *  The %%key%% may be any type of key, a raw public key, a\n     *  compressed/uncompressed public key or private key.\n     *\n     *  @example:\n     *    sign = new SigningKey(id(\"some-secret\"));\n     *\n     *    // Compute the uncompressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey)\n     *    //_result:\n     *\n     *    // Compute the compressed public key for a private key\n     *    SigningKey.computePublicKey(sign.privateKey, true)\n     *    //_result:\n     *\n     *    // Compute the uncompressed public key\n     *    SigningKey.computePublicKey(sign.publicKey, false);\n     *    //_result:\n     *\n     *    // Compute the Compressed a public key\n     *    SigningKey.computePublicKey(sign.publicKey, true);\n     *    //_result:\n     */ static computePublicKey(key, compressed) {\n        let bytes = (0, index_js_1.getBytes)(key, \"key\");\n        // private key\n        if (bytes.length === 32) {\n            const pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);\n            return (0, index_js_1.hexlify)(pubKey);\n        }\n        // raw public key; use uncompressed key with 0x04 prefix\n        if (bytes.length === 64) {\n            const pub = new Uint8Array(65);\n            pub[0] = 0x04;\n            pub.set(bytes, 1);\n            bytes = pub;\n        }\n        const point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);\n        return (0, index_js_1.hexlify)(point.toRawBytes(compressed));\n    }\n    /**\n     *  Returns the public key for the private key which produced the\n     *  %%signature%% for the given %%digest%%.\n     *\n     *  @example:\n     *    key = new SigningKey(id(\"some-secret\"))\n     *    digest = id(\"hello world\")\n     *    sig = key.sign(digest)\n     *\n     *    // Notice the signer public key...\n     *    key.publicKey\n     *    //_result:\n     *\n     *    // ...is equal to the recovered public key\n     *    SigningKey.recoverPublicKey(digest, sig)\n     *    //_result:\n     *\n     */ static recoverPublicKey(digest, signature) {\n        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, \"invalid digest length\", \"digest\", digest);\n        const sig = signature_js_1.Signature.from(signature);\n        let secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([\n            sig.r,\n            sig.s\n        ])));\n        secpSig = secpSig.addRecoveryBit(sig.yParity);\n        const pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));\n        (0, index_js_1.assertArgument)(pubKey != null, \"invalid signautre for digest\", \"signature\", signature);\n        return \"0x\" + pubKey.toHex(false);\n    }\n    /**\n     *  Returns the point resulting from adding the ellipic curve points\n     *  %%p0%% and %%p1%%.\n     *\n     *  This is not a common function most developers should require, but\n     *  can be useful for certain privacy-specific techniques.\n     *\n     *  For example, it is used by [[HDNodeWallet]] to compute child\n     *  addresses from parent public keys and chain codes.\n     */ static addPoints(p0, p1, compressed) {\n        const pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));\n        const pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n    }\n}\nexports.SigningKey = SigningKey; //# sourceMappingURL=signing-key.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9jcnlwdG8vc2lnbmluZy1rZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7OztDQUlDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLGdGQUF5QjtBQUNyRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQyxvRkFBZ0I7QUFDL0M7OztDQUdDLEdBQ0QsTUFBTUY7SUFDRixDQUFDSyxVQUFVLENBQUM7SUFDWjs7S0FFQyxHQUNEQyxZQUFZRCxVQUFVLENBQUU7UUFDbkIsSUFBR0YsV0FBV0ksY0FBYyxFQUFFLENBQUMsR0FBR0osV0FBV0ssVUFBVSxFQUFFSCxnQkFBZ0IsSUFBSSx1QkFBdUIsY0FBYztRQUNuSCxJQUFJLENBQUMsQ0FBQ0EsVUFBVSxHQUFHLENBQUMsR0FBR0YsV0FBV00sT0FBTyxFQUFFSjtJQUMvQztJQUNBOztLQUVDLEdBQ0QsSUFBSUEsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLFVBQVU7SUFBRTtJQUM1Qzs7Ozs7S0FLQyxHQUNELElBQUlLLFlBQVk7UUFBRSxPQUFPVixXQUFXVyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQ04sVUFBVTtJQUFHO0lBQ3hFOzs7Ozs7S0FNQyxHQUNELElBQUlPLHNCQUFzQjtRQUFFLE9BQU9aLFdBQVdXLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDTixVQUFVLEVBQUU7SUFBTztJQUN4Rjs7S0FFQyxHQUNEUSxLQUFLQyxNQUFNLEVBQUU7UUFDUixJQUFHWCxXQUFXSSxjQUFjLEVBQUUsQ0FBQyxHQUFHSixXQUFXSyxVQUFVLEVBQUVNLFlBQVksSUFBSSx5QkFBeUIsVUFBVUE7UUFDN0csTUFBTUMsTUFBTWQsWUFBWWUsU0FBUyxD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QUFDekMsV0FBV1csZ0JBQWdCLENBQUN5QyxJQUFJRyxTQUFTLENBQUM7UUFDckcsTUFBTUMsT0FBT3ZELFlBQVllLFNBQVMsQ0FBQ3dCLGVBQWUsQ0FBQ0MsT0FBTyxDQUFDekMsV0FBV1csZ0JBQWdCLENBQUMwQyxJQUFJRSxTQUFTLENBQUM7UUFDckcsT0FBTyxPQUFPRCxLQUFLRyxHQUFHLENBQUNELE1BQU1OLEtBQUssQ0FBQyxDQUFDLENBQUNsQjtJQUN6QztBQUNKO0FBQ0FsQyxrQkFBa0IsR0FBR0UsWUFDckIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvY3J5cHRvL3NpZ25pbmcta2V5LmpzPzZlNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBZGQgZGV0YWlscyBhYm91dCBzaWduaW5nIGhlcmUuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL2NyeXB0bzpTaWduaW5nICBbYWJvdXQtc2lnbmluZ11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduaW5nS2V5ID0gdm9pZCAwO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgc2lnbmF0dXJlX2pzXzEgPSByZXF1aXJlKFwiLi9zaWduYXR1cmUuanNcIik7XG4vKipcbiAqICBBICoqU2lnbmluZ0tleSoqIHByb3ZpZGVzIGhpZ2gtbGV2ZWwgYWNjZXNzIHRvIHRoZSBlbGxpcHRpYyBjdXJ2ZVxuICogIGNyeXB0b2dyYXBoeSAoRUNDKSBvcGVyYXRpb25zIGFuZCBrZXkgbWFuYWdlbWVudC5cbiAqL1xuY2xhc3MgU2lnbmluZ0tleSB7XG4gICAgI3ByaXZhdGVLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipTaWduaW5nS2V5KiogZm9yICUlcHJpdmF0ZUtleSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18xLmRhdGFMZW5ndGgpKHByaXZhdGVLZXkpID09PSAzMiwgXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI3ByaXZhdGVLZXkgPSAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgICBnZXQgcHJpdmF0ZUtleSgpIHsgcmV0dXJuIHRoaXMuI3ByaXZhdGVLZXk7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIHRoZSBwcmVmaXggYGAweDA0YGAgYW5kIGJlIDEzMlxuICAgICAqIGNoYXJhY3RlcnMgbG9uZyAodGhlIGBgMHhgYCBwcmVmaXggYW5kIDEzMCBoZXhhZGVjaW1hbCBuaWJibGVzKS5cbiAgICAgKi9cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXkpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIGFsd2F5cyBiZWdpbiB3aXRoIGVpdGhlciB0aGUgcHJlZml4IGBgMHgwMmBgIG9yIGBgMHgwM2BgXG4gICAgICogIGFuZCBiZSA2OCBjaGFyYWN0ZXJzIGxvbmcgKHRoZSBgYDB4YGAgcHJlZml4IGFuZCAzMyBoZXhhZGVjaW1hbFxuICAgICAqICBuaWJibGVzKVxuICAgICAqL1xuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5KCkgeyByZXR1cm4gU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHRoaXMuI3ByaXZhdGVLZXksIHRydWUpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgJSVkaWdlc3QlJS5cbiAgICAgKi9cbiAgICBzaWduKGRpZ2VzdCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzEuZGF0YUxlbmd0aCkoZGlnZXN0KSA9PT0gMzIsIFwiaW52YWxpZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5zaWduKCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoZGlnZXN0KSwgKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KSh0aGlzLiNwcml2YXRlS2V5KSwge1xuICAgICAgICAgICAgbG93UzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZV9qc18xLlNpZ25hdHVyZS5mcm9tKHtcbiAgICAgICAgICAgIHI6ICgwLCBpbmRleF9qc18xLnRvQmVIZXgpKHNpZy5yLCAzMiksXG4gICAgICAgICAgICBzOiAoMCwgaW5kZXhfanNfMS50b0JlSGV4KShzaWcucywgMzIpLFxuICAgICAgICAgICAgdjogKHNpZy5yZWNvdmVyeSA/IDB4MWMgOiAweDFiKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFtbbGluay13aWtpLWVjZGhdXSBzaGFyZWQgc2VjcmV0IGJldHdlZW4gdGhpc1xuICAgICAqICBwcml2YXRlIGtleSBhbmQgdGhlICUlb3RoZXIlJSBrZXkuXG4gICAgICpcbiAgICAgKiAgVGhlICUlb3RoZXIlJSBrZXkgbWF5IGJlIGFueSB0eXBlIG9mIGtleSwgYSByYXcgcHVibGljIGtleSxcbiAgICAgKiAgYSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZCBwdWJpYyBrZXkgb3IgYXByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogIEJlc3QgcHJhY3RpY2UgaXMgdXN1YWxseSB0byB1c2UgYSBjcnlwdG9ncmFwaGljIGhhc2ggb24gdGhlXG4gICAgICogIHJldHVybmVkIHZhbHVlIGJlZm9yZSB1c2luZyBpdCBhcyBhIHN5bWV0cmljIHNlY3JldC5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZTpcbiAgICAgKiAgICBzaWduMSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMVwiKSlcbiAgICAgKiAgICBzaWduMiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXQtMlwiKSlcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGF0IHByaXZBLmNvbXB1dGVTaGFyZWRTZWNyZXQocHViQikuLi5cbiAgICAgKiAgICBzaWduMS5jb21wdXRlU2hhcmVkU2VjcmV0KHNpZ24yLnB1YmxpY0tleSlcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyAuLi5pcyBlcXVhbCB0byBwcml2Qi5jb21wdXRlU2hhcmVkU2VjcmV0KHB1YkEpLlxuICAgICAqICAgIHNpZ24yLmNvbXB1dGVTaGFyZWRTZWNyZXQoc2lnbjEucHVibGljS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKi9cbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHB1YktleSA9IFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShvdGhlcik7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5oZXhsaWZ5KShzZWNwMjU2azFfMS5zZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkodGhpcy4jcHJpdmF0ZUtleSksICgwLCBpbmRleF9qc18xLmdldEJ5dGVzKShwdWJLZXkpLCBmYWxzZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgJSVrZXklJSwgb3B0aW9uYWxseSAlJWNvbXByZXNzZWQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgJSVrZXklJSBtYXkgYmUgYW55IHR5cGUgb2Yga2V5LCBhIHJhdyBwdWJsaWMga2V5LCBhXG4gICAgICogIGNvbXByZXNzZWQvdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgb3IgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiAgQGV4YW1wbGU6XG4gICAgICogICAgc2lnbiA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpO1xuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wcml2YXRlS2V5KVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqICAgIC8vIENvbXB1dGUgdGhlIGNvbXByZXNzZWQgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnByaXZhdGVLZXksIHRydWUpXG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gQ29tcHV0ZSB0aGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgKiAgICBTaWduaW5nS2V5LmNvbXB1dGVQdWJsaWNLZXkoc2lnbi5wdWJsaWNLZXksIGZhbHNlKTtcbiAgICAgKiAgICAvL19yZXN1bHQ6XG4gICAgICpcbiAgICAgKiAgICAvLyBDb21wdXRlIHRoZSBDb21wcmVzc2VkIGEgcHVibGljIGtleVxuICAgICAqICAgIFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShzaWduLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSAoMCwgaW5kZXhfanNfMS5nZXRCeXRlcykoa2V5LCBcImtleVwiKTtcbiAgICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YktleSA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoYnl0ZXMsICEhY29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocHViS2V5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByYXcgcHVibGljIGtleTsgdXNlIHVuY29tcHJlc3NlZCBrZXkgd2l0aCAweDA0IHByZWZpeFxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgY29uc3QgcHViID0gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgICAgICAgICAgcHViWzBdID0gMHgwNDtcbiAgICAgICAgICAgIHB1Yi5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgYnl0ZXMgPSBwdWI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEuaGV4bGlmeSkocG9pbnQudG9SYXdCeXRlcyhjb21wcmVzc2VkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGZvciB0aGUgcHJpdmF0ZSBrZXkgd2hpY2ggcHJvZHVjZWQgdGhlXG4gICAgICogICUlc2lnbmF0dXJlJSUgZm9yIHRoZSBnaXZlbiAlJWRpZ2VzdCUlLlxuICAgICAqXG4gICAgICogIEBleGFtcGxlOlxuICAgICAqICAgIGtleSA9IG5ldyBTaWduaW5nS2V5KGlkKFwic29tZS1zZWNyZXRcIikpXG4gICAgICogICAgZGlnZXN0ID0gaWQoXCJoZWxsbyB3b3JsZFwiKVxuICAgICAqICAgIHNpZyA9IGtleS5zaWduKGRpZ2VzdClcbiAgICAgKlxuICAgICAqICAgIC8vIE5vdGljZSB0aGUgc2lnbmVyIHB1YmxpYyBrZXkuLi5cbiAgICAgKiAgICBrZXkucHVibGljS2V5XG4gICAgICogICAgLy9fcmVzdWx0OlxuICAgICAqXG4gICAgICogICAgLy8gLi4uaXMgZXF1YWwgdG8gdGhlIHJlY292ZXJlZCBwdWJsaWMga2V5XG4gICAgICogICAgU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnKVxuICAgICAqICAgIC8vX3Jlc3VsdDpcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5kYXRhTGVuZ3RoKShkaWdlc3QpID09PSAzMiwgXCJpbnZhbGlkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgY29uc3Qgc2lnID0gc2lnbmF0dXJlX2pzXzEuU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgbGV0IHNlY3BTaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KCgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoKDAsIGluZGV4X2pzXzEuY29uY2F0KShbc2lnLnIsIHNpZy5zXSkpKTtcbiAgICAgICAgc2VjcFNpZyA9IHNlY3BTaWcuYWRkUmVjb3ZlcnlCaXQoc2lnLnlQYXJpdHkpO1xuICAgICAgICBjb25zdCBwdWJLZXkgPSBzZWNwU2lnLnJlY292ZXJQdWJsaWNLZXkoKDAsIGluZGV4X2pzXzEuZ2V0Qnl0ZXNDb3B5KShkaWdlc3QpKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHB1YktleSAhPSBudWxsLCBcImludmFsaWQgc2lnbmF1dHJlIGZvciBkaWdlc3RcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YktleS50b0hleChmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBwb2ludCByZXN1bHRpbmcgZnJvbSBhZGRpbmcgdGhlIGVsbGlwaWMgY3VydmUgcG9pbnRzXG4gICAgICogICUlcDAlJSBhbmQgJSVwMSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGEgY29tbW9uIGZ1bmN0aW9uIG1vc3QgZGV2ZWxvcGVycyBzaG91bGQgcmVxdWlyZSwgYnV0XG4gICAgICogIGNhbiBiZSB1c2VmdWwgZm9yIGNlcnRhaW4gcHJpdmFjeS1zcGVjaWZpYyB0ZWNobmlxdWVzLlxuICAgICAqXG4gICAgICogIEZvciBleGFtcGxlLCBpdCBpcyB1c2VkIGJ5IFtbSEROb2RlV2FsbGV0XV0gdG8gY29tcHV0ZSBjaGlsZFxuICAgICAqICBhZGRyZXNzZXMgZnJvbSBwYXJlbnQgcHVibGljIGtleXMgYW5kIGNoYWluIGNvZGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQb2ludHMocDAsIHAxLCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHB1YjAgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoU2lnbmluZ0tleS5jb21wdXRlUHVibGljS2V5KHAwKS5zdWJzdHJpbmcoMikpO1xuICAgICAgICBjb25zdCBwdWIxID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tSGV4KFNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShwMSkuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHB1YjAuYWRkKHB1YjEpLnRvSGV4KCEhY29tcHJlc3NlZCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaWduaW5nS2V5ID0gU2lnbmluZ0tleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25pbmcta2V5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNpZ25pbmdLZXkiLCJzZWNwMjU2azFfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwic2lnbmF0dXJlX2pzXzEiLCJwcml2YXRlS2V5IiwiY29uc3RydWN0b3IiLCJhc3NlcnRBcmd1bWVudCIsImRhdGFMZW5ndGgiLCJoZXhsaWZ5IiwicHVibGljS2V5IiwiY29tcHV0ZVB1YmxpY0tleSIsImNvbXByZXNzZWRQdWJsaWNLZXkiLCJzaWduIiwiZGlnZXN0Iiwic2lnIiwic2VjcDI1NmsxIiwiZ2V0Qnl0ZXNDb3B5IiwibG93UyIsIlNpZ25hdHVyZSIsImZyb20iLCJyIiwidG9CZUhleCIsInMiLCJ2IiwicmVjb3ZlcnkiLCJjb21wdXRlU2hhcmVkU2VjcmV0Iiwib3RoZXIiLCJwdWJLZXkiLCJnZXRTaGFyZWRTZWNyZXQiLCJnZXRCeXRlcyIsImtleSIsImNvbXByZXNzZWQiLCJieXRlcyIsImxlbmd0aCIsImdldFB1YmxpY0tleSIsInB1YiIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJwb2ludCIsIlByb2plY3RpdmVQb2ludCIsImZyb21IZXgiLCJ0b1Jhd0J5dGVzIiwicmVjb3ZlclB1YmxpY0tleSIsInNpZ25hdHVyZSIsInNlY3BTaWciLCJmcm9tQ29tcGFjdCIsImNvbmNhdCIsImFkZFJlY292ZXJ5Qml0IiwieVBhcml0eSIsInRvSGV4IiwiYWRkUG9pbnRzIiwicDAiLCJwMSIsInB1YjAiLCJzdWJzdHJpbmciLCJwdWIxIiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/crypto/signing-key.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/ethers.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/ethers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/////////////////////////////\n//\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;\nexports.EtherscanPlugin = exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;\nexports.toBeArray = exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = void 0;\nexports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = void 0;\nvar _version_js_1 = __webpack_require__(/*! ./_version.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/_version.js\");\nObject.defineProperty(exports, \"version\", ({\n    enumerable: true,\n    get: function() {\n        return _version_js_1.version;\n    }\n}));\nvar index_js_1 = __webpack_require__(/*! ./abi/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nObject.defineProperty(exports, \"decodeBytes32String\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.decodeBytes32String;\n    }\n}));\nObject.defineProperty(exports, \"encodeBytes32String\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.encodeBytes32String;\n    }\n}));\nObject.defineProperty(exports, \"AbiCoder\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.AbiCoder;\n    }\n}));\nObject.defineProperty(exports, \"ConstructorFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.ConstructorFragment;\n    }\n}));\nObject.defineProperty(exports, \"ErrorFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.ErrorFragment;\n    }\n}));\nObject.defineProperty(exports, \"EventFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.EventFragment;\n    }\n}));\nObject.defineProperty(exports, \"Fragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.Fragment;\n    }\n}));\nObject.defineProperty(exports, \"FallbackFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.FallbackFragment;\n    }\n}));\nObject.defineProperty(exports, \"FunctionFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.FunctionFragment;\n    }\n}));\nObject.defineProperty(exports, \"NamedFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.NamedFragment;\n    }\n}));\nObject.defineProperty(exports, \"ParamType\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.ParamType;\n    }\n}));\nObject.defineProperty(exports, \"StructFragment\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.StructFragment;\n    }\n}));\nObject.defineProperty(exports, \"checkResultErrors\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.checkResultErrors;\n    }\n}));\nObject.defineProperty(exports, \"ErrorDescription\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.ErrorDescription;\n    }\n}));\nObject.defineProperty(exports, \"Indexed\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.Indexed;\n    }\n}));\nObject.defineProperty(exports, \"Interface\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.Interface;\n    }\n}));\nObject.defineProperty(exports, \"LogDescription\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.LogDescription;\n    }\n}));\nObject.defineProperty(exports, \"Result\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.Result;\n    }\n}));\nObject.defineProperty(exports, \"TransactionDescription\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.TransactionDescription;\n    }\n}));\nObject.defineProperty(exports, \"Typed\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_1.Typed;\n    }\n}));\nvar index_js_2 = __webpack_require__(/*! ./address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nObject.defineProperty(exports, \"getAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.getAddress;\n    }\n}));\nObject.defineProperty(exports, \"getIcapAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.getIcapAddress;\n    }\n}));\nObject.defineProperty(exports, \"getCreateAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.getCreateAddress;\n    }\n}));\nObject.defineProperty(exports, \"getCreate2Address\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.getCreate2Address;\n    }\n}));\nObject.defineProperty(exports, \"isAddressable\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.isAddressable;\n    }\n}));\nObject.defineProperty(exports, \"isAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.isAddress;\n    }\n}));\nObject.defineProperty(exports, \"resolveAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_2.resolveAddress;\n    }\n}));\nvar index_js_3 = __webpack_require__(/*! ./constants/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nObject.defineProperty(exports, \"ZeroAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.ZeroAddress;\n    }\n}));\nObject.defineProperty(exports, \"WeiPerEther\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.WeiPerEther;\n    }\n}));\nObject.defineProperty(exports, \"MaxUint256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.MaxUint256;\n    }\n}));\nObject.defineProperty(exports, \"MinInt256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.MinInt256;\n    }\n}));\nObject.defineProperty(exports, \"MaxInt256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.MaxInt256;\n    }\n}));\nObject.defineProperty(exports, \"N\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.N;\n    }\n}));\nObject.defineProperty(exports, \"ZeroHash\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.ZeroHash;\n    }\n}));\nObject.defineProperty(exports, \"EtherSymbol\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.EtherSymbol;\n    }\n}));\nObject.defineProperty(exports, \"MessagePrefix\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_3.MessagePrefix;\n    }\n}));\nvar index_js_4 = __webpack_require__(/*! ./contract/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nObject.defineProperty(exports, \"BaseContract\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.BaseContract;\n    }\n}));\nObject.defineProperty(exports, \"Contract\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.Contract;\n    }\n}));\nObject.defineProperty(exports, \"ContractFactory\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.ContractFactory;\n    }\n}));\nObject.defineProperty(exports, \"ContractEventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.ContractEventPayload;\n    }\n}));\nObject.defineProperty(exports, \"ContractTransactionReceipt\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.ContractTransactionReceipt;\n    }\n}));\nObject.defineProperty(exports, \"ContractTransactionResponse\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.ContractTransactionResponse;\n    }\n}));\nObject.defineProperty(exports, \"ContractUnknownEventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.ContractUnknownEventPayload;\n    }\n}));\nObject.defineProperty(exports, \"EventLog\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.EventLog;\n    }\n}));\nObject.defineProperty(exports, \"UndecodedEventLog\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_4.UndecodedEventLog;\n    }\n}));\nvar index_js_5 = __webpack_require__(/*! ./crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nObject.defineProperty(exports, \"computeHmac\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.computeHmac;\n    }\n}));\nObject.defineProperty(exports, \"randomBytes\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.randomBytes;\n    }\n}));\nObject.defineProperty(exports, \"keccak256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.keccak256;\n    }\n}));\nObject.defineProperty(exports, \"ripemd160\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.ripemd160;\n    }\n}));\nObject.defineProperty(exports, \"sha256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.sha256;\n    }\n}));\nObject.defineProperty(exports, \"sha512\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.sha512;\n    }\n}));\nObject.defineProperty(exports, \"pbkdf2\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.pbkdf2;\n    }\n}));\nObject.defineProperty(exports, \"scrypt\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.scrypt;\n    }\n}));\nObject.defineProperty(exports, \"scryptSync\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.scryptSync;\n    }\n}));\nObject.defineProperty(exports, \"lock\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.lock;\n    }\n}));\nObject.defineProperty(exports, \"Signature\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.Signature;\n    }\n}));\nObject.defineProperty(exports, \"SigningKey\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_5.SigningKey;\n    }\n}));\nvar index_js_6 = __webpack_require__(/*! ./hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nObject.defineProperty(exports, \"id\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.id;\n    }\n}));\nObject.defineProperty(exports, \"ensNormalize\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.ensNormalize;\n    }\n}));\nObject.defineProperty(exports, \"isValidName\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.isValidName;\n    }\n}));\nObject.defineProperty(exports, \"namehash\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.namehash;\n    }\n}));\nObject.defineProperty(exports, \"dnsEncode\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.dnsEncode;\n    }\n}));\nObject.defineProperty(exports, \"hashMessage\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.hashMessage;\n    }\n}));\nObject.defineProperty(exports, \"verifyMessage\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.verifyMessage;\n    }\n}));\nObject.defineProperty(exports, \"solidityPacked\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.solidityPacked;\n    }\n}));\nObject.defineProperty(exports, \"solidityPackedKeccak256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.solidityPackedKeccak256;\n    }\n}));\nObject.defineProperty(exports, \"solidityPackedSha256\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.solidityPackedSha256;\n    }\n}));\nObject.defineProperty(exports, \"TypedDataEncoder\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.TypedDataEncoder;\n    }\n}));\nObject.defineProperty(exports, \"verifyTypedData\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_6.verifyTypedData;\n    }\n}));\nvar index_js_7 = __webpack_require__(/*! ./providers/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nObject.defineProperty(exports, \"getDefaultProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.getDefaultProvider;\n    }\n}));\nObject.defineProperty(exports, \"Block\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.Block;\n    }\n}));\nObject.defineProperty(exports, \"FeeData\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.FeeData;\n    }\n}));\nObject.defineProperty(exports, \"Log\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.Log;\n    }\n}));\nObject.defineProperty(exports, \"TransactionReceipt\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.TransactionReceipt;\n    }\n}));\nObject.defineProperty(exports, \"TransactionResponse\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.TransactionResponse;\n    }\n}));\nObject.defineProperty(exports, \"AbstractSigner\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.AbstractSigner;\n    }\n}));\nObject.defineProperty(exports, \"NonceManager\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.NonceManager;\n    }\n}));\nObject.defineProperty(exports, \"VoidSigner\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.VoidSigner;\n    }\n}));\nObject.defineProperty(exports, \"AbstractProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.AbstractProvider;\n    }\n}));\nObject.defineProperty(exports, \"FallbackProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.FallbackProvider;\n    }\n}));\nObject.defineProperty(exports, \"JsonRpcApiProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.JsonRpcApiProvider;\n    }\n}));\nObject.defineProperty(exports, \"JsonRpcProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.JsonRpcProvider;\n    }\n}));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.JsonRpcSigner;\n    }\n}));\nObject.defineProperty(exports, \"BrowserProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.BrowserProvider;\n    }\n}));\nObject.defineProperty(exports, \"AlchemyProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.AlchemyProvider;\n    }\n}));\nObject.defineProperty(exports, \"AnkrProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.AnkrProvider;\n    }\n}));\nObject.defineProperty(exports, \"CloudflareProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.CloudflareProvider;\n    }\n}));\nObject.defineProperty(exports, \"EtherscanProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.EtherscanProvider;\n    }\n}));\nObject.defineProperty(exports, \"InfuraProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.InfuraProvider;\n    }\n}));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.InfuraWebSocketProvider;\n    }\n}));\nObject.defineProperty(exports, \"PocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.PocketProvider;\n    }\n}));\nObject.defineProperty(exports, \"QuickNodeProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.QuickNodeProvider;\n    }\n}));\nObject.defineProperty(exports, \"IpcSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.IpcSocketProvider;\n    }\n}));\nObject.defineProperty(exports, \"SocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.SocketProvider;\n    }\n}));\nObject.defineProperty(exports, \"WebSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.WebSocketProvider;\n    }\n}));\nObject.defineProperty(exports, \"EnsResolver\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.EnsResolver;\n    }\n}));\nObject.defineProperty(exports, \"Network\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.Network;\n    }\n}));\nObject.defineProperty(exports, \"EnsPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.EnsPlugin;\n    }\n}));\nObject.defineProperty(exports, \"EtherscanPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.EtherscanPlugin;\n    }\n}));\nObject.defineProperty(exports, \"FeeDataNetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.FeeDataNetworkPlugin;\n    }\n}));\nObject.defineProperty(exports, \"FetchUrlFeeDataNetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.FetchUrlFeeDataNetworkPlugin;\n    }\n}));\nObject.defineProperty(exports, \"GasCostPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.GasCostPlugin;\n    }\n}));\nObject.defineProperty(exports, \"NetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.NetworkPlugin;\n    }\n}));\nObject.defineProperty(exports, \"MulticoinProviderPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.MulticoinProviderPlugin;\n    }\n}));\nObject.defineProperty(exports, \"SocketBlockSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.SocketBlockSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketEventSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.SocketEventSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketPendingSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.SocketPendingSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.SocketSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"UnmanagedSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.UnmanagedSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"copyRequest\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.copyRequest;\n    }\n}));\nObject.defineProperty(exports, \"showThrottleMessage\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_7.showThrottleMessage;\n    }\n}));\nvar index_js_8 = __webpack_require__(/*! ./transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nObject.defineProperty(exports, \"accessListify\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_8.accessListify;\n    }\n}));\nObject.defineProperty(exports, \"computeAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_8.computeAddress;\n    }\n}));\nObject.defineProperty(exports, \"recoverAddress\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_8.recoverAddress;\n    }\n}));\nObject.defineProperty(exports, \"Transaction\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_8.Transaction;\n    }\n}));\nvar index_js_9 = __webpack_require__(/*! ./utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nObject.defineProperty(exports, \"decodeBase58\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.decodeBase58;\n    }\n}));\nObject.defineProperty(exports, \"encodeBase58\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.encodeBase58;\n    }\n}));\nObject.defineProperty(exports, \"decodeBase64\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.decodeBase64;\n    }\n}));\nObject.defineProperty(exports, \"encodeBase64\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.encodeBase64;\n    }\n}));\nObject.defineProperty(exports, \"concat\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.concat;\n    }\n}));\nObject.defineProperty(exports, \"dataLength\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.dataLength;\n    }\n}));\nObject.defineProperty(exports, \"dataSlice\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.dataSlice;\n    }\n}));\nObject.defineProperty(exports, \"getBytes\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.getBytes;\n    }\n}));\nObject.defineProperty(exports, \"getBytesCopy\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.getBytesCopy;\n    }\n}));\nObject.defineProperty(exports, \"hexlify\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.hexlify;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"isBytesLike\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.isBytesLike;\n    }\n}));\nObject.defineProperty(exports, \"stripZerosLeft\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.stripZerosLeft;\n    }\n}));\nObject.defineProperty(exports, \"zeroPadBytes\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.zeroPadBytes;\n    }\n}));\nObject.defineProperty(exports, \"zeroPadValue\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.zeroPadValue;\n    }\n}));\nObject.defineProperty(exports, \"defineProperties\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.defineProperties;\n    }\n}));\nObject.defineProperty(exports, \"resolveProperties\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.resolveProperties;\n    }\n}));\nObject.defineProperty(exports, \"assert\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.assert;\n    }\n}));\nObject.defineProperty(exports, \"assertArgument\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.assertArgument;\n    }\n}));\nObject.defineProperty(exports, \"assertArgumentCount\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.assertArgumentCount;\n    }\n}));\nObject.defineProperty(exports, \"assertNormalize\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.assertNormalize;\n    }\n}));\nObject.defineProperty(exports, \"assertPrivate\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.assertPrivate;\n    }\n}));\nObject.defineProperty(exports, \"makeError\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.makeError;\n    }\n}));\nObject.defineProperty(exports, \"isCallException\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.isCallException;\n    }\n}));\nObject.defineProperty(exports, \"isError\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.isError;\n    }\n}));\nObject.defineProperty(exports, \"EventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.EventPayload;\n    }\n}));\nObject.defineProperty(exports, \"FetchRequest\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.FetchRequest;\n    }\n}));\nObject.defineProperty(exports, \"FetchResponse\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.FetchResponse;\n    }\n}));\nObject.defineProperty(exports, \"FetchCancelSignal\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.FetchCancelSignal;\n    }\n}));\nObject.defineProperty(exports, \"FixedNumber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.FixedNumber;\n    }\n}));\nObject.defineProperty(exports, \"getBigInt\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.getBigInt;\n    }\n}));\nObject.defineProperty(exports, \"getNumber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.getNumber;\n    }\n}));\nObject.defineProperty(exports, \"getUint\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.getUint;\n    }\n}));\nObject.defineProperty(exports, \"toBeArray\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toBeArray;\n    }\n}));\nObject.defineProperty(exports, \"toBigInt\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toBigInt;\n    }\n}));\nObject.defineProperty(exports, \"toBeHex\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toBeHex;\n    }\n}));\nObject.defineProperty(exports, \"toNumber\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toNumber;\n    }\n}));\nObject.defineProperty(exports, \"toQuantity\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toQuantity;\n    }\n}));\nObject.defineProperty(exports, \"fromTwos\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.fromTwos;\n    }\n}));\nObject.defineProperty(exports, \"toTwos\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toTwos;\n    }\n}));\nObject.defineProperty(exports, \"mask\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.mask;\n    }\n}));\nObject.defineProperty(exports, \"formatEther\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.formatEther;\n    }\n}));\nObject.defineProperty(exports, \"parseEther\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.parseEther;\n    }\n}));\nObject.defineProperty(exports, \"formatUnits\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.formatUnits;\n    }\n}));\nObject.defineProperty(exports, \"parseUnits\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.parseUnits;\n    }\n}));\nObject.defineProperty(exports, \"toUtf8Bytes\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toUtf8Bytes;\n    }\n}));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toUtf8CodePoints;\n    }\n}));\nObject.defineProperty(exports, \"toUtf8String\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.toUtf8String;\n    }\n}));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.Utf8ErrorFuncs;\n    }\n}));\nObject.defineProperty(exports, \"decodeRlp\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.decodeRlp;\n    }\n}));\nObject.defineProperty(exports, \"encodeRlp\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.encodeRlp;\n    }\n}));\nObject.defineProperty(exports, \"uuidV4\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_9.uuidV4;\n    }\n}));\nvar index_js_10 = __webpack_require__(/*! ./wallet/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/index.js\");\nObject.defineProperty(exports, \"Mnemonic\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.Mnemonic;\n    }\n}));\nObject.defineProperty(exports, \"BaseWallet\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.BaseWallet;\n    }\n}));\nObject.defineProperty(exports, \"HDNodeWallet\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.HDNodeWallet;\n    }\n}));\nObject.defineProperty(exports, \"HDNodeVoidWallet\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.HDNodeVoidWallet;\n    }\n}));\nObject.defineProperty(exports, \"Wallet\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.Wallet;\n    }\n}));\nObject.defineProperty(exports, \"defaultPath\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.defaultPath;\n    }\n}));\nObject.defineProperty(exports, \"getAccountPath\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.getAccountPath;\n    }\n}));\nObject.defineProperty(exports, \"getIndexedAccountPath\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.getIndexedAccountPath;\n    }\n}));\nObject.defineProperty(exports, \"isCrowdsaleJson\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.isCrowdsaleJson;\n    }\n}));\nObject.defineProperty(exports, \"isKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.isKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"decryptCrowdsaleJson\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.decryptCrowdsaleJson;\n    }\n}));\nObject.defineProperty(exports, \"decryptKeystoreJsonSync\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.decryptKeystoreJsonSync;\n    }\n}));\nObject.defineProperty(exports, \"decryptKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.decryptKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"encryptKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.encryptKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"encryptKeystoreJsonSync\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_10.encryptKeystoreJsonSync;\n    }\n}));\nvar index_js_11 = __webpack_require__(/*! ./wordlists/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/index.js\");\nObject.defineProperty(exports, \"Wordlist\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_11.Wordlist;\n    }\n}));\nObject.defineProperty(exports, \"LangEn\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_11.LangEn;\n    }\n}));\nObject.defineProperty(exports, \"WordlistOwl\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_11.WordlistOwl;\n    }\n}));\nObject.defineProperty(exports, \"WordlistOwlA\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_11.WordlistOwlA;\n    }\n}));\nObject.defineProperty(exports, \"wordlists\", ({\n    enumerable: true,\n    get: function() {\n        return index_js_11.wordlists;\n    }\n})); //# sourceMappingURL=ethers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9ldGhlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLHlCQUF5QixHQUFHQSxnQkFBZ0IsR0FBR0EsbUNBQW1DLEdBQUdBLG1DQUFtQyxHQUFHQSxrQ0FBa0MsR0FBR0EsNEJBQTRCLEdBQUdBLHVCQUF1QixHQUFHQSxnQkFBZ0IsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLFNBQVMsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxzQkFBc0IsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHQSx5QkFBeUIsR0FBR0Esd0JBQXdCLEdBQUdBLHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBR0EsYUFBYSxHQUFHQSw4QkFBOEIsR0FBR0EsY0FBYyxHQUFHQSxzQkFBc0IsR0FBR0EsaUJBQWlCLEdBQUdBLGVBQWUsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHQSx3QkFBd0IsR0FBR0Esd0JBQXdCLEdBQUdBLGdCQUFnQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxnQkFBZ0IsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUNqckNBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBR0Es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QWMsT0FBT1csWUFBWWhELFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSDlKLDBDQUF5QztJQUFFa00sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csWUFBWWpELE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRzdKLCtDQUE4QztJQUFFa00sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csWUFBWWxELFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN6SDVKLGdEQUErQztJQUFFa00sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csWUFBWW5ELFlBQVk7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSDNKLDZDQUE0QztJQUFFa00sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csWUFBWXBELFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUNySCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9ldGhlcnMuanM/NzEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLmNvbXB1dGVIbWFjID0gZXhwb3J0cy5VbmRlY29kZWRFdmVudExvZyA9IGV4cG9ydHMuRXZlbnRMb2cgPSBleHBvcnRzLkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZCA9IGV4cG9ydHMuQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5Db250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuQ29udHJhY3RFdmVudFBheWxvYWQgPSBleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3QgPSBleHBvcnRzLkJhc2VDb250cmFjdCA9IGV4cG9ydHMuTWVzc2FnZVByZWZpeCA9IGV4cG9ydHMuRXRoZXJTeW1ib2wgPSBleHBvcnRzLlplcm9IYXNoID0gZXhwb3J0cy5OID0gZXhwb3J0cy5NYXhJbnQyNTYgPSBleHBvcnRzLk1pbkludDI1NiA9IGV4cG9ydHMuTWF4VWludDI1NiA9IGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBleHBvcnRzLlplcm9BZGRyZXNzID0gZXhwb3J0cy5yZXNvbHZlQWRkcmVzcyA9IGV4cG9ydHMuaXNBZGRyZXNzID0gZXhwb3J0cy5pc0FkZHJlc3NhYmxlID0gZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGV4cG9ydHMuZ2V0Q3JlYXRlQWRkcmVzcyA9IGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSBleHBvcnRzLlR5cGVkID0gZXhwb3J0cy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gZXhwb3J0cy5SZXN1bHQgPSBleHBvcnRzLkxvZ0Rlc2NyaXB0aW9uID0gZXhwb3J0cy5JbnRlcmZhY2UgPSBleHBvcnRzLkluZGV4ZWQgPSBleHBvcnRzLkVycm9yRGVzY3JpcHRpb24gPSBleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gZXhwb3J0cy5TdHJ1Y3RGcmFnbWVudCA9IGV4cG9ydHMuUGFyYW1UeXBlID0gZXhwb3J0cy5OYW1lZEZyYWdtZW50ID0gZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZXhwb3J0cy5GYWxsYmFja0ZyYWdtZW50ID0gZXhwb3J0cy5GcmFnbWVudCA9IGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IGV4cG9ydHMuRXJyb3JGcmFnbWVudCA9IGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGV4cG9ydHMuQWJpQ29kZXIgPSBleHBvcnRzLmVuY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLmRlY29kZUJ5dGVzMzJTdHJpbmcgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLkV0aGVyc2NhblBsdWdpbiA9IGV4cG9ydHMuRW5zUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5FbnNSZXNvbHZlciA9IGV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JcGNTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBleHBvcnRzLlBvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhUHJvdmlkZXIgPSBleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSBleHBvcnRzLkFua3JQcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gZXhwb3J0cy5Ccm93c2VyUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNTaWduZXIgPSBleHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVByb3ZpZGVyID0gZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyID0gZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5Ob25jZU1hbmFnZXIgPSBleHBvcnRzLkFic3RyYWN0U2lnbmVyID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBleHBvcnRzLkxvZyA9IGV4cG9ydHMuRmVlRGF0YSA9IGV4cG9ydHMuQmxvY2sgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMudmVyaWZ5VHlwZWREYXRhID0gZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZFNoYTI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkID0gZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGV4cG9ydHMuZG5zRW5jb2RlID0gZXhwb3J0cy5uYW1laGFzaCA9IGV4cG9ydHMuaXNWYWxpZE5hbWUgPSBleHBvcnRzLmVuc05vcm1hbGl6ZSA9IGV4cG9ydHMuaWQgPSBleHBvcnRzLlNpZ25pbmdLZXkgPSBleHBvcnRzLlNpZ25hdHVyZSA9IGV4cG9ydHMubG9jayA9IGV4cG9ydHMuc2NyeXB0U3luYyA9IGV4cG9ydHMuc2NyeXB0ID0gZXhwb3J0cy5wYmtkZjIgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuZXhwb3J0cy50b0JlQXJyYXkgPSBleHBvcnRzLmdldFVpbnQgPSBleHBvcnRzLmdldE51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuRmV0Y2hDYW5jZWxTaWduYWwgPSBleHBvcnRzLkZldGNoUmVzcG9uc2UgPSBleHBvcnRzLkZldGNoUmVxdWVzdCA9IGV4cG9ydHMuRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5pc0Vycm9yID0gZXhwb3J0cy5pc0NhbGxFeGNlcHRpb24gPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGV4cG9ydHMuYXNzZXJ0Tm9ybWFsaXplID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudENvdW50ID0gZXhwb3J0cy5hc3NlcnRBcmd1bWVudCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IGV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy56ZXJvUGFkQnl0ZXMgPSBleHBvcnRzLnN0cmlwWmVyb3NMZWZ0ID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmdldEJ5dGVzQ29weSA9IGV4cG9ydHMuZ2V0Qnl0ZXMgPSBleHBvcnRzLmRhdGFTbGljZSA9IGV4cG9ydHMuZGF0YUxlbmd0aCA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBleHBvcnRzLmRlY29kZUJhc2U2NCA9IGV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBleHBvcnRzLlRyYW5zYWN0aW9uID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSBleHBvcnRzLnNob3dUaHJvdHRsZU1lc3NhZ2UgPSBleHBvcnRzLmNvcHlSZXF1ZXN0ID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gZXhwb3J0cy5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5GZWVEYXRhTmV0d29ya1BsdWdpbiA9IHZvaWQgMDtcbmV4cG9ydHMud29yZGxpc3RzID0gZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSBleHBvcnRzLldvcmRsaXN0T3dsID0gZXhwb3J0cy5MYW5nRW4gPSBleHBvcnRzLldvcmRsaXN0ID0gZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlSnNvblN5bmMgPSBleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5pc0tleXN0b3JlSnNvbiA9IGV4cG9ydHMuaXNDcm93ZHNhbGVKc29uID0gZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGV4cG9ydHMuV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVWb2lkV2FsbGV0ID0gZXhwb3J0cy5IRE5vZGVXYWxsZXQgPSBleHBvcnRzLkJhc2VXYWxsZXQgPSBleHBvcnRzLk1uZW1vbmljID0gZXhwb3J0cy51dWlkVjQgPSBleHBvcnRzLmVuY29kZVJscCA9IGV4cG9ydHMuZGVjb2RlUmxwID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IGV4cG9ydHMudG9VdGY4U3RyaW5nID0gZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gZXhwb3J0cy50b1V0ZjhCeXRlcyA9IGV4cG9ydHMucGFyc2VVbml0cyA9IGV4cG9ydHMuZm9ybWF0VW5pdHMgPSBleHBvcnRzLnBhcnNlRXRoZXIgPSBleHBvcnRzLmZvcm1hdEV0aGVyID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gZXhwb3J0cy50b1F1YW50aXR5ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMudG9CZUhleCA9IGV4cG9ydHMudG9CaWdJbnQgPSB2b2lkIDA7XG52YXIgX3ZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuL192ZXJzaW9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3ZlcnNpb25fanNfMS52ZXJzaW9uOyB9IH0pO1xudmFyIGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi9hYmkvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmRlY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVCeXRlczMyU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLmVuY29kZUJ5dGVzMzJTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYmlDb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5BYmlDb2RlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN0cnVjdG9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuQ29uc3RydWN0b3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVycm9yRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRXJyb3JGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50RnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuRXZlbnRGcmFnbWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmFsbGJhY2tGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5GYWxsYmFja0ZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25GcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5GdW5jdGlvbkZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZWRGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5OYW1lZEZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFyYW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlBhcmFtVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cnVjdEZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLlN0cnVjdEZyYWdtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tSZXN1bHRFcnJvcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuY2hlY2tSZXN1bHRFcnJvcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckRlc2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkVycm9yRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmRleGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xLkluZGV4ZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuSW50ZXJmYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nRGVzY3JpcHRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuTG9nRGVzY3JpcHRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXN1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuUmVzdWx0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEuVHlwZWQ7IH0gfSk7XG52YXIgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuL2FkZHJlc3MvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmdldEFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJY2FwQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5nZXRJY2FwQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzIuZ2V0Q3JlYXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENyZWF0ZTJBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmdldENyZWF0ZTJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBZGRyZXNzYWJsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMi5pc0FkZHJlc3NhYmxlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLmlzQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzOyB9IH0pO1xudmFyIGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaZXJvQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5aZXJvQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlaVBlckV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLldlaVBlckV0aGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWF4VWludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NYXhVaW50MjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWluSW50MjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLk1pbkludDI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1heEludDI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NYXhJbnQyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLk47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaZXJvSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5aZXJvSGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyU3ltYm9sXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18zLkV0aGVyU3ltYm9sOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVByZWZpeFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMy5NZXNzYWdlUHJlZml4OyB9IH0pO1xudmFyIGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi9jb250cmFjdC9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5CYXNlQ29udHJhY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0RmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdEZhY3Rvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdEV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdEV2ZW50UGF5bG9hZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LkNvbnRyYWN0VHJhbnNhY3Rpb25SZWNlaXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udHJhY3RUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LkNvbnRyYWN0VHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRyYWN0VW5rbm93bkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5Db250cmFjdFVua25vd25FdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudExvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNC5FdmVudExvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZGVjb2RlZEV2ZW50TG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc180LlVuZGVjb2RlZEV2ZW50TG9nOyB9IH0pO1xudmFyIGluZGV4X2pzXzUgPSByZXF1aXJlKFwiLi9jcnlwdG8vaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlSG1hY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5jb21wdXRlSG1hYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJhbmRvbUJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnJhbmRvbUJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwia2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LmtlY2NhazI1NjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcGVtZDE2MFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5yaXBlbWQxNjA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuc2hhMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhNTEyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LnNoYTUxMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBia2RmMlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5wYmtkZjI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzY3J5cHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuc2NyeXB0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2NyeXB0U3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5zY3J5cHRTeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9ja1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNS5sb2NrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lnbmF0dXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc181LlNpZ25hdHVyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNpZ25pbmdLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzUuU2lnbmluZ0tleTsgfSB9KTtcbnZhciBpbmRleF9qc182ID0gcmVxdWlyZShcIi4vaGFzaC9pbmRleC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmlkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zTm9ybWFsaXplXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmVuc05vcm1hbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LmlzVmFsaWROYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFtZWhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYubmFtZWhhc2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkbnNFbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuZG5zRW5jb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuaGFzaE1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnZlcmlmeU1lc3NhZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNi5zb2xpZGl0eVBhY2tlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkS2VjY2FrMjU2XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRTaGEyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYuc29saWRpdHlQYWNrZWRTaGEyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlZERhdGFFbmNvZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc182LlR5cGVkRGF0YUVuY29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlUeXBlZERhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzYudmVyaWZ5VHlwZWREYXRhOyB9IH0pO1xudmFyIGluZGV4X2pzXzcgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREZWZhdWx0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuZ2V0RGVmYXVsdFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmxvY2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQmxvY2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVEYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkZlZURhdGE7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuTG9nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25SZWNlaXB0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlRyYW5zYWN0aW9uUmVjZWlwdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVzcG9uc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuVHJhbnNhY3Rpb25SZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0U2lnbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkFic3RyYWN0U2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uY2VNYW5hZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lk5vbmNlTWFuYWdlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvaWRTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuVm9pZFNpZ25lcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQWJzdHJhY3RQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZhbGxiYWNrUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRmFsbGJhY2tQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNBcGlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Kc29uUnBjQXBpUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc29uUnBjUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSnNvblJwY1Byb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY1NpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Kc29uUnBjU2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnJvd3NlclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkJyb3dzZXJQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5BbGNoZW15UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbmtyUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuQW5rclByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xvdWRmbGFyZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkNsb3VkZmxhcmVQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyc2NhblByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkV0aGVyc2NhblByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5mdXJhUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuSW5mdXJhUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmZ1cmFXZWJTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlBvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUXVpY2tOb2RlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuUXVpY2tOb2RlUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJcGNTb2NrZXRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5JcGNTb2NrZXRQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlNvY2tldFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViU29ja2V0UHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuV2ViU29ja2V0UHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnNSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5FbnNSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuTmV0d29yazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5FbnNQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5QbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRXRoZXJzY2FuUGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YU5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHYXNDb3N0UGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lkdhc0Nvc3RQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183Lk5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aWNvaW5Qcm92aWRlclBsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldEJsb2NrU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5Tb2NrZXRCbG9ja1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRFdmVudFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0RXZlbnRTdWJzY3JpYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0UGVuZGluZ1N1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuU29ja2V0UGVuZGluZ1N1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlNvY2tldFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbm1hbmFnZWRTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc183LlVubWFuYWdlZFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfNy5jb3B5UmVxdWVzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3dUaHJvdHRsZU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzcuc2hvd1Rocm90dGxlTWVzc2FnZTsgfSB9KTtcbnZhciBpbmRleF9qc184ID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhY2Nlc3NMaXN0aWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc184LmFjY2Vzc0xpc3RpZnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOC5jb21wdXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlY292ZXJBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc184LnJlY292ZXJBZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzguVHJhbnNhY3Rpb247IH0gfSk7XG52YXIgaW5kZXhfanNfOSA9IHJlcXVpcmUoXCIuL3V0aWxzL2luZGV4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRlY29kZUJhc2U1ODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5lbmNvZGVCYXNlNTg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCYXNlNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVjb2RlQmFzZTY0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQmFzZTY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmVuY29kZUJhc2U2NDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5jb25jYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhTGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRhdGFMZW5ndGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkYXRhU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGF0YVNsaWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCeXRlc0NvcHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0Qnl0ZXNDb3B5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGV4bGlmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5oZXhsaWZ5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzTGlrZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5pc0J5dGVzTGlrZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwWmVyb3NMZWZ0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnN0cmlwWmVyb3NMZWZ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiemVyb1BhZEJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185Lnplcm9QYWRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInplcm9QYWRWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS56ZXJvUGFkVmFsdWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZpbmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmRlZmluZVByb3BlcnRpZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUHJvcGVydGllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5yZXNvbHZlUHJvcGVydGllczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRBcmd1bWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnRBcmd1bWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydEFyZ3VtZW50Q291bnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuYXNzZXJ0QXJndW1lbnRDb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydE5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5hc3NlcnROb3JtYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRQcml2YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmFzc2VydFByaXZhdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkubWFrZUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNDYWxsRXhjZXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmlzQ2FsbEV4Y2VwdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuaXNFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50UGF5bG9hZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5FdmVudFBheWxvYWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFJlcXVlc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuRmV0Y2hSZXF1ZXN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hSZXNwb25zZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GZXRjaFJlc3BvbnNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hDYW5jZWxTaWduYWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuRmV0Y2hDYW5jZWxTaWduYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZE51bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5GaXhlZE51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRCaWdJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZ2V0TnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VWludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5nZXRVaW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUFycmF5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvQmVBcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmlnSW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvQmlnSW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CZUhleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b0JlSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9OdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9OdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1F1YW50aXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvUXVhbnRpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5mcm9tVHdvczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVHdvc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS50b1R3b3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXNrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185Lm1hc2s7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRFdGhlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5mb3JtYXRFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRXRoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkucGFyc2VFdGhlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFVuaXRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmZvcm1hdFVuaXRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VVbml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS5wYXJzZVVuaXRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9VdGY4Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhDb2RlUG9pbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LnRvVXRmOENvZGVQb2ludHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1V0ZjhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkudG9VdGY4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOEVycm9yRnVuY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuVXRmOEVycm9yRnVuY3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVSbHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzkuZGVjb2RlUmxwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlUmxwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc185LmVuY29kZVJscDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV1aWRWNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfOS51dWlkVjQ7IH0gfSk7XG52YXIgaW5kZXhfanNfMTAgPSByZXF1aXJlKFwiLi93YWxsZXQvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNbmVtb25pY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuTW5lbW9uaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5CYXNlV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEROb2RlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5IRE5vZGVXYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIRE5vZGVWb2lkV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5IRE5vZGVWb2lkV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMC5XYWxsZXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVmYXVsdFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZ2V0QWNjb3VudFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbmRleGVkQWNjb3VudFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmdldEluZGV4ZWRBY2NvdW50UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ3Jvd2RzYWxlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuaXNDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmlzS2V5c3RvcmVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdENyb3dkc2FsZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmRlY3J5cHRDcm93ZHNhbGVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjcnlwdEtleXN0b3JlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZGVjcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzEwLmVuY3J5cHRLZXlzdG9yZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNyeXB0S2V5c3RvcmVKc29uU3luY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTAuZW5jcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG52YXIgaW5kZXhfanNfMTEgPSByZXF1aXJlKFwiLi93b3JkbGlzdHMvaW5kZXguanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JkbGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTEuV29yZGxpc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYW5nRW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4X2pzXzExLkxhbmdFbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS5Xb3JkbGlzdE93bDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsQVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXhfanNfMTEuV29yZGxpc3RPd2xBOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZGxpc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleF9qc18xMS53b3JkbGlzdHM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmlwZW1kMTYwIiwia2VjY2FrMjU2IiwicmFuZG9tQnl0ZXMiLCJjb21wdXRlSG1hYyIsIlVuZGVjb2RlZEV2ZW50TG9nIiwiRXZlbnRMb2ciLCJDb250cmFjdFVua25vd25FdmVudFBheWxvYWQiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJDb250cmFjdFRyYW5zYWN0aW9uUmVjZWlwdCIsIkNvbnRyYWN0RXZlbnRQYXlsb2FkIiwiQ29udHJhY3RGYWN0b3J5IiwiQ29udHJhY3QiLCJCYXNlQ29udHJhY3QiLCJNZXNzYWdlUHJlZml4IiwiRXRoZXJTeW1ib2wiLCJaZXJvSGFzaCIsIk4iLCJNYXhJbnQyNTYiLCJNaW5JbnQyNTYiLCJNYXhVaW50MjU2IiwiV2VpUGVyRXRoZXIiLCJaZXJvQWRkcmVzcyIsInJlc29sdmVBZGRyZXNzIiwiaXNBZGRyZXNzIiwiaXNBZGRyZXNzYWJsZSIsImdldENyZWF0ZTJBZGRyZXNzIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsImdldEljYXBBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsIlR5cGVkIiwiVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsIlJlc3VsdCIsIkxvZ0Rlc2NyaXB0aW9uIiwiSW50ZXJmYWNlIiwiSW5kZXhlZCIsIkVycm9yRGVzY3JpcHRpb24iLCJjaGVja1Jlc3VsdEVycm9ycyIsIlN0cnVjdEZyYWdtZW50IiwiUGFyYW1UeXBlIiwiTmFtZWRGcmFnbWVudCIsIkZ1bmN0aW9uRnJhZ21lbnQiLCJGYWxsYmFja0ZyYWdtZW50IiwiRnJhZ21lbnQiLCJFdmVudEZyYWdtZW50IiwiRXJyb3JGcmFnbWVudCIsIkNvbnN0cnVjdG9yRnJhZ21lbnQiLCJBYmlDb2RlciIsImVuY29kZUJ5dGVzMzJTdHJpbmciLCJkZWNvZGVCeXRlczMyU3RyaW5nIiwidmVyc2lvbiIsIkV0aGVyc2NhblBsdWdpbiIsIkVuc1BsdWdpbiIsIk5ldHdvcmsiLCJFbnNSZXNvbHZlciIsIldlYlNvY2tldFByb3ZpZGVyIiwiU29ja2V0UHJvdmlkZXIiLCJJcGNTb2NrZXRQcm92aWRlciIsIlF1aWNrTm9kZVByb3ZpZGVyIiwiUG9ja2V0UHJvdmlkZXIiLCJJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciIsIkluZnVyYVByb3ZpZGVyIiwiRXRoZXJzY2FuUHJvdmlkZXIiLCJDbG91ZGZsYXJlUHJvdmlkZXIiLCJBbmtyUHJvdmlkZXIiLCJBbGNoZW15UHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJKc29uUnBjU2lnbmVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiSnNvblJwY0FwaVByb3ZpZGVyIiwiRmFsbGJhY2tQcm92aWRlciIsIkFic3RyYWN0UHJvdmlkZXIiLCJWb2lkU2lnbmVyIiwiTm9uY2VNYW5hZ2VyIiwiQWJzdHJhY3RTaWduZXIiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiTG9nIiwiRmVlRGF0YSIsIkJsb2NrIiwiZ2V0RGVmYXVsdFByb3ZpZGVyIiwidmVyaWZ5VHlwZWREYXRhIiwiVHlwZWREYXRhRW5jb2RlciIsInNvbGlkaXR5UGFja2VkU2hhMjU2Iiwic29saWRpdHlQYWNrZWRLZWNjYWsyNTYiLCJzb2xpZGl0eVBhY2tlZCIsInZlcmlmeU1lc3NhZ2UiLCJoYXNoTWVzc2FnZSIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiaXNWYWxpZE5hbWUiLCJlbnNOb3JtYWxpemUiLCJpZCIsIlNpZ25pbmdLZXkiLCJTaWduYXR1cmUiLCJsb2NrIiwic2NyeXB0U3luYyIsInNjcnlwdCIsInBia2RmMiIsInNoYTUxMiIsInNoYTI1NiIsInRvQmVBcnJheSIsImdldFVpbnQiLCJnZXROdW1iZXIiLCJnZXRCaWdJbnQiLCJGaXhlZE51bWJlciIsIkZldGNoQ2FuY2VsU2lnbmFsIiwiRmV0Y2hSZXNwb25zZSIsIkZldGNoUmVxdWVzdCIsIkV2ZW50UGF5bG9hZCIsImlzRXJyb3IiLCJpc0NhbGxFeGNlcHRpb24iLCJtYWtlRXJyb3IiLCJhc3NlcnRQcml2YXRlIiwiYXNzZXJ0Tm9ybWFsaXplIiwiYXNzZXJ0QXJndW1lbnRDb3VudCIsImFzc2VydEFyZ3VtZW50IiwiYXNzZXJ0IiwicmVzb2x2ZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiemVyb1BhZFZhbHVlIiwiemVyb1BhZEJ5dGVzIiwic3RyaXBaZXJvc0xlZnQiLCJpc0J5dGVzTGlrZSIsImlzSGV4U3RyaW5nIiwiaGV4bGlmeSIsImdldEJ5dGVzQ29weSIsImdldEJ5dGVzIiwiZGF0YVNsaWNlIiwiZGF0YUxlbmd0aCIsImNvbmNhdCIsImVuY29kZUJhc2U2NCIsImRlY29kZUJhc2U2NCIsImVuY29kZUJhc2U1OCIsImRlY29kZUJhc2U1OCIsIlRyYW5zYWN0aW9uIiwicmVjb3ZlckFkZHJlc3MiLCJjb21wdXRlQWRkcmVzcyIsImFjY2Vzc0xpc3RpZnkiLCJzaG93VGhyb3R0bGVNZXNzYWdlIiwiY29weVJlcXVlc3QiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiU29ja2V0U3Vic2NyaWJlciIsIlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyIiwiU29ja2V0RXZlbnRTdWJzY3JpYmVyIiwiU29ja2V0QmxvY2tTdWJzY3JpYmVyIiwiTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJOZXR3b3JrUGx1Z2luIiwiR2FzQ29zdFBsdWdpbiIsIkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJGZWVEYXRhTmV0d29ya1BsdWdpbiIsIndvcmRsaXN0cyIsIldvcmRsaXN0T3dsQSIsIldvcmRsaXN0T3dsIiwiTGFuZ0VuIiwiV29yZGxpc3QiLCJlbmNyeXB0S2V5c3RvcmVKc29uU3luYyIsImVuY3J5cHRLZXlzdG9yZUpzb24iLCJkZWNyeXB0S2V5c3RvcmVKc29uIiwiZGVjcnlwdEtleXN0b3JlSnNvblN5bmMiLCJkZWNyeXB0Q3Jvd2RzYWxlSnNvbiIsImlzS2V5c3RvcmVKc29uIiwiaXNDcm93ZHNhbGVKc29uIiwiZ2V0SW5kZXhlZEFjY291bnRQYXRoIiwiZ2V0QWNjb3VudFBhdGgiLCJkZWZhdWx0UGF0aCIsIldhbGxldCIsIkhETm9kZVZvaWRXYWxsZXQiLCJIRE5vZGVXYWxsZXQiLCJCYXNlV2FsbGV0IiwiTW5lbW9uaWMiLCJ1dWlkVjQiLCJlbmNvZGVSbHAiLCJkZWNvZGVSbHAiLCJVdGY4RXJyb3JGdW5jcyIsInRvVXRmOFN0cmluZyIsInRvVXRmOENvZGVQb2ludHMiLCJ0b1V0ZjhCeXRlcyIsInBhcnNlVW5pdHMiLCJmb3JtYXRVbml0cyIsInBhcnNlRXRoZXIiLCJmb3JtYXRFdGhlciIsIm1hc2siLCJ0b1R3b3MiLCJmcm9tVHdvcyIsInRvUXVhbnRpdHkiLCJ0b051bWJlciIsInRvQmVIZXgiLCJ0b0JpZ0ludCIsIl92ZXJzaW9uX2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImluZGV4X2pzXzEiLCJpbmRleF9qc18yIiwiaW5kZXhfanNfMyIsImluZGV4X2pzXzQiLCJpbmRleF9qc181IiwiaW5kZXhfanNfNiIsImluZGV4X2pzXzciLCJpbmRleF9qc184IiwiaW5kZXhfanNfOSIsImluZGV4X2pzXzEwIiwiaW5kZXhfanNfMTEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/ethers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/id.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/id.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.id = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */ function id(value) {\n    return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));\n}\nexports.id = id; //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2lkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxVQUFVLEdBQUcsS0FBSztBQUNsQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxvRkFBb0I7QUFDL0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTRixHQUFHRCxLQUFLO0lBQ2IsT0FBTyxDQUFDLEdBQUdFLFdBQVdHLFNBQVMsRUFBRSxDQUFDLEdBQUdELFdBQVdFLFdBQVcsRUFBRU47QUFDakU7QUFDQUQsVUFBVSxHQUFHRSxJQUNiLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvaWQuanM/N2VjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaWQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBBIHNpbXBsZSBoYXNoaW5nIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIFVURi04IHN0cmluZ3MgdG9cbiAqICBjb21wdXRlIGFuIDMyLWJ5dGUgaWRlbnRpZmllci5cbiAqXG4gKiAgVGhpcyBzaW1wbHkgY29tcHV0ZXMgdGhlIFtVVEYtOCBieXRlc10odG9VdGY4Qnl0ZXMpIGFuZCBjb21wdXRlc1xuICogIHRoZSBbW2tlY2NhazI1Nl1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGlkKFwiaGVsbG8gd29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gaWQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfMi50b1V0ZjhCeXRlcykodmFsdWUpKTtcbn1cbmV4cG9ydHMuaWQgPSBpZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlkIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18yIiwia2VjY2FrMjU2IiwidG9VdGY4Qnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Utilities for common tasks involving hashing. Also see\n *  [cryptographic hashing](about-crypto-hashing).\n *\n *  @_section: api/hashing:Hashing Utilities  [about-hashing]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;\nvar id_js_1 = __webpack_require__(/*! ./id.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/id.js\");\nObject.defineProperty(exports, \"id\", ({\n    enumerable: true,\n    get: function() {\n        return id_js_1.id;\n    }\n}));\nvar namehash_js_1 = __webpack_require__(/*! ./namehash.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/namehash.js\");\nObject.defineProperty(exports, \"ensNormalize\", ({\n    enumerable: true,\n    get: function() {\n        return namehash_js_1.ensNormalize;\n    }\n}));\nObject.defineProperty(exports, \"isValidName\", ({\n    enumerable: true,\n    get: function() {\n        return namehash_js_1.isValidName;\n    }\n}));\nObject.defineProperty(exports, \"namehash\", ({\n    enumerable: true,\n    get: function() {\n        return namehash_js_1.namehash;\n    }\n}));\nObject.defineProperty(exports, \"dnsEncode\", ({\n    enumerable: true,\n    get: function() {\n        return namehash_js_1.dnsEncode;\n    }\n}));\nvar message_js_1 = __webpack_require__(/*! ./message.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/message.js\");\nObject.defineProperty(exports, \"hashMessage\", ({\n    enumerable: true,\n    get: function() {\n        return message_js_1.hashMessage;\n    }\n}));\nObject.defineProperty(exports, \"verifyMessage\", ({\n    enumerable: true,\n    get: function() {\n        return message_js_1.verifyMessage;\n    }\n}));\nvar solidity_js_1 = __webpack_require__(/*! ./solidity.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/solidity.js\");\nObject.defineProperty(exports, \"solidityPacked\", ({\n    enumerable: true,\n    get: function() {\n        return solidity_js_1.solidityPacked;\n    }\n}));\nObject.defineProperty(exports, \"solidityPackedKeccak256\", ({\n    enumerable: true,\n    get: function() {\n        return solidity_js_1.solidityPackedKeccak256;\n    }\n}));\nObject.defineProperty(exports, \"solidityPackedSha256\", ({\n    enumerable: true,\n    get: function() {\n        return solidity_js_1.solidityPackedSha256;\n    }\n}));\nvar typed_data_js_1 = __webpack_require__(/*! ./typed-data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/typed-data.js\");\nObject.defineProperty(exports, \"TypedDataEncoder\", ({\n    enumerable: true,\n    get: function() {\n        return typed_data_js_1.TypedDataEncoder;\n    }\n}));\nObject.defineProperty(exports, \"verifyTypedData\", ({\n    enumerable: true,\n    get: function() {\n        return typed_data_js_1.verifyTypedData;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7O0NBS0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBR0EsNEJBQTRCLEdBQUdBLCtCQUErQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDblMsSUFBSWMsVUFBVUMsbUJBQU9BLENBQUMsb0VBQVM7QUFDL0JqQixzQ0FBcUM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFFBQVFELEVBQUU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuRyxJQUFJSyxnQkFBZ0JILG1CQUFPQSxDQUFDLGdGQUFlO0FBQzNDakIsZ0RBQStDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxjQUFjTixZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0hkLCtDQUE4QztJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsY0FBY1AsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNIYiw0Q0FBMkM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGNBQWNSLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySFosNkNBQTRDO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxjQUFjVCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkgsSUFBSVUsZUFBZUosbUJBQU9BLENBQUMsOEVBQWM7QUFDekNqQiwrQ0FBOEM7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGFBQWFYLFdBQVc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSFYsaURBQWdEO0lBQUVrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxhQUFhWixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUgsSUFBSWEsZ0JBQWdCTCxtQkFBT0EsQ0FBQyxnRkFBZTtBQUMzQ2pCLGtEQUFpRDtJQUFFa0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csY0FBY2QsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pJUiwyREFBMEQ7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLGNBQWNmLHVCQUF1QjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25KUCx3REFBdUQ7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9HLGNBQWNoQixvQkFBb0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SSxJQUFJaUIsa0JBQWtCTixtQkFBT0EsQ0FBQyxvRkFBaUI7QUFDL0NqQixvREFBbUQ7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9JLGdCQUFnQmxCLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZJTCxtREFBa0Q7SUFBRWtCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9JLGdCQUFnQm5CLGVBQWU7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUNySSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL2luZGV4LmpzP2UzMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBVdGlsaXRpZXMgZm9yIGNvbW1vbiB0YXNrcyBpbnZvbHZpbmcgaGFzaGluZy4gQWxzbyBzZWVcbiAqICBbY3J5cHRvZ3JhcGhpYyBoYXNoaW5nXShhYm91dC1jcnlwdG8taGFzaGluZykuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL2hhc2hpbmc6SGFzaGluZyBVdGlsaXRpZXMgIFthYm91dC1oYXNoaW5nXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeVR5cGVkRGF0YSA9IGV4cG9ydHMuVHlwZWREYXRhRW5jb2RlciA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWRTaGEyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2ID0gZXhwb3J0cy5zb2xpZGl0eVBhY2tlZCA9IGV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBleHBvcnRzLmRuc0VuY29kZSA9IGV4cG9ydHMubmFtZWhhc2ggPSBleHBvcnRzLmlzVmFsaWROYW1lID0gZXhwb3J0cy5lbnNOb3JtYWxpemUgPSBleHBvcnRzLmlkID0gdm9pZCAwO1xudmFyIGlkX2pzXzEgPSByZXF1aXJlKFwiLi9pZC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpZF9qc18xLmlkOyB9IH0pO1xudmFyIG5hbWVoYXNoX2pzXzEgPSByZXF1aXJlKFwiLi9uYW1laGFzaC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuc05vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfanNfMS5lbnNOb3JtYWxpemU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZWhhc2hfanNfMS5pc1ZhbGlkTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5hbWVoYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1laGFzaF9qc18xLm5hbWVoYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG5zRW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1laGFzaF9qc18xLmRuc0VuY29kZTsgfSB9KTtcbnZhciBtZXNzYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzaE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VfanNfMS5oYXNoTWVzc2FnZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcmlmeU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VfanNfMS52ZXJpZnlNZXNzYWdlOyB9IH0pO1xudmFyIHNvbGlkaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9zb2xpZGl0eS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNvbGlkaXR5UGFja2VkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2xpZGl0eV9qc18xLnNvbGlkaXR5UGFja2VkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29saWRpdHlQYWNrZWRLZWNjYWsyNTZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvbGlkaXR5X2pzXzEuc29saWRpdHlQYWNrZWRLZWNjYWsyNTY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzb2xpZGl0eVBhY2tlZFNoYTI1NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29saWRpdHlfanNfMS5zb2xpZGl0eVBhY2tlZFNoYTI1NjsgfSB9KTtcbnZhciB0eXBlZF9kYXRhX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1kYXRhLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZWREYXRhRW5jb2RlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZWRfZGF0YV9qc18xLlR5cGVkRGF0YUVuY29kZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlUeXBlZERhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVkX2RhdGFfanNfMS52ZXJpZnlUeXBlZERhdGE7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ2ZXJpZnlUeXBlZERhdGEiLCJUeXBlZERhdGFFbmNvZGVyIiwic29saWRpdHlQYWNrZWRTaGEyNTYiLCJzb2xpZGl0eVBhY2tlZEtlY2NhazI1NiIsInNvbGlkaXR5UGFja2VkIiwidmVyaWZ5TWVzc2FnZSIsImhhc2hNZXNzYWdlIiwiZG5zRW5jb2RlIiwibmFtZWhhc2giLCJpc1ZhbGlkTmFtZSIsImVuc05vcm1hbGl6ZSIsImlkIiwiaWRfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibmFtZWhhc2hfanNfMSIsIm1lc3NhZ2VfanNfMSIsInNvbGlkaXR5X2pzXzEiLCJ0eXBlZF9kYXRhX2pzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/message.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/message.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.verifyMessage = exports.hashMessage = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  Computes the [[link-eip-191]] personal-sign message digest to sign.\n *\n *  This prefixes the message with [[MessagePrefix]] and the decimal length\n *  of %%message%% and computes the [[keccak256]] digest.\n *\n *  If %%message%% is a string, it is converted to its UTF-8 bytes\n *  first. To compute the digest of a [[DataHexString]], it must be converted\n *  to [bytes](getBytes).\n *\n *  @example:\n *    hashMessage(\"Hello World\")\n *    //_result:\n *\n *    // Hashes the SIX (6) string characters, i.e.\n *    // [ \"0\", \"x\", \"4\", \"2\", \"4\", \"3\" ]\n *    hashMessage(\"0x4243\")\n *    //_result:\n *\n *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...\n *    hashMessage(getBytes(\"0x4243\"))\n *    //_result:\n *\n *    // ...which is equal to using data\n *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))\n *    //_result:\n *\n */ function hashMessage(message) {\n    if (typeof message === \"string\") {\n        message = (0, index_js_4.toUtf8Bytes)(message);\n    }\n    return (0, index_js_1.keccak256)((0, index_js_4.concat)([\n        (0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix),\n        (0, index_js_4.toUtf8Bytes)(String(message.length)),\n        message\n    ]));\n}\nexports.hashMessage = hashMessage;\n/**\n *  Return the address of the private key that produced\n *  the signature %%sig%% during signing for %%message%%.\n */ function verifyMessage(message, sig) {\n    const digest = hashMessage(message);\n    return (0, index_js_3.recoverAddress)(digest, sig);\n}\nexports.verifyMessage = verifyMessage; //# sourceMappingURL=message.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL21lc3NhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQ25ELE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQywwRkFBdUI7QUFDbEQsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLEdBQ0QsU0FBU0YsWUFBWU0sT0FBTztJQUN4QixJQUFJLE9BQVFBLFlBQWEsVUFBVTtRQUMvQkEsVUFBVSxDQUFDLEdBQUdELFdBQVdFLFdBQVcsRUFBRUQ7SUFDMUM7SUFDQSxPQUFPLENBQUMsR0FBR0wsV0FBV08sU0FBUyxFQUFFLENBQUMsR0FBR0gsV0FBV0ksTUFBTSxFQUFFO1FBQ25ELElBQUdKLFdBQVdFLFdBQVcsRUFBRUosV0FBV08sYUFBYTtRQUNuRCxJQUFHTCxXQUFXRSxXQUFXLEVBQUVJLE9BQU9MLFFBQVFNLE1BQU07UUFDakROO0tBQ0g7QUFDTDtBQUNBVCxtQkFBbUIsR0FBR0c7QUFDdEI7OztDQUdDLEdBQ0QsU0FBU0QsY0FBY08sT0FBTyxFQUFFTyxHQUFHO0lBQy9CLE1BQU1DLFNBQVNkLFlBQVlNO0lBQzNCLE9BQU8sQ0FBQyxHQUFHRixXQUFXVyxjQUFjLEVBQUVELFFBQVFEO0FBQ2xEO0FBQ0FoQixxQkFBcUIsR0FBR0UsZUFDeEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9tZXNzYWdlLmpzPzE0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQ29tcHV0ZXMgdGhlIFtbbGluay1laXAtMTkxXV0gcGVyc29uYWwtc2lnbiBtZXNzYWdlIGRpZ2VzdCB0byBzaWduLlxuICpcbiAqICBUaGlzIHByZWZpeGVzIHRoZSBtZXNzYWdlIHdpdGggW1tNZXNzYWdlUHJlZml4XV0gYW5kIHRoZSBkZWNpbWFsIGxlbmd0aFxuICogIG9mICUlbWVzc2FnZSUlIGFuZCBjb21wdXRlcyB0aGUgW1trZWNjYWsyNTZdXSBkaWdlc3QuXG4gKlxuICogIElmICUlbWVzc2FnZSUlIGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gaXRzIFVURi04IGJ5dGVzXG4gKiAgZmlyc3QuIFRvIGNvbXB1dGUgdGhlIGRpZ2VzdCBvZiBhIFtbRGF0YUhleFN0cmluZ11dLCBpdCBtdXN0IGJlIGNvbnZlcnRlZFxuICogIHRvIFtieXRlc10oZ2V0Qnl0ZXMpLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIGhhc2hNZXNzYWdlKFwiSGVsbG8gV29ybGRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBIYXNoZXMgdGhlIFNJWCAoNikgc3RyaW5nIGNoYXJhY3RlcnMsIGkuZS5cbiAqICAgIC8vIFsgXCIwXCIsIFwieFwiLCBcIjRcIiwgXCIyXCIsIFwiNFwiLCBcIjNcIiBdXG4gKiAgICBoYXNoTWVzc2FnZShcIjB4NDI0M1wiKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIC8vIEhhc2hlcyB0aGUgVFdPICgyKSBieXRlcyBbIDB4NDIsIDB4NDMgXS4uLlxuICogICAgaGFzaE1lc3NhZ2UoZ2V0Qnl0ZXMoXCIweDQyNDNcIikpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gLi4ud2hpY2ggaXMgZXF1YWwgdG8gdXNpbmcgZGF0YVxuICogICAgaGFzaE1lc3NhZ2UobmV3IFVpbnQ4QXJyYXkoWyAweDQyLCAweDQzIF0pKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqL1xuZnVuY3Rpb24gaGFzaE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSAoMCwgaW5kZXhfanNfNC50b1V0ZjhCeXRlcykobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc180LmNvbmNhdCkoW1xuICAgICAgICAoMCwgaW5kZXhfanNfNC50b1V0ZjhCeXRlcykoaW5kZXhfanNfMi5NZXNzYWdlUHJlZml4KSxcbiAgICAgICAgKDAsIGluZGV4X2pzXzQudG9VdGY4Qnl0ZXMpKFN0cmluZyhtZXNzYWdlLmxlbmd0aCkpLFxuICAgICAgICBtZXNzYWdlXG4gICAgXSkpO1xufVxuZXhwb3J0cy5oYXNoTWVzc2FnZSA9IGhhc2hNZXNzYWdlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBhZGRyZXNzIG9mIHRoZSBwcml2YXRlIGtleSB0aGF0IHByb2R1Y2VkXG4gKiAgdGhlIHNpZ25hdHVyZSAlJXNpZyUlIGR1cmluZyBzaWduaW5nIGZvciAlJW1lc3NhZ2UlJS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWcpIHtcbiAgICBjb25zdCBkaWdlc3QgPSBoYXNoTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMucmVjb3ZlckFkZHJlc3MpKGRpZ2VzdCwgc2lnKTtcbn1cbmV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IHZlcmlmeU1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZlcmlmeU1lc3NhZ2UiLCJoYXNoTWVzc2FnZSIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJpbmRleF9qc180IiwibWVzc2FnZSIsInRvVXRmOEJ5dGVzIiwia2VjY2FrMjU2IiwiY29uY2F0IiwiTWVzc2FnZVByZWZpeCIsIlN0cmluZyIsImxlbmd0aCIsInNpZyIsImRpZ2VzdCIsInJlY292ZXJBZGRyZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/message.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/namehash.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/namehash.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst ens_normalize_1 = __webpack_require__(/*! @adraffy/ens-normalize */ \"(rsc)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs\");\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    (0, index_js_2.assertArgument)(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp);\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    (0, index_js_2.assertArgument)(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n/**\n *  Returns the ENS %%name%% normalized.\n */ function ensNormalize(name) {\n    try {\n        if (name.length === 0) {\n            throw new Error(\"empty label\");\n        }\n        return (0, ens_normalize_1.ens_normalize)(name);\n    } catch (error) {\n        (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, \"name\", name);\n    }\n}\nexports.ensNormalize = ensNormalize;\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */ function isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\nexports.isValidName = isValidName;\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */ function namehash(name) {\n    (0, index_js_2.assertArgument)(typeof name === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n    (0, index_js_2.assertArgument)(name.length, `invalid ENS name (empty label)`, \"name\", name);\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0, index_js_1.keccak256)((0, index_js_2.concat)([\n            result,\n            (0, index_js_1.keccak256)(comps.pop())\n        ]));\n    }\n    return (0, index_js_2.hexlify)(result);\n}\nexports.namehash = namehash;\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */ function dnsEncode(name) {\n    return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map((comp)=>{\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\nexports.dnsEncode = dnsEncode; //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQ3pGLE1BQU1NLGFBQWFDLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsa0JBQWtCRixtQkFBT0EsQ0FBQyw4R0FBd0I7QUFDeEQsTUFBTUcsUUFBUSxJQUFJQyxXQUFXO0FBQzdCRCxNQUFNRSxJQUFJLENBQUM7QUFDWCxTQUFTQyxlQUFlQyxJQUFJO0lBQ3ZCLElBQUdOLFdBQVdPLGNBQWMsRUFBRUQsS0FBS0UsTUFBTSxLQUFLLEdBQUcscUNBQXFDLFFBQVFGO0lBQy9GLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFFBQVEsQ0FBQyxHQUFHWCxXQUFXWSxXQUFXLEVBQUVmLGFBQWFhO0lBQ3ZELE1BQU1HLFFBQVEsRUFBRTtJQUNoQixJQUFJSCxLQUFLRixNQUFNLEtBQUssR0FBRztRQUNuQixPQUFPSztJQUNYO0lBQ0EsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixNQUFNSCxNQUFNLEVBQUVPLElBQUs7UUFDbkMsTUFBTUMsSUFBSUwsS0FBSyxDQUFDSSxFQUFFO1FBQ2xCLDhDQUE4QztRQUM5QyxJQUFJQyxNQUFNLE1BQU07WUFDWkgsTUFBTUksSUFBSSxDQUFDWixlQUFlTSxNQUFNTyxLQUFLLENBQUNKLE1BQU1DO1lBQzVDRCxPQUFPQyxJQUFJO1FBQ2Y7SUFDSjtJQUNBLHFEQUFxRDtJQUNwRCxJQUFHZixXQUFXTyxjQUFjLEVBQUVPLE9BQU9ILE1BQU1ILE1BQU0sRUFBRSxxQ0FBcUMsUUFBUUU7SUFDakdHLE1BQU1JLElBQUksQ0FBQ1osZUFBZU0sTUFBTU8sS0FBSyxDQUFDSjtJQUN0QyxPQUFPRDtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTaEIsYUFBYWEsSUFBSTtJQUN0QixJQUFJO1FBQ0EsSUFBSUEsS0FBS0YsTUFBTSxLQUFLLEdBQUc7WUFDbkIsTUFBTSxJQUFJVyxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxDQUFDLEdBQUdsQixnQkFBZ0JtQixhQUFhLEVBQUVWO0lBQzlDLEVBQ0EsT0FBT1csT0FBTztRQUNULElBQUdyQixXQUFXTyxjQUFjLEVBQUUsT0FBTyxDQUFDLGtCQUFrQixFQUFFYyxNQUFNQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUVo7SUFDekY7QUFDSjtBQUNBbEIsb0JBQW9CLEdBQUdLO0FBQ3ZCOztDQUVDLEdBQ0QsU0FBU0QsWUFBWWMsSUFBSTtJQUNyQixJQUFJO1FBQ0EsT0FBUUQsYUFBYUMsTUFBTUYsTUFBTSxLQUFLO0lBQzFDLEVBQ0EsT0FBT2EsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNBN0IsbUJBQW1CLEdBQUdJO0FBQ3RCOztDQUVDLEdBQ0QsU0FBU0QsU0FBU2UsSUFBSTtJQUNqQixJQUFHVixXQUFXTyxjQUFjLEVBQUUsT0FBUUcsU0FBVSxVQUFVLGtDQUFrQyxRQUFRQTtJQUNwRyxJQUFHVixXQUFXTyxjQUFjLEVBQUVHLEtBQUtGLE1BQU0sRUFBRSxDQUFDLDhCQUE4QixDQUFDLEVBQUUsUUFBUUU7SUFDdEYsSUFBSWEsU0FBU3JCO0lBQ2IsTUFBTVcsUUFBUUosYUFBYUM7SUFDM0IsTUFBT0csTUFBTUwsTUFBTSxDQUFFO1FBQ2pCZSxTQUFTLENBQUMsR0FBR3pCLFdBQVcwQixTQUFTLEVBQUUsQ0FBQyxHQUFHeEIsV0FBV3lCLE1BQU0sRUFBRTtZQUFDRjtZQUFTLElBQUd6QixXQUFXMEIsU0FBUyxFQUFHWCxNQUFNYSxHQUFHO1NBQUs7SUFDaEg7SUFDQSxPQUFPLENBQUMsR0FBRzFCLFdBQVcyQixPQUFPLEVBQUVKO0FBQ25DO0FBQ0EvQixnQkFBZ0IsR0FBR0c7QUFDbkI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxVQUFVZ0IsSUFBSTtJQUNuQixPQUFPLENBQUMsR0FBR1YsV0FBVzJCLE9BQU8sRUFBRSxDQUFDLEdBQUczQixXQUFXeUIsTUFBTSxFQUFFaEIsYUFBYUMsTUFBTWtCLEdBQUcsQ0FBQyxDQUFDdEI7UUFDMUUsd0RBQXdEO1FBQ3hELElBQUlBLEtBQUtFLE1BQU0sR0FBRyxJQUFJO1lBQ2xCLE1BQU0sSUFBSVcsTUFBTTtRQUNwQjtRQUNBLE1BQU1SLFFBQVEsSUFBSVIsV0FBV0csS0FBS0UsTUFBTSxHQUFHO1FBQzNDRyxNQUFNa0IsR0FBRyxDQUFDdkIsTUFBTTtRQUNoQkssS0FBSyxDQUFDLEVBQUUsR0FBR0EsTUFBTUgsTUFBTSxHQUFHO1FBQzFCLE9BQU9HO0lBQ1gsT0FBTztBQUNYO0FBQ0FuQixpQkFBaUIsR0FBR0UsV0FDcEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9uYW1laGFzaC5qcz80YTEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kbnNFbmNvZGUgPSBleHBvcnRzLm5hbWVoYXNoID0gZXhwb3J0cy5pc1ZhbGlkTmFtZSA9IGV4cG9ydHMuZW5zTm9ybWFsaXplID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgZW5zX25vcm1hbGl6ZV8xID0gcmVxdWlyZShcIkBhZHJhZmZ5L2Vucy1ub3JtYWxpemVcIik7XG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChjb21wKSB7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNvbXAubGVuZ3RoICE9PSAwLCBcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiLCBcImNvbXBcIiwgY29tcCk7XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKGVuc05vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGxhc3QgPCBieXRlcy5sZW5ndGgsIFwiaW52YWxpZCBFTlMgbmFtZTsgZW1wdHkgY29tcG9uZW50XCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBjb21wcy5wdXNoKGNoZWNrQ29tcG9uZW50KGJ5dGVzLnNsaWNlKGxhc3QpKSk7XG4gICAgcmV0dXJuIGNvbXBzO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgRU5TICUlbmFtZSUlIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIGVuc05vcm1hbGl6ZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBsYWJlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGVuc19ub3JtYWxpemVfMS5lbnNfbm9ybWFsaXplKShuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgRU5TIG5hbWUgKCR7ZXJyb3IubWVzc2FnZX0pYCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5zTm9ybWFsaXplID0gZW5zTm9ybWFsaXplO1xuLyoqXG4gKiAgUmV0dXJucyBgYHRydWVgYCBpZiAlJW5hbWUlJSBpcyBhIHZhbGlkIEVOUyBuYW1lLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVmFsaWROYW1lID0gaXNWYWxpZE5hbWU7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBbW2xpbmstbmFtZWhhc2hdXSBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuYW1lKSA9PT0gXCJzdHJpbmdcIiwgXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShuYW1lLmxlbmd0aCwgYGludmFsaWQgRU5TIG5hbWUgKGVtcHR5IGxhYmVsKWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSAoMCwgaW5kZXhfanNfMS5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc18yLmNvbmNhdCkoW3Jlc3VsdCwgKDAsIGluZGV4X2pzXzEua2VjY2FrMjU2KSgoY29tcHMucG9wKCkpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKHJlc3VsdCk7XG59XG5leHBvcnRzLm5hbWVoYXNoID0gbmFtZWhhc2g7XG4vKipcbiAqICBSZXR1cm5zIHRoZSBETlMgZW5jb2RlZCAlJW5hbWUlJS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VkIGZvciB2YXJpb3VzIHBhcnRzIG9mIEVOUyBuYW1lIHJlc29sdXRpb24sIHN1Y2hcbiAqICBhcyB0aGUgd2lsZGNhcmQgcmVzb2x1dGlvbi5cbiAqL1xuZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzIuY29uY2F0KShlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIC8vIEROUyBkb2VzIG5vdCBhbGxvdyBjb21wb25lbnRzIG92ZXIgNjMgYnl0ZXMgaW4gbGVuZ3RoXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEROUyBlbmNvZGVkIGVudHJ5OyBsZW5ndGggZXhjZWVkcyA2MyBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbmV4cG9ydHMuZG5zRW5jb2RlID0gZG5zRW5jb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZG5zRW5jb2RlIiwibmFtZWhhc2giLCJpc1ZhbGlkTmFtZSIsImVuc05vcm1hbGl6ZSIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImVuc19ub3JtYWxpemVfMSIsIlplcm9zIiwiVWludDhBcnJheSIsImZpbGwiLCJjaGVja0NvbXBvbmVudCIsImNvbXAiLCJhc3NlcnRBcmd1bWVudCIsImxlbmd0aCIsImVuc05hbWVTcGxpdCIsIm5hbWUiLCJieXRlcyIsInRvVXRmOEJ5dGVzIiwiY29tcHMiLCJsYXN0IiwiaSIsImQiLCJwdXNoIiwic2xpY2UiLCJFcnJvciIsImVuc19ub3JtYWxpemUiLCJlcnJvciIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJwb3AiLCJoZXhsaWZ5IiwibWFwIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/namehash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/solidity.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/solidity.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n    switch(type){\n        case \"address\":\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));\n        case \"string\":\n            return (0, index_js_3.toUtf8Bytes)(value);\n        case \"bytes\":\n            return (0, index_js_3.getBytes)(value);\n        case \"bool\":\n            value = !!value ? \"0x01\" : \"0x00\";\n            if (isArray) {\n                return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));\n            }\n            return (0, index_js_3.getBytes)(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        let signed = match[1] === \"int\";\n        let size = parseInt(match[2] || \"256\");\n        (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n        if (isArray) {\n            size = 256;\n        }\n        if (signed) {\n            value = (0, index_js_3.toTwos)(value, size);\n        }\n        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        (0, index_js_3.assertArgument)(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size, `invalid value for ${type}`, \"value\", value);\n        if (isArray) {\n            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type}`, \"value\", value);\n        const result = [];\n        value.forEach(function(value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));\n    }\n    (0, index_js_3.assertArgument)(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */ function solidityPacked(types, values) {\n    (0, index_js_3.assertArgument)(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n    const tight = [];\n    types.forEach(function(type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));\n}\nexports.solidityPacked = solidityPacked;\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */ function solidityPackedKeccak256(types, values) {\n    return (0, index_js_2.keccak256)(solidityPacked(types, values));\n}\nexports.solidityPackedKeccak256 = solidityPackedKeccak256;\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */ function solidityPackedSha256(types, values) {\n    return (0, index_js_2.sha256)(solidityPacked(types, values));\n}\nexports.solidityPackedSha256 = solidityPackedSha256; //# sourceMappingURL=solidity.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL3NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw0QkFBNEIsR0FBR0EsK0JBQStCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDL0YsTUFBTUssYUFBYUMsbUJBQU9BLENBQUMsc0ZBQXFCO0FBQ2hELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUcsYUFBYSxJQUFJQyxPQUFPO0FBQzlCLE1BQU1DLGNBQWMsSUFBSUQsT0FBTztBQUMvQixNQUFNRSxhQUFhLElBQUlGLE9BQU87QUFDOUIsU0FBU0csTUFBTUMsSUFBSSxFQUFFYixLQUFLLEVBQUVjLE9BQU87SUFDL0IsT0FBUUQ7UUFDSixLQUFLO1lBQ0QsSUFBSUMsU0FBUztnQkFDVCxPQUFPLENBQUMsR0FBR1AsV0FBV1EsUUFBUSxFQUFFLENBQUMsR0FBR1IsV0FBV1MsWUFBWSxFQUFFaEIsT0FBTztZQUN4RTtZQUNBLE9BQU8sQ0FBQyxHQUFHTyxXQUFXUSxRQUFRLEVBQUUsQ0FBQyxHQUFHWCxXQUFXYSxVQUFVLEVBQUVqQjtRQUMvRCxLQUFLO1lBQ0QsT0FBTyxDQUFDLEdBQUdPLFdBQVdXLFdBQVcsRUFBRWxCO1FBQ3ZDLEtBQUs7WUFDRCxPQUFPLENBQUMsR0FBR08sV0FBV1EsUUFBUSxFQUFFZjtRQUNwQyxLQUFLO1lBQ0RBLFFBQVMsQ0FBQyxDQUFDQSxRQUFRLFNBQVM7WUFDNUIsSUFBSWMsU0FBUztnQkFDVCxPQUFPLENBQUMsR0FBR1AsV0FBV1EsUUFBUSxFQUFFLENBQUMsR0FBR1IsV0FBV1MsWUFBWSxFQUFFaEIsT0FBTztZQUN4RTtZQUNBLE9BQU8sQ0FBQyxHQUFHTyxXQUFXUSxRQUFRLEVBQUVmO0lBQ3hDO0lBQ0EsSUFBSW1C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RUMsTUFBTTtJQUMxQyxPQUFPLENBQUMsR0FBR2hDLFdBQVdvQyxTQUFTLEVBQUV2QyxlQUFla0MsT0FBT0M7QUFDM0Q7QUFDQXZDLCtCQUErQixHQUFHRztBQUNsQzs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELHFCQUFxQm9DLEtBQUssRUFBRUMsTUFBTTtJQUN2QyxPQUFPLENBQUMsR0FBR2hDLFdBQVdxQyxNQUFNLEVBQUV4QyxlQUFla0MsT0FBT0M7QUFDeEQ7QUFDQXZDLDRCQUE0QixHQUFHRSxzQkFDL0Isb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvaGFzaC9zb2xpZGl0eS5qcz82ZDdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zb2xpZGl0eVBhY2tlZFNoYTI1NiA9IGV4cG9ydHMuc29saWRpdHlQYWNrZWRLZWNjYWsyNTYgPSBleHBvcnRzLnNvbGlkaXR5UGFja2VkID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgcmVnZXhCeXRlcyA9IG5ldyBSZWdFeHAoXCJeYnl0ZXMoWzAtOV0rKSRcIik7XG5jb25zdCByZWdleE51bWJlciA9IG5ldyBSZWdFeHAoXCJeKHU/aW50KShbMC05XSopJFwiKTtcbmNvbnN0IHJlZ2V4QXJyYXkgPSBuZXcgUmVnRXhwKFwiXiguKilcXFxcWyhbMC05XSopXFxcXF0kXCIpO1xuZnVuY3Rpb24gX3BhY2sodHlwZSwgdmFsdWUsIGlzQXJyYXkpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKHZhbHVlLCAzMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSh2YWx1ZSkpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMudG9VdGY4Qnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgIHZhbHVlID0gKCEhdmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSgoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKHZhbHVlLCAzMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSh2YWx1ZSk7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBsZXQgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcImludFwiKTtcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCghbWF0Y2hbMl0gfHwgbWF0Y2hbMl0gPT09IFN0cmluZyhzaXplKSkgJiYgKHNpemUgJSA4ID09PSAwKSAmJiBzaXplICE9PSAwICYmIHNpemUgPD0gMjU2LCBcImludmFsaWQgbnVtYmVyIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgc2l6ZSA9IDI1NjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLnRvVHdvcykodmFsdWUsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKSgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHZhbHVlKSwgc2l6ZSAvIDgpKTtcbiAgICB9XG4gICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4Qnl0ZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoU3RyaW5nKHNpemUpID09PSBtYXRjaFsxXSAmJiBzaXplICE9PSAwICYmIHNpemUgPD0gMzIsIFwiaW52YWxpZCBieXRlcyB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKCgwLCBpbmRleF9qc18zLmRhdGFMZW5ndGgpKHZhbHVlKSA9PT0gc2l6ZSwgYGludmFsaWQgdmFsdWUgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzMuemVyb1BhZEJ5dGVzKSh2YWx1ZSwgMzIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEFycmF5KTtcbiAgICBpZiAobWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChtYXRjaFsyXSB8fCBTdHJpbmcodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShjb3VudCA9PT0gdmFsdWUubGVuZ3RoLCBgaW52YWxpZCBhcnJheSBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChfcGFjayhiYXNlVHlwZSwgdmFsdWUsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMy5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzMuY29uY2F0KShyZXN1bHQpKTtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG59XG4vLyBAVE9ETzogQXJyYXkgRW51bVxuLyoqXG4gKiAgIENvbXB1dGVzIHRoZSBbW2xpbmstc29sYy1wYWNrZWRdXSByZXByZXNlbnRhdGlvbiBvZiAlJXZhbHVlcyUlXG4gKiAgIHJlc3BlY3RpdmVseSB0byB0aGVpciAlJXR5cGVzJSUuXG4gKlxuICogICBAZXhhbXBsZTpcbiAqICAgICAgIGFkZHIgPSBcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiXG4gKiAgICAgICBzb2xpZGl0eVBhY2tlZChbIFwiYWRkcmVzc1wiLCBcInVpbnRcIiBdLCBbIGFkZHIsIDQ1IF0pO1xuICogICAgICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHR5cGVzLmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aCwgXCJ3cm9uZyBudW1iZXIgb2YgdmFsdWVzOyBleHBlY3RlZCAkeyB0eXBlcy5sZW5ndGggfVwiLCBcInZhbHVlc1wiLCB2YWx1ZXMpO1xuICAgIGNvbnN0IHRpZ2h0ID0gW107XG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICAgICAgdGlnaHQucHVzaChfcGFjayh0eXBlLCB2YWx1ZXNbaW5kZXhdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmhleGxpZnkpKCgwLCBpbmRleF9qc18zLmNvbmNhdCkodGlnaHQpKTtcbn1cbmV4cG9ydHMuc29saWRpdHlQYWNrZWQgPSBzb2xpZGl0eVBhY2tlZDtcbi8qKlxuICogICBDb21wdXRlcyB0aGUgW1tsaW5rLXNvbGMtcGFja2VkXV0gW1trZWNjYWsyNTZdXSBoYXNoIG9mICUldmFsdWVzJSVcbiAqICAgcmVzcGVjdGl2ZWx5IHRvIHRoZWlyICUldHlwZXMlJS5cbiAqXG4gKiAgIEBleGFtcGxlOlxuICogICAgICAgYWRkciA9IFwiMHg4YmExZjEwOTU1MWJkNDMyODAzMDEyNjQ1YWMxMzZkZGQ2NGRiYTcyXCJcbiAqICAgICAgIHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KFsgXCJhZGRyZXNzXCIsIFwidWludFwiIF0sIFsgYWRkciwgNDUgXSk7XG4gKiAgICAgICAvL19yZXN1bHQ6XG4gKi9cbmZ1bmN0aW9uIHNvbGlkaXR5UGFja2VkS2VjY2FrMjU2KHR5cGVzLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KShzb2xpZGl0eVBhY2tlZCh0eXBlcywgdmFsdWVzKSk7XG59XG5leHBvcnRzLnNvbGlkaXR5UGFja2VkS2VjY2FrMjU2ID0gc29saWRpdHlQYWNrZWRLZWNjYWsyNTY7XG4vKipcbiAqICAgQ29tcHV0ZXMgdGhlIFtbbGluay1zb2xjLXBhY2tlZF1dIFtbc2hhMjU2XV0gaGFzaCBvZiAlJXZhbHVlcyUlXG4gKiAgIHJlc3BlY3RpdmVseSB0byB0aGVpciAlJXR5cGVzJSUuXG4gKlxuICogICBAZXhhbXBsZTpcbiAqICAgICAgIGFkZHIgPSBcIjB4OGJhMWYxMDk1NTFiZDQzMjgwMzAxMjY0NWFjMTM2ZGRkNjRkYmE3MlwiXG4gKiAgICAgICBzb2xpZGl0eVBhY2tlZFNoYTI1NihbIFwiYWRkcmVzc1wiLCBcInVpbnRcIiBdLCBbIGFkZHIsIDQ1IF0pO1xuICogICAgICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eVBhY2tlZFNoYTI1Nih0eXBlcywgdmFsdWVzKSB7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLnNoYTI1Nikoc29saWRpdHlQYWNrZWQodHlwZXMsIHZhbHVlcykpO1xufVxuZXhwb3J0cy5zb2xpZGl0eVBhY2tlZFNoYTI1NiA9IHNvbGlkaXR5UGFja2VkU2hhMjU2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWRpdHkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic29saWRpdHlQYWNrZWRTaGEyNTYiLCJzb2xpZGl0eVBhY2tlZEtlY2NhazI1NiIsInNvbGlkaXR5UGFja2VkIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18yIiwiaW5kZXhfanNfMyIsInJlZ2V4Qnl0ZXMiLCJSZWdFeHAiLCJyZWdleE51bWJlciIsInJlZ2V4QXJyYXkiLCJfcGFjayIsInR5cGUiLCJpc0FycmF5IiwiZ2V0Qnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJnZXRBZGRyZXNzIiwidG9VdGY4Qnl0ZXMiLCJtYXRjaCIsInNpZ25lZCIsInNpemUiLCJwYXJzZUludCIsImFzc2VydEFyZ3VtZW50IiwiU3RyaW5nIiwidG9Ud29zIiwidG9CZUFycmF5IiwiZGF0YUxlbmd0aCIsInplcm9QYWRCeXRlcyIsIkFycmF5IiwiYmFzZVR5cGUiLCJjb3VudCIsImxlbmd0aCIsInJlc3VsdCIsImZvckVhY2giLCJwdXNoIiwiY29uY2F0IiwidHlwZXMiLCJ2YWx1ZXMiLCJ0aWdodCIsImluZGV4IiwiaGV4bGlmeSIsImtlY2NhazI1NiIsInNoYTI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/solidity.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/hash/typed-data.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/hash/typed-data.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.verifyTypedData = exports.TypedDataEncoder = void 0;\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst id_js_1 = __webpack_require__(/*! ./id.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/id.js\");\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n    const bytes = (0, index_js_4.getBytes)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0, index_js_4.concat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0, index_js_4.hexlify)(bytes);\n}\nconst hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);\nconst hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        (0, index_js_4.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value) {\n        const value = (0, index_js_4.getBigInt)(_value, \"domain.chainId\");\n        (0, index_js_4.assertArgument)(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) {\n            return Number(value);\n        }\n        return (0, index_js_4.toQuantity)(value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0, index_js_1.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        (0, index_js_4.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        const bytes = (0, index_js_4.getBytes)(value, \"domain.salt\");\n        (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return (0, index_js_4.hexlify)(bytes);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2] || \"256\");\n            (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n            const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n            return function(_value) {\n                const value = (0, index_js_4.getBigInt)(_value, \"value\");\n                (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n                return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n            return function(value) {\n                const bytes = (0, index_js_4.getBytes)(value);\n                (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0, index_js_2.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0, id_js_1.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\n/**\n *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads\n *  for signed typed data.\n *\n *  This is useful for those that wish to compute various components of a\n *  typed data hash, primary types, or sub-components, but generally the\n *  higher level [[Signer-signTypedData]] is more useful.\n */ class TypedDataEncoder {\n    #types;\n    /**\n     *  The types.\n     */ get types() {\n        return JSON.parse(this.#types);\n    }\n    #fullTypes;\n    #encoderCache;\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     *\n     *  This performs all necessary checking that types are valid and\n     *  do not violate the [[link-eip-712]] structural constraints as\n     *  well as computes the [[primaryType]].\n     */ constructor(types){\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n        // Link struct types to their direct child structs\n        const links = new Map();\n        // Link structs to structs which contain them as a child\n        const parents = new Map();\n        // Link all subtypes within a given struct\n        const subtypes = new Map();\n        Object.keys(types).forEach((type)=>{\n            links.set(type, new Set());\n            parents.set(type, []);\n            subtypes.set(type, new Set());\n        });\n        for(const name in types){\n            const uniqueNames = new Set();\n            for (const field of types[name]){\n                // Check each field has a unique name\n                (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                uniqueNames.add(field.name);\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n                (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    continue;\n                }\n                (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                // Add linkage\n                parents.get(baseType).push(name);\n                links.get(name).add(baseType);\n            }\n        }\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n)=>parents.get(n).length === 0);\n        (0, index_js_4.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", types);\n        (0, index_js_4.defineProperties)(this, {\n            primaryType: primaryTypes[0]\n        });\n        // Check for circular type references\n        function checkCircular(type, found) {\n            (0, index_js_4.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            found.add(type);\n            for (const child of links.get(type)){\n                if (!parents.has(child)) {\n                    continue;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                for (const subtype of found){\n                    subtypes.get(subtype).add(child);\n                }\n            }\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n        // Compute each fully describe type\n        for (const [name, set] of subtypes){\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\"));\n        }\n    }\n    /**\n     *  Returnthe encoder for the specific %%type%%.\n     */ getEncoder(type) {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n    #getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value)=>{\n                (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(index_js_2.keccak256);\n                }\n                return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0, id_js_1.id)(this.#fullTypes.get(type));\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) {\n                        return (0, index_js_2.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0, index_js_4.concat)(values);\n            };\n        }\n        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Return the full type for %%name%%.\n     */ encodeType(name) {\n        const result = this.#fullTypes.get(name);\n        (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        return result;\n    }\n    /**\n     *  Return the encoded %%value%% for the %%type%%.\n     */ encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    /**\n     *  Returns the hash of %%value%% for the type of %%name%%.\n     */ hashStruct(name, value) {\n        return (0, index_js_2.keccak256)(this.encodeData(name, value));\n    }\n    /**\n     *  Return the fulled encoded %%value%% for the [[types]].\n     */ encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    /**\n     *  Return the hash of the fully encoded %%value%% for the [[types]].\n     */ hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    /**\n     *  @_ignore:\n     */ _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            (0, index_js_4.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n            return value.map((v)=>this._visit(match[1], v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        (0, index_js_4.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n    }\n    /**\n     *  Call %%calback%% for each value in %%value%%, passing the type and\n     *  component within %%value%%.\n     *\n     *  This is useful for replacing addresses or other transformation that\n     *  may be desired on each component, based on its type.\n     */ visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    /**\n     *  Create a new **TypedDataEncoder** for %%types%%.\n     */ static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    /**\n     *  Return the primary type for %%types%%.\n     */ static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    /**\n     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.\n     */ static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    /**\n     *  Return the domain hash for %%domain%%.\n     */ static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            if (domain[name] == null) {\n                continue;\n            }\n            const type = domainFieldTypes[name];\n            (0, index_js_4.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    /**\n     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static encode(domain, types, value) {\n        return (0, index_js_4.concat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    /**\n     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.\n     */ static hash(domain, types, value) {\n        return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    /**\n     * Resolves to the value from resolving all addresses in %%value%% for\n     * %%types%% and the %%domain%%.\n     */ static async resolveNames(domain, types, value, resolveName) {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({}, domain);\n        // Allow passing null to ignore value\n        for(const key in domain){\n            if (domain[key] == null) {\n                delete domain[key];\n            }\n        }\n        // Look up all ENS names\n        const ensCache = {};\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n        // Get a list of all the addresses\n        encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && !(0, index_js_4.isHexString)(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n        // Lookup each name\n        for(const name in ensCache){\n            ensCache[name] = await resolveName(name);\n        }\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type, value)=>{\n            if (type === \"address\" && ensCache[value]) {\n                return ensCache[value];\n            }\n            return value;\n        });\n        return {\n            domain,\n            value\n        };\n    }\n    /**\n     *  Returns the JSON-encoded payload expected by nodes which implement\n     *  the JSON-RPC [[link-eip-712]] method.\n     */ static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = Object.assign({}, types);\n        (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        typesWithDomain.EIP712Domain = domainTypes;\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return (0, index_js_4.getBigInt)(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        (0, index_js_4.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n                (0, index_js_4.assertArgument)(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\nexports.TypedDataEncoder = TypedDataEncoder;\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */ function verifyTypedData(domain, types, value, signature) {\n    return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);\n}\nexports.verifyTypedData = verifyTypedData; //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9oYXNoL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQzFELDJGQUEyRjtBQUMzRixNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQW9CO0FBQy9DLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDhGQUF5QjtBQUNwRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsb0VBQVM7QUFDakMsTUFBTUssVUFBVSxJQUFJQyxXQUFXO0FBQy9CRCxRQUFRRSxJQUFJLENBQUM7QUFDYixNQUFNQyxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLGlCQUFpQkgsT0FBTzs7O0FBRzlCLFNBQVNJLFlBQVlqQixLQUFLO0lBQ3RCLE1BQU1rQixRQUFRLENBQUMsR0FBR1gsV0FBV1ksUUFBUSxFQUFFbkI7SUFDdkMsTUFBTW9CLFlBQVlGLE1BQU1HLE1BQU0sR0FBRztJQUNqQyxJQUFJRCxXQUFXO1FBQ1gsT0FBTyxDQUFDLEdBQUdiLFdBQVdlLE1BQU0sRUFBRTtZQUFDSjtZQUFPVCxRQUFRYyxLQUFLLENBQUNIO1NBQVc7SUFDbkU7SUFDQSxPQUFPLENBQUMsR0FBR2IsV0FBV2lCLE9BQU8sRUFBRU47QUFDbkM7QUFDQSxNQUFNTyxVQUFVLENBQUMsR0FBR2xCLFdBQVdtQixPQUFPLEVBQUVYLE1BQU07QUFDOUMsTUFBTVksV0FBVyxDQUFDLEdBQUdwQixXQUFXbUIsT0FBTyxFQUFFWixNQUFNO0FBQy9DLE1BQU1jLG1CQUFtQjtJQUNyQkMsTUFB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QWMsRUFBRSxPQUFRckMsVUFBVyxVQUFVLGtCQUFrQixTQUFTQTt3QkFDdkYsT0FBT0E7Z0JBQ2Y7Z0JBQ0MsSUFBR08sV0FBVzhCLGNBQWMsRUFBRSxPQUFPLG9CQUFvQixRQUFRYTtZQUN0RTtRQUNKO0lBQ0o7QUFDSjtBQUNBbkQsd0JBQXdCLEdBQUdHO0FBQzNCOztDQUVDLEdBQ0QsU0FBU0QsZ0JBQWdCd0gsTUFBTSxFQUFFdEQsS0FBSyxFQUFFbkUsS0FBSyxFQUFFMEksU0FBUztJQUNwRCxPQUFPLENBQUMsR0FBR3BJLFdBQVdxSSxjQUFjLEVBQUV6SSxpQkFBaUI4RyxJQUFJLENBQUNTLFFBQVF0RCxPQUFPbkUsUUFBUTBJO0FBQ3ZGO0FBQ0EzSSx1QkFBdUIsR0FBR0UsaUJBQzFCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL2hhc2gvdHlwZWQtZGF0YS5qcz85NGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJpZnlUeXBlZERhdGEgPSBleHBvcnRzLlR5cGVkRGF0YUVuY29kZXIgPSB2b2lkIDA7XG4vL2ltcG9ydCB7IFR5cGVkRGF0YURvbWFpbiwgVHlwZWREYXRhRmllbGQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJhYnN0cmFjdC1zaWduZXJcIjtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBpZF9qc18xID0gcmVxdWlyZShcIi4vaWQuanNcIik7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgQk5fXzEgPSBCaWdJbnQoLTEpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoMSk7XG5jb25zdCBCTl9NQVhfVUlOVDI1NiA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbjtcbjtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmNvbmNhdCkoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc180LmhleGxpZnkpKGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSAoMCwgaW5kZXhfanNfNC50b0JlSGV4KShCTl8xLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9ICgwLCBpbmRleF9qc180LnRvQmVIZXgpKEJOXzAsIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KShfdmFsdWUsIFwiZG9tYWluLmNoYWluSWRcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAwLCBcImludmFsaWQgY2hhaW4gSURcIiwgXCJkb21haW4uY2hhaW5JZFwiLCBfdmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQudG9RdWFudGl0eSkodmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKSh2YWx1ZSwgXCJkb21haW4uc2FsdFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGJ5dGVzLmxlbmd0aCA9PT0gMzIsIGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh3aWR0aCAlIDggPT09IDAgJiYgd2lkdGggIT09IDAgJiYgd2lkdGggPD0gMjU2ICYmIChtYXRjaFsyXSA9PSBudWxsIHx8IG1hdGNoWzJdID09PSBTdHJpbmcod2lkdGgpKSwgXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSAoMCwgaW5kZXhfanNfNC5tYXNrKShCTl9NQVhfVUlOVDI1Niwgc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/ICgoYm91bmRzVXBwZXIgKyBCTl8xKSAqIEJOX18xKSA6IEJOXzA7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KShfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID49IGJvdW5kc0xvd2VyICYmIHZhbHVlIDw9IGJvdW5kc1VwcGVyLCBgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC50b0JlSGV4KShzaWduZWQgPyAoMCwgaW5kZXhfanNfNC50b1R3b3MpKHZhbHVlLCAyNTYpIDogdmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkod2lkdGggIT09IDAgJiYgd2lkdGggPD0gMzIgJiYgbWF0Y2hbMV0gPT09IFN0cmluZyh3aWR0aCksIFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykodmFsdWUpO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShieXRlcy5sZW5ndGggPT09IHdpZHRoLCBgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180Lnplcm9QYWRWYWx1ZSkoKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykodmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaWRfanNfMS5pZCkodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG4vKipcbiAqICBBICoqVHlwZWREYXRhRW5jb2RlKiogcHJlcGFyZXMgYW5kIGVuY29kZXMgW1tsaW5rLWVpcC03MTJdXSBwYXlsb2Fkc1xuICogIGZvciBzaWduZWQgdHlwZWQgZGF0YS5cbiAqXG4gKiAgVGhpcyBpcyB1c2VmdWwgZm9yIHRob3NlIHRoYXQgd2lzaCB0byBjb21wdXRlIHZhcmlvdXMgY29tcG9uZW50cyBvZiBhXG4gKiAgdHlwZWQgZGF0YSBoYXNoLCBwcmltYXJ5IHR5cGVzLCBvciBzdWItY29tcG9uZW50cywgYnV0IGdlbmVyYWxseSB0aGVcbiAqICBoaWdoZXIgbGV2ZWwgW1tTaWduZXItc2lnblR5cGVkRGF0YV1dIGlzIG1vcmUgdXNlZnVsLlxuICovXG5jbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByaW1hcnkgdHlwZSBmb3IgdGhlIHN0cnVjdHVyZWQgW1t0eXBlc11dLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZGVyaXZlZCBhdXRvbWF0aWNhbGx5IGZyb20gdGhlIFtbdHlwZXNdXSwgc2luY2Ugbm9cbiAgICAgKiAgcmVjdXJzaW9uIGlzIHBvc3NpYmxlLCBvbmNlIHRoZSBEQUcgZm9yIHRoZSB0eXBlcyBpcyBjb25zdHVyY3RlZFxuICAgICAqICBpbnRlcm5hbGx5LCB0aGUgcHJpbWFyeSB0eXBlIG11c3QgYmUgdGhlIG9ubHkgcmVtYWluaW5nIHR5cGUgd2l0aFxuICAgICAqICBubyBwYXJlbnQgbm9kZXMuXG4gICAgICovXG4gICAgcHJpbWFyeVR5cGU7XG4gICAgI3R5cGVzO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHlwZXMuXG4gICAgICovXG4gICAgZ2V0IHR5cGVzKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLiN0eXBlcyk7XG4gICAgfVxuICAgICNmdWxsVHlwZXM7XG4gICAgI2VuY29kZXJDYWNoZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqVHlwZWREYXRhRW5jb2RlcioqIGZvciAlJXR5cGVzJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwZXJmb3JtcyBhbGwgbmVjZXNzYXJ5IGNoZWNraW5nIHRoYXQgdHlwZXMgYXJlIHZhbGlkIGFuZFxuICAgICAqICBkbyBub3QgdmlvbGF0ZSB0aGUgW1tsaW5rLWVpcC03MTJdXSBzdHJ1Y3R1cmFsIGNvbnN0cmFpbnRzIGFzXG4gICAgICogIHdlbGwgYXMgY29tcHV0ZXMgdGhlIFtbcHJpbWFyeVR5cGVdXS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgICAgICB0aGlzLiN0eXBlcyA9IEpTT04uc3RyaW5naWZ5KHR5cGVzKTtcbiAgICAgICAgdGhpcy4jZnVsbFR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNlbmNvZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsaW5rcy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIHBhcmVudHMuc2V0KHR5cGUsIFtdKTtcbiAgICAgICAgICAgIHN1YnR5cGVzLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKCF1bmlxdWVOYW1lcy5oYXMoZmllbGQubmFtZSksIGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IChmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKSlbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoYmFzZVR5cGUgIT09IG5hbWUsIGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShwYXJlbnRzLmhhcyhiYXNlVHlwZSksIGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzLmdldChiYXNlVHlwZSkucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5nZXQobmFtZSkuYWRkKGJhc2VUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBBcnJheS5mcm9tKHBhcmVudHMua2V5cygpKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzLmdldChuKS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKHByaW1hcnlUeXBlcy5sZW5ndGggIT09IDAsIFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAxLCBgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcmltYXJ5VHlwZTogcHJpbWFyeVR5cGVzWzBdIH0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSghZm91bmQuaGFzKHR5cGUpLCBgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh0eXBlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbGlua3MuZ2V0KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXMuZ2V0KHN1YnR5cGUpLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgc2V0XSBvZiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLiNmdWxsVHlwZXMuc2V0KG5hbWUsIGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnRoZSBlbmNvZGVyIGZvciB0aGUgc3BlY2lmaWMgJSV0eXBlJSUuXG4gICAgICovXG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy4jZW5jb2RlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy4jZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuI2VuY29kZXJDYWNoZS5zZXQodHlwZSwgZW5jb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgICNnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSghbWF0Y2hbM10gfHwgcGFyc2VJbnQobWF0Y2hbM10pID09PSB2YWx1ZS5sZW5ndGgsIGBhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAke3BhcnNlSW50KG1hdGNoWzNdKX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNmdWxsVHlwZXMuaGFzKHN1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoaW5kZXhfanNfMi5rZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfNC5jb25jYXQpKHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSAoMCwgaWRfanNfMS5pZCkodGhpcy4jZnVsbFR5cGVzLmdldCh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2Z1bGxUeXBlcy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmNvbmNhdCkodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBmdWxsIHR5cGUgZm9yICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNmdWxsVHlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkocmVzdWx0LCBgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgZW5jb2RlZCAlJXZhbHVlJSUgZm9yIHRoZSAlJXR5cGUlJS5cbiAgICAgKi9cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgaGFzaCBvZiAlJXZhbHVlJSUgZm9yIHRoZSB0eXBlIG9mICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGxlZCBlbmNvZGVkICUldmFsdWUlJSBmb3IgdGhlIFtbdHlwZXNdXS5cbiAgICAgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGhhc2ggb2YgdGhlIGZ1bGx5IGVuY29kZWQgJSV2YWx1ZSUlIGZvciB0aGUgW1t0eXBlc11dLlxuICAgICAqL1xuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoIW1hdGNoWzNdIHx8IHBhcnNlSW50KG1hdGNoWzNdKSA9PT0gdmFsdWUubGVuZ3RoLCBgYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHtwYXJzZUludChtYXRjaFszXSl9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChtYXRjaFsxXSwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ2FsbCAlJWNhbGJhY2slJSBmb3IgZWFjaCB2YWx1ZSBpbiAlJXZhbHVlJSUsIHBhc3NpbmcgdGhlIHR5cGUgYW5kXG4gICAgICogIGNvbXBvbmVudCB3aXRoaW4gJSV2YWx1ZSUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgdXNlZnVsIGZvciByZXBsYWNpbmcgYWRkcmVzc2VzIG9yIG90aGVyIHRyYW5zZm9ybWF0aW9uIHRoYXRcbiAgICAgKiAgbWF5IGJlIGRlc2lyZWQgb24gZWFjaCBjb21wb25lbnQsIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgICAqL1xuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlR5cGVkRGF0YUVuY29kZXIqKiBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIHByaW1hcnkgdHlwZSBmb3IgJSV0eXBlcyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgaGFzaGVkIHN0cnVjdCBmb3IgJSV2YWx1ZSUlIHVzaW5nICUldHlwZXMlJSBhbmQgJSVuYW1lJSUuXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBkb21haW4gaGFzaCBmb3IgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5bbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZSwgYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwiZG9tYWluXCIsIGRvbWFpbik7XG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGZ1bGx5IGVuY29kZWQgW1tsaW5rLWVpcC03MTJdXSAlJXZhbHVlJSUgZm9yICUldHlwZXMlJSB3aXRoICUlZG9tYWluJSUuXG4gICAgICovXG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuY29uY2F0KShbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBoYXNoIG9mIHRoZSBmdWxseSBlbmNvZGVkIFtbbGluay1laXAtNzEyXV0gJSV2YWx1ZSUlIGZvciAlJXR5cGVzJSUgd2l0aCAlJWRvbWFpbiUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0byB0aGUgdmFsdWUgZnJvbSByZXNvbHZpbmcgYWxsIGFkZHJlc3NlcyBpbiAlJXZhbHVlJSUgZm9yXG4gICAgICogJSV0eXBlcyUlIGFuZCB0aGUgJSVkb21haW4lJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgZG9tYWluKTtcbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBudWxsIHRvIGlnbm9yZSB2YWx1ZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGlmIChkb21haW5ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICEoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0gPSBcIjB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmICEoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IGF3YWl0IHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgSlNPTi1lbmNvZGVkIHBheWxvYWQgZXhwZWN0ZWQgYnkgbm9kZXMgd2hpY2ggaW1wbGVtZW50XG4gICAgICogIHRoZSBKU09OLVJQQyBbW2xpbmstZWlwLTcxMl1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZXMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9PSBudWxsLCBcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc180LmhleGxpZnkpKCgwLCBpbmRleF9qc180LmdldEJ5dGVzKSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuZ2V0QmlnSW50KSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwiaW52YWxpZCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZERhdGFFbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlcjtcbi8qKlxuICogIENvbXB1dGUgdGhlIGFkZHJlc3MgdXNlZCB0byBzaWduIHRoZSB0eXBlZCBkYXRhIGZvciB0aGUgJSVzaWduYXR1cmUlJS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMucmVjb3ZlckFkZHJlc3MpKFR5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG5leHBvcnRzLnZlcmlmeVR5cGVkRGF0YSA9IHZlcmlmeVR5cGVkRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmVyaWZ5VHlwZWREYXRhIiwiVHlwZWREYXRhRW5jb2RlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJpbmRleF9qc180IiwiaWRfanNfMSIsInBhZGRpbmciLCJVaW50OEFycmF5IiwiZmlsbCIsIkJOX18xIiwiQmlnSW50IiwiQk5fMCIsIkJOXzEiLCJCTl9NQVhfVUlOVDI1NiIsImhleFBhZFJpZ2h0IiwiYnl0ZXMiLCJnZXRCeXRlcyIsInBhZE9mZnNldCIsImxlbmd0aCIsImNvbmNhdCIsInNsaWNlIiwiaGV4bGlmeSIsImhleFRydWUiLCJ0b0JlSGV4IiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsInZlcnNpb24iLCJjaGFpbklkIiwidmVyaWZ5aW5nQ29udHJhY3QiLCJzYWx0IiwiZG9tYWluRmllbGROYW1lcyIsImNoZWNrU3RyaW5nIiwia2V5IiwiYXNzZXJ0QXJndW1lbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiZG9tYWluQ2hlY2tzIiwiX3ZhbHVlIiwiZ2V0QmlnSW50IiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsInRvUXVhbnRpdHkiLCJnZXRBZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJlcnJvciIsImdldEJhc2VFbmNvZGVyIiwidHlwZSIsIm1hdGNoIiwic2lnbmVkIiwid2lkdGgiLCJwYXJzZUludCIsIlN0cmluZyIsImJvdW5kc1VwcGVyIiwibWFzayIsImJvdW5kc0xvd2VyIiwidG9Ud29zIiwiemVyb1BhZFZhbHVlIiwia2VjY2FrMjU2IiwiaWQiLCJlbmNvZGVUeXBlIiwiZmllbGRzIiwibWFwIiwiam9pbiIsInR5cGVzIiwicGFyc2UiLCJmdWxsVHlwZXMiLCJlbmNvZGVyQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIk1hcCIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwia2V5cyIsImZvckVhY2giLCJzZXQiLCJTZXQiLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiaGFzIiwiYWRkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwiZ2V0IiwicHVzaCIsInByaW1hcnlUeXBlcyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIm4iLCJ0IiwiZGVmaW5lUHJvcGVydGllcyIsInByaW1hcnlUeXBlIiwiY2hlY2tDaXJjdWxhciIsImZvdW5kIiwiY2hpbGQiLCJzdWJ0eXBlIiwiZGVsZXRlIiwic3QiLCJzb3J0IiwiZ2V0RW5jb2RlciIsInN1YkVuY29kZXIiLCJyZXN1bHQiLCJlbmNvZGVkVHlwZSIsInZhbHVlcyIsInVuc2hpZnQiLCJlbmNvZGVEYXRhIiwiaGFzaFN0cnVjdCIsImVuY29kZSIsImhhc2giLCJfdmlzaXQiLCJjYWxsYmFjayIsInYiLCJyZWR1Y2UiLCJhY2N1bSIsInZpc2l0IiwiZ2V0UHJpbWFyeVR5cGUiLCJoYXNoRG9tYWluIiwiZG9tYWluIiwiZG9tYWluRmllbGRzIiwiYSIsImIiLCJpbmRleE9mIiwiRUlQNzEyRG9tYWluIiwicmVzb2x2ZU5hbWVzIiwicmVzb2x2ZU5hbWUiLCJhc3NpZ24iLCJlbnNDYWNoZSIsImlzSGV4U3RyaW5nIiwiZ2V0UGF5bG9hZCIsImRvbWFpblZhbHVlcyIsImRvbWFpblR5cGVzIiwidHlwZXNXaXRoRG9tYWluIiwibWVzc2FnZSIsInRvU3RyaW5nIiwic2lnbmF0dXJlIiwicmVjb3ZlckFkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/hash/typed-data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ethers = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\");\n/**\n *  The Application Programming Interface (API) is the collection of\n *  functions, classes and types offered by the Ethers library.\n *\n *  @_section: api:Application Programming Interface  [about-api]\n *  @_navTitle: API\n */ const ethers = tslib_1.__importStar(__webpack_require__(/*! ./ethers.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/ethers.js\"));\nexports.ethers = ethers;\ntslib_1.__exportStar(__webpack_require__(/*! ./ethers.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/ethers.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsVUFBVUMsbUJBQU9BLENBQUMsMEVBQU87QUFDL0I7Ozs7OztDQU1DLEdBQ0QsTUFBTUYsU0FBU0MsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyx1RUFBYTtBQUN6REosY0FBYyxHQUFHRTtBQUNqQkMsUUFBUUcsWUFBWSxDQUFDRixtQkFBT0EsQ0FBQyx1RUFBYSxHQUFHSixVQUM3QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9pbmRleC5qcz8yNTNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ldGhlcnMgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyoqXG4gKiAgVGhlIEFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAoQVBJKSBpcyB0aGUgY29sbGVjdGlvbiBvZlxuICogIGZ1bmN0aW9ucywgY2xhc3NlcyBhbmQgdHlwZXMgb2ZmZXJlZCBieSB0aGUgRXRoZXJzIGxpYnJhcnkuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpOkFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAgW2Fib3V0LWFwaV1cbiAqICBAX25hdlRpdGxlOiBBUElcbiAqL1xuY29uc3QgZXRoZXJzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZXRoZXJzLmpzXCIpKTtcbmV4cG9ydHMuZXRoZXJzID0gZXRoZXJzO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXRoZXJzLmpzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV0aGVycyIsInRzbGliXzEiLCJyZXF1aXJlIiwiX19pbXBvcnRTdGFyIiwiX19leHBvcnRTdGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/abstract-provider.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AbstractProvider = exports.UnmanagedSubscriber = void 0;\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../contract/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_6 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\");\nconst format_js_1 = __webpack_require__(/*! ./format.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/format.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\n// Constants\nconst BN_2 = BigInt(2);\nconst MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n    return prefix + \":\" + JSON.stringify(value, (k, v)=>{\n        if (v == null) {\n            return \"null\";\n        }\n        if (typeof v === \"bigint\") {\n            return `bigint:${v.toString()}`;\n        }\n        if (typeof v === \"string\") {\n            return v.toLowerCase();\n        }\n        // Sort object keys\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key)=>{\n                accum[key] = v[key];\n                return accum;\n            }, {});\n        }\n        return v;\n    });\n}\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */ class UnmanagedSubscriber {\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */ constructor(name){\n        (0, index_js_6.defineProperties)(this, {\n            name\n        });\n    }\n    start() {}\n    stop() {}\n    pause(dropWhilePaused) {}\n    resume() {}\n}\nexports.UnmanagedSubscriber = UnmanagedSubscriber;\nfunction copy(value) {\n    return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n    items = Array.from(new Set(items).values());\n    items.sort();\n    return items;\n}\nasync function getSubscription(_event, provider) {\n    if (_event == null) {\n        throw new Error(\"invalid event\");\n    }\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) {\n        _event = {\n            topics: _event\n        };\n    }\n    if (typeof _event === \"string\") {\n        switch(_event){\n            case \"block\":\n            case \"pending\":\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                {\n                    return {\n                        type: _event,\n                        tag: _event\n                    };\n                }\n        }\n    }\n    if ((0, index_js_6.isHexString)(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n                hash\n            }),\n            hash\n        };\n    }\n    if (_event.orphan) {\n        const event = _event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n        };\n    }\n    if (_event.address || _event.topics) {\n        const event = _event;\n        const filter = {\n            topics: (event.topics || []).map((t)=>{\n                if (t == null) {\n                    return null;\n                }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t)=>t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            })\n        };\n        if (event.address) {\n            const addresses = [];\n            const promises = [];\n            const addAddress = (addr)=>{\n                if ((0, index_js_6.isHexString)(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async ()=>{\n                        addresses.push(await (0, index_js_1.resolveAddress)(addr, provider));\n                    })());\n                }\n            };\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) {\n                await Promise.all(promises);\n            }\n            filter.address = concisify(addresses.map((a)=>a.toLowerCase()));\n        }\n        return {\n            filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n        };\n    }\n    (0, index_js_6.assertArgument)(false, \"unknown ProviderEvent\", \"event\", _event);\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */ class AbstractProvider {\n    #subs;\n    #plugins;\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState;\n    #destroyed;\n    #networkPromise;\n    #anyNetwork;\n    #performCache;\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber;\n    #nextTimer;\n    #timers;\n    #disableCcipRead;\n    #options;\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */ constructor(_network, options){\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = network_js_1.Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(()=>{\n                this.emit(\"network\", network, null);\n            }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n        this.#lastBlockNumber = -1;\n        this.#performCache = new Map();\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n        this.#destroyed = false;\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n        this.#disableCcipRead = false;\n    }\n    get pollingInterval() {\n        return this.#options.pollingInterval;\n    }\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */ get provider() {\n        return this;\n    }\n    /**\n     *  Returns all the registered plug-ins.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new plug-in.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.connect(this));\n        return this;\n    }\n    /**\n     *  Get a plugin by name.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */ get disableCcipRead() {\n        return this.#disableCcipRead;\n    }\n    set disableCcipRead(value) {\n        this.#disableCcipRead = !!value;\n    }\n    // Shares multiple identical requests made during the same 250ms\n    async #perform(req) {\n        const timeout = this.#options.cacheTimeout;\n        // Caching disabled\n        if (timeout < 0) {\n            return await this._perform(req);\n        }\n        // Create a tag\n        const tag = getTag(req.method, req);\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n            setTimeout(()=>{\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n        return await perform;\n    }\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */ async ccipReadFetch(tx, calldata, urls) {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\n            return null;\n        }\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n        const errorMessages = [];\n        for(let i = 0; i < urls.length; i++){\n            const url = urls[i];\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new index_js_6.FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                    data,\n                    sender\n                };\n            }\n            this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request,\n                index: i,\n                urls\n            });\n            let errorMessage = \"unknown error\";\n            const resp = await request.send();\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadFetchResult\",\n                        request,\n                        result\n                    });\n                    return result.data;\n                }\n                if (result.message) {\n                    errorMessage = result.message;\n                }\n                this.emit(\"debug\", {\n                    action: \"receiveCcipReadFetchError\",\n                    request,\n                    result\n                });\n            } catch (error) {}\n            // 4xx indicates the result is not present; stop\n            (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                    url,\n                    errorMessage\n                }\n            });\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n        (0, index_js_6.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx,\n            info: {\n                urls,\n                errorMessages\n            }\n        });\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */ _wrapBlock(value, network) {\n        return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */ _wrapLog(value, network) {\n        return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */ _wrapTransactionReceipt(value, network) {\n        return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);\n    }\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */ _wrapTransactionResponse(tx, network) {\n        return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);\n    }\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */ _detectNetwork() {\n        (0, index_js_6.assert)(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */ async _perform(req) {\n        (0, index_js_6.assert)(false, `unsupported method: ${req.method}`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n    // State\n    async getBlockNumber() {\n        const blockNumber = (0, index_js_6.getNumber)(await this.#perform({\n            method: \"getBlockNumber\"\n        }), \"%response\");\n        if (this.#lastBlockNumber >= 0) {\n            this.#lastBlockNumber = blockNumber;\n        }\n        return blockNumber;\n    }\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */ _getAddress(address) {\n        return (0, index_js_1.resolveAddress)(address, this);\n    }\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */ _getBlockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if ((0, index_js_6.isHexString)(blockTag)) {\n            if ((0, index_js_6.isHexString)(blockTag, 32)) {\n                return blockTag;\n            }\n            return (0, index_js_6.toQuantity)(blockTag);\n        }\n        if (typeof blockTag === \"bigint\") {\n            blockTag = (0, index_js_6.getNumber)(blockTag, \"blockTag\");\n        }\n        if (typeof blockTag === \"number\") {\n            if (blockTag >= 0) {\n                return (0, index_js_6.toQuantity)(blockTag);\n            }\n            if (this.#lastBlockNumber >= 0) {\n                return (0, index_js_6.toQuantity)(this.#lastBlockNumber + blockTag);\n            }\n            return this.getBlockNumber().then((b)=>(0, index_js_6.toQuantity)(b + blockTag));\n        }\n        (0, index_js_6.assertArgument)(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */ _getFilter(filter) {\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || []).map((t)=>{\n            if (t == null) {\n                return null;\n            }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t)=>t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n        const resolve = (_address, fromBlock, toBlock)=>{\n            let address = undefined;\n            switch(_address.length){\n                case 0:\n                    break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n            const filter = {};\n            if (address) {\n                filter.address = address;\n            }\n            if (topics.length) {\n                filter.topics = topics;\n            }\n            if (fromBlock) {\n                filter.fromBlock = fromBlock;\n            }\n            if (toBlock) {\n                filter.toBlock = toBlock;\n            }\n            if (blockHash) {\n                filter.blockHash = blockHash;\n            }\n            return filter;\n        };\n        // Addresses could be async (ENS names or Addressables)\n        let address = [];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address){\n                    address.push(this._getAddress(addr));\n                }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n        let fromBlock = undefined;\n        if (\"fromBlock\" in filter) {\n            fromBlock = this._getBlockTag(filter.fromBlock);\n        }\n        let toBlock = undefined;\n        if (\"toBlock\" in filter) {\n            toBlock = this._getBlockTag(filter.toBlock);\n        }\n        if (address.filter((a)=>typeof a !== \"string\").length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n            return Promise.all([\n                Promise.all(address),\n                fromBlock,\n                toBlock\n            ]).then((result)=>{\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n        return resolve(address, fromBlock, toBlock);\n    }\n    /**\n     *  Returns or resovles to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */ _getTransactionRequest(_request) {\n        const request = (0, provider_js_1.copyRequest)(_request);\n        const promises = [];\n        [\n            \"to\",\n            \"from\"\n        ].forEach((key)=>{\n            if (request[key] == null) {\n                return;\n            }\n            const addr = (0, index_js_1.resolveAddress)(request[key], this);\n            if (isPromise(addr)) {\n                promises.push(async function() {\n                    request[key] = await addr;\n                }());\n            } else {\n                request[key] = addr;\n            }\n        });\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push(async function() {\n                    request.blockTag = await blockTag;\n                }());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n        if (promises.length) {\n            return async function() {\n                await Promise.all(promises);\n                return request;\n            }();\n        }\n        return request;\n    }\n    async getNetwork() {\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n            // Detect the current network (shared with all calls)\n            const detectNetwork = this._detectNetwork().then((network)=>{\n                this.emit(\"network\", network, null);\n                return network;\n            }, (error)=>{\n                // Reset the networkPromise on failure, so we will try again\n                if (this.#networkPromise === detectNetwork) {\n                    this.#networkPromise = null;\n                }\n                throw error;\n            });\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n        const networkPromise = this.#networkPromise;\n        const [expected, actual] = await Promise.all([\n            networkPromise,\n            this._detectNetwork() // The actual connected network\n        ]);\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                (0, index_js_6.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n        return expected.clone();\n    }\n    async getFeeData() {\n        const network = await this.getNetwork();\n        const getFeeDataFunc = async ()=>{\n            const { _block, gasPrice } = await (0, index_js_6.resolveProperties)({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: (async ()=>{\n                    try {\n                        const gasPrice = await this.#perform({\n                            method: \"getGasPrice\"\n                        });\n                        return (0, index_js_6.getBigInt)(gasPrice, \"%response\");\n                    } catch (error) {}\n                    return null;\n                })()\n            });\n            let maxFeePerGas = null;\n            let maxPriorityFeePerGas = null;\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = BigInt(\"1000000000\");\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n            }\n            return new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new index_js_6.FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n        return await getFeeDataFunc();\n    }\n    async estimateGas(_tx) {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) {\n            tx = await tx;\n        }\n        return (0, index_js_6.getBigInt)(await this.#perform({\n            method: \"estimateGas\",\n            transaction: tx\n        }), \"%response\");\n    }\n    async #call(tx, blockTag, attempt) {\n        (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n                blockTag,\n                enableCcipRead: true\n            })\n        });\n        // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n        const transaction = (0, provider_js_1.copyRequest)(tx);\n        try {\n            return (0, index_js_6.hexlify)(await this._perform({\n                method: \"call\",\n                transaction,\n                blockTag\n            }));\n        } catch (error) {\n            // CCIP Read OffchainLookup\n            if (!this.disableCcipRead && (0, index_js_6.isCallException)(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && (0, index_js_6.dataSlice)(error.data, 0, 4) === \"0x556f1830\") {\n                const data = error.data;\n                const txSender = await (0, index_js_1.resolveAddress)(transaction.to, this);\n                // Parse the CCIP Read Arguments\n                let ccipArgs;\n                try {\n                    ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(error.data, 4));\n                } catch (error) {\n                    (0, index_js_6.assert)(false, error.message, \"OFFCHAIN_FAULT\", {\n                        reason: \"BAD_DATA\",\n                        transaction,\n                        info: {\n                            data\n                        }\n                    });\n                }\n                // Check the sender of the OffchainLookup matches the transaction\n                (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                    action: \"call\",\n                    data,\n                    reason: \"OffchainLookup\",\n                    transaction: transaction,\n                    invocation: null,\n                    revert: {\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        name: \"OffchainLookup\",\n                        args: ccipArgs.errorArgs\n                    }\n                });\n                const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                (0, index_js_6.assert)(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                    reason: \"FETCH_FAILED\",\n                    transaction,\n                    info: {\n                        data: error.data,\n                        errorArgs: ccipArgs.errorArgs\n                    }\n                });\n                const tx = {\n                    to: txSender,\n                    data: (0, index_js_6.concat)([\n                        ccipArgs.selector,\n                        encodeBytes([\n                            ccipResult,\n                            ccipArgs.extraData\n                        ])\n                    ])\n                };\n                this.emit(\"debug\", {\n                    action: \"sendCcipReadCall\",\n                    transaction: tx\n                });\n                try {\n                    const result = await this.#call(tx, blockTag, attempt + 1);\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallResult\",\n                        transaction: Object.assign({}, tx),\n                        result\n                    });\n                    return result;\n                } catch (error) {\n                    this.emit(\"debug\", {\n                        action: \"receiveCcipReadCallError\",\n                        transaction: Object.assign({}, tx),\n                        error\n                    });\n                    throw error;\n                }\n            }\n            throw error;\n        }\n    }\n    async #checkNetwork(promise) {\n        const { value } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n    async call(_tx) {\n        const { tx, blockTag } = await (0, index_js_6.resolveProperties)({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n    }\n    // Account\n    async #getAccountValue(request, _address, _blockTag) {\n        let address = this._getAddress(_address);\n        let blockTag = this._getBlockTag(_blockTag);\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\n            [address, blockTag] = await Promise.all([\n                address,\n                blockTag\n            ]);\n        }\n        return await this.#checkNetwork(this.#perform(Object.assign(request, {\n            address,\n            blockTag\n        })));\n    }\n    async getBalance(address, blockTag) {\n        return (0, index_js_6.getBigInt)(await this.#getAccountValue({\n            method: \"getBalance\"\n        }, address, blockTag), \"%response\");\n    }\n    async getTransactionCount(address, blockTag) {\n        return (0, index_js_6.getNumber)(await this.#getAccountValue({\n            method: \"getTransactionCount\"\n        }, address, blockTag), \"%response\");\n    }\n    async getCode(address, blockTag) {\n        return (0, index_js_6.hexlify)(await this.#getAccountValue({\n            method: \"getCode\"\n        }, address, blockTag));\n    }\n    async getStorage(address, _position, blockTag) {\n        const position = (0, index_js_6.getBigInt)(_position, \"position\");\n        return (0, index_js_6.hexlify)(await this.#getAccountValue({\n            method: \"getStorage\",\n            position\n        }, address, blockTag));\n    }\n    // Write\n    async broadcastTransaction(signedTx) {\n        const { blockNumber, hash, network } = await (0, index_js_6.resolveProperties)({\n            blockNumber: this.getBlockNumber(),\n            hash: this._perform({\n                method: \"broadcastTransaction\",\n                signedTransaction: signedTx\n            }),\n            network: this.getNetwork()\n        });\n        const tx = index_js_5.Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);\n    }\n    async #getBlock(block, includeTransactions) {\n        // @TODO: Add CustomBlockPlugin check\n        if ((0, index_js_6.isHexString)(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\",\n                blockHash: block,\n                includeTransactions\n            });\n        }\n        let blockTag = this._getBlockTag(block);\n        if (typeof blockTag !== \"string\") {\n            blockTag = await blockTag;\n        }\n        return await this.#perform({\n            method: \"getBlock\",\n            blockTag,\n            includeTransactions\n        });\n    }\n    // Queries\n    async getBlock(block, prefetchTxs) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapBlock(params, network);\n    }\n    async getTransaction(hash) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransaction\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        return this._wrapTransactionResponse(params, network);\n    }\n    async getTransactionReceipt(hash) {\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getTransactionReceipt\",\n                hash\n            })\n        });\n        if (params == null) {\n            return null;\n        }\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({\n                method: \"getTransaction\",\n                hash\n            });\n            if (tx == null) {\n                throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n        return this._wrapTransactionReceipt(params, network);\n    }\n    async getTransactionResult(hash) {\n        const { result } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            result: this.#perform({\n                method: \"getTransactionResult\",\n                hash\n            })\n        });\n        if (result == null) {\n            return null;\n        }\n        return (0, index_js_6.hexlify)(result);\n    }\n    // Bloom-filter Queries\n    async getLogs(_filter) {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) {\n            filter = await filter;\n        }\n        const { network, params } = await (0, index_js_6.resolveProperties)({\n            network: this.getNetwork(),\n            params: this.#perform({\n                method: \"getLogs\",\n                filter\n            })\n        });\n        return params.map((p)=>this._wrapLog(p, network));\n    }\n    // ENS\n    _getProvider(chainId) {\n        (0, index_js_6.assert)(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n    async getResolver(name) {\n        return await ens_resolver_js_1.EnsResolver.fromName(this, name);\n    }\n    async getAvatar(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAvatar();\n        }\n        return null;\n    }\n    async resolveName(name) {\n        const resolver = await this.getResolver(name);\n        if (resolver) {\n            return await resolver.getAddress();\n        }\n        return null;\n    }\n    async lookupAddress(address) {\n        address = (0, index_js_1.getAddress)(address);\n        const node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + \".addr.reverse\");\n        try {\n            const ensAddr = await ens_resolver_js_1.EnsResolver.getEnsAddress(this);\n            const ensContract = new index_js_3.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === index_js_2.ZeroAddress) {\n                return null;\n            }\n            const resolverContract = new index_js_3.Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) {\n                return null;\n            }\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if ((0, index_js_6.isError)(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n            // Something reerted\n            if ((0, index_js_6.isError)(error, \"CALL_EXCEPTION\")) {\n                return null;\n            }\n            throw error;\n        }\n        return null;\n    }\n    async waitForTransaction(hash, _confirms, timeout) {\n        const confirms = _confirms != null ? _confirms : 1;\n        if (confirms === 0) {\n            return this.getTransactionReceipt(hash);\n        }\n        return new Promise(async (resolve, reject)=>{\n            let timer = null;\n            const listener = async (blockNumber)=>{\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            };\n            if (timeout != null) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject((0, index_js_6.makeError)(\"timeout\", \"TIMEOUT\", {\n                        reason: \"timeout\"\n                    }));\n                }, timeout);\n            }\n            listener(await this.getBlockNumber());\n        });\n    }\n    async waitForBlock(blockTag) {\n        (0, index_js_6.assert)(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */ _clearTimeout(timerId) {\n        const timer = this.#timers.get(timerId);\n        if (!timer) {\n            return;\n        }\n        if (timer.timer) {\n            clearTimeout(timer.timer);\n        }\n        this.#timers.delete(timerId);\n    }\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */ _setTimeout(_func, timeout) {\n        if (timeout == null) {\n            timeout = 0;\n        }\n        const timerId = this.#nextTimer++;\n        const func = ()=>{\n            this.#timers.delete(timerId);\n            _func();\n        };\n        if (this.paused) {\n            this.#timers.set(timerId, {\n                timer: null,\n                func,\n                time: timeout\n            });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, {\n                timer,\n                func,\n                time: getTime()\n            });\n        }\n        return timerId;\n    }\n    /**\n     *  Perform %%func%% on each subscriber.\n     */ _forEachSubscriber(func) {\n        for (const sub of this.#subs.values()){\n            func(sub.subscriber);\n        }\n    }\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                {\n                    const subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);\n                    subscriber.pollingInterval = this.pollingInterval;\n                    return subscriber;\n                }\n            case \"event\":\n                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);\n        }\n        throw new Error(`unsupported event: ${sub.type}`);\n    }\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */ _recoverSubscriber(oldSub, newSub) {\n        for (const sub of this.#subs.values()){\n            if (sub.subscriber === oldSub) {\n                if (sub.started) {\n                    sub.subscriber.stop();\n                }\n                sub.subscriber = newSub;\n                if (sub.started) {\n                    newSub.start();\n                }\n                if (this.#pausedState != null) {\n                    newSub.pause(this.#pausedState);\n                }\n                break;\n            }\n        }\n    }\n    async #hasSub(event, emitArgs) {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({\n                orphan: \"drop-log\",\n                log: emitArgs[0]\n            }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n    async #getSub(event) {\n        const subscription = await getSubscription(event, this);\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = {\n                subscriber,\n                tag,\n                addressableMap,\n                nameMap,\n                started: false,\n                listeners: []\n            };\n            this.#subs.set(tag, sub);\n        }\n        return sub;\n    }\n    async on(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: false\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async once(event, listener) {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({\n            listener,\n            once: true\n        });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) {\n                sub.subscriber.pause(this.#pausedState);\n            }\n        }\n        return this;\n    }\n    async emit(event, ...args) {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) {\n            return false;\n        }\n        ;\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once })=>{\n            const payload = new index_js_6.EventPayload(this, once ? null : listener, event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch (error) {}\n            return !once;\n        });\n        if (sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return count > 0;\n    }\n    async listenerCount(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        let total = 0;\n        for (const { listeners } of this.#subs.values()){\n            total += listeners.length;\n        }\n        return total;\n    }\n    async listeners(event) {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener })=>listener);\n        }\n        let result = [];\n        for (const { listeners } of this.#subs.values()){\n            result = result.concat(listeners.map(({ listener })=>listener));\n        }\n        return result;\n    }\n    async off(event, listener) {\n        const sub = await this.#hasSub(event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener })=>listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) {\n                sub.subscriber.stop();\n            }\n            this.#subs.delete(sub.tag);\n        }\n        return this;\n    }\n    async removeAllListeners(event) {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) {\n                subscriber.stop();\n            }\n            this.#subs.delete(tag);\n        } else {\n            for (const [tag, { started, subscriber }] of this.#subs){\n                if (started) {\n                    subscriber.stop();\n                }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    // Alias for \"on\"\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    // Alias for \"off\"\n    async removeListener(event, listener) {\n        return this.off(event, listener);\n    }\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */ get destroyed() {\n        return this.#destroyed;\n    }\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */ destroy() {\n        // Stop all listeners\n        this.removeAllListeners();\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()){\n            this._clearTimeout(timerId);\n        }\n        this.#destroyed = true;\n    }\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */ get paused() {\n        return this.#pausedState != null;\n    }\n    set paused(pause) {\n        if (!!pause === this.paused) {\n            return;\n        }\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */ pause(dropWhilePaused) {\n        this.#lastBlockNumber = -1;\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) {\n                return;\n            }\n            (0, index_js_6.assert)(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n        this._forEachSubscriber((s)=>s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n        for (const timer of this.#timers.values()){\n            // Clear the timer\n            if (timer.timer) {\n                clearTimeout(timer.timer);\n            }\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n    /**\n     *  Resume the provider.\n     */ resume() {\n        if (this.#pausedState == null) {\n            return;\n        }\n        this._forEachSubscriber((s)=>s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()){\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\nexports.AbstractProvider = AbstractProvider;\nfunction _parseString(result, start) {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) {\n            return (0, index_js_6.toUtf8String)(bytes);\n        }\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    try {\n        const offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));\n        const length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));\n        return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);\n    } catch (error) {}\n    return null;\n}\nfunction numPad(value) {\n    const result = (0, index_js_6.toBeArray)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\nconst empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(empty);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0, index_js_6.getBytes)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0, index_js_6.concat)(result);\n}\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n    const result = {\n        sender: \"\",\n        urls: [],\n        calldata: \"\",\n        selector: \"\",\n        extraData: \"\",\n        errorArgs: []\n    };\n    (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n    const sender = (0, index_js_6.dataSlice)(data, 0, 32);\n    (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = (0, index_js_6.dataSlice)(sender, 12);\n    // Read the URLs from the response\n    try {\n        const urls = [];\n        const urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));\n        const urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));\n        const urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);\n        for(let u = 0; u < urlsLength; u++){\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) {\n                throw new Error(\"abort\");\n            }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) {\n            throw new Error(\"abort\");\n        }\n        result.calldata = calldata;\n    } catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n    // Get the callbackSelector (bytes4)\n    (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = (0, index_js_6.dataSlice)(data, 96, 100);\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) {\n            throw new Error(\"abort\");\n        }\n        result.extraData = extraData;\n    } catch (error) {\n        (0, index_js_6.assert)(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k)=>result[k]);\n    return result;\n} //# sourceMappingURL=abstract-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7O0NBTUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQzlELFFBQVE7QUFDUixvQkFBb0I7QUFDcEIsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSw2RUFBNkU7QUFDN0UsNkVBQTZFO0FBQzdFLDJFQUEyRTtBQUMzRSxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEZBQXVCO0FBQ2xELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLHdGQUFzQjtBQUNqRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyxnRkFBa0I7QUFDN0MsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNTSxvQkFBb0JOLG1CQUFPQSxDQUFDLDZGQUFtQjtBQUNyRCxNQUFNTyxjQUFjUCxtQkFBT0EsQ0FBQyxpRkFBYTtBQUN6QyxNQUFNUSxlQUFlUixtQkFBT0EsQ0FBQyxtRkFBYztBQUMzQyxNQUFNUyxnQkFBZ0JULG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDLE1BQU1VLDBCQUEwQlYsbUJBQU9BLENBQUMseUdBQXlCO0FBQ2pFLFlBQVk7QUFDWixNQUFNVyxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLHFCQUFxQjtBQUMzQixTQUFTQyxVQUFVbEIsS0FBSztJQUNwQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1tQixJQUFJLEtBQU07QUFDN0M7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVyQixLQUFLO0lBQ3pCLE9BQU9xQixTQUFTLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ3ZCLE9B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SyxNQUFNO1FBQ3BCO1FBQ0FrRixPQUFPa0YsU0FBUyxHQUFHQTtJQUN2QixFQUNBLE9BQU8vRSxPQUFPO1FBQ1QsSUFBR2pJLFdBQVdrSSxNQUFNLEVBQUUsT0FBTyxvQ0FBb0Msa0JBQWtCO1lBQ2hGRSxRQUFRO1FBQ1o7SUFDSjtJQUNBTixPQUFPNkUsU0FBUyxHQUFHLDBDQUEwQytILEtBQUssQ0FBQyxLQUFLcFIsR0FBRyxDQUFDLENBQUN2QyxJQUFNK0csTUFBTSxDQUFDL0csRUFBRTtJQUM1RixPQUFPK0c7QUFDWCxFQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlci5qcz81N2NkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgVGhlIGF2YWlsYWJsZSBwcm92aWRlcnMgc2hvdWxkIHN1ZmZpY2UgZm9yIG1vc3QgZGV2ZWxvcGVycyBwdXJwb3NlcyxcbiAqICBidXQgdGhlIFtbQWJzdHJhY3RQcm92aWRlcl1dIGNsYXNzIGhhcyBtYW55IGZlYXR1cmVzIHdoaWNoIGVuYWJsZVxuICogIHN1Yi1jbGFzc2luZyBpdCBmb3Igc3BlY2lmaWMgcHVycG9zZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlcjogU3ViY2xhc3NpbmcgUHJvdmlkZXIgIFthYnN0cmFjdC1wcm92aWRlcl1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdFByb3ZpZGVyID0gZXhwb3J0cy5Vbm1hbmFnZWRTdWJzY3JpYmVyID0gdm9pZCAwO1xuLy8gQFRPRE9cbi8vIEV2ZW50IGNvYWxlc2NlbmNlXG4vLyAgIFdoZW4gd2UgcmVnaXN0ZXIgYW4gZXZlbnQgd2l0aCBhbiBhc3luYyB2YWx1ZSAoZS5nLiBhZGRyZXNzIGlzIGEgU2lnbmVyXG4vLyAgIG9yIEVOUyBuYW1lKSwgd2UgbmVlZCB0byBhZGQgaXQgaW1tZWlkYXRlbHkgZm9yIHRoZSBFdmVudCBBUEksIGJ1dCBhbHNvXG4vLyAgIG5lZWQgdGltZSB0byByZXNvbHZlIHRoZSBhZGRyZXNzLiBVcG9uIHJlc29sdmluZyB0aGUgYWRkcmVzcywgd2UgbmVlZCB0b1xuLy8gICBtaWdyYXRlIHRoZSBsaXN0ZW5lciB0byB0aGUgc3RhdGljIGV2ZW50LiBXZSBhbHNvIG5lZWQgdG8gbWFpbnRhaW4gYSBtYXBcbi8vICAgb2YgU2lnbmVyL0VOUyBuYW1lIHRvIGFkZHJlc3Mgc28gd2UgY2FuIHN5bmMgcmVzcG9uZCB0byBsaXN0ZW5lckNvdW50LlxuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzYgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBlbnNfcmVzb2x2ZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Vucy1yZXNvbHZlci5qc1wiKTtcbmNvbnN0IGZvcm1hdF9qc18xID0gcmVxdWlyZShcIi4vZm9ybWF0LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci5qc1wiKTtcbmNvbnN0IHN1YnNjcmliZXJfcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCIpO1xuLy8gQ29uc3RhbnRzXG5jb25zdCBCTl8yID0gQmlnSW50KDIpO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBnZXRUYWcocHJlZml4LCB2YWx1ZSkge1xuICAgIHJldHVybiBwcmVmaXggKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoaywgdikgPT4ge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgYmlnaW50OiR7di50b1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydCBvYmplY3Qga2V5c1xuICAgICAgICBpZiAodHlwZW9mICh2KSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHYpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtrZXldID0gdltrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9KTtcbn1cbi8qKlxuICogIEFuICoqVW5tYW5hZ2VkU3Vic2NyaWJlcioqIGlzIHVzZWZ1bCBmb3IgZXZlbnRzIHdoaWNoIGRvIG5vdCByZXF1aXJlXG4gKiAgYW55IGFkZGl0aW9uYWwgbWFuYWdlbWVudCwgc3VjaCBhcyBgYFwiZGVidWdcImBgIHdoaWNoIG9ubHkgcmVxdWlyZXNcbiAqICBlbWl0IGluIHN5bmNocm9ub3VzIGV2ZW50IGxvb3AgdHJpZ2dlcmVkIGNhbGxzLlxuICovXG5jbGFzcyBVbm1hbmFnZWRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgZm9mIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgVW5tYW5hZ2VkU3Vic2NyaWJlciB3aXRoICUlbmFtZSUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsgKDAsIGluZGV4X2pzXzYuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lIH0pOyB9XG4gICAgc3RhcnQoKSB7IH1cbiAgICBzdG9wKCkgeyB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7IH1cbiAgICByZXN1bWUoKSB7IH1cbn1cbmV4cG9ydHMuVW5tYW5hZ2VkU3Vic2NyaWJlciA9IFVubWFuYWdlZFN1YnNjcmliZXI7XG5mdW5jdGlvbiBjb3B5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGNvbmNpc2lmeShpdGVtcykge1xuICAgIGl0ZW1zID0gQXJyYXkuZnJvbSgobmV3IFNldChpdGVtcykpLnZhbHVlcygpKTtcbiAgICBpdGVtcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uKF9ldmVudCwgcHJvdmlkZXIpIHtcbiAgICBpZiAoX2V2ZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudFwiKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHRvcGljIGFycmF5IGluZm8gYW4gRXZlbnRGaWx0ZXJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShfZXZlbnQpKSB7XG4gICAgICAgIF9ldmVudCA9IHsgdG9waWNzOiBfZXZlbnQgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoX2V2ZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzd2l0Y2ggKF9ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBfZXZlbnQsIHRhZzogX2V2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShfZXZlbnQsIDMyKSkge1xuICAgICAgICBjb25zdCBoYXNoID0gX2V2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidHJhbnNhY3Rpb25cIiwgdGFnOiBnZXRUYWcoXCJ0eFwiLCB7IGhhc2ggfSksIGhhc2ggfTtcbiAgICB9XG4gICAgaWYgKF9ldmVudC5vcnBoYW4pIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZXZlbnQ7XG4gICAgICAgIC8vIEBUT0RPOiBTaG91bGQgbG93ZXJjYXNlIGFuZCB3aGF0bm90IHRoaW5ncyBoZXJlIGluc3RlYWQgb2YgY29weS4uLlxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9ycGhhblwiLCB0YWc6IGdldFRhZyhcIm9ycGhhblwiLCBldmVudCksIGZpbHRlcjogY29weShldmVudCkgfTtcbiAgICB9XG4gICAgaWYgKChfZXZlbnQuYWRkcmVzcyB8fCBfZXZlbnQudG9waWNzKSkge1xuICAgICAgICBjb25zdCBldmVudCA9IF9ldmVudDtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgdG9waWNzOiAoKGV2ZW50LnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNpc2lmeSh0Lm1hcCgodCkgPT4gdC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV2ZW50LmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZEFkZHJlc3MgPSAoYWRkcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0hleFN0cmluZykoYWRkcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhd2FpdCAoMCwgaW5kZXhfanNfMS5yZXNvbHZlQWRkcmVzcykoYWRkciwgcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50LmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuYWRkcmVzcy5mb3JFYWNoKGFkZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkQWRkcmVzcyhldmVudC5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGNvbmNpc2lmeShhZGRyZXNzZXMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWx0ZXIsIHRhZzogZ2V0VGFnKFwiZXZlbnRcIiwgZmlsdGVyKSwgdHlwZTogXCJldmVudFwiIH07XG4gICAgfVxuICAgICgwLCBpbmRleF9qc182LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bmtub3duIFByb3ZpZGVyRXZlbnRcIiwgXCJldmVudFwiLCBfZXZlbnQpO1xufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNhY2hlVGltZW91dDogMjUwLFxuICAgIHBvbGxpbmdJbnRlcnZhbDogNDAwMFxufTtcbi8qKlxuICogIEFuICoqQWJzdHJhY3RQcm92aWRlcioqIHByb3ZpZGVzIGEgYmFzZSBjbGFzcyBmb3Igb3RoZXIgc3ViLWNsYXNzZXMgdG9cbiAqICBpbXBsZW1lbnQgdGhlIFtbUHJvdmlkZXJdXSBBUEkgYnkgbm9ybWFsaXppbmcgaW5wdXQgYXJndW1lbnRzIGFuZFxuICogIGZvcm1hdHRpbmcgb3V0cHV0IHJlc3VsdHMgYXMgd2VsbCBhcyB0cmFja2luZyBldmVudHMgZm9yIGNvbnNpc3RlbnRcbiAqICBiZWhhdmlvdXIgb24gYW4gZXZlbnR1YWxseS1jb25zaXN0ZW50IG5ldHdvcmsuXG4gKi9cbmNsYXNzIEFic3RyYWN0UHJvdmlkZXIge1xuICAgICNzdWJzO1xuICAgICNwbHVnaW5zO1xuICAgIC8vIG51bGw9dW5wYXVzZWQsIHRydWU9cGF1c2VkK2Ryb3BXaGlsZVBhdXNlZCwgZmFsc2U9cGF1c2VkXG4gICAgI3BhdXNlZFN0YXRlO1xuICAgICNkZXN0cm95ZWQ7XG4gICAgI25ldHdvcmtQcm9taXNlO1xuICAgICNhbnlOZXR3b3JrO1xuICAgICNwZXJmb3JtQ2FjaGU7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIG51bWJlciBpZiBydW5uaW5nIGFuIGV2ZW50IG9yIC0xIGlmIG5vIFwiYmxvY2tcIiBldmVudFxuICAgICNsYXN0QmxvY2tOdW1iZXI7XG4gICAgI25leHRUaW1lcjtcbiAgICAjdGltZXJzO1xuICAgICNkaXNhYmxlQ2NpcFJlYWQ7XG4gICAgI29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFic3RyYWN0UHJvdmlkZXIqKiBjb25uZWN0ZWQgdG8gJSVuZXR3b3JrJSUsIG9yXG4gICAgICogIHVzZSB0aGUgdmFyaW91cyBuZXR3b3JrIGRldGVjdGlvbiBjYXBhYmlsaXRpZXMgdG8gZGlzY292ZXIgdGhlXG4gICAgICogIFtbTmV0d29ya11dIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLiNvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICBpZiAoX25ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jbmV0d29ya1Byb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9uZXR3b3JrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgICAgICB0aGlzLiNhbnlOZXR3b3JrID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpOyB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2FueU5ldHdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNzdWJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNwYXVzZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNuZXh0VGltZXIgPSAxO1xuICAgICAgICB0aGlzLiN0aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2Rpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkgeyByZXR1cm4gdGhpcy4jb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBgYHRoaXNgYCwgdG8gYWxsb3cgYW4gKipBYnN0cmFjdFByb3ZpZGVyKiogdG8gaW1wbGVtZW50XG4gICAgICogIHRoZSBbW0NvbnRyYWN0UnVubmVyXV0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGdldCBwcm92aWRlcigpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbGwgdGhlIHJlZ2lzdGVyZWQgcGx1Zy1pbnMuXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3BsdWdpbnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQXR0YWNoIGEgbmV3IHBsdWctaW4uXG4gICAgICovXG4gICAgYXR0YWNoUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBpZiAodGhpcy4jcGx1Z2lucy5nZXQocGx1Z2luLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXBsYWNlIGV4aXN0aW5nIHBsdWdpbjogJHtwbHVnaW4ubmFtZX0gYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGx1Z2lucy5zZXQocGx1Z2luLm5hbWUsIHBsdWdpbi5jb25uZWN0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgYSBwbHVnaW4gYnkgbmFtZS5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3BsdWdpbnMuZ2V0KG5hbWUpKSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJldmVudCBhbnkgQ0NJUC1yZWFkIG9wZXJhdGlvbiwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHJlcXVlc3RlZFxuICAgICAqICBpbiBhIFtbY2FsbF1dIHVzaW5nIGBgZW5hYmxlQ2NpcFJlYWRgYC5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZUNjaXBSZWFkKCkgeyByZXR1cm4gdGhpcy4jZGlzYWJsZUNjaXBSZWFkOyB9XG4gICAgc2V0IGRpc2FibGVDY2lwUmVhZCh2YWx1ZSkgeyB0aGlzLiNkaXNhYmxlQ2NpcFJlYWQgPSAhIXZhbHVlOyB9XG4gICAgLy8gU2hhcmVzIG11bHRpcGxlIGlkZW50aWNhbCByZXF1ZXN0cyBtYWRlIGR1cmluZyB0aGUgc2FtZSAyNTBtc1xuICAgIGFzeW5jICNwZXJmb3JtKHJlcSkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy4jb3B0aW9ucy5jYWNoZVRpbWVvdXQ7XG4gICAgICAgIC8vIENhY2hpbmcgZGlzYWJsZWRcbiAgICAgICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcGVyZm9ybShyZXEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRhZ1xuICAgICAgICBjb25zdCB0YWcgPSBnZXRUYWcocmVxLm1ldGhvZCwgcmVxKTtcbiAgICAgICAgbGV0IHBlcmZvcm0gPSB0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZyk7XG4gICAgICAgIGlmICghcGVyZm9ybSkge1xuICAgICAgICAgICAgcGVyZm9ybSA9IHRoaXMuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgICAgIHRoaXMuI3BlcmZvcm1DYWNoZS5zZXQodGFnLCBwZXJmb3JtKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwZXJmb3JtQ2FjaGUuZ2V0KHRhZykgPT09IHBlcmZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcGVyZm9ybUNhY2hlLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBwZXJmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIGRhdGEgZm9yIGV4ZWN1dGluZyB0aGUgQ0NJUC1yZWFkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgYXN5bmMgY2NpcFJlYWRGZXRjaCh0eCwgY2FsbGRhdGEsIHVybHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwIHx8IHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsc1tpXTtcbiAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgIC8vIElmIG5vIHtkYXRhfSBpcyBwcmVzZW50LCB1c2UgUE9TVDsgb3RoZXJ3aXNlIEdFVFxuICAgICAgICAgICAgLy9jb25zdCBqc29uOiBzdHJpbmcgfCBudWxsID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbDogSlNPTi5zdHJpbmdpZnkoeyBkYXRhLCBzZW5kZXIgfSk7XG4gICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAvLyAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgLy8gICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfNi5GZXRjaFJlcXVlc3QoaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJ7ZGF0YX1cIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0geyBkYXRhLCBzZW5kZXIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRDY2lwUmVhZEZldGNoUmVxdWVzdFwiLCByZXF1ZXN0LCBpbmRleDogaSwgdXJscyB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcC5ib2R5SnNvbjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hSZXN1bHRcIiwgcmVxdWVzdCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkRmV0Y2hFcnJvclwiLCByZXF1ZXN0LCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gNHh4IGluZGljYXRlcyB0aGUgcmVzdWx0IGlzIG5vdCBwcmVzZW50OyBzdG9wXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKHJlc3Auc3RhdHVzQ29kZSA8IDQwMCB8fCByZXNwLnN0YXR1c0NvZGUgPj0gNTAwLCBgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHsgcmVhc29uOiBcIjQwNF9NSVNTSU5HX1JFU09VUkNFXCIsIHRyYW5zYWN0aW9uOiB0eCwgaW5mbzogeyB1cmwsIGVycm9yTWVzc2FnZSB9IH0pO1xuICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIGBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2VzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oXCIsIFwiKX1gLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCI1MDBfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGluZm86IHsgdXJscywgZXJyb3JNZXNzYWdlcyB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgYmxvY2sgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBfd3JhcEJsb2NrKHZhbHVlLCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5CbG9jaygoMCwgZm9ybWF0X2pzXzEuZm9ybWF0QmxvY2spKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSBsb2cgYmVmb3JlXG4gICAgICogIHJldHVybmluZyBpdCwgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciBhbiBhbHRlcm5hdGVcbiAgICAgKiAgc3ViLWNsYXNzIG9mIFtbTG9nXV0uXG4gICAgICovXG4gICAgX3dyYXBMb2codmFsdWUsIG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkxvZygoMCwgZm9ybWF0X2pzXzEuZm9ybWF0TG9nKSh2YWx1ZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUHJvdmlkZXMgdGhlIG9wcG9ydHVuaXR5IGZvciBhIHN1Yi1jbGFzcyB0byB3cmFwIGEgdHJhbnNhY3Rpb25cbiAgICAgKiAgcmVjZWlwdCBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlY2VpcHRdXS5cbiAgICAgKi9cbiAgICBfd3JhcFRyYW5zYWN0aW9uUmVjZWlwdCh2YWx1ZSwgbmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzXzEuVHJhbnNhY3Rpb25SZWNlaXB0KCgwLCBmb3JtYXRfanNfMS5mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQpKHZhbHVlKSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBQcm92aWRlcyB0aGUgb3Bwb3J0dW5pdHkgZm9yIGEgc3ViLWNsYXNzIHRvIHdyYXAgYSB0cmFuc2FjdGlvblxuICAgICAqICByZXNwb25zZSBiZWZvcmUgcmV0dXJuaW5nIGl0LCB0byBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG9yIGFuXG4gICAgICogIGFsdGVybmF0ZSBzdWItY2xhc3Mgb2YgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlc3BvbnNlKCgwLCBmb3JtYXRfanNfMS5mb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKSh0eCksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIE5ldHdvcmssIGZvcmNpbmcgYSBuZXR3b3JrIGRldGVjdGlvbiB1c2luZyB3aGF0ZXZlclxuICAgICAqICB0ZWNobmlxdWUgdGhlIHN1Yi1jbGFzcyByZXF1aXJlcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcInN1Yi1jbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXNcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIl9kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBzaG91bGQgdXNlIHRoaXMgdG8gcGVyZm9ybSBhbGwgYnVpbHQtaW4gb3BlcmF0aW9ucy4gQWxsXG4gICAgICogIG1ldGhvZHMgc2FuaXRpemVzIGFuZCBub3JtYWxpemVzIHRoZSB2YWx1ZXMgcGFzc2VkIGludG8gdGhpcy5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzLlxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtKHJlcSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBgdW5zdXBwb3J0ZWQgbWV0aG9kOiAke3JlcS5tZXRob2R9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiByZXEubWV0aG9kLFxuICAgICAgICAgICAgaW5mbzogcmVxXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTdGF0ZVxuICAgIGFzeW5jIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9ICgwLCBpbmRleF9qc182LmdldE51bWJlcikoYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRCbG9ja051bWJlclwiIH0pLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciAlJWFkZHJlc3MlJSwgcmVzb2x2aW5nIEVOU1xuICAgICAqICBuYW1lcyBhbmQgW1tBZGRyZXNzYWJsZV1dIG9iamVjdHMgYW5kIHJldHVybmluZyBpZiBhbHJlYWR5IGFuXG4gICAgICogIGFkZHJlc3MuXG4gICAgICovXG4gICAgX2dldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKGFkZHJlc3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBvciByZXNvbHZlcyB0byBhIHZhbGlkIGJsb2NrIHRhZyBmb3IgJSVibG9ja1RhZyUlLCByZXNvbHZpbmdcbiAgICAgKiAgbmVnYXRpdmUgdmFsdWVzIGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkIGJsb2NrIHRhZy5cbiAgICAgKi9cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcImxhdGVzdFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYWZlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0hleFN0cmluZykoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNIZXhTdHJpbmcpKGJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYudG9RdWFudGl0eSkoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSAoMCwgaW5kZXhfanNfNi5nZXROdW1iZXIpKGJsb2NrVGFnLCBcImJsb2NrVGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFnID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYudG9RdWFudGl0eSkoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RCbG9ja051bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LnRvUXVhbnRpdHkpKHRoaXMuI2xhc3RCbG9ja051bWJlciArIGJsb2NrVGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYikgPT4gKDAsIGluZGV4X2pzXzYudG9RdWFudGl0eSkoYiArIGJsb2NrVGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgYmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG9yIHJlc29sdmVzIHRvIGEgZmlsdGVyIGZvciAlJWZpbHRlciUlLCByZXNvbHZpbmcgYW55IEVOU1xuICAgICAqICBuYW1lcyBvciBbW0FkZHJlc3NhYmxlXV0gb2JqZWN0IGFuZCByZXR1cm5pbmcgaWYgYWxyZWFkeSBhIHZhbGlkXG4gICAgICogIGZpbHRlci5cbiAgICAgKi9cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRvcGljc1xuICAgICAgICBjb25zdCB0b3BpY3MgPSAoZmlsdGVyLnRvcGljcyB8fCBbXSkubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jaXNpZnkodC5tYXAoKHQpID0+IHQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IChcImJsb2NrSGFzaFwiIGluIGZpbHRlcikgPyBmaWx0ZXIuYmxvY2tIYXNoIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKF9hZGRyZXNzLCBmcm9tQmxvY2ssIHRvQmxvY2spID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc3dpdGNoIChfYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hZGRyZXNzWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfYWRkcmVzcy5zb3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUJsb2NrICE9IG51bGwgfHwgdG9CbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsdGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9waWNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGZyb21CbG9jaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSB0b0Jsb2NrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgIGZpbHRlci5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBZGRyZXNzZXMgY291bGQgYmUgYXN5bmMgKEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXMpXG4gICAgICAgIGxldCBhZGRyZXNzID0gW107XG4gICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyIG9mIGZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MucHVzaCh0aGlzLl9nZXRBZGRyZXNzKGFkZHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnB1c2godGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmcm9tQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcImZyb21CbG9ja1wiIGluIGZpbHRlcikge1xuICAgICAgICAgICAgZnJvbUJsb2NrID0gdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvQmxvY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInRvQmxvY2tcIiBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRvQmxvY2sgPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXIudG9CbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3MuZmlsdGVyKChhKSA9PiAodHlwZW9mIChhKSAhPT0gXCJzdHJpbmdcIikpLmxlbmd0aCB8fFxuICAgICAgICAgICAgKGZyb21CbG9jayAhPSBudWxsICYmIHR5cGVvZiAoZnJvbUJsb2NrKSAhPT0gXCJzdHJpbmdcIikgfHxcbiAgICAgICAgICAgICh0b0Jsb2NrICE9IG51bGwgJiYgdHlwZW9mICh0b0Jsb2NrKSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5hbGwoYWRkcmVzcyksIGZyb21CbG9jaywgdG9CbG9ja10pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoYWRkcmVzcywgZnJvbUJsb2NrLCB0b0Jsb2NrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgb3IgcmVzb3ZsZXMgdG8gYSB0cmFuc2FjdGlvbiBmb3IgJSVyZXF1ZXN0JSUsIHJlc29sdmluZ1xuICAgICAqICBhbnkgRU5TIG5hbWVzIG9yIFtbQWRkcmVzc2FibGVdXSBhbmQgcmV0dXJuaW5nIGlmIGFscmVhZHkgYSB2YWxpZFxuICAgICAqICB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KF9yZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkoX3JlcXVlc3QpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBbXCJ0b1wiLCBcImZyb21cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKHJlcXVlc3Rba2V5XSwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgoYXN5bmMgZnVuY3Rpb24gKCkgeyByZXF1ZXN0W2tleV0gPSBhd2FpdCBhZGRyOyB9KSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Rba2V5XSA9IGFkZHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVxdWVzdC5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKHJlcXVlc3QuYmxvY2tUYWcpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyBmdW5jdGlvbiAoKSB7IHJlcXVlc3QuYmxvY2tUYWcgPSBhd2FpdCBibG9ja1RhZzsgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmJsb2NrVGFnID0gYmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgLy8gTm8gZXhwbGljaXQgbmV0d29yayB3YXMgc2V0IGFuZCB0aGlzIGlzIG91ciBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIGN1cnJlbnQgbmV0d29yayAoc2hhcmVkIHdpdGggYWxsIGNhbGxzKVxuICAgICAgICAgICAgY29uc3QgZGV0ZWN0TmV0d29yayA9IHRoaXMuX2RldGVjdE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBuZXR3b3JrUHJvbWlzZSBvbiBmYWlsdXJlLCBzbyB3ZSB3aWxsIHRyeSBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuZXR3b3JrUHJvbWlzZSA9PT0gZGV0ZWN0TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrUHJvbWlzZSA9IGRldGVjdE5ldHdvcms7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0IGRldGVjdE5ldHdvcmspLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLiNuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgY29uc3QgW2V4cGVjdGVkLCBhY3R1YWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbmV0d29ya1Byb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9kZXRlY3ROZXR3b3JrKCkgLy8gVGhlIGFjdHVhbCBjb25uZWN0ZWQgbmV0d29ya1xuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkLmNoYWluSWQgIT09IGFjdHVhbC5jaGFpbklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBcImFueVwiIG5ldHdvcmsgY2FuIGNoYW5nZSwgc28gbm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgYWN0dWFsLCBleHBlY3RlZCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBuZXR3b3JrIGlmIHNvbWV0aGluZyBlbHNlIGhhc24ndCBhbHJlYWR5IGNoYW5nZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jbmV0d29ya1Byb21pc2UgPT09IG5ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI25ldHdvcmtQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgYWxsb3cgY2hhbmdlcyB0byB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgYG5ldHdvcmsgY2hhbmdlZDogJHtleHBlY3RlZC5jaGFpbklkfSA9PiAke2FjdHVhbC5jaGFpbklkfSBgLCBcIk5FVFdPUktfRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwZWN0ZWQuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBnZXRGZWVEYXRhRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2Jsb2NrLCBnYXNQcmljZSB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICBfYmxvY2s6IHRoaXMuI2dldEJsb2NrKFwibGF0ZXN0XCIsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IGF3YWl0IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0R2FzUHJpY2VcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5nZXRCaWdJbnQpKGdhc1ByaWNlLCBcIiVyZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIHJlY29tbWVuZGVkIEVJUC0xNTU5IGhldXJpc3RpY3MgZm9yIGZlZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHRoaXMuX3dyYXBCbG9jayhfYmxvY2ssIG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChcIjEwMDAwMDAwMDBcIik7XG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gKGJsb2NrLmJhc2VGZWVQZXJHYXMgKiBCTl8yKSArIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcl9qc18xLkZlZURhdGEoZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayBmb3IgYSBGZWVEYXRhTmV0V29ya1BsdWdpblxuICAgICAgICBjb25zdCBwbHVnaW4gPSBuZXR3b3JrLmdldFBsdWdpbihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZldGNoVXJsRmVlRGF0YVBsdWdpblwiKTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IGluZGV4X2pzXzYuRmV0Y2hSZXF1ZXN0KHBsdWdpbi51cmwpO1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHBsdWdpbi5wcm9jZXNzRnVuYyhnZXRGZWVEYXRhRnVuYywgdGhpcywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJfanNfMS5GZWVEYXRhKGZlZURhdGEuZ2FzUHJpY2UsIGZlZURhdGEubWF4RmVlUGVyR2FzLCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RmVlRGF0YUZ1bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgZXN0aW1hdGVHYXMoX3R4KSB7XG4gICAgICAgIGxldCB0eCA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdChfdHgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKHR4KSkge1xuICAgICAgICAgICAgdHggPSBhd2FpdCB0eDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KShhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLCB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgfSksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyAjY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShhdHRlbXB0IDwgTUFYX0NDSVBfUkVESVJFQ1RTLCBcIkNDSVAgcmVhZCBleGNlZWRlZCBtYXhpbXVtIHJlZGlyZWN0aW9uc1wiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJUT09fTUFOWV9SRURJUkVDVFNcIixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKHt9LCB0eCwgeyBibG9ja1RhZywgZW5hYmxlQ2NpcFJlYWQ6IHRydWUgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoaXMgY2FtZSBpbiBhcyBhIFBlcmZvcm1BY3Rpb25UcmFuc2FjdGlvbiwgc28gdG8vZnJvbSBhcmUgc2FmZTsgd2UgY2FuIGNhc3RcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoMCwgcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdCkodHgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LmhleGxpZnkpKGF3YWl0IHRoaXMuX3BlcmZvcm0oeyBtZXRob2Q6IFwiY2FsbFwiLCB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIE9mZmNoYWluTG9va3VwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZUNjaXBSZWFkICYmICgwLCBpbmRleF9qc182LmlzQ2FsbEV4Y2VwdGlvbikoZXJyb3IpICYmIGVycm9yLmRhdGEgJiYgYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHRyYW5zYWN0aW9uLnRvICE9IG51bGwgJiYgKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShlcnJvci5kYXRhLCAwLCA0KSA9PT0gXCIweDU1NmYxODMwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFNlbmRlciA9IGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKSh0cmFuc2FjdGlvbi50bywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIENDSVAgUmVhZCBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgY2NpcEFyZ3M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2NpcEFyZ3MgPSBwYXJzZU9mZmNoYWluTG9va3VwKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZXJyb3IuZGF0YSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgZXJyb3IubWVzc2FnZSwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQkFEX0RBVEFcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoY2NpcEFyZ3Muc2VuZGVyLnRvTG93ZXJDYXNlKCkgPT09IHR4U2VuZGVyLnRvTG93ZXJDYXNlKCksIFwiQ0NJUCBSZWFkIHNlbmRlciBtaXNtYXRjaFwiLCBcIkNBTExfRVhDRVBUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBjY2lwQXJncy5lcnJvckFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSBhd2FpdCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNjaXBBcmdzLmNhbGxkYXRhLCBjY2lwQXJncy51cmxzKTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGNjaXBSZXN1bHQgIT0gbnVsbCwgXCJDQ0lQIFJlYWQgZmFpbGVkIHRvIGZldGNoIGRhdGFcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJGRVRDSF9GQUlMRURcIiwgdHJhbnNhY3Rpb24sIGluZm86IHsgZGF0YTogZXJyb3IuZGF0YSwgZXJyb3JBcmdzOiBjY2lwQXJncy5lcnJvckFyZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICB0bzogdHhTZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBpbmRleF9qc182LmNvbmNhdCkoW2NjaXBBcmdzLnNlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgY2NpcEFyZ3MuZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZENjaXBSZWFkQ2FsbFwiLCB0cmFuc2FjdGlvbjogdHggfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUNjaXBSZWFkQ2FsbFJlc3VsdFwiLCB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbih7fSwgdHgpLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlQ2NpcFJlYWRDYWxsRXJyb3JcIiwgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4KSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNjaGVja05ldHdvcmsocHJvbWlzZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICB2YWx1ZTogcHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxsKF90eCkge1xuICAgICAgICBjb25zdCB7IHR4LCBibG9ja1RhZyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIHR4OiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QoX3R4KSxcbiAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhfdHguYmxvY2tUYWcpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2hlY2tOZXR3b3JrKHRoaXMuI2NhbGwodHgsIGJsb2NrVGFnLCBfdHguZW5hYmxlQ2NpcFJlYWQgPyAwIDogLTEpKTtcbiAgICB9XG4gICAgLy8gQWNjb3VudFxuICAgIGFzeW5jICNnZXRBY2NvdW50VmFsdWUocmVxdWVzdCwgX2FkZHJlc3MsIF9ibG9ja1RhZykge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoX2FkZHJlc3MpO1xuICAgICAgICBsZXQgYmxvY2tUYWcgPSB0aGlzLl9nZXRCbG9ja1RhZyhfYmxvY2tUYWcpO1xuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgKGJsb2NrVGFnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgW2FkZHJlc3MsIGJsb2NrVGFnXSA9IGF3YWl0IFByb21pc2UuYWxsKFthZGRyZXNzLCBibG9ja1RhZ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjaGVja05ldHdvcmsodGhpcy4jcGVyZm9ybShPYmplY3QuYXNzaWduKHJlcXVlc3QsIHsgYWRkcmVzcywgYmxvY2tUYWcgfSkpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZ2V0QmlnSW50KShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0QmFsYW5jZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSwgXCIlcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoYWRkcmVzcywgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc182LmdldE51bWJlcikoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIiB9LCBhZGRyZXNzLCBibG9ja1RhZyksIFwiJXJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRDb2RlKGFkZHJlc3MsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5oZXhsaWZ5KShhd2FpdCB0aGlzLiNnZXRBY2NvdW50VmFsdWUoeyBtZXRob2Q6IFwiZ2V0Q29kZVwiIH0sIGFkZHJlc3MsIGJsb2NrVGFnKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN0b3JhZ2UoYWRkcmVzcywgX3Bvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBpbmRleF9qc182LmdldEJpZ0ludCkoX3Bvc2l0aW9uLCBcInBvc2l0aW9uXCIpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuaGV4bGlmeSkoYXdhaXQgdGhpcy4jZ2V0QWNjb3VudFZhbHVlKHsgbWV0aG9kOiBcImdldFN0b3JhZ2VcIiwgcG9zaXRpb24gfSwgYWRkcmVzcywgYmxvY2tUYWcpKTtcbiAgICB9XG4gICAgLy8gV3JpdGVcbiAgICBhc3luYyBicm9hZGNhc3RUcmFuc2FjdGlvbihzaWduZWRUeCkge1xuICAgICAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBoYXNoLCBuZXR3b3JrIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuX3BlcmZvcm0oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzaWduZWRUeFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHggPSBpbmRleF9qc181LlRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHgpO1xuICAgICAgICBpZiAodHguaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQFRPRE86IHRoZSByZXR1cm5lZCBoYXNoIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBuZXR3b3JrKS5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgYXN5bmMgI2dldEJsb2NrKGJsb2NrLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgQ3VzdG9tQmxvY2tQbHVnaW4gY2hlY2tcbiAgICAgICAgaWYgKCgwLCBpbmRleF9qc182LmlzSGV4U3RyaW5nKShibG9jaywgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcGVyZm9ybSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJsb2NrXCIsIGJsb2NrSGFzaDogYmxvY2ssIGluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja1RhZyA9IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IGF3YWl0IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJmb3JtKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCbG9ja1wiLCBibG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUXVlcmllc1xuICAgIGFzeW5jIGdldEJsb2NrKGJsb2NrLCBwcmVmZXRjaFR4cykge1xuICAgICAgICBjb25zdCB7IG5ldHdvcmssIHBhcmFtcyB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzYucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgIG5ldHdvcms6IHRoaXMuZ2V0TmV0d29yaygpLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLiNnZXRCbG9jayhibG9jaywgISFwcmVmZXRjaFR4cylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBCbG9jayhwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29yaywgcGFyYW1zIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25cIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVzcG9uc2UocGFyYW1zLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpIHtcbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGJhY2tlbmRzIGRpZCBub3QgYmFja2ZpbGwgdGhlIGVmZmVjdGl2ZUdhc1ByaWNlIGludG8gb2xkIHRyYW5zYWN0aW9uc1xuICAgICAgICAvLyBpbiB0aGUgcmVjZWlwdCwgc28gd2UgbG9vayBpdCB1cCBtYW51YWxseSBhbmQgaW5qZWN0IGl0LlxuICAgICAgICBpZiAocGFyYW1zLmdhc1ByaWNlID09IG51bGwgJiYgcGFyYW1zLmVmZmVjdGl2ZUdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvblwiLCBoYXNoIH0pO1xuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBvcnQgdGhpczsgY291bGQgbm90IGZpbmQgdHggb3IgZWZmZWN0aXZlR2FzUHJpY2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMuZWZmZWN0aXZlR2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uUmVjZWlwdChwYXJhbXMsIG5ldHdvcmspO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvblJlc3VsdChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNi5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuI3BlcmZvcm0oeyBtZXRob2Q6IFwiZ2V0VHJhbnNhY3Rpb25SZXN1bHRcIiwgaGFzaCB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuaGV4bGlmeSkocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQmxvb20tZmlsdGVyIFF1ZXJpZXNcbiAgICBhc3luYyBnZXRMb2dzKF9maWx0ZXIpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuX2dldEZpbHRlcihfZmlsdGVyKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShmaWx0ZXIpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSBhd2FpdCBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuZXR3b3JrLCBwYXJhbXMgfSA9IGF3YWl0ICgwLCBpbmRleF9qc182LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICBuZXR3b3JrOiB0aGlzLmdldE5ldHdvcmsoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy4jcGVyZm9ybSh7IG1ldGhvZDogXCJnZXRMb2dzXCIsIGZpbHRlciB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoKHApID0+IHRoaXMuX3dyYXBMb2cocCwgbmV0d29yaykpO1xuICAgIH1cbiAgICAvLyBFTlNcbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKGZhbHNlLCBcInByb3ZpZGVyIGNhbm5vdCBjb25uZWN0IHRvIHRhcmdldCBuZXR3b3JrXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJfZ2V0UHJvdmlkZXIoKVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBlbnNfcmVzb2x2ZXJfanNfMS5FbnNSZXNvbHZlci5mcm9tTmFtZSh0aGlzLCBuYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXZhdGFyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBhd2FpdCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICgwLCBpbmRleF9qc180Lm5hbWVoYXNoKShhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IGVuc19yZXNvbHZlcl9qc18xLkVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3ModGhpcyk7XG4gICAgICAgICAgICBjb25zdCBlbnNDb250cmFjdCA9IG5ldyBpbmRleF9qc18zLkNvbnRyYWN0KGVuc0FkZHIsIFtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHJlc29sdmVyKGJ5dGVzMzIpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IGVuc0NvbnRyYWN0LnJlc29sdmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyID09IG51bGwgfHwgcmVzb2x2ZXIgPT09IGluZGV4X2pzXzIuWmVyb0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQ29udHJhY3QgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChyZXNvbHZlciwgW1xuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gbmFtZShieXRlczMyKSB2aWV3IHJldHVybnMgKHN0cmluZylcIlxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYXdhaXQgcmVzb2x2ZXJDb250cmFjdC5uYW1lKG5vZGUpO1xuICAgICAgICAgICAgLy8gRmFpbGVkIGZvcndhcmQgcmVzb2x1dGlvblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSBhd2FpdCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoZWNrICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIGRhdGEgd2FzIHJldHVybmVkIGZyb20gdGhlIHJlc29sdmVyXG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzYuaXNFcnJvcikoZXJyb3IsIFwiQkFEX0RBVEFcIikgJiYgZXJyb3IudmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIHJlZXJ0ZWRcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNi5pc0Vycm9yKShlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBfY29uZmlybXMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSAoX2NvbmZpcm1zICE9IG51bGwpID8gX2NvbmZpcm1zIDogMTtcbiAgICAgICAgaWYgKGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChhc3luYyAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMub2ZmKFwiYmxvY2tcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFRUVcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYoXCJibG9ja1wiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgaW5kZXhfanNfNi5tYWtlRXJyb3IpKFwidGltZW91dFwiLCBcIlRJTUVPVVRcIiwgeyByZWFzb246IFwidGltZW91dFwiIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB3YWl0Rm9yQmxvY2soYmxvY2tUYWcpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJub3QgaW1wbGVtZW50ZWQgeWV0XCIsIFwiTk9UX0lNUExFTUVOVEVEXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ3YWl0Rm9yQmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGEgdGltZXIgY3JlYXRlZCB1c2luZyB0aGUgW1tfc2V0VGltZW91dF1dIG1ldGhvZC5cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLiN0aW1lcnMuZ2V0KHRpbWVySWQpO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3RpbWVycy5kZWxldGUodGltZXJJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSB0aW1lciB0aGF0IHdpbGwgZXhlY3V0ZSAlJWZ1bmMlJSBhZnRlciBhdCBsZWFzdCAlJXRpbWVvdXQlJVxuICAgICAqICAoaW4gbXMpLiBJZiAlJXRpbWVvdXQlJSBpcyB1bnNwZWNpZmllZCwgdGhlbiAlJWZ1bmMlJSB3aWxsIGV4ZWN1dGVcbiAgICAgKiAgaW4gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqICBbUGF1c2luZ10oQWJzdHJhY3RQcm92aWRlci1wYXVzZWQpIHRoZSBwcm92aWRlciB3aWxsIHBhdXNlIGFueVxuICAgICAqICBhc3NvY2lhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICBfc2V0VGltZW91dChfZnVuYywgdGltZW91dCkge1xuICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lcklkID0gdGhpcy4jbmV4dFRpbWVyKys7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuZGVsZXRlKHRpbWVySWQpO1xuICAgICAgICAgICAgX2Z1bmMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXI6IG51bGwsIGZ1bmMsIHRpbWU6IHRpbWVvdXQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoZnVuYywgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLiN0aW1lcnMuc2V0KHRpbWVySWQsIHsgdGltZXIsIGZ1bmMsIHRpbWU6IGdldFRpbWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBlcmZvcm0gJSVmdW5jJSUgb24gZWFjaCBzdWJzY3JpYmVyLlxuICAgICAqL1xuICAgIF9mb3JFYWNoU3Vic2NyaWJlcihmdW5jKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuI3N1YnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZ1bmMoc3ViLnN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyB0byBjdXN0b21pemUgc3Vic2NyaXB0aW9uXG4gICAgICogIGltcGxlbWVudGF0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgc3dpdGNoIChzdWIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuZXR3b3JrXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbm1hbmFnZWRTdWJzY3JpYmVyKHN1Yi50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBzdWJzY3JpYmVyX3BvbGxpbmdfanNfMS5Qb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIucG9sbGluZ0ludGVydmFsID0gdGhpcy5wb2xsaW5nSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIodGhpcywgc3ViLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ09ycGhhblN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBldmVudDogJHtzdWIudHlwZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGEgW1tTdWJzY3JpYmVyXV0gZmFpbHMgYW5kIG5lZWRzIHRvIHJlcGxhY2UgaXRzZWxmLCB0aGlzXG4gICAgICogIG1ldGhvZCBtYXkgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqICBGb3IgZXhhbXBsZSwgdGhpcyBpcyB1c2VkIGZvciBwcm92aWRlcnMgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAgYGBldGhfZ2V0RmlsdGVyQ2hhbmdlc2BgIG1ldGhvZCwgd2hpY2ggY2FuIHJldHVybiBudWxsIGlmIHN0YXRlXG4gICAgICogIGZpbHRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGJhY2tlbmQsIGFsbG93aW5nIHRoZSBTdWJzY3JpYmVyXG4gICAgICogIHRvIHN3YXAgaW4gYSBbW1BvbGxpbmdFdmVudFN1YnNjcmliZXJdXS5cbiAgICAgKi9cbiAgICBfcmVjb3ZlclN1YnNjcmliZXIob2xkU3ViLCBuZXdTdWIpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHN1Yi5zdWJzY3JpYmVyID09PSBvbGRTdWIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlciA9IG5ld1N1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1Yi5wYXVzZSh0aGlzLiNwYXVzZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICNoYXNTdWIoZXZlbnQsIGVtaXRBcmdzKSB7XG4gICAgICAgIGxldCBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbG9nIHRoYXQgaXMgcmVtb3ZpbmcgYW4gZXhpc3RpbmcgbG9nOyB3ZSBhY3R1YWxseSB3YW50XG4gICAgICAgIC8vIHRvIGVtaXQgYW4gb3JwaGFuIGV2ZW50IGZvciB0aGUgcmVtb3ZlZCBsb2dcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcImV2ZW50XCIgJiYgZW1pdEFyZ3MgJiYgZW1pdEFyZ3MubGVuZ3RoID4gMCAmJiBlbWl0QXJnc1swXS5yZW1vdmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdWIgPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oeyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiBlbWl0QXJnc1swXSB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jc3Vicy5nZXQoc3ViLnRhZykgfHwgbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgI2dldFN1YihldmVudCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRTdWJzY3JpcHRpb24oZXZlbnQsIHRoaXMpO1xuICAgICAgICAvLyBQcmV2ZW50IHRhbXBlcmluZyB3aXRoIG91ciB0YWcgaW4gYW55IHN1YmNsYXNzJyBfZ2V0U3Vic2NyaWJlclxuICAgICAgICBjb25zdCB0YWcgPSBzdWJzY3JpcHRpb24udGFnO1xuICAgICAgICBsZXQgc3ViID0gdGhpcy4jc3Vicy5nZXQodGFnKTtcbiAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB0aGlzLl9nZXRTdWJzY3JpYmVyKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzYWJsZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgc3ViID0geyBzdWJzY3JpYmVyLCB0YWcsIGFkZHJlc3NhYmxlTWFwLCBuYW1lTWFwLCBzdGFydGVkOiBmYWxzZSwgbGlzdGVuZXJzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy4jc3Vicy5zZXQodGFnLCBzdWIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIGFzeW5jIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNnZXRTdWIoZXZlbnQpO1xuICAgICAgICBzdWIubGlzdGVuZXJzLnB1c2goeyBsaXN0ZW5lciwgb25jZTogZmFsc2UgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3Qgc3ViID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgc3ViLmxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIsIG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICBzdWIuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy4jcGF1c2VkU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnBhdXNlKHRoaXMuI3BhdXNlZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3Qgc3Vic2NyaXB0aW9uIG9yIGlmIGEgcmVjZW50IGVtaXQgcmVtb3ZlZFxuICAgICAgICAvLyB0aGUgbGFzdCBvZiB0aGVtICh3aGljaCBhbHNvIGRlbGV0ZWQgdGhlIHN1YikgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXN1YiB8fCBzdWIubGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgY291bnQgPSBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgc3ViLmxpc3RlbmVycyA9IHN1Yi5saXN0ZW5lcnMuZmlsdGVyKCh7IGxpc3RlbmVyLCBvbmNlIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgaW5kZXhfanNfNi5FdmVudFBheWxvYWQodGhpcywgKG9uY2UgPyBudWxsIDogbGlzdGVuZXIpLCBldmVudCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgLi4uYXJncywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuICFvbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1Yi5saXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBzdWIuc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZShzdWIudGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvdW50ID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdG90YWwgKz0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IGF3YWl0IHRoaXMuI2hhc1N1YihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdWIubGlzdGVuZXJzLm1hcCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbGlzdGVuZXJzIH0gb2YgdGhpcy4jc3Vicy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChsaXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBzdWIgPSBhd2FpdCB0aGlzLiNoYXNTdWIoZXZlbnQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Yi5saXN0ZW5lcnMubWFwKCh7IGxpc3RlbmVyIH0pID0+IGxpc3RlbmVyKS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGlzdGVuZXIgfHwgc3ViLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdWIuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHN1Yi5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3N1YnMuZGVsZXRlKHN1Yi50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRhZywgc3RhcnRlZCwgc3Vic2NyaWJlciB9ID0gYXdhaXQgdGhpcy4jZ2V0U3ViKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdGFnLCB7IHN0YXJ0ZWQsIHN1YnNjcmliZXIgfV0gb2YgdGhpcy4jc3Vicykge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNzdWJzLmRlbGV0ZSh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYXN5bmMgYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgSWYgdGhpcyBwcm92aWRlciBoYXMgYmVlbiBkZXN0cm95ZWQgdXNpbmcgdGhlIFtbZGVzdHJveV1dIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICBPbmNlIGRlc3Ryb3llZCwgYWxsIHJlc291cmNlcyBhcmUgcmVjbGFpbWVkLCBpbnRlcm5hbCBldmVudCBsb29wc1xuICAgICAqICBhbmQgdGltZXJzIGFyZSBjbGVhbmVkIHVwIGFuZCBubyBmdXJ0aGVyIHJlcXVlc3RzIG1heSBiZSBzZW50IHRvXG4gICAgICogIHRoZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXQgZGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGVzdHJveWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IHVzZSB0aGlzIHRvIHNodXRkb3duIGFueSBzb2NrZXRzIG9yIHJlbGVhc2UgdGhlaXJcbiAgICAgKiAgcmVzb3VyY2VzIGFuZCByZWplY3QgYW55IHBlbmRpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0KiogY2FsbCBgYHN1cGVyLmRlc3Ryb3koKWBgLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAvLyBTaHV0IGRvd24gYWxsIHRpZW1yc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVySWQgb2YgdGhpcy4jdGltZXJzLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBXaGV0aGVyIHRoZSBwcm92aWRlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICAqXG4gICAgICogIEEgcGF1c2VkIHByb3ZpZGVyIHdpbGwgbm90IGVtaXQgYW55IGV2ZW50cywgYW5kIGdlbmVyYWxseSBzaG91bGRcbiAgICAgKiAgbm90IG1ha2UgYW55IHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrLCBidXQgdGhhdCBpcyB1cCB0byBzdWItY2xhc3Nlc1xuICAgICAqICB0byBtYW5hZ2UuXG4gICAgICpcbiAgICAgKiAgU2V0dGluZyBgYHBhdXNlZCA9IHRydWVgYCBpcyBpZGVudGljYWwgdG8gY2FsbGluZyBgYC5wYXVzZShmYWxzZSlgYCxcbiAgICAgKiAgd2hpY2ggd2lsbCBidWZmZXIgYW55IGV2ZW50cyB0aGF0IG9jY3VyIHdoaWxlIHBhdXNlZCB1bnRpbCB0aGVcbiAgICAgKiAgcHJvdmlkZXIgaXMgdW5wYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHsgcmV0dXJuICh0aGlzLiNwYXVzZWRTdGF0ZSAhPSBudWxsKTsgfVxuICAgIHNldCBwYXVzZWQocGF1c2UpIHtcbiAgICAgICAgaWYgKCEhcGF1c2UgPT09IHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlIHRoZSBwcm92aWRlci4gSWYgJSVkcm9wV2hpbGVQYXVzZWQlJSwgYW55IGV2ZW50cyB0aGF0IG9jY3VyXG4gICAgICogIHdoaWxlIHBhdXNlZCBhcmUgZHJvcHBlZCwgb3RoZXJ3aXNlIGFsbCBldmVudHMgd2lsbCBiZSBlbWl0dGVkIG9uY2VcbiAgICAgKiAgdGhlIHByb3ZpZGVyIGlzIHVucGF1c2VkLlxuICAgICAqL1xuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLiNsYXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNwYXVzZWRTdGF0ZSA9PSAhIWRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwiY2Fubm90IGNoYW5nZSBwYXVzZSB0eXBlOyByZXN1bWUgZmlyc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwYXVzZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5wYXVzZShkcm9wV2hpbGVQYXVzZWQpKTtcbiAgICAgICAgdGhpcy4jcGF1c2VkU3RhdGUgPSAhIWRyb3BXaGlsZVBhdXNlZDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgaWYgKHRpbWVyLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG5lZWRlZCBmb3Igd2hlbiB3ZSBiZWNvbWUgdW5wYXVzZWRcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCkgLSB0aW1lci50aW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXN1bWUgdGhlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigocykgPT4gcy5yZXN1bWUoKSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZFN0YXRlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLiN0aW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIHdoZW4gd2Ugd2VyZSBwYXVzZWRcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGltZXIudGltZTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgdGltZSAoaW4gY2F1c2UgcGF1c2VkLCBzbyB3ZSBjb24gY29tcHV0ZSByZW1haW5pbmYgdGltZSlcbiAgICAgICAgICAgIHRpbWVyLnRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdGltZXJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZXIuZnVuYywgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0UHJvdmlkZXIgPSBBYnN0cmFjdFByb3ZpZGVyO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBieXRlcyA9IF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpO1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi50b1V0ZjhTdHJpbmcpKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlQnl0ZXMocmVzdWx0LCBzdGFydCkge1xuICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHJlc3VsdCwgc3RhcnQsIHN0YXJ0ICsgMzIpKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpO1xuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBudW1QYWQodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSAoMCwgaW5kZXhfanNfNi50b0JlQXJyYXkpKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZW1wdHkgPSBuZXcgVWludDhBcnJheShbXSk7XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVtcHR5KTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgaW5kZXhfanNfNi5nZXRCeXRlcykoZGF0YXNbaV0pO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGJ5dGVzIG9mZnNldFxuICAgICAgICByZXN1bHRbaV0gPSBudW1QYWQoYnl0ZUNvdW50KTtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBhbmQgcGFkZGVkIHZhbHVlIG9mIGRhdGFcbiAgICAgICAgcmVzdWx0LnB1c2gobnVtUGFkKGRhdGEubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGJ5dGVzUGFkKGRhdGEpKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyICsgTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gMzIpICogMzI7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfNi5jb25jYXQpKHJlc3VsdCk7XG59XG5jb25zdCB6ZXJvcyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBwYXJzZU9mZmNoYWluTG9va3VwKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlbmRlcjogXCJcIiwgdXJsczogW10sIGNhbGxkYXRhOiBcIlwiLCBzZWxlY3RvcjogXCJcIiwgZXh0cmFEYXRhOiBcIlwiLCBlcnJvckFyZ3M6IFtdXG4gICAgfTtcbiAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKCgwLCBpbmRleF9qc182LmRhdGFMZW5ndGgpKGRhdGEpID49IDUgKiAzMiwgXCJpbnN1ZmZpY2llbnQgT2ZmY2hhaW5Mb29rdXAgZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImluc3VmZmljaWVudCBPZmZjaGFpbkxvb2t1cCBkYXRhXCJcbiAgICB9KTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDAsIDMyKTtcbiAgICAoMCwgaW5kZXhfanNfNi5hc3NlcnQpKCgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoc2VuZGVyLCAwLCAxMikgPT09ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoemVyb3MsIDAsIDEyKSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHNlbmRlclwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgcmVhc29uOiBcImNvcnJ1cHQgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyXCJcbiAgICB9KTtcbiAgICByZXN1bHQuc2VuZGVyID0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShzZW5kZXIsIDEyKTtcbiAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIDMyLCA2NCkpO1xuICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gKDAsIGluZGV4X2pzXzYuZ2V0TnVtYmVyKSgoMCwgaW5kZXhfanNfNi5kYXRhU2xpY2UpKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpO1xuICAgICAgICBjb25zdCB1cmxzRGF0YSA9ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFib3J0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVybHMgPSB1cmxzO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIHVybHNcIiwgXCJPRkZDSEFJTl9GQVVMVFwiLCB7XG4gICAgICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCB1cmxzXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgIGlmIChjYWxsZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuY2FsbGRhdGEgPSBjYWxsZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoZmFsc2UsIFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsZGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxkYXRhXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgICgwLCBpbmRleF9qc182LmFzc2VydCkoKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShkYXRhLCAxMDAsIDEyOCkgPT09ICgwLCBpbmRleF9qc182LmRhdGFTbGljZSkoemVyb3MsIDAsIDI4KSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGNhbGxiYWFja1NlbGVjdG9yXCIsIFwiT0ZGQ0hBSU5fRkFVTFRcIiwge1xuICAgICAgICByZWFzb246IFwiY29ycnVwdCBPZmZjaGFpbkxvb2t1cCBjYWxsYmFhY2tTZWxlY3RvclwiXG4gICAgfSk7XG4gICAgcmVzdWx0LnNlbGVjdG9yID0gKDAsIGluZGV4X2pzXzYuZGF0YVNsaWNlKShkYXRhLCA5NiwgMTAwKTtcbiAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgaWYgKGV4dHJhRGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhYm9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZXh0cmFEYXRhID0gZXh0cmFEYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzYuYXNzZXJ0KShmYWxzZSwgXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiLCBcIk9GRkNIQUlOX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIHJlYXNvbjogXCJjb3JydXB0IE9mZmNoYWluTG9va3VwIGV4dHJhRGF0YVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHQuZXJyb3JBcmdzID0gXCJzZW5kZXIsdXJscyxjYWxsZGF0YSxzZWxlY3RvcixleHRyYURhdGFcIi5zcGxpdCgvLC8pLm1hcCgoaykgPT4gcmVzdWx0W2tdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3QtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQWJzdHJhY3RQcm92aWRlciIsIlVubWFuYWdlZFN1YnNjcmliZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiaW5kZXhfanNfNCIsImluZGV4X2pzXzUiLCJpbmRleF9qc182IiwiZW5zX3Jlc29sdmVyX2pzXzEiLCJmb3JtYXRfanNfMSIsIm5ldHdvcmtfanNfMSIsInByb3ZpZGVyX2pzXzEiLCJzdWJzY3JpYmVyX3BvbGxpbmdfanNfMSIsIkJOXzIiLCJCaWdJbnQiLCJNQVhfQ0NJUF9SRURJUkVDVFMiLCJpc1Byb21pc2UiLCJ0aGVuIiwiZ2V0VGFnIiwicHJlZml4IiwiSlNPTiIsInN0cmluZ2lmeSIsImsiLCJ2IiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJzb3J0IiwicmVkdWNlIiwiYWNjdW0iLCJrZXkiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwic3RhcnQiLCJzdG9wIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJjb3B5IiwicGFyc2UiLCJjb25jaXNpZnkiLCJpdGVtcyIsImZyb20iLCJTZXQiLCJ2YWx1ZXMiLCJnZXRTdWJzY3JpcHRpb24iLCJfZXZlbnQiLCJwcm92aWRlciIsIkVycm9yIiwidG9waWNzIiwidHlwZSIsInRhZyIsImlzSGV4U3RyaW5nIiwiaGFzaCIsIm9ycGhhbiIsImV2ZW50IiwiZmlsdGVyIiwiYWRkcmVzcyIsIm1hcCIsInQiLCJhZGRyZXNzZXMiLCJwcm9taXNlcyIsImFkZEFkZHJlc3MiLCJhZGRyIiwicHVzaCIsInJlc29sdmVBZGRyZXNzIiwiZm9yRWFjaCIsImxlbmd0aCIsIlByb21pc2UiLCJhbGwiLCJhIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXRUaW1lIiwiRGF0ZSIsImRlZmF1bHRPcHRpb25zIiwiY2FjaGVUaW1lb3V0IiwicG9sbGluZ0ludGVydmFsIiwic3VicyIsInBsdWdpbnMiLCJwYXVzZWRTdGF0ZSIsImRlc3Ryb3llZCIsIm5ldHdvcmtQcm9taXNlIiwiYW55TmV0d29yayIsInBlcmZvcm1DYWNoZSIsImxhc3RCbG9ja051bWJlciIsIm5leHRUaW1lciIsInRpbWVycyIsImRpc2FibGVDY2lwUmVhZCIsIm9wdGlvbnMiLCJfbmV0d29yayIsImFzc2lnbiIsIm5ldHdvcmsiLCJOZXR3b3JrIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbWl0IiwiTWFwIiwiYXR0YWNoUGx1Z2luIiwicGx1Z2luIiwiZ2V0Iiwic2V0IiwiY29ubmVjdCIsImdldFBsdWdpbiIsInBlcmZvcm0iLCJyZXEiLCJ0aW1lb3V0IiwiX3BlcmZvcm0iLCJtZXRob2QiLCJkZWxldGUiLCJjY2lwUmVhZEZldGNoIiwidHgiLCJjYWxsZGF0YSIsInVybHMiLCJ0byIsInNlbmRlciIsImRhdGEiLCJlcnJvck1lc3NhZ2VzIiwiaSIsInVybCIsImhyZWYiLCJyZXBsYWNlIiwicmVxdWVzdCIsIkZldGNoUmVxdWVzdCIsImluZGV4T2YiLCJib2R5IiwiYWN0aW9uIiwiaW5kZXgiLCJlcnJvck1lc3NhZ2UiLCJyZXNwIiwic2VuZCIsInJlc3VsdCIsImJvZHlKc29uIiwibWVzc2FnZSIsImVycm9yIiwiYXNzZXJ0Iiwic3RhdHVzQ29kZSIsInJlYXNvbiIsInRyYW5zYWN0aW9uIiwiaW5mbyIsIm0iLCJqb2luIiwiX3dyYXBCbG9jayIsIkJsb2NrIiwiZm9ybWF0QmxvY2siLCJfd3JhcExvZyIsIkxvZyIsImZvcm1hdExvZyIsIl93cmFwVHJhbnNhY3Rpb25SZWNlaXB0IiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0IiwiX3dyYXBUcmFuc2FjdGlvblJlc3BvbnNlIiwiVHJhbnNhY3Rpb25SZXNwb25zZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJfZGV0ZWN0TmV0d29yayIsIm9wZXJhdGlvbiIsImdldEJsb2NrTnVtYmVyIiwiYmxvY2tOdW1iZXIiLCJnZXROdW1iZXIiLCJfZ2V0QWRkcmVzcyIsIl9nZXRCbG9ja1RhZyIsImJsb2NrVGFnIiwidG9RdWFudGl0eSIsImIiLCJfZ2V0RmlsdGVyIiwiYmxvY2tIYXNoIiwidW5kZWZpbmVkIiwiX2FkZHJlc3MiLCJmcm9tQmxvY2siLCJ0b0Jsb2NrIiwiX2dldFRyYW5zYWN0aW9uUmVxdWVzdCIsIl9yZXF1ZXN0IiwiY29weVJlcXVlc3QiLCJnZXROZXR3b3JrIiwiZGV0ZWN0TmV0d29yayIsImNsb25lIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJjaGFpbklkIiwiZ2V0RmVlRGF0YSIsImdldEZlZURhdGFGdW5jIiwiX2Jsb2NrIiwiZ2FzUHJpY2UiLCJyZXNvbHZlUHJvcGVydGllcyIsImdldEJsb2NrIiwiZ2V0QmlnSW50IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJibG9jayIsImJhc2VGZWVQZXJHYXMiLCJGZWVEYXRhIiwiZmVlRGF0YSIsInByb2Nlc3NGdW5jIiwiZXN0aW1hdGVHYXMiLCJfdHgiLCJjYWxsIiwiYXR0ZW1wdCIsImVuYWJsZUNjaXBSZWFkIiwiaGV4bGlmeSIsImlzQ2FsbEV4Y2VwdGlvbiIsImRhdGFTbGljZSIsInR4U2VuZGVyIiwiY2NpcEFyZ3MiLCJwYXJzZU9mZmNoYWluTG9va3VwIiwiaW52b2NhdGlvbiIsInJldmVydCIsInNpZ25hdHVyZSIsImFyZ3MiLCJlcnJvckFyZ3MiLCJjY2lwUmVzdWx0IiwiY29uY2F0Iiwic2VsZWN0b3IiLCJlbmNvZGVCeXRlcyIsImV4dHJhRGF0YSIsImNoZWNrTmV0d29yayIsInByb21pc2UiLCJnZXRBY2NvdW50VmFsdWUiLCJfYmxvY2tUYWciLCJnZXRCYWxhbmNlIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldENvZGUiLCJnZXRTdG9yYWdlIiwiX3Bvc2l0aW9uIiwicG9zaXRpb24iLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25lZFR4Iiwic2lnbmVkVHJhbnNhY3Rpb24iLCJUcmFuc2FjdGlvbiIsInJlcGxhY2VhYmxlVHJhbnNhY3Rpb24iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwicHJlZmV0Y2hUeHMiLCJwYXJhbXMiLCJnZXRUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwiZ2V0VHJhbnNhY3Rpb25SZXN1bHQiLCJnZXRMb2dzIiwiX2ZpbHRlciIsInAiLCJfZ2V0UHJvdmlkZXIiLCJnZXRSZXNvbHZlciIsIkVuc1Jlc29sdmVyIiwiZnJvbU5hbWUiLCJnZXRBdmF0YXIiLCJyZXNvbHZlciIsInJlc29sdmVOYW1lIiwiZ2V0QWRkcmVzcyIsImxvb2t1cEFkZHJlc3MiLCJub2RlIiwibmFtZWhhc2giLCJzdWJzdHJpbmciLCJlbnNBZGRyIiwiZ2V0RW5zQWRkcmVzcyIsImVuc0NvbnRyYWN0IiwiQ29udHJhY3QiLCJaZXJvQWRkcmVzcyIsInJlc29sdmVyQ29udHJhY3QiLCJjaGVjayIsImlzRXJyb3IiLCJ3YWl0Rm9yVHJhbnNhY3Rpb24iLCJfY29uZmlybXMiLCJjb25maXJtcyIsInJlamVjdCIsInRpbWVyIiwibGlzdGVuZXIiLCJyZWNlaXB0IiwiY2xlYXJUaW1lb3V0IiwiY29uc29sZSIsImxvZyIsIm9uY2UiLCJvZmYiLCJtYWtlRXJyb3IiLCJ3YWl0Rm9yQmxvY2siLCJfY2xlYXJUaW1lb3V0IiwidGltZXJJZCIsIl9zZXRUaW1lb3V0IiwiX2Z1bmMiLCJmdW5jIiwicGF1c2VkIiwidGltZSIsIl9mb3JFYWNoU3Vic2NyaWJlciIsInN1YiIsInN1YnNjcmliZXIiLCJfZ2V0U3Vic2NyaWJlciIsIlBvbGxpbmdCbG9ja1N1YnNjcmliZXIiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlciIsIlBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIiwiX3JlY292ZXJTdWJzY3JpYmVyIiwib2xkU3ViIiwibmV3U3ViIiwic3RhcnRlZCIsImhhc1N1YiIsImVtaXRBcmdzIiwicmVtb3ZlZCIsImdldFN1YiIsInN1YnNjcmlwdGlvbiIsImFkZHJlc3NhYmxlTWFwIiwiV2Vha01hcCIsIm5hbWVNYXAiLCJsaXN0ZW5lcnMiLCJvbiIsImNvdW50IiwicGF5bG9hZCIsIkV2ZW50UGF5bG9hZCIsImxpc3RlbmVyQ291bnQiLCJ0b3RhbCIsInNwbGljZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJkZXN0cm95IiwicyIsIl9wYXJzZVN0cmluZyIsImJ5dGVzIiwiX3BhcnNlQnl0ZXMiLCJ0b1V0ZjhTdHJpbmciLCJvZmZzZXQiLCJudW1QYWQiLCJ0b0JlQXJyYXkiLCJwYWRkZWQiLCJVaW50OEFycmF5IiwiYnl0ZXNQYWQiLCJNYXRoIiwiY2VpbCIsImVtcHR5IiwiZGF0YXMiLCJieXRlQ291bnQiLCJnZXRCeXRlcyIsInplcm9zIiwiZGF0YUxlbmd0aCIsInVybHNPZmZzZXQiLCJ1cmxzTGVuZ3RoIiwidXJsc0RhdGEiLCJ1Iiwic3BsaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/abstract-signer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.VoidSigner = exports.AbstractSigner = void 0;\n/**\n *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes\n *  are sufficent for most developers, but this is provided to\n *  fascilitate more complex Signers.\n *\n *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]\n */ const index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nfunction checkProvider(signer, operation) {\n    if (signer.provider) {\n        return signer.provider;\n    }\n    (0, index_js_3.assert)(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\n        operation\n    });\n}\nasync function populate(signer, tx) {\n    let pop = (0, provider_js_1.copyRequest)(tx);\n    if (pop.to != null) {\n        pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);\n    }\n    if (pop.from != null) {\n        const from = pop.from;\n        pop.from = Promise.all([\n            signer.getAddress(),\n            (0, index_js_1.resolveAddress)(from, signer)\n        ]).then(([address, from])=>{\n            (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), \"transaction from mismatch\", \"tx.from\", from);\n            return address;\n        });\n    } else {\n        pop.from = signer.getAddress();\n    }\n    return await (0, index_js_3.resolveProperties)(pop);\n}\n/**\n *  An **AbstractSigner** includes most of teh functionality required\n *  to get a [[Signer]] working as expected, but requires a few\n *  Signer-specific methods be overridden.\n *\n */ class AbstractSigner {\n    /**\n     *  Creates a new Signer connected to %%provider%%.\n     */ constructor(provider){\n        (0, index_js_3.defineProperties)(this, {\n            provider: provider || null\n        });\n    }\n    async getNonce(blockTag) {\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(await this.getAddress(), blockTag);\n    }\n    async populateCall(tx) {\n        const pop = await populate(this, tx);\n        return pop;\n    }\n    async populateTransaction(tx) {\n        const provider = checkProvider(this, \"populateTransaction\");\n        const pop = await populate(this, tx);\n        if (pop.nonce == null) {\n            pop.nonce = await this.getNonce(\"pending\");\n        }\n        if (pop.gasLimit == null) {\n            pop.gasLimit = await this.estimateGas(pop);\n        }\n        // Populate the chain ID\n        const network = await this.provider.getNetwork();\n        if (pop.chainId != null) {\n            const chainId = (0, index_js_3.getBigInt)(pop.chainId);\n            (0, index_js_3.assertArgument)(chainId === network.chainId, \"transaction chainId mismatch\", \"tx.chainId\", tx.chainId);\n        } else {\n            pop.chainId = network.chainId;\n        }\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\n            (0, index_js_3.assertArgument)(false, \"eip-1559 transaction do not support gasPrice\", \"tx\", tx);\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\n            (0, index_js_3.assertArgument)(false, \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"tx\", tx);\n        }\n        if ((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            pop.type = 2;\n        } else if (pop.type === 0 || pop.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            (0, index_js_3.assert)(feeData.gasPrice != null, \"network does not support gasPrice\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getGasPrice\"\n            });\n            // Populate missing gasPrice\n            if (pop.gasPrice == null) {\n                pop.gasPrice = feeData.gasPrice;\n            }\n        } else {\n            // We need to get fee data to determine things\n            const feeData = await provider.getFeeData();\n            if (pop.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n                    // Upgrade transaction from null to eip-1559\n                    pop.type = 2;\n                    if (pop.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = pop.gasPrice;\n                        delete pop.gasPrice;\n                        pop.maxFeePerGas = gasPrice;\n                        pop.maxPriorityFeePerGas = gasPrice;\n                    } else {\n                        // Populate missing fee data\n                        if (pop.maxFeePerGas == null) {\n                            pop.maxFeePerGas = feeData.maxFeePerGas;\n                        }\n                        if (pop.maxPriorityFeePerGas == null) {\n                            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                        }\n                    }\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n                    // ...but they are trying to use EIP-1559 properties\n                    (0, index_js_3.assert)(!hasEip1559, \"network does not support EIP-1559\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"populateTransaction\"\n                    });\n                    // Populate missing fee data\n                    if (pop.gasPrice == null) {\n                        pop.gasPrice = feeData.gasPrice;\n                    }\n                    // Explicitly set untyped transaction to legacy\n                    // @TODO: Maybe this shold allow type 1?\n                    pop.type = 0;\n                } else {\n                    // getFeeData has failed us.\n                    (0, index_js_3.assert)(false, \"failed to get consistent fee data\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n            } else if (pop.type === 2) {\n                // Explicitly using EIP-1559\n                // Populate missing fee data\n                if (pop.maxFeePerGas == null) {\n                    pop.maxFeePerGas = feeData.maxFeePerGas;\n                }\n                if (pop.maxPriorityFeePerGas == null) {\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                }\n            }\n        }\n        //@TOOD: Don't await all over the place; save them up for\n        // the end for better batching\n        return await (0, index_js_3.resolveProperties)(pop);\n    }\n    async estimateGas(tx) {\n        return checkProvider(this, \"estimateGas\").estimateGas(await this.populateCall(tx));\n    }\n    async call(tx) {\n        return checkProvider(this, \"call\").call(await this.populateCall(tx));\n    }\n    async resolveName(name) {\n        const provider = checkProvider(this, \"resolveName\");\n        return await provider.resolveName(name);\n    }\n    async sendTransaction(tx) {\n        const provider = checkProvider(this, \"sendTransaction\");\n        const pop = await this.populateTransaction(tx);\n        delete pop.from;\n        const txObj = index_js_2.Transaction.from(pop);\n        return await provider.broadcastTransaction(await this.signTransaction(txObj));\n    }\n}\nexports.AbstractSigner = AbstractSigner;\n/**\n *  A **VoidSigner** is a class deisgned to allow an address to be used\n *  in any API which accepts a Signer, but for which there are no\n *  credentials available to perform any actual signing.\n *\n *  This for example allow impersonating an account for the purpose of\n *  static calls or estimating gas, but does not allow sending transactions.\n */ class VoidSigner extends AbstractSigner {\n    /**\n     *  Creates a new **VoidSigner** with %%address%% attached to\n     *  %%provider%%.\n     */ constructor(address, provider){\n        super(provider);\n        (0, index_js_3.defineProperties)(this, {\n            address\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n    #throwUnsupported(suffix, operation) {\n        (0, index_js_3.assert)(false, `VoidSigner cannot sign ${suffix}`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n    async signTransaction(tx) {\n        this.#throwUnsupported(\"transactions\", \"signTransaction\");\n    }\n    async signMessage(message) {\n        this.#throwUnsupported(\"messages\", \"signMessage\");\n    }\n    async signTypedData(domain, types, value) {\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\");\n    }\n}\nexports.VoidSigner = VoidSigner; //# sourceMappingURL=abstract-signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUNuRDs7Ozs7O0NBTUMsR0FDRCxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRyxnQkFBZ0JILG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDLFNBQVNJLGNBQWNDLE1BQU0sRUFBRUMsU0FBUztJQUNwQyxJQUFJRCxPQUFPRSxRQUFRLEVBQUU7UUFDakIsT0FBT0YsT0FBT0UsUUFBUTtJQUMxQjtJQUNDLElBQUdMLFdBQVdNLE1BQU0sRUFBRSxPQUFPLG9CQUFvQix5QkFBeUI7UUFBRUY7SUFBVTtBQUMzRjtBQUNBLGVBQWVHLFNBQVNKLE1BQU0sRUFBRUssRUFBRTtJQUM5QixJQUFJQyxNQUFNLENBQUMsR0FBR1IsY0FBY1MsV0FBVyxFQUFFRjtJQUN6QyxJQUFJQyxJQUFJRSxFQUFFLElBQUksTUFBTTtRQUNoQkYsSUFBSUUsRUFBRSxHQUFHLENBQUMsR0FBR2QsV0FBV2UsY0FBYyxFQUFFSCxJQUFJRSxFQUFFLEVBQUVSO0lBQ3BEO0lBQ0EsSUFBSU0sSUFBSUksSUFBSSxJQUFJLE1BQU07UUFDbEIsTUFBTUEsT0FBT0osSUFBSUksSUFBSTtRQUNyQkosSUFBSUksSUFBSSxHQUFHQyxRQUFRQyxHQUFHLENBQUM7WUFDbkJaLE9BQU9hLFVBQVU7WUFDaEIsSUFBR25CLFdBQVdlLGNBQWMsRUFBRUMsTUFBTVY7U0FDeEMsRUFBRWMsSUFBSSxDQUFDLENBQUMsQ0FBQ0MsU0FBU0wsS0FBSztZQUNuQixJQUFHYixX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b2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2Fic3RyYWN0LXNpZ25lci5qcz9jNTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXhwb3J0cy5BYnN0cmFjdFNpZ25lciA9IHZvaWQgMDtcbi8qKlxuICogIEdlbmVyYWxseSB0aGUgW1tXYWxsZXRdXSBhbmQgW1tKc29uUnBjU2lnbmVyXV0gYW5kIHRoZWlyIHN1Yi1jbGFzc2VzXG4gKiAgYXJlIHN1ZmZpY2VudCBmb3IgbW9zdCBkZXZlbG9wZXJzLCBidXQgdGhpcyBpcyBwcm92aWRlZCB0b1xuICogIGZhc2NpbGl0YXRlIG1vcmUgY29tcGxleCBTaWduZXJzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3Qtc2lnbmVyOiBTdWJjbGFzc2luZyBTaWduZXIgW2Fic3RyYWN0LXNpZ25lcl1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBwcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXIuanNcIik7XG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHNpZ25lciwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKHNpZ25lci5wcm92aWRlcikge1xuICAgICAgICByZXR1cm4gc2lnbmVyLnByb3ZpZGVyO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZhbHNlLCBcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG59XG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZShzaWduZXIsIHR4KSB7XG4gICAgbGV0IHBvcCA9ICgwLCBwcm92aWRlcl9qc18xLmNvcHlSZXF1ZXN0KSh0eCk7XG4gICAgaWYgKHBvcC50byAhPSBudWxsKSB7XG4gICAgICAgIHBvcC50byA9ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKShwb3AudG8sIHNpZ25lcik7XG4gICAgfVxuICAgIGlmIChwb3AuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSBwb3AuZnJvbTtcbiAgICAgICAgcG9wLmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKGZyb20sIHNpZ25lcilcbiAgICAgICAgXSkudGhlbigoW2FkZHJlc3MsIGZyb21dKSA9PiB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBmcm9tLnRvTG93ZXJDYXNlKCksIFwidHJhbnNhY3Rpb24gZnJvbSBtaXNtYXRjaFwiLCBcInR4LmZyb21cIiwgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3AuZnJvbSA9IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCAoMCwgaW5kZXhfanNfMy5yZXNvbHZlUHJvcGVydGllcykocG9wKTtcbn1cbi8qKlxuICogIEFuICoqQWJzdHJhY3RTaWduZXIqKiBpbmNsdWRlcyBtb3N0IG9mIHRlaCBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkXG4gKiAgdG8gZ2V0IGEgW1tTaWduZXJdXSB3b3JraW5nIGFzIGV4cGVjdGVkLCBidXQgcmVxdWlyZXMgYSBmZXdcbiAqICBTaWduZXItc3BlY2lmaWMgbWV0aG9kcyBiZSBvdmVycmlkZGVuLlxuICpcbiAqL1xuY2xhc3MgQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgcHJvdmlkZXIgdGhpcyBzaWduZXIgaXMgY29ubmVjdGVkIHRvLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFNpZ25lciBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcHJvdmlkZXI6IChwcm92aWRlciB8fCBudWxsKSB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpLmdldFRyYW5zYWN0aW9uQ291bnQoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVDYWxsKHR4KSB7XG4gICAgICAgIGNvbnN0IHBvcCA9IGF3YWl0IHBvcHVsYXRlKHRoaXMsIHR4KTtcbiAgICAgICAgcmV0dXJuIHBvcDtcbiAgICB9XG4gICAgYXN5bmMgcG9wdWxhdGVUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCBwb3B1bGF0ZSh0aGlzLCB0eCk7XG4gICAgICAgIGlmIChwb3Aubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9wLm5vbmNlID0gYXdhaXQgdGhpcy5nZXROb25jZShcInBlbmRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3AuZ2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlR2FzKHBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGNoYWluIElEXG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCAodGhpcy5wcm92aWRlcikuZ2V0TmV0d29yaygpO1xuICAgICAgICBpZiAocG9wLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkocG9wLmNoYWluSWQpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGNoYWluSWQgPT09IG5ldHdvcmsuY2hhaW5JZCwgXCJ0cmFuc2FjdGlvbiBjaGFpbklkIG1pc21hdGNoXCIsIFwidHguY2hhaW5JZFwiLCB0eC5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcC5jaGFpbklkID0gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgaWYgKHBvcC5nYXNQcmljZSAhPSBudWxsICYmIChwb3AudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwb3AudHlwZSA9PT0gMCB8fCBwb3AudHlwZSA9PT0gMSkgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwb3AudHlwZSA9PT0gMiB8fCBwb3AudHlwZSA9PSBudWxsKSAmJiAocG9wLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXG4gICAgICAgICAgICBwb3AudHlwZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9wLnR5cGUgPT09IDAgfHwgcG9wLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsLCBcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEdhc1ByaWNlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgaWYgKHBvcC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9wLmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSBhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICBpZiAocG9wLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgcG9wLnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gcG9wLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBvcC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSghaGFzRWlwMTU1OSwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9wLmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IE1heWJlIHRoaXMgc2hvbGQgYWxsb3cgdHlwZSAxP1xuICAgICAgICAgICAgICAgICAgICBwb3AudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBvcC50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAocG9wLm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQFRPT0Q6IERvbid0IGF3YWl0IGFsbCBvdmVyIHRoZSBwbGFjZTsgc2F2ZSB0aGVtIHVwIGZvclxuICAgICAgICAvLyB0aGUgZW5kIGZvciBiZXR0ZXIgYmF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBpbmRleF9qc18zLnJlc29sdmVQcm9wZXJ0aWVzKShwb3ApO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZUdhcyh0eCkge1xuICAgICAgICByZXR1cm4gY2hlY2tQcm92aWRlcih0aGlzLCBcImVzdGltYXRlR2FzXCIpLmVzdGltYXRlR2FzKGF3YWl0IHRoaXMucG9wdWxhdGVDYWxsKHR4KSk7XG4gICAgfVxuICAgIGFzeW5jIGNhbGwodHgpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvdmlkZXIodGhpcywgXCJjYWxsXCIpLmNhbGwoYXdhaXQgdGhpcy5wb3B1bGF0ZUNhbGwodHgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGNoZWNrUHJvdmlkZXIodGhpcywgXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBjaGVja1Byb3ZpZGVyKHRoaXMsIFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBwb3AgPSBhd2FpdCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICBkZWxldGUgcG9wLmZyb207XG4gICAgICAgIGNvbnN0IHR4T2JqID0gaW5kZXhfanNfMi5UcmFuc2FjdGlvbi5mcm9tKHBvcCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eE9iaikpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RTaWduZXIgPSBBYnN0cmFjdFNpZ25lcjtcbi8qKlxuICogIEEgKipWb2lkU2lnbmVyKiogaXMgYSBjbGFzcyBkZWlzZ25lZCB0byBhbGxvdyBhbiBhZGRyZXNzIHRvIGJlIHVzZWRcbiAqICBpbiBhbnkgQVBJIHdoaWNoIGFjY2VwdHMgYSBTaWduZXIsIGJ1dCBmb3Igd2hpY2ggdGhlcmUgYXJlIG5vXG4gKiAgY3JlZGVudGlhbHMgYXZhaWxhYmxlIHRvIHBlcmZvcm0gYW55IGFjdHVhbCBzaWduaW5nLlxuICpcbiAqICBUaGlzIGZvciBleGFtcGxlIGFsbG93IGltcGVyc29uYXRpbmcgYW4gYWNjb3VudCBmb3IgdGhlIHB1cnBvc2Ugb2ZcbiAqICBzdGF0aWMgY2FsbHMgb3IgZXN0aW1hdGluZyBnYXMsIGJ1dCBkb2VzIG5vdCBhbGxvdyBzZW5kaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIEFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25lciBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipWb2lkU2lnbmVyKiogd2l0aCAlJWFkZHJlc3MlJSBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFkZHJlc3MgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFkZHJlc3MoKSB7IHJldHVybiB0aGlzLmFkZHJlc3M7IH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVm9pZFNpZ25lcih0aGlzLmFkZHJlc3MsIHByb3ZpZGVyKTtcbiAgICB9XG4gICAgI3Rocm93VW5zdXBwb3J0ZWQoc3VmZml4LCBvcGVyYXRpb24pIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KShmYWxzZSwgYFZvaWRTaWduZXIgY2Fubm90IHNpZ24gJHtzdWZmaXh9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb24gfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0eCkge1xuICAgICAgICB0aGlzLiN0aHJvd1Vuc3VwcG9ydGVkKFwidHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJtZXNzYWdlc1wiLCBcInNpZ25NZXNzYWdlXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3Rocm93VW5zdXBwb3J0ZWQoXCJ0eXBlZC1kYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG59XG5leHBvcnRzLlZvaWRTaWduZXIgPSBWb2lkU2lnbmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJzdHJhY3Qtc2lnbmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlZvaWRTaWduZXIiLCJBYnN0cmFjdFNpZ25lciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJwcm92aWRlcl9qc18xIiwiY2hlY2tQcm92aWRlciIsInNpZ25lciIsIm9wZXJhdGlvbiIsInByb3ZpZGVyIiwiYXNzZXJ0IiwicG9wdWxhdGUiLCJ0eCIsInBvcCIsImNvcHlSZXF1ZXN0IiwidG8iLCJyZXNvbHZlQWRkcmVzcyIsImZyb20iLCJQcm9taXNlIiwiYWxsIiwiZ2V0QWRkcmVzcyIsInRoZW4iLCJhZGRyZXNzIiwiYXNzZXJ0QXJndW1lbnQiLCJ0b0xvd2VyQ2FzZSIsInJlc29sdmVQcm9wZXJ0aWVzIiwiY29uc3RydWN0b3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZ2V0Tm9uY2UiLCJibG9ja1RhZyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJwb3B1bGF0ZUNhbGwiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwibm9uY2UiLCJnYXNMaW1pdCIsImVzdGltYXRlR2FzIiwibmV0d29yayIsImdldE5ldHdvcmsiLCJjaGFpbklkIiwiZ2V0QmlnSW50IiwiaGFzRWlwMTU1OSIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZ2FzUHJpY2UiLCJ0eXBlIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJjYWxsIiwicmVzb2x2ZU5hbWUiLCJuYW1lIiwic2VuZFRyYW5zYWN0aW9uIiwidHhPYmoiLCJUcmFuc2FjdGlvbiIsImJyb2FkY2FzdFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwiY29ubmVjdCIsInRocm93VW5zdXBwb3J0ZWQiLCJzdWZmaXgiLCJzaWduTWVzc2FnZSIsIm1lc3NhZ2UiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/community.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n *  There are many awesome community services that provide Ethereum\n *  nodes both for developers just starting out and for large-scale\n *  communities.\n *\n *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.showThrottleMessage = void 0;\n// Show the throttle message only once per service\nconst shown = new Set();\n/**\n *  Displays a warning in tht console when the community resource is\n *  being used too heavily by the app, recommending the developer\n *  acquire their own credentials instead of using the community\n *  credentials.\n *\n *  The notification will only occur once per service.\n */ function showThrottleMessage(service) {\n    if (shown.has(service)) {\n        return;\n    }\n    shown.add(service);\n    console.log(\"========= NOTICE =========\");\n    console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https://docs.ethers.org/api-keys/\");\n    console.log(\"==========================\");\n}\nexports.showThrottleMessage = showThrottleMessage; //# sourceMappingURL=community.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvY29tbXVuaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7OztDQU1DLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBRyxLQUFLO0FBQ25DLGtEQUFrRDtBQUNsRCxNQUFNRyxRQUFRLElBQUlDO0FBQ2xCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRixvQkFBb0JHLE9BQU87SUFDaEMsSUFBSUYsTUFBTUcsR0FBRyxDQUFDRCxVQUFVO1FBQ3BCO0lBQ0o7SUFDQUYsTUFBTUksR0FBRyxDQUFDRjtJQUNWRyxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDLENBQUMsMEJBQTBCLEVBQUVKLFFBQVEsb0NBQW9DLENBQUM7SUFDdEZHLFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztBQUNoQjtBQUNBVCwyQkFBMkIsR0FBR0UscUJBQzlCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9jb21tdW5pdHkuanM/M2IzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZXJlIGFyZSBtYW55IGF3ZXNvbWUgY29tbXVuaXR5IHNlcnZpY2VzIHRoYXQgcHJvdmlkZSBFdGhlcmV1bVxuICogIG5vZGVzIGJvdGggZm9yIGRldmVsb3BlcnMganVzdCBzdGFydGluZyBvdXQgYW5kIGZvciBsYXJnZS1zY2FsZVxuICogIGNvbW11bml0aWVzLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTogQ29tbXVuaXR5IFByb3ZpZGVycyAgW3RoaXJkcGFydHldXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IHZvaWQgMDtcbi8vIFNob3cgdGhlIHRocm90dGxlIG1lc3NhZ2Ugb25seSBvbmNlIHBlciBzZXJ2aWNlXG5jb25zdCBzaG93biA9IG5ldyBTZXQoKTtcbi8qKlxuICogIERpc3BsYXlzIGEgd2FybmluZyBpbiB0aHQgY29uc29sZSB3aGVuIHRoZSBjb21tdW5pdHkgcmVzb3VyY2UgaXNcbiAqICBiZWluZyB1c2VkIHRvbyBoZWF2aWx5IGJ5IHRoZSBhcHAsIHJlY29tbWVuZGluZyB0aGUgZGV2ZWxvcGVyXG4gKiAgYWNxdWlyZSB0aGVpciBvd24gY3JlZGVudGlhbHMgaW5zdGVhZCBvZiB1c2luZyB0aGUgY29tbXVuaXR5XG4gKiAgY3JlZGVudGlhbHMuXG4gKlxuICogIFRoZSBub3RpZmljYXRpb24gd2lsbCBvbmx5IG9jY3VyIG9uY2UgcGVyIHNlcnZpY2UuXG4gKi9cbmZ1bmN0aW9uIHNob3dUaHJvdHRsZU1lc3NhZ2Uoc2VydmljZSkge1xuICAgIGlmIChzaG93bi5oYXMoc2VydmljZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaG93bi5hZGQoc2VydmljZSk7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT0gTk9USUNFID09PT09PT09PVwiKTtcbiAgICBjb25zb2xlLmxvZyhgUmVxdWVzdC1SYXRlIEV4Y2VlZGVkIGZvciAke3NlcnZpY2V9ICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpYCk7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJUaGUgZGVmYXVsdCBBUEkga2V5cyBmb3IgZWFjaCBzZXJ2aWNlIGFyZSBwcm92aWRlZCBhcyBhIGhpZ2hseS10aHJvdHRsZWQsXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiY29tbXVuaXR5IHJlc291cmNlIGZvciBsb3ctdHJhZmZpYyBwcm9qZWN0cyBhbmQgZWFybHkgcHJvdG90eXBpbmcuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiV2hpbGUgeW91ciBhcHBsaWNhdGlvbiB3aWxsIGNvbnRpbnVlIHRvIGZ1bmN0aW9uLCB3ZSBoaWdobHkgcmVjb21tZW5kZWRcIik7XG4gICAgY29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBpbmNyZWFzZSB5b3VyXCIpO1xuICAgIGNvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovXFwvZG9jcy5ldGhlcnMub3JnL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gc2hvd1Rocm90dGxlTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW11bml0eS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaG93VGhyb3R0bGVNZXNzYWdlIiwic2hvd24iLCJTZXQiLCJzZXJ2aWNlIiwiaGFzIiwiYWRkIiwiY29uc29sZSIsImxvZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/default-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/default-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDefaultProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\");\nconst provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\");\nconst provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\");\nconst provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\");\nconst provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\");\n//import { PocketProvider } from \"./provider-pocket.js\";\nconst provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\");\nconst provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nfunction isWebSocketLike(value) {\n    return value && typeof value.send === \"function\" && typeof value.close === \"function\";\n}\nconst Testnets = \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\" \");\n/**\n *  Returns a default provider for %%network%%.\n *\n *  If %%network%% is a [[WebSocketLike]] or string that begins with\n *  ``\"ws:\"`` or ``\"wss:\"``, a [[WebSocketProvider]] is returned backed\n *  by that WebSocket or URL.\n *\n *  If %%network%% is a string that begins with ``\"HTTP:\"`` or ``\"HTTPS:\"``,\n *  a [[JsonRpcProvider]] is returned connected to that URL.\n *\n *  Otherwise, a default provider is created backed by well-known public\n *  Web3 backends (such as [[link-infura]]) using community-provided API\n *  keys.\n *\n *  The %%options%% allows specifying custom API keys per backend (setting\n *  an API key to ``\"-\"`` will omit that provider) and ``options.exclusive``\n *  can be set to either a backend name or and array of backend names, which\n *  will whitelist **only** those backends.\n *\n *  Current backend strings supported are:\n *  - ``\"alchemy\"``\n *  - ``\"ankr\"``\n *  - ``\"cloudflare\"``\n *  - ``\"etherscan\"``\n *  - ``\"infura\"``\n *  - ``\"publicPolygon\"``\n *  - ``\"quicknode\"``\n *\n *  @example:\n *    // Connect to a local Geth node\n *    provider = getDefaultProvider(\"http://localhost:8545/\");\n *\n *    // Connect to Ethereum mainnet with any current and future\n *    // third-party services available\n *    provider = getDefaultProvider(\"mainnet\");\n *\n *    // Connect to Polygoin, but only allow Etherscan and\n *    // INFURA and use \"MY_API_KEY\" in calls to Etherscan.\n *    provider = getDefaultProvider(\"matic\", {\n *      etherscan: \"MY_API_KEY\",\n *      exclusive: [ \"etherscan\", \"infura\" ]\n *    });\n */ function getDefaultProvider(network, options) {\n    if (options == null) {\n        options = {};\n    }\n    const allowService = (name)=>{\n        if (options[name] === \"-\") {\n            return false;\n        }\n        if (typeof options.exclusive === \"string\") {\n            return name === options.exclusive;\n        }\n        if (Array.isArray(options.exclusive)) {\n            return options.exclusive.indexOf(name) !== -1;\n        }\n        return true;\n    };\n    if (typeof network === \"string\" && network.match(/^https?:/)) {\n        return new provider_jsonrpc_js_1.JsonRpcProvider(network);\n    }\n    if (typeof network === \"string\" && network.match(/^wss?:/) || isWebSocketLike(network)) {\n        return new provider_websocket_js_1.WebSocketProvider(network);\n    }\n    // Get the network and name, if possible\n    let staticNetwork = null;\n    try {\n        staticNetwork = network_js_1.Network.from(network);\n    } catch (error) {}\n    const providers = [];\n    if (allowService(\"publicPolygon\") && staticNetwork) {\n        if (staticNetwork.name === \"matic\") {\n            providers.push(new provider_jsonrpc_js_1.JsonRpcProvider(\"https://polygon-rpc.com/\", staticNetwork, {\n                staticNetwork\n            }));\n        }\n    }\n    if (allowService(\"alchemy\")) {\n        try {\n            providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));\n        } catch (error) {}\n    }\n    if (allowService(\"ankr\") && options.ankr != null) {\n        try {\n            providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));\n        } catch (error) {}\n    }\n    if (allowService(\"cloudflare\")) {\n        try {\n            providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));\n        } catch (error) {}\n    }\n    if (allowService(\"etherscan\")) {\n        try {\n            providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));\n        } catch (error) {}\n    }\n    if (allowService(\"infura\")) {\n        try {\n            let projectId = options.infura;\n            let projectSecret = undefined;\n            if (typeof projectId === \"object\") {\n                projectSecret = projectId.projectSecret;\n                projectId = projectId.projectId;\n            }\n            providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));\n        } catch (error) {}\n    }\n    /*\n        if (options.pocket !== \"-\") {\n            try {\n                let appId = options.pocket;\n                let secretKey: undefined | string = undefined;\n                let loadBalancer: undefined | boolean = undefined;\n                if (typeof(appId) === \"object\") {\n                    loadBalancer = !!appId.loadBalancer;\n                    secretKey = appId.secretKey;\n                    appId = appId.appId;\n                }\n                providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));\n            } catch (error) { console.log(error); }\n        }\n    */ if (allowService(\"quicknode\")) {\n        try {\n            let token = options.quicknode;\n            providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));\n        } catch (error) {}\n    }\n    (0, index_js_1.assert)(providers.length, \"unsupported default network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getDefaultProvider\"\n    });\n    // No need for a FallbackProvider\n    if (providers.length === 1) {\n        return providers[0];\n    }\n    // We use the floor because public third-party providers can be unreliable,\n    // so a low number of providers with a large quorum will fail too often\n    let quorum = Math.floor(providers.length / 2);\n    if (quorum > 2) {\n        quorum = 2;\n    }\n    // Testnets don't need as strong a security gaurantee and speed is\n    // more useful during testing\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\n        quorum = 1;\n    }\n    // Provided override qorum takes priority\n    if (options && options.quorum) {\n        quorum = options.quorum;\n    }\n    return new provider_fallback_js_1.FallbackProvider(providers, undefined, {\n        quorum\n    });\n}\nexports.getDefaultProvider = getDefaultProvider; //# sourceMappingURL=default-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZGVmYXVsdC1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMscUJBQXFCRCxtQkFBT0EsQ0FBQywrRkFBb0I7QUFDdkQsTUFBTUUsd0JBQXdCRixtQkFBT0EsQ0FBQyxxR0FBdUI7QUFDN0QsTUFBTUcsMkJBQTJCSCxtQkFBT0EsQ0FBQywyR0FBMEI7QUFDbkUsTUFBTUksMEJBQTBCSixtQkFBT0EsQ0FBQyx5R0FBeUI7QUFDakUsTUFBTUssdUJBQXVCTCxtQkFBT0EsQ0FBQyxtR0FBc0I7QUFDM0Qsd0RBQXdEO0FBQ3hELE1BQU1NLDBCQUEwQk4sbUJBQU9BLENBQUMseUdBQXlCO0FBQ2pFLE1BQU1PLHlCQUF5QlAsbUJBQU9BLENBQUMsdUdBQXdCO0FBQy9ELE1BQU1RLHdCQUF3QlIsbUJBQU9BLENBQUMscUdBQXVCO0FBQzdELE1BQU1TLGVBQWVULG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1VLDBCQUEwQlYsbUJBQU9BLENBQUMseUdBQXlCO0FBQ2pFLFNBQVNXLGdCQUFnQmQsS0FBSztJQUMxQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1lLElBQUksS0FBTSxjQUNyQyxPQUFRZixNQUFNZ0IsS0FBSyxLQUFNO0FBQ2pDO0FBQ0EsTUFBTUMsV0FBVyxzRkFBc0ZDLEtBQUssQ0FBQztBQUM3Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMENDLEdBQ0QsU0FBU2pCLG1CQUFtQmtCLE9BQU8sRUFBRUMsT0FBTztJQUN4QyxJQUFJQSxXQUFXLE1BQU07UUFDakJBLFVBQVUsQ0FBQztJQUNmO0lBQ0EsTUFBTUMsZUFBZSxDQUFDQztR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akMsSUFBSW5CLFVBQVVrQixNQUFNLEtBQUssR0FBRztRQUN4QixPQUFPbEIsU0FBUyxDQUFDLEVBQUU7SUFDdkI7SUFDQSwyRUFBMkU7SUFDM0UsdUVBQXVFO0lBQ3ZFLElBQUlvQixTQUFTQyxLQUFLQyxLQUFLLENBQUN0QixVQUFVa0IsTUFBTSxHQUFHO0lBQzNDLElBQUlFLFNBQVMsR0FBRztRQUNaQSxTQUFTO0lBQ2I7SUFDQSxrRUFBa0U7SUFDbEUsNkJBQTZCO0lBQzdCLElBQUl4QixpQkFBaUJiLFNBQVNTLE9BQU8sQ0FBQ0ksY0FBY1IsSUFBSSxNQUFNLENBQUMsR0FBRztRQUM5RGdDLFNBQVM7SUFDYjtJQUNBLHlDQUF5QztJQUN6QyxJQUFJbEMsV0FBV0EsUUFBUWtDLE1BQU0sRUFBRTtRQUMzQkEsU0FBU2xDLFFBQVFrQyxNQUFNO0lBQzNCO0lBQ0EsT0FBTyxJQUFJNUMsdUJBQXVCK0MsZ0JBQWdCLENBQUN2QixXQUFXWSxXQUFXO1FBQUVRO0lBQU87QUFDdEY7QUFDQXZELDBCQUEwQixHQUFHRSxvQkFDN0IsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL2RlZmF1bHQtcHJvdmlkZXIuanM/ZTliNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2Fua3JfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWFua3IuanNcIik7XG5jb25zdCBwcm92aWRlcl9hbGNoZW15X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1hbGNoZW15LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfY2xvdWRmbGFyZV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItY2xvdWRmbGFyZS5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZXRoZXJzY2FuLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfaW5mdXJhX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1pbmZ1cmEuanNcIik7XG4vL2ltcG9ydCB7IFBvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vcHJvdmlkZXItcG9ja2V0LmpzXCI7XG5jb25zdCBwcm92aWRlcl9xdWlja25vZGVfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXF1aWNrbm9kZS5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2ZhbGxiYWNrX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1mYWxsYmFjay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci13ZWJzb2NrZXQuanNcIik7XG5mdW5jdGlvbiBpc1dlYlNvY2tldExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUuc2VuZCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgKHZhbHVlLmNsb3NlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmNvbnN0IFRlc3RuZXRzID0gXCJnb2VybGkga292YW4gc2Vwb2xpYSBjbGFzc2ljS290dGkgb3B0aW1pc20tZ29lcmxpIGFyYml0cnVtLWdvZXJsaSBtYXRpYy1tdW1iYWkgYm5idFwiLnNwbGl0KFwiIFwiKTtcbi8qKlxuICogIFJldHVybnMgYSBkZWZhdWx0IHByb3ZpZGVyIGZvciAlJW5ldHdvcmslJS5cbiAqXG4gKiAgSWYgJSVuZXR3b3JrJSUgaXMgYSBbW1dlYlNvY2tldExpa2VdXSBvciBzdHJpbmcgdGhhdCBiZWdpbnMgd2l0aFxuICogIGBgXCJ3czpcImBgIG9yIGBgXCJ3c3M6XCJgYCwgYSBbW1dlYlNvY2tldFByb3ZpZGVyXV0gaXMgcmV0dXJuZWQgYmFja2VkXG4gKiAgYnkgdGhhdCBXZWJTb2NrZXQgb3IgVVJMLlxuICpcbiAqICBJZiAlJW5ldHdvcmslJSBpcyBhIHN0cmluZyB0aGF0IGJlZ2lucyB3aXRoIGBgXCJIVFRQOlwiYGAgb3IgYGBcIkhUVFBTOlwiYGAsXG4gKiAgYSBbW0pzb25ScGNQcm92aWRlcl1dIGlzIHJldHVybmVkIGNvbm5lY3RlZCB0byB0aGF0IFVSTC5cbiAqXG4gKiAgT3RoZXJ3aXNlLCBhIGRlZmF1bHQgcHJvdmlkZXIgaXMgY3JlYXRlZCBiYWNrZWQgYnkgd2VsbC1rbm93biBwdWJsaWNcbiAqICBXZWIzIGJhY2tlbmRzIChzdWNoIGFzIFtbbGluay1pbmZ1cmFdXSkgdXNpbmcgY29tbXVuaXR5LXByb3ZpZGVkIEFQSVxuICogIGtleXMuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBhbGxvd3Mgc3BlY2lmeWluZyBjdXN0b20gQVBJIGtleXMgcGVyIGJhY2tlbmQgKHNldHRpbmdcbiAqICBhbiBBUEkga2V5IHRvIGBgXCItXCJgYCB3aWxsIG9taXQgdGhhdCBwcm92aWRlcikgYW5kIGBgb3B0aW9ucy5leGNsdXNpdmVgYFxuICogIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGEgYmFja2VuZCBuYW1lIG9yIGFuZCBhcnJheSBvZiBiYWNrZW5kIG5hbWVzLCB3aGljaFxuICogIHdpbGwgd2hpdGVsaXN0ICoqb25seSoqIHRob3NlIGJhY2tlbmRzLlxuICpcbiAqICBDdXJyZW50IGJhY2tlbmQgc3RyaW5ncyBzdXBwb3J0ZWQgYXJlOlxuICogIC0gYGBcImFsY2hlbXlcImBgXG4gKiAgLSBgYFwiYW5rclwiYGBcbiAqICAtIGBgXCJjbG91ZGZsYXJlXCJgYFxuICogIC0gYGBcImV0aGVyc2NhblwiYGBcbiAqICAtIGBgXCJpbmZ1cmFcImBgXG4gKiAgLSBgYFwicHVibGljUG9seWdvblwiYGBcbiAqICAtIGBgXCJxdWlja25vZGVcImBgXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgLy8gQ29ubmVjdCB0byBhIGxvY2FsIEdldGggbm9kZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJodHRwOi8vbG9jYWxob3N0Ojg1NDUvXCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gRXRoZXJldW0gbWFpbm5ldCB3aXRoIGFueSBjdXJyZW50IGFuZCBmdXR1cmVcbiAqICAgIC8vIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGF2YWlsYWJsZVxuICogICAgcHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXIoXCJtYWlubmV0XCIpO1xuICpcbiAqICAgIC8vIENvbm5lY3QgdG8gUG9seWdvaW4sIGJ1dCBvbmx5IGFsbG93IEV0aGVyc2NhbiBhbmRcbiAqICAgIC8vIElORlVSQSBhbmQgdXNlIFwiTVlfQVBJX0tFWVwiIGluIGNhbGxzIHRvIEV0aGVyc2Nhbi5cbiAqICAgIHByb3ZpZGVyID0gZ2V0RGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIiwge1xuICogICAgICBldGhlcnNjYW46IFwiTVlfQVBJX0tFWVwiLFxuICogICAgICBleGNsdXNpdmU6IFsgXCJldGhlcnNjYW5cIiwgXCJpbmZ1cmFcIiBdXG4gKiAgICB9KTtcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dTZXJ2aWNlID0gKG5hbWUpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5leGNsdXNpdmUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IG9wdGlvbnMuZXhjbHVzaXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV4Y2x1c2l2ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucy5leGNsdXNpdmUuaW5kZXhPZihuYW1lKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgJiYgbmV0d29yay5tYXRjaCgvXmh0dHBzPzovKSkge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIobmV0d29yayk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiICYmIG5ldHdvcmsubWF0Y2goL153c3M/Oi8pIHx8IGlzV2ViU29ja2V0TGlrZShuZXR3b3JrKSkge1xuICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVyX3dlYnNvY2tldF9qc18xLldlYlNvY2tldFByb3ZpZGVyKG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIG5ldHdvcmsgYW5kIG5hbWUsIGlmIHBvc3NpYmxlXG4gICAgbGV0IHN0YXRpY05ldHdvcmsgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHN0YXRpY05ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKG5ldHdvcmspO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIGNvbnN0IHByb3ZpZGVycyA9IFtdO1xuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJwdWJsaWNQb2x5Z29uXCIpICYmIHN0YXRpY05ldHdvcmspIHtcbiAgICAgICAgaWYgKHN0YXRpY05ldHdvcmsubmFtZSA9PT0gXCJtYXRpY1wiKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlcihcImh0dHBzOi9cXC9wb2x5Z29uLXJwYy5jb20vXCIsIHN0YXRpY05ldHdvcmssIHsgc3RhdGljTmV0d29yayB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbG93U2VydmljZShcImFsY2hlbXlcIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBwcm92aWRlcl9hbGNoZW15X2pzXzEuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJhbmtyXCIpICYmIG9wdGlvbnMuYW5rciAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgcHJvdmlkZXJfYW5rcl9qc18xLkFua3JQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFua3IpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dTZXJ2aWNlKFwiY2xvdWRmbGFyZVwiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2Nsb3VkZmxhcmVfanNfMS5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJldGhlcnNjYW5cIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBwcm92aWRlcl9ldGhlcnNjYW5fanNfMS5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJpbmZ1cmFcIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwcm9qZWN0SWQgPSBvcHRpb25zLmluZnVyYTtcbiAgICAgICAgICAgIGxldCBwcm9qZWN0U2VjcmV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAocHJvamVjdElkKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHByb2plY3RTZWNyZXQgPSBwcm9qZWN0SWQucHJvamVjdFNlY3JldDtcbiAgICAgICAgICAgICAgICBwcm9qZWN0SWQgPSBwcm9qZWN0SWQucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX2luZnVyYV9qc18xLkluZnVyYVByb3ZpZGVyKG5ldHdvcmssIHByb2plY3RJZCwgcHJvamVjdFNlY3JldCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIC8qXG4gICAgICAgIGlmIChvcHRpb25zLnBvY2tldCAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGFwcElkID0gb3B0aW9ucy5wb2NrZXQ7XG4gICAgICAgICAgICAgICAgbGV0IHNlY3JldEtleTogdW5kZWZpbmVkIHwgc3RyaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBsb2FkQmFsYW5jZXI6IHVuZGVmaW5lZCB8IGJvb2xlYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhcHBJZCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEJhbGFuY2VyID0gISFhcHBJZC5sb2FkQmFsYW5jZXI7XG4gICAgICAgICAgICAgICAgICAgIHNlY3JldEtleSA9IGFwcElkLnNlY3JldEtleTtcbiAgICAgICAgICAgICAgICAgICAgYXBwSWQgPSBhcHBJZC5hcHBJZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IFBvY2tldFByb3ZpZGVyKG5ldHdvcmssIGFwcElkLCBzZWNyZXRLZXksIGxvYWRCYWxhbmNlcikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgY29uc29sZS5sb2coZXJyb3IpOyB9XG4gICAgICAgIH1cbiAgICAqL1xuICAgIGlmIChhbGxvd1NlcnZpY2UoXCJxdWlja25vZGVcIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IG9wdGlvbnMucXVpY2tub2RlO1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IHByb3ZpZGVyX3F1aWNrbm9kZV9qc18xLlF1aWNrTm9kZVByb3ZpZGVyKG5ldHdvcmssIHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShwcm92aWRlcnMubGVuZ3RoLCBcInVuc3VwcG9ydGVkIGRlZmF1bHQgbmV0d29ya1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIlxuICAgIH0pO1xuICAgIC8vIE5vIG5lZWQgZm9yIGEgRmFsbGJhY2tQcm92aWRlclxuICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwcm92aWRlcnNbMF07XG4gICAgfVxuICAgIC8vIFdlIHVzZSB0aGUgZmxvb3IgYmVjYXVzZSBwdWJsaWMgdGhpcmQtcGFydHkgcHJvdmlkZXJzIGNhbiBiZSB1bnJlbGlhYmxlLFxuICAgIC8vIHNvIGEgbG93IG51bWJlciBvZiBwcm92aWRlcnMgd2l0aCBhIGxhcmdlIHF1b3J1bSB3aWxsIGZhaWwgdG9vIG9mdGVuXG4gICAgbGV0IHF1b3J1bSA9IE1hdGguZmxvb3IocHJvdmlkZXJzLmxlbmd0aCAvIDIpO1xuICAgIGlmIChxdW9ydW0gPiAyKSB7XG4gICAgICAgIHF1b3J1bSA9IDI7XG4gICAgfVxuICAgIC8vIFRlc3RuZXRzIGRvbid0IG5lZWQgYXMgc3Ryb25nIGEgc2VjdXJpdHkgZ2F1cmFudGVlIGFuZCBzcGVlZCBpc1xuICAgIC8vIG1vcmUgdXNlZnVsIGR1cmluZyB0ZXN0aW5nXG4gICAgaWYgKHN0YXRpY05ldHdvcmsgJiYgVGVzdG5ldHMuaW5kZXhPZihzdGF0aWNOZXR3b3JrLm5hbWUpICE9PSAtMSkge1xuICAgICAgICBxdW9ydW0gPSAxO1xuICAgIH1cbiAgICAvLyBQcm92aWRlZCBvdmVycmlkZSBxb3J1bSB0YWtlcyBwcmlvcml0eVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucXVvcnVtKSB7XG4gICAgICAgIHF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHByb3ZpZGVyX2ZhbGxiYWNrX2pzXzEuRmFsbGJhY2tQcm92aWRlcihwcm92aWRlcnMsIHVuZGVmaW5lZCwgeyBxdW9ydW0gfSk7XG59XG5leHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGdldERlZmF1bHRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0RGVmYXVsdFByb3ZpZGVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJwcm92aWRlcl9hbmtyX2pzXzEiLCJwcm92aWRlcl9hbGNoZW15X2pzXzEiLCJwcm92aWRlcl9jbG91ZGZsYXJlX2pzXzEiLCJwcm92aWRlcl9ldGhlcnNjYW5fanNfMSIsInByb3ZpZGVyX2luZnVyYV9qc18xIiwicHJvdmlkZXJfcXVpY2tub2RlX2pzXzEiLCJwcm92aWRlcl9mYWxsYmFja19qc18xIiwicHJvdmlkZXJfanNvbnJwY19qc18xIiwibmV0d29ya19qc18xIiwicHJvdmlkZXJfd2Vic29ja2V0X2pzXzEiLCJpc1dlYlNvY2tldExpa2UiLCJzZW5kIiwiY2xvc2UiLCJUZXN0bmV0cyIsInNwbGl0IiwibmV0d29yayIsIm9wdGlvbnMiLCJhbGxvd1NlcnZpY2UiLCJuYW1lIiwiZXhjbHVzaXZlIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5kZXhPZiIsIm1hdGNoIiwiSnNvblJwY1Byb3ZpZGVyIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJzdGF0aWNOZXR3b3JrIiwiTmV0d29yayIsImZyb20iLCJlcnJvciIsInByb3ZpZGVycyIsInB1c2giLCJBbGNoZW15UHJvdmlkZXIiLCJhbGNoZW15IiwiYW5rciIsIkFua3JQcm92aWRlciIsIkNsb3VkZmxhcmVQcm92aWRlciIsIkV0aGVyc2NhblByb3ZpZGVyIiwiZXRoZXJzY2FuIiwicHJvamVjdElkIiwiaW5mdXJhIiwicHJvamVjdFNlY3JldCIsInVuZGVmaW5lZCIsIkluZnVyYVByb3ZpZGVyIiwidG9rZW4iLCJxdWlja25vZGUiLCJRdWlja05vZGVQcm92aWRlciIsImFzc2VydCIsImxlbmd0aCIsIm9wZXJhdGlvbiIsInF1b3J1bSIsIk1hdGgiLCJmbG9vciIsIkZhbGxiYWNrUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/default-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/ens-resolver.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../constants/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/constants/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../contract/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        (0, index_js_5.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */ class MulticoinProviderPlugin {\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */ constructor(name){\n        (0, index_js_5.defineProperties)(this, {\n            name\n        });\n    }\n    connect(proivder) {\n        return this;\n    }\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */ supportsCoinType(coinType) {\n        return false;\n    }\n    /**\n     *  Resovles to the encoded %%address%% for %%coinType%%.\n     */ async encodeAddress(coinType, address) {\n        throw new Error(\"unsupported coin\");\n    }\n    /**\n     *  Resovles to the decoded %%data%% for %%coinType%%.\n     */ async decodeAddress(coinType, data) {\n        throw new Error(\"unsupported coin\");\n    }\n}\nexports.MulticoinProviderPlugin = MulticoinProviderPlugin;\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */ class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */ constructor(){\n        super(BasicMulticoinPluginId);\n    }\n}\nexports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */ class EnsResolver {\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544;\n    #resolver;\n    constructor(provider, address, name){\n        (0, index_js_5.defineProperties)(this, {\n            provider,\n            address,\n            name\n        });\n        this.#supports2544 = null;\n        this.#resolver = new index_js_3.Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\"\n        ], provider);\n    }\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */ async supportsWildcard() {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async ()=>{\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if ((0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                        return false;\n                    }\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n                    throw error;\n                }\n            })();\n        }\n        return await this.#supports2544;\n    }\n    async #fetch(funcName, params) {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n        // The first parameters is always the nodehash\n        params.unshift((0, index_js_4.namehash)(this.name));\n        let fragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            (0, index_js_5.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: {\n                    funcName\n                }\n            });\n            params = [\n                (0, index_js_4.dnsEncode)(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n            funcName = \"resolve(bytes,bytes)\";\n        }\n        params.push({\n            enableCcipRead: true\n        });\n        try {\n            const result = await this.#resolver[funcName](...params);\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n            return result;\n        } catch (error) {\n            if (!(0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                throw error;\n            }\n        }\n        return null;\n    }\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */ async getAddress(coinType) {\n        if (coinType == null) {\n            coinType = 60;\n        }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n                // No address\n                if (result == null || result === index_js_2.ZeroAddress) {\n                    return null;\n                }\n                return result;\n            } catch (error) {\n                if ((0, index_js_5.isError)(error, \"CALL_EXCEPTION\")) {\n                    return null;\n                }\n                throw error;\n            }\n        }\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [\n                ethCoinType\n            ]);\n            if ((0, index_js_5.isHexString)(data, 20)) {\n                return (0, index_js_1.getAddress)(data);\n            }\n        }\n        let coinPlugin = null;\n        for (const plugin of this.provider.plugins){\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\n                continue;\n            }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n        if (coinPlugin == null) {\n            return null;\n        }\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [\n            coinType\n        ]);\n        // No address\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n        if (address != null) {\n            return address;\n        }\n        (0, index_js_5.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${coinType})`,\n            info: {\n                coinType,\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */ async getText(key) {\n        const data = await this.#fetch(\"text(bytes32,string)\", [\n            key\n        ]);\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        return data;\n    }\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */ async getContentHash() {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n        // No contenthash\n        if (data == null || data === \"0x\") {\n            return null;\n        }\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${scheme}:/\\/${(0, index_js_5.encodeBase58)(\"0x\" + ipfs[2])}`;\n            }\n        }\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${swarm[1]}`;\n        }\n        (0, index_js_5.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: {\n                data\n            }\n        });\n    }\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */ async getAvatar() {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */ async _getAvatar() {\n        const linkage = [\n            {\n                type: \"name\",\n                value: this.name\n            }\n        ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({\n                    type: \"!avatar\",\n                    value: \"\"\n                });\n                return {\n                    url: null,\n                    linkage\n                };\n            }\n            linkage.push({\n                type: \"avatar\",\n                value: avatar\n            });\n            for(let i = 0; i < matchers.length; i++){\n                const match = avatar.match(matchers[i]);\n                if (match == null) {\n                    continue;\n                }\n                const scheme = match[1].toLowerCase();\n                switch(scheme){\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({\n                            type: \"url\",\n                            value: avatar\n                        });\n                        return {\n                            linkage,\n                            url: avatar\n                        };\n                    case \"ipfs\":\n                        {\n                            const url = getIpfsLink(avatar);\n                            linkage.push({\n                                type: \"ipfs\",\n                                value: avatar\n                            });\n                            linkage.push({\n                                type: \"url\",\n                                value: url\n                            });\n                            return {\n                                linkage,\n                                url\n                            };\n                        }\n                    case \"erc721\":\n                    case \"erc1155\":\n                        {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n                            linkage.push({\n                                type: scheme,\n                                value: avatar\n                            });\n                            // The owner of this name\n                            const owner = await this.getAddress();\n                            if (owner == null) {\n                                linkage.push({\n                                    type: \"!owner\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                linkage.push({\n                                    type: `!${scheme}caip`,\n                                    value: match[2] || \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            const tokenId = comps[1];\n                            const contract = new index_js_3.Contract(comps[0], [\n                                // ERC-721\n                                \"function tokenURI(uint) view returns (string)\",\n                                \"function ownerOf(uint) view returns (address)\",\n                                // ERC-1155\n                                \"function uri(uint) view returns (string)\",\n                                \"function balanceOf(address, uint256) view returns (uint)\"\n                            ], this.provider);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                const tokenOwner = await contract.ownerOf(tokenId);\n                                if (owner !== tokenOwner) {\n                                    linkage.push({\n                                        type: \"!owner\",\n                                        value: tokenOwner\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"owner\",\n                                    value: tokenOwner\n                                });\n                            } else if (scheme === \"erc1155\") {\n                                const balance = await contract.balanceOf(owner, tokenId);\n                                if (!balance) {\n                                    linkage.push({\n                                        type: \"!balance\",\n                                        value: \"0\"\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"balance\",\n                                    value: balance.toString()\n                                });\n                            }\n                            // Call the token contract for the metadata URL\n                            let metadataUrl = await contract[selector](tokenId);\n                            if (metadataUrl == null || metadataUrl === \"0x\") {\n                                linkage.push({\n                                    type: \"!metadata-url\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata-url-base\",\n                                value: metadataUrl\n                            });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));\n                                linkage.push({\n                                    type: \"metadata-url-expanded\",\n                                    value: metadataUrl\n                                });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({\n                                type: \"metadata-url\",\n                                value: metadataUrl\n                            });\n                            // Get the token metadata\n                            let metadata = {};\n                            const response = await new index_js_5.FetchRequest(metadataUrl).send();\n                            response.assertOk();\n                            try {\n                                metadata = response.bodyJson;\n                            } catch (error) {\n                                try {\n                                    linkage.push({\n                                        type: \"!metadata\",\n                                        value: response.bodyText\n                                    });\n                                } catch (error) {\n                                    const bytes = response.body;\n                                    if (bytes) {\n                                        linkage.push({\n                                            type: \"!metadata\",\n                                            value: (0, index_js_5.hexlify)(bytes)\n                                        });\n                                    }\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (!metadata) {\n                                linkage.push({\n                                    type: \"!metadata\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            linkage.push({\n                                type: \"metadata\",\n                                value: JSON.stringify(metadata)\n                            });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof imageUrl !== \"string\") {\n                                linkage.push({\n                                    type: \"!imageUrl\",\n                                    value: \"\"\n                                });\n                                return {\n                                    url: null,\n                                    linkage\n                                };\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                            } else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    linkage.push({\n                                        type: \"!imageUrl-ipfs\",\n                                        value: imageUrl\n                                    });\n                                    return {\n                                        url: null,\n                                        linkage\n                                    };\n                                }\n                                linkage.push({\n                                    type: \"imageUrl-ipfs\",\n                                    value: imageUrl\n                                });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({\n                                type: \"url\",\n                                value: imageUrl\n                            });\n                            return {\n                                linkage,\n                                url: imageUrl\n                            };\n                        }\n                }\n            }\n        } catch (error) {}\n        return {\n            linkage,\n            url: null\n        };\n    }\n    static async getEnsAddress(provider) {\n        const network = await provider.getNetwork();\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n        // No ENS...\n        (0, index_js_5.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\",\n            info: {\n                network\n            }\n        });\n        return ensPlugin.address;\n    }\n    static async #getResolver(provider, name) {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n        try {\n            const contract = new index_js_3.Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n            const addr = await contract.resolver((0, index_js_4.namehash)(name), {\n                enableCcipRead: true\n            });\n            if (addr === index_js_2.ZeroAddress) {\n                return null;\n            }\n            return addr;\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n        return null;\n    }\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */ static async fromName(provider, name) {\n        let currentName = name;\n        while(true){\n            if (currentName === \"\" || currentName === \".\") {\n                return null;\n            }\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") {\n                return null;\n            }\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !await resolver.supportsWildcard()) {\n                    return null;\n                }\n                return resolver;\n            }\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\nexports.EnsResolver = EnsResolver; //# sourceMappingURL=ens-resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZW5zLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7O0NBS0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxvQ0FBb0MsR0FBR0EsK0JBQStCLEdBQUcsS0FBSztBQUNwRyxNQUFNSyxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEZBQXVCO0FBQ2xELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLHdGQUFzQjtBQUNqRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyxnRkFBa0I7QUFDN0MsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLHFEQUFxRDtBQUNyRCxpRUFBaUU7QUFDakUsU0FBU0ssWUFBWUMsSUFBSTtJQUNyQixJQUFJQSxLQUFLQyxLQUFLLENBQUMsc0JBQXNCO1FBQ2pDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSyxJQUFJRixLQUFLQyxLQUFLLENBQUMsZ0JBQWdCO1FBQ2hDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSztRQUNBLElBQUdKLFdBQVdLLGNBQWMsRUFBRSxPQUFPLDJCQUEyQixRQUFRSDtJQUM3RTtJQUNBLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsS0FBSyxDQUFDO0FBQ2xEOzs7QUFHQTs7Q0FFQyxHQUNELE1BQU1SO0lBS0Y7O0tBRUMsR0FDRFksWUFBWUMsSUFBSSxDQUFFO1FBQ2IsSUFBR1AsV0FBV1EsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQUVEO1FBQUs7SUFDbEQ7SUFDQUUsUUFBUUMsUUFBUSxFQUFFO1FBQ2QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEQyxpQkFBaUJDLFFBQVEsRUFBRTtRQUN2QixPQUFPO0lBQ1g7SUFDQTs7S0FFQyxH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MkI7WUFDM0IsTUFBTUE7UUFDVjtRQUNBLE9BQU87SUFDWDtJQUNBOzs7S0FHQyxHQUNELGFBQWFpRixTQUFTckYsUUFBUSxFQUFFakIsSUFBSSxFQUFFO1FBQ2xDLElBQUl1RyxjQUFjdkc7UUFDbEIsTUFBTyxLQUFNO1lBQ1QsSUFBSXVHLGdCQUFnQixNQUFNQSxnQkFBZ0IsS0FBSztnQkFDM0MsT0FBTztZQUNYO1lBQ0EseURBQXlEO1lBQ3pELCtCQUErQjtZQUMvQixJQUFJdkcsU0FBUyxTQUFTdUcsZ0JBQWdCLE9BQU87Z0JBQ3pDLE9BQU87WUFDWDtZQUNBLHdDQUF3QztZQUN4QyxNQUFNRixPQUFPLE1BQU1wSCxZQUFZLENBQUNrSCxXQUFXLENBQUNsRixVQUFVc0Y7WUFDdEQsb0JBQW9CO1lBQ3BCLElBQUlGLFFBQVEsTUFBTTtnQkFDZCxNQUFNckYsV0FBVyxJQUFJL0IsWUFBWWdDLFVBQVVvRixNQUFNckc7Z0JBQ2pELGdFQUFnRTtnQkFDaEUsSUFBSXVHLGdCQUFnQnZHLFFBQVEsQ0FBRSxNQUFNZ0IsU0FBU0csZ0JBQWdCLElBQUs7b0JBQzlELE9BQU87Z0JBQ1g7Z0JBQ0EsT0FBT0g7WUFDWDtZQUNBLHNCQUFzQjtZQUN0QnVGLGNBQWNBLFlBQVlsQyxLQUFLLENBQUMsS0FBSzNDLEtBQUssQ0FBQyxHQUFHOEUsSUFBSSxDQUFDO1FBQ3ZEO0lBQ0o7QUFDSjtBQUNBekgsbUJBQW1CLEdBQUdFLGFBQ3RCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXIuanM/NDk1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEVOUyBpcyBhIHNlcnZpY2Ugd2hpY2ggYWxsb3dzIGVhc3ktdG8tcmVtZW1iZXIgbmFtZXMgdG8gbWFwIHRvXG4gKiAgbmV0d29yayBhZGRyZXNzZXMuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9lbnMtcmVzb2x2ZXI6RU5TIFJlc29sdmVyICBbYWJvdXQtZW5zLXJzb2x2ZXJdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBleHBvcnRzLkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4gPSBleHBvcnRzLk11bHRpY29pblByb3ZpZGVyUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0L2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbi8vIEBUT0RPOiBUaGlzIHNob3VsZCB1c2UgdGhlIGZldGNoLWRhdGE6aXBmcyBnYXRld2F5XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbjtcbjtcbi8qKlxuICogIEEgcHJvdmlkZXIgcGx1Z2luIHN1cGVyLWNsYXNzIGZvciBwcm9jZXNzaW5nIG11bHRpY29pbiBhZGRyZXNzIHR5cGVzLlxuICovXG5jbGFzcyBNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBuYW1lLlxuICAgICAqL1xuICAgIG5hbWU7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipNdWx0aWNvaW5Qcm92aWRlclBsdWluZyoqIGZvciAlJW5hbWUlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgbmFtZSB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm9pdmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgJSVjb2luVHlwZSUlIGlzIHN1cHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgKi9cbiAgICBzdXBwb3J0c0NvaW5UeXBlKGNvaW5UeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc292bGVzIHRvIHRoZSBlbmNvZGVkICUlYWRkcmVzcyUlIGZvciAlJWNvaW5UeXBlJSUuXG4gICAgICovXG4gICAgYXN5bmMgZW5jb2RlQWRkcmVzcyhjb2luVHlwZSwgYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb3ZsZXMgdG8gdGhlIGRlY29kZWQgJSVkYXRhJSUgZm9yICUlY29pblR5cGUlJS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWNvZGVBZGRyZXNzKGNvaW5UeXBlLCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGNvaW5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbiA9IE11bHRpY29pblByb3ZpZGVyUGx1Z2luO1xuY29uc3QgQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCA9IFwib3JnLmV0aGVycy5wbHVnaW5zLnByb3ZpZGVyLkJhc2ljTXVsdGljb2luXCI7XG4vKipcbiAqICBBICoqQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbioqIHByb3ZpZGVzIHNlcnZpY2UgZm9yIGNvbW1vblxuICogIGNvaW4gdHlwZXMsIHdoaWNoIGRvIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgbGlicmFyaWVzIHRvIGVuY29kZSBvclxuICogIGRlY29kZS5cbiAqL1xuY2xhc3MgQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbiBleHRlbmRzIE11bHRpY29pblByb3ZpZGVyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkJhc2ljTXVsdGljb2luUHJvdmlkZXJQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoQmFzaWNNdWx0aWNvaW5QbHVnaW5JZCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luID0gQmFzaWNNdWx0aWNvaW5Qcm92aWRlclBsdWdpbjtcbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbi8qKlxuICogIEEgY29ubmVjdGVkIG9iamVjdCB0byBhIHJlc29sdmVkIEVOUyBuYW1lIHJlc29sdmVyLCB3aGljaCBjYW4gYmVcbiAqICB1c2VkIHRvIHF1ZXJ5IGFkZGl0aW9uYWwgZGV0YWlscy5cbiAqL1xuY2xhc3MgRW5zUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgY29ubmVjdGVkIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkcmVzcyBvZiB0aGUgcmVzb2x2ZXIuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgdGhpcyByZXNvbHZlciB3YXMgcmVzb2x2ZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8vIEZvciBFSVAtMjU0NCBuYW1lcywgdGhlIGFuY2VzdG9yIHRoYXQgcHJvdmlkZWQgdGhlIHJlc29sdmVyXG4gICAgI3N1cHBvcnRzMjU0NDtcbiAgICAjcmVzb2x2ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwcm92aWRlciwgYWRkcmVzcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZXIgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChhZGRyZXNzLCBbXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCkgdmlldyByZXR1cm5zIChib29sKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlKGJ5dGVzLCBieXRlcykgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gYWRkcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICBcImZ1bmN0aW9uIGFkZHIoYnl0ZXMzMiwgdWludCkgdmlldyByZXR1cm5zIChieXRlcylcIixcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gdGV4dChieXRlczMyLCBzdHJpbmcpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgXCJmdW5jdGlvbiBjb250ZW50aGFzaChieXRlczMyKSB2aWV3IHJldHVybnMgKGJ5dGVzKVwiLFxuICAgICAgICBdLCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0cnVlIGlmIHRoZSByZXNvbHZlciBzdXBwb3J0cyB3aWxkY2FyZCByZXNvbHV0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNzdXBwb3J0czI1NDQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jc3VwcG9ydHMyNTQ0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jcmVzb2x2ZXIuc3VwcG9ydHNJbnRlcmZhY2UoXCIweDkwNjFiOTIzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgcmVzb2x2ZXJzIG11c3QgdW5kZXJzdGFuZCBzdXBwb3J0c0ludGVyZmFjZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfNS5pc0Vycm9yKShlcnJvciwgXCJDQUxMX0VYQ0VQVElPTlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCBmdXR1cmUgYXR0ZW1wdHMgdHJ5IGFnYWluLi4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N1cHBvcnRzMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3N1cHBvcnRzMjU0NDtcbiAgICB9XG4gICAgYXN5bmMgI2ZldGNoKGZ1bmNOYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gKHBhcmFtcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaWZhY2UgPSB0aGlzLiNyZXNvbHZlci5pbnRlcmZhY2U7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXJzIGlzIGFsd2F5cyB0aGUgbm9kZWhhc2hcbiAgICAgICAgcGFyYW1zLnVuc2hpZnQoKDAsIGluZGV4X2pzXzQubmFtZWhhc2gpKHRoaXMubmFtZSkpO1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gaWZhY2UuZ2V0RnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmcmFnbWVudCwgXCJtaXNzaW5nIGZyYWdtZW50XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgaW5mbzogeyBmdW5jTmFtZSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5kbnNFbmNvZGUpKHRoaXMubmFtZSksXG4gICAgICAgICAgICAgICAgaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCBwYXJhbXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2goe1xuICAgICAgICAgICAgZW5hYmxlQ2NpcFJlYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXNvbHZlcltmdW5jTmFtZV0oLi4ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoISgwLCBpbmRleF9qc181LmlzRXJyb3IpKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYWRkcmVzcyBmb3IgJSVjb2luVHlwZSUlIG9yIG51bGwgaWYgdGhlXG4gICAgICogIHByb3ZpZGVkICUlY29pblR5cGUlJSBoYXMgbm90IGJlZW4gY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGNvaW5UeXBlKSB7XG4gICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2luVHlwZSA9PT0gNjApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIpXCIpO1xuICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0ID09PSBpbmRleF9qc18yLlplcm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbmRleF9qc181LmlzRXJyb3IpKGVycm9yLCBcIkNBTExfRVhDRVBUSU9OXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgZGVjb2RpbmcgaXRzIEVWTSBjYW5vbmljYWwgY2hhaW4gYXMgYW4gRVZNIGNoYWluIGFkZHJlc3MgZmlyc3RcbiAgICAgICAgaWYgKGNvaW5UeXBlID49IDAgJiYgY29pblR5cGUgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICBsZXQgZXRoQ29pblR5cGUgPSBjb2luVHlwZSArIDB4ODAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2V0aENvaW5UeXBlXSk7XG4gICAgICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzUuaXNIZXhTdHJpbmcpKGRhdGEsIDIwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29pblBsdWdpbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucHJvdmlkZXIucGx1Z2lucykge1xuICAgICAgICAgICAgaWYgKCEocGx1Z2luIGluc3RhbmNlb2YgTXVsdGljb2luUHJvdmlkZXJQbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzQ29pblR5cGUoY29pblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29pblBsdWdpbiA9IHBsdWdpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pblBsdWdpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy4jZmV0Y2goXCJhZGRyKGJ5dGVzMzIsdWludClcIiwgW2NvaW5UeXBlXSk7XG4gICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IGNvaW5QbHVnaW4uZGVjb2RlQWRkcmVzcyhjb2luVHlwZSwgZGF0YSk7XG4gICAgICAgIGlmIChhZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydCkoZmFsc2UsIGBpbnZhbGlkIGNvaW4gZGF0YWAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgIGluZm86IHsgY29pblR5cGUsIGRhdGEgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBFSVAtNjM0IHRleHQgcmVjb3JkIGZvciAlJWtleSUlLCBvciBgYG51bGxgYFxuICAgICAqICBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZldGNoKFwidGV4dChieXRlczMyLHN0cmluZylcIiwgW2tleV0pO1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSc29sdmVzIHRvIHRoZSBjb250ZW50LWhhc2ggb3IgYGBudWxsYGAgaWYgdW5jb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRlbnRIYXNoKCkge1xuICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNmZXRjaChcImNvbnRlbnRoYXNoKGJ5dGVzMzIpXCIpO1xuICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiA3MD1EQUctUEIsIDcyPWxpYnAycC1rZXkpXG4gICAgICAgIGNvbnN0IGlwZnMgPSBkYXRhLm1hdGNoKC9eMHgoZTMwMTAxNzB8ZTUwMTAxNzIpKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgaWYgKGlwZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IChpcGZzWzFdID09PSBcImUzMDEwMTcwXCIpID8gXCJpcGZzXCIgOiBcImlwbnNcIjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbNF0sIDE2KTtcbiAgICAgICAgICAgIGlmIChpcGZzWzVdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzY2hlbWV9Oi9cXC8keygwLCBpbmRleF9qc181LmVuY29kZUJhc2U1OCkoXCIweFwiICsgaXBmc1syXSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgIGNvbnN0IHN3YXJtID0gZGF0YS5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgaWYgKHN3YXJtICYmIHN3YXJtWzFdLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgIHJldHVybiBgYnp6Oi9cXC8ke3N3YXJtWzFdfWA7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KShmYWxzZSwgYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuICAgICAgICAgICAgaW5mbzogeyBkYXRhIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYXZhdGFyIHVybCBvciBgYG51bGxgYCBpZiB0aGUgYXZhdGFyIGlzIGVpdGhlclxuICAgICAqICB1bmNvbmZpZ3VyZWQgb3IgaW5jb3JyZWN0bHkgY29uZmlndXJlZCAoZS5nLiByZWZlcmVuY2VzIGFuIE5GVFxuICAgICAqICBub3Qgb3duZWQgYnkgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogIElmIGRpYWdub3NpbmcgaXNzdWVzIHdpdGggY29uZmlndXJhdGlvbnMsIHRoZSBbW19nZXRBdmF0YXJdXVxuICAgICAqICBtZXRob2QgbWF5IGJlIHVzZWZ1bC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmF0YXIoKSB7XG4gICAgICAgIGNvbnN0IGF2YXRhciA9IGF3YWl0IHRoaXMuX2dldEF2YXRhcigpO1xuICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFdoZW4gcmVzb2x2aW5nIGFuIGF2YXRhciwgdGhlcmUgYXJlIG1hbnkgc3RlcHMgaW52b2x2ZWQsIHN1Y2hcbiAgICAgKiAgZmV0Y2hpbmcgbWV0YWRhdGEgYW5kIHBvc3NpYmx5IHZhbGlkYXRpbmcgb3duZXJzaGlwIG9mIGFuXG4gICAgICogIE5GVC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBleGFtaW5lIGVhY2ggc3RlcCBhbmQgdGhlIHZhbHVlIGl0XG4gICAgICogIHdhcyB3b3JraW5nIGZyb20uXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF2YXRhcigpIHtcbiAgICAgICAgY29uc3QgbGlua2FnZSA9IFt7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdGhpcy5uYW1lIH1dO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0gYXdhaXQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhYXZhdGFyXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJhdmF0YXJcIiwgdmFsdWU6IGF2YXRhciB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImh0dHBzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gZ2V0SXBmc0xpbmsoYXZhdGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCB2YWx1ZTogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgdmFsdWU6IHVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlcmM3MjFcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoc2NoZW1lID09PSBcImVyYzcyMVwiKSA/IFwidG9rZW5VUkkodWludDI1NilcIiA6IFwidXJpKHVpbnQyNTYpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIHZhbHVlOiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFvd25lclwiLCB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBgISR7c2NoZW1lfWNhaXBgLCB2YWx1ZTogKG1hdGNoWzJdIHx8IFwiXCIpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGNvbXBzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChjb21wc1swXSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy03MjFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHRva2VuVVJJKHVpbnQpIHZpZXcgcmV0dXJucyAoc3RyaW5nKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24gb3duZXJPZih1aW50KSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIHVyaSh1aW50KSB2aWV3IHJldHVybnMgKHN0cmluZylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzLCB1aW50MjU2KSB2aWV3IHJldHVybnMgKHVpbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbk93bmVyID0gYXdhaXQgY29udHJhY3Qub3duZXJPZih0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3duZXIgIT09IHRva2VuT3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhb3duZXJcIiwgdmFsdWU6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIHZhbHVlOiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2Yob3duZXIsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFiYWxhbmNlXCIsIHZhbHVlOiBcIjBcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCB2YWx1ZTogYmFsYW5jZS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IGF3YWl0IGNvbnRyYWN0W3NlbGVjdG9yXSh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybCA9PSBudWxsIHx8IG1ldGFkYXRhVXJsID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YS11cmxcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1iYXNlXCIsIHZhbHVlOiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVSQy0xMTU1IGFsbG93cyBhIGdlbmVyaWMge2lkfSBpbiB0aGUgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgKDAsIGluZGV4X2pzXzUudG9CZUhleCkodG9rZW5JZCwgMzIpLnN1YnN0cmluZygyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgdmFsdWU6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVVybC5tYXRjaCgvXmlwZnM6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybFwiLCB2YWx1ZTogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKG5ldyBpbmRleF9qc181LkZldGNoUmVxdWVzdChtZXRhZGF0YVVybCkpLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIiFtZXRhZGF0YVwiLCB2YWx1ZTogcmVzcG9uc2UuYm9keVRleHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6ICgwLCBpbmRleF9qc181LmhleGxpZnkpKGJ5dGVzKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCIhbWV0YWRhdGFcIiwgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiBudWxsLCBsaW5rYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIHZhbHVlOiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VVcmwgPSBtZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsXCIsIHZhbHVlOiBcIlwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogbnVsbCwgbGlua2FnZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXBmcyA9IGltYWdlVXJsLm1hdGNoKG1hdGNoZXJJcGZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiIWltYWdlVXJsLWlwZnNcIiwgdmFsdWU6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IG51bGwsIGxpbmthZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJpbWFnZVVybC1pcGZzXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIHZhbHVlOiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogaW1hZ2VVcmwgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG51bGwgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGdldEVuc0FkZHJlc3MocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgY29uc3QgZW5zUGx1Z2luID0gbmV0d29yay5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGVuc1BsdWdpbiwgXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRFbnNBZGRyZXNzXCIsIGluZm86IHsgbmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5zUGx1Z2luLmFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyAjZ2V0UmVzb2x2ZXIocHJvdmlkZXIsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5zQWRkciA9IGF3YWl0IEVuc1Jlc29sdmVyLmdldEVuc0FkZHJlc3MocHJvdmlkZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgaW5kZXhfanNfMy5Db250cmFjdChlbnNBZGRyLCBbXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvbiByZXNvbHZlcihieXRlczMyKSB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgICAgICAgICAgIF0sIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSBhd2FpdCBjb250cmFjdC5yZXNvbHZlcigoMCwgaW5kZXhfanNfNC5uYW1laGFzaCkobmFtZSksIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDY2lwUmVhZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gaW5kZXhfanNfMi5aZXJvQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKSxcbiAgICAgICAgICAgIC8vIHNvIHByb2JhYmx5IGEgbGluayBlcnJvclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBFTlMgcmVzb2x2ZXIgZm9yICUlbmFtZSUlIHVzaW5nICUlcHJvdmlkZXIlJSBvclxuICAgICAqICBgYG51bGxgYCBpZiB1bmNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OYW1lKHByb3ZpZGVyLCBuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50TmFtZSA9IG5hbWU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgIC8vIG5vdCBoYXZlIGEgd2lsZGNhcmQgcmVzb2x2ZXJcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICBjb25zdCBhZGRyID0gYXdhaXQgRW5zUmVzb2x2ZXIuI2dldFJlc29sdmVyKHByb3ZpZGVyLCBjdXJyZW50TmFtZSk7XG4gICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IEVuc1Jlc29sdmVyKHByb3ZpZGVyLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoYXdhaXQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVuc1Jlc29sdmVyID0gRW5zUmVzb2x2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMtcmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRW5zUmVzb2x2ZXIiLCJCYXNpY011bHRpY29pblByb3ZpZGVyUGx1Z2luIiwiTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiaW5kZXhfanNfNCIsImluZGV4X2pzXzUiLCJnZXRJcGZzTGluayIsImxpbmsiLCJtYXRjaCIsInN1YnN0cmluZyIsImFzc2VydEFyZ3VtZW50IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZGVmaW5lUHJvcGVydGllcyIsImNvbm5lY3QiLCJwcm9pdmRlciIsInN1cHBvcnRzQ29pblR5cGUiLCJjb2luVHlwZSIsImVuY29kZUFkZHJlc3MiLCJhZGRyZXNzIiwiRXJyb3IiLCJkZWNvZGVBZGRyZXNzIiwiZGF0YSIsIkJhc2ljTXVsdGljb2luUGx1Z2luSWQiLCJtYXRjaGVySXBmcyIsIlJlZ0V4cCIsIm1hdGNoZXJzIiwic3VwcG9ydHMyNTQ0IiwicmVzb2x2ZXIiLCJwcm92aWRlciIsIkNvbnRyYWN0Iiwic3VwcG9ydHNXaWxkY2FyZCIsInN1cHBvcnRzSW50ZXJmYWNlIiwiZXJyb3IiLCJpc0Vycm9yIiwiZmV0Y2giLCJmdW5jTmFtZSIsInBhcmFtcyIsInNsaWNlIiwiaWZhY2UiLCJpbnRlcmZhY2UiLCJ1bnNoaWZ0IiwibmFtZWhhc2giLCJmcmFnbWVudCIsImdldEZ1bmN0aW9uIiwiYXNzZXJ0IiwiaW5mbyIsImRuc0VuY29kZSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInB1c2giLCJlbmFibGVDY2lwUmVhZCIsInJlc3VsdCIsImRlY29kZUZ1bmN0aW9uUmVzdWx0IiwiZ2V0QWRkcmVzcyIsIlplcm9BZGRyZXNzIiwiZXRoQ29pblR5cGUiLCJpc0hleFN0cmluZyIsImNvaW5QbHVnaW4iLCJwbHVnaW4iLCJwbHVnaW5zIiwib3BlcmF0aW9uIiwiZ2V0VGV4dCIsImtleSIsImdldENvbnRlbnRIYXNoIiwiaXBmcyIsInNjaGVtZSIsImxlbmd0aCIsInBhcnNlSW50IiwiZW5jb2RlQmFzZTU4Iiwic3dhcm0iLCJnZXRBdmF0YXIiLCJhdmF0YXIiLCJfZ2V0QXZhdGFyIiwidXJsIiwibGlua2FnZSIsInR5cGUiLCJpIiwidG9Mb3dlckNhc2UiLCJzZWxlY3RvciIsIm93bmVyIiwiY29tcHMiLCJzcGxpdCIsInRva2VuSWQiLCJjb250cmFjdCIsInRva2VuT3duZXIiLCJvd25lck9mIiwiYmFsYW5jZSIsImJhbGFuY2VPZiIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwidG9CZUhleCIsIm1ldGFkYXRhIiwicmVzcG9uc2UiLCJGZXRjaFJlcXVlc3QiLCJzZW5kIiwiYXNzZXJ0T2siLCJib2R5SnNvbiIsImJvZHlUZXh0IiwiYnl0ZXMiLCJib2R5IiwiaGV4bGlmeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbWFnZVVybCIsImltYWdlIiwiZ2V0RW5zQWRkcmVzcyIsIm5ldHdvcmsiLCJnZXROZXR3b3JrIiwiZW5zUGx1Z2luIiwiZ2V0UGx1Z2luIiwiZ2V0UmVzb2x2ZXIiLCJlbnNBZGRyIiwiYWRkciIsImZyb21OYW1lIiwiY3VycmVudE5hbWUiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/format.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/format.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;\n/**\n *  @_ignore\n */ const index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst BN_0 = BigInt(0);\nfunction allowNull(format, nullValue) {\n    return function(value) {\n        if (value == null) {\n            return nullValue;\n        }\n        return format(value);\n    };\n}\nexports.allowNull = allowNull;\nfunction arrayOf(format) {\n    return (array)=>{\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        return array.map((i)=>format(i));\n    };\n}\nexports.arrayOf = arrayOf;\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nfunction object(format, altNames) {\n    return (value)=>{\n        const result = {};\n        for(const key in format){\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]){\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) {\n                    result[key] = nv;\n                }\n            } catch (error) {\n                const message = error instanceof Error ? error.message : \"not-an-error\";\n                (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, \"BAD_DATA\", {\n                    value\n                });\n            }\n        }\n        return result;\n    };\n}\nexports.object = object;\nfunction formatBoolean(value) {\n    switch(value){\n        case true:\n        case \"true\":\n            return true;\n        case false:\n        case \"false\":\n            return false;\n    }\n    (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, \"value\", value);\n}\nexports.formatBoolean = formatBoolean;\nfunction formatData(value) {\n    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\nexports.formatData = formatData;\nfunction formatHash(value) {\n    (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\nexports.formatHash = formatHash;\nfunction formatUint256(value) {\n    if (!(0, index_js_4.isHexString)(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return (0, index_js_4.zeroPadValue)(value, 32);\n}\nexports.formatUint256 = formatUint256;\nconst _formatLog = object({\n    address: index_js_1.getAddress,\n    blockHash: formatHash,\n    blockNumber: index_js_4.getNumber,\n    data: formatData,\n    index: index_js_4.getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: index_js_4.getNumber\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatLog(value) {\n    return _formatLog(value);\n}\nexports.formatLog = formatLog;\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    number: index_js_4.getNumber,\n    timestamp: index_js_4.getNumber,\n    nonce: allowNull(formatData),\n    difficulty: index_js_4.getBigInt,\n    gasLimit: index_js_4.getBigInt,\n    gasUsed: index_js_4.getBigInt,\n    miner: allowNull(index_js_1.getAddress),\n    extraData: formatData,\n    baseFeePerGas: allowNull(index_js_4.getBigInt)\n});\nfunction formatBlock(value) {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx)=>{\n        if (typeof tx === \"string\") {\n            return tx;\n        }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\nexports.formatBlock = formatBlock;\nconst _formatReceiptLog = object({\n    transactionIndex: index_js_4.getNumber,\n    blockNumber: index_js_4.getNumber,\n    transactionHash: formatHash,\n    address: index_js_1.getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: index_js_4.getNumber,\n    blockHash: formatHash\n}, {\n    index: [\n        \"logIndex\"\n    ]\n});\nfunction formatReceiptLog(value) {\n    return _formatReceiptLog(value);\n}\nexports.formatReceiptLog = formatReceiptLog;\nconst _formatTransactionReceipt = object({\n    to: allowNull(index_js_1.getAddress, null),\n    from: allowNull(index_js_1.getAddress, null),\n    contractAddress: allowNull(index_js_1.getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: index_js_4.getNumber,\n    root: allowNull(index_js_4.hexlify),\n    gasUsed: index_js_4.getBigInt,\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: index_js_4.getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: index_js_4.getBigInt,\n    effectiveGasPrice: allowNull(index_js_4.getBigInt),\n    status: allowNull(index_js_4.getNumber),\n    type: allowNull(index_js_4.getNumber, 0)\n}, {\n    effectiveGasPrice: [\n        \"gasPrice\"\n    ],\n    hash: [\n        \"transactionHash\"\n    ],\n    index: [\n        \"transactionIndex\"\n    ]\n});\nfunction formatTransactionReceipt(value) {\n    return _formatTransactionReceipt(value);\n}\nexports.formatTransactionReceipt = formatTransactionReceipt;\nfunction formatTransactionResponse(value) {\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n    const result = object({\n        hash: formatHash,\n        type: (value)=>{\n            if (value === \"0x\" || value == null) {\n                return 0;\n            }\n            return (0, index_js_4.getNumber)(value);\n        },\n        accessList: allowNull(index_js_3.accessListify, null),\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(index_js_4.getNumber, null),\n        transactionIndex: allowNull(index_js_4.getNumber, null),\n        //confirmations: allowNull(getNumber, null),\n        from: index_js_1.getAddress,\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(index_js_4.getBigInt),\n        maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),\n        maxFeePerGas: allowNull(index_js_4.getBigInt),\n        gasLimit: index_js_4.getBigInt,\n        to: allowNull(index_js_1.getAddress, null),\n        value: index_js_4.getBigInt,\n        nonce: index_js_4.getNumber,\n        data: formatData,\n        creates: allowNull(index_js_1.getAddress, null),\n        chainId: allowNull(index_js_4.getBigInt, null)\n    }, {\n        data: [\n            \"input\"\n        ],\n        gasLimit: [\n            \"gas\"\n        ]\n    })(value);\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = (0, index_js_1.getCreateAddress)(result);\n    }\n    // @TODO: Check fee data\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [];\n    }\n    // Compute the signature\n    if (value.signature) {\n        result.signature = index_js_2.Signature.from(value.signature);\n    } else {\n        result.signature = index_js_2.Signature.from(value);\n    }\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) {\n            result.chainId = chainId;\n        }\n    }\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */ // 0x0000... should actually be null\n    if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n    return result;\n}\nexports.formatTransactionResponse = formatTransactionResponse; //# sourceMappingURL=format.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsZ0NBQWdDLEdBQUdBLHdCQUF3QixHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLHFCQUFxQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNsUzs7Q0FFQyxHQUNELE1BQU1jLGFBQWFDLG1CQUFPQSxDQUFDLHNGQUFxQjtBQUNoRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxvRkFBb0I7QUFDL0MsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNSSxPQUFPQyxPQUFPO0FBQ3BCLFNBQVNQLFVBQVVRLE1BQU0sRUFBRUMsU0FBUztJQUNoQyxPQUFRLFNBQVVyQixLQUFLO1FBQ25CLElBQUlBLFNBQVMsTUFBTTtZQUNmLE9BQU9xQjtRQUNYO1FBQ0EsT0FBT0QsT0FBT3BCO0lBQ2xCO0FBQ0o7QUFDQUQsaUJBQWlCLEdBQUdhO0FBQ3BCLFNBQVNELFFBQVFTLE1BQU07SUFDbkIsT0FBUSxDQUFDRTtRQUNMLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1lBQ3ZCLE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLE9BQU9ILE1BQU1JLEdBQUcsQ0FBQyxDQUFDQyxJQUFNUCxPQUFPTztJQUNuQztBQUNKO0FBQ0E1QixlQUFlLEdBQUdZO0FBQ2xCLCtEQUErRDtBQUMvRCxrRUFBa0U7QUFDbEUsaURBQWlEO0FBQ2pELFNBQVNELE9BQU9VLE1BQU0sRUFBRVEsUUFBUTtJQUM1QixPQUFRLENBQUM1QjtR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Q0FBQ0UsYUFBYTtRQUM5QyxJQUFJSixXQUFXLE1BQU07WUFDakI1RCxPQUFPNEQsT0FBTyxHQUFHQTtRQUNyQjtJQUNKO0lBQ0EsdUJBQXVCO0lBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDQSxHQUNBLG9DQUFvQztJQUNwQyxJQUFJNUQsT0FBT2lCLFNBQVMsSUFBSSxDQUFDLEdBQUc3QixXQUFXNkMsU0FBUyxFQUFFakMsT0FBT2lCLFNBQVMsTUFBTTVCLE1BQU07UUFDMUVXLE9BQU9pQixTQUFTLEdBQUc7SUFDdkI7SUFDQSxPQUFPakI7QUFDWDtBQUNBOUIsaUNBQWlDLEdBQUdFLDJCQUNwQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvZm9ybWF0LmpzP2I2NGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLmZvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuZm9ybWF0UmVjZWlwdExvZyA9IGV4cG9ydHMuZm9ybWF0QmxvY2sgPSBleHBvcnRzLmZvcm1hdExvZyA9IGV4cG9ydHMuZm9ybWF0VWludDI1NiA9IGV4cG9ydHMuZm9ybWF0SGFzaCA9IGV4cG9ydHMuZm9ybWF0RGF0YSA9IGV4cG9ydHMuZm9ybWF0Qm9vbGVhbiA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5hcnJheU9mID0gZXhwb3J0cy5hbGxvd051bGwgPSB2b2lkIDA7XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXQodmFsdWUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hbGxvd051bGwgPSBhbGxvd051bGw7XG5mdW5jdGlvbiBhcnJheU9mKGZvcm1hdCkge1xuICAgIHJldHVybiAoKGFycmF5KSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpKSA9PiBmb3JtYXQoaSkpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbi8vIFJlcXVpcmVzIGFuIG9iamVjdCB3aGljaCBtYXRjaGVzIGEgZmxlZXQgb2Ygb3RoZXIgZm9ybWF0dGVyc1xuLy8gQW55IEZvcm1hdEZ1bmMgbWF5IHJldHVybiBgdW5kZWZpbmVkYCB0byBoYXZlIHRoZSB2YWx1ZSBvbWl0dGVkXG4vLyBmcm9tIHRoZSByZXN1bHQgb2JqZWN0LiBDYWxscyBwcmVzZXJ2ZSBgdGhpc2AuXG5mdW5jdGlvbiBvYmplY3QoZm9ybWF0LCBhbHROYW1lcykge1xuICAgIHJldHVybiAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtYXQpIHtcbiAgICAgICAgICAgIGxldCBzcmNLZXkgPSBrZXk7XG4gICAgICAgICAgICBpZiAoYWx0TmFtZXMgJiYga2V5IGluIGFsdE5hbWVzICYmICEoc3JjS2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYWx0S2V5IG9mIGFsdE5hbWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsdEtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjS2V5ID0gYWx0S2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG52ID0gZm9ybWF0W2tleV0odmFsdWVbc3JjS2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKG52ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpID8gZXJyb3IubWVzc2FnZSA6IFwibm90LWFuLWVycm9yXCI7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgYGludmFsaWQgdmFsdWUgZm9yIHZhbHVlLiR7a2V5fSAoJHttZXNzYWdlfSlgLCBcIkJBRF9EQVRBXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn1cbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuZnVuY3Rpb24gZm9ybWF0Qm9vbGVhbih2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIGJvb2xlYW47ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRCb29sZWFuID0gZm9ybWF0Qm9vbGVhbjtcbmZ1bmN0aW9uIGZvcm1hdERhdGEodmFsdWUpIHtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKHZhbHVlLCB0cnVlKSwgXCJpbnZhbGlkIGRhdGFcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5mb3JtYXREYXRhID0gZm9ybWF0RGF0YTtcbmZ1bmN0aW9uIGZvcm1hdEhhc2godmFsdWUpIHtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNIZXhTdHJpbmcpKHZhbHVlLCAzMiksIFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuZm9ybWF0SGFzaCA9IGZvcm1hdEhhc2g7XG5mdW5jdGlvbiBmb3JtYXRVaW50MjU2KHZhbHVlKSB7XG4gICAgaWYgKCEoMCwgaW5kZXhfanNfNC5pc0hleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc180Lnplcm9QYWRWYWx1ZSkodmFsdWUsIDMyKTtcbn1cbmV4cG9ydHMuZm9ybWF0VWludDI1NiA9IGZvcm1hdFVpbnQyNTY7XG5jb25zdCBfZm9ybWF0TG9nID0gb2JqZWN0KHtcbiAgICBhZGRyZXNzOiBpbmRleF9qc18xLmdldEFkZHJlc3MsXG4gICAgYmxvY2tIYXNoOiBmb3JtYXRIYXNoLFxuICAgIGJsb2NrTnVtYmVyOiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgIGluZGV4OiBpbmRleF9qc180LmdldE51bWJlcixcbiAgICByZW1vdmVkOiBhbGxvd051bGwoZm9ybWF0Qm9vbGVhbiwgZmFsc2UpLFxuICAgIHRvcGljczogYXJyYXlPZihmb3JtYXRIYXNoKSxcbiAgICB0cmFuc2FjdGlvbkhhc2g6IGZvcm1hdEhhc2gsXG4gICAgdHJhbnNhY3Rpb25JbmRleDogaW5kZXhfanNfNC5nZXROdW1iZXIsXG59LCB7XG4gICAgaW5kZXg6IFtcImxvZ0luZGV4XCJdXG59KTtcbmZ1bmN0aW9uIGZvcm1hdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0TG9nKHZhbHVlKTtcbn1cbmV4cG9ydHMuZm9ybWF0TG9nID0gZm9ybWF0TG9nO1xuY29uc3QgX2Zvcm1hdEJsb2NrID0gb2JqZWN0KHtcbiAgICBoYXNoOiBhbGxvd051bGwoZm9ybWF0SGFzaCksXG4gICAgcGFyZW50SGFzaDogZm9ybWF0SGFzaCxcbiAgICBudW1iZXI6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIHRpbWVzdGFtcDogaW5kZXhfanNfNC5nZXROdW1iZXIsXG4gICAgbm9uY2U6IGFsbG93TnVsbChmb3JtYXREYXRhKSxcbiAgICBkaWZmaWN1bHR5OiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICBnYXNMaW1pdDogaW5kZXhfanNfNC5nZXRCaWdJbnQsXG4gICAgZ2FzVXNlZDogaW5kZXhfanNfNC5nZXRCaWdJbnQsXG4gICAgbWluZXI6IGFsbG93TnVsbChpbmRleF9qc18xLmdldEFkZHJlc3MpLFxuICAgIGV4dHJhRGF0YTogZm9ybWF0RGF0YSxcbiAgICBiYXNlRmVlUGVyR2FzOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXRCaWdJbnQpXG59KTtcbmZ1bmN0aW9uIGZvcm1hdEJsb2NrKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX2Zvcm1hdEJsb2NrKHZhbHVlKTtcbiAgICByZXN1bHQudHJhbnNhY3Rpb25zID0gdmFsdWUudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZvcm1hdEJsb2NrID0gZm9ybWF0QmxvY2s7XG5jb25zdCBfZm9ybWF0UmVjZWlwdExvZyA9IG9iamVjdCh7XG4gICAgdHJhbnNhY3Rpb25JbmRleDogaW5kZXhfanNfNC5nZXROdW1iZXIsXG4gICAgYmxvY2tOdW1iZXI6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIHRyYW5zYWN0aW9uSGFzaDogZm9ybWF0SGFzaCxcbiAgICBhZGRyZXNzOiBpbmRleF9qc18xLmdldEFkZHJlc3MsXG4gICAgdG9waWNzOiBhcnJheU9mKGZvcm1hdEhhc2gpLFxuICAgIGRhdGE6IGZvcm1hdERhdGEsXG4gICAgaW5kZXg6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbn0sIHtcbiAgICBpbmRleDogW1wibG9nSW5kZXhcIl1cbn0pO1xuZnVuY3Rpb24gZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSkge1xuICAgIHJldHVybiBfZm9ybWF0UmVjZWlwdExvZyh2YWx1ZSk7XG59XG5leHBvcnRzLmZvcm1hdFJlY2VpcHRMb2cgPSBmb3JtYXRSZWNlaXB0TG9nO1xuY29uc3QgX2Zvcm1hdFRyYW5zYWN0aW9uUmVjZWlwdCA9IG9iamVjdCh7XG4gICAgdG86IGFsbG93TnVsbChpbmRleF9qc18xLmdldEFkZHJlc3MsIG51bGwpLFxuICAgIGZyb206IGFsbG93TnVsbChpbmRleF9qc18xLmdldEFkZHJlc3MsIG51bGwpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogYWxsb3dOdWxsKGluZGV4X2pzXzEuZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgLy8gc2hvdWxkIGJlIGFsbG93TnVsbChoYXNoKSwgYnV0IGJyb2tlbi1FSVAtNjU4IHN1cHBvcnQgaXMgaGFuZGxlZCBpbiByZWNlaXB0XG4gICAgaW5kZXg6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIHJvb3Q6IGFsbG93TnVsbChpbmRleF9qc180LmhleGxpZnkpLFxuICAgIGdhc1VzZWQ6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgIGxvZ3NCbG9vbTogYWxsb3dOdWxsKGZvcm1hdERhdGEpLFxuICAgIGJsb2NrSGFzaDogZm9ybWF0SGFzaCxcbiAgICBoYXNoOiBmb3JtYXRIYXNoLFxuICAgIGxvZ3M6IGFycmF5T2YoZm9ybWF0UmVjZWlwdExvZyksXG4gICAgYmxvY2tOdW1iZXI6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgIGVmZmVjdGl2ZUdhc1ByaWNlOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXRCaWdJbnQpLFxuICAgIHN0YXR1czogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0TnVtYmVyKSxcbiAgICB0eXBlOiBhbGxvd051bGwoaW5kZXhfanNfNC5nZXROdW1iZXIsIDApXG59LCB7XG4gICAgZWZmZWN0aXZlR2FzUHJpY2U6IFtcImdhc1ByaWNlXCJdLFxuICAgIGhhc2g6IFtcInRyYW5zYWN0aW9uSGFzaFwiXSxcbiAgICBpbmRleDogW1widHJhbnNhY3Rpb25JbmRleFwiXSxcbn0pO1xuZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHZhbHVlKSB7XG4gICAgcmV0dXJuIF9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQodmFsdWUpO1xufVxuZXhwb3J0cy5mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQgPSBmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQ7XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlKHZhbHVlKSB7XG4gICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgaWYgKHZhbHVlLnRvICYmICgwLCBpbmRleF9qc180LmdldEJpZ0ludCkodmFsdWUudG8pID09PSBCTl8wKSB7XG4gICAgICAgIHZhbHVlLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gb2JqZWN0KHtcbiAgICAgICAgaGFzaDogZm9ybWF0SGFzaCxcbiAgICAgICAgdHlwZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiMHhcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFsbG93TnVsbChpbmRleF9qc18zLmFjY2Vzc0xpc3RpZnksIG51bGwpLFxuICAgICAgICBibG9ja0hhc2g6IGFsbG93TnVsbChmb3JtYXRIYXNoLCBudWxsKSxcbiAgICAgICAgYmxvY2tOdW1iZXI6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGFsbG93TnVsbChpbmRleF9qc180LmdldE51bWJlciwgbnVsbCksXG4gICAgICAgIC8vY29uZmlybWF0aW9uczogYWxsb3dOdWxsKGdldE51bWJlciwgbnVsbCksXG4gICAgICAgIGZyb206IGluZGV4X2pzXzEuZ2V0QWRkcmVzcyxcbiAgICAgICAgLy8gZWl0aGVyIChnYXNQcmljZSkgb3IgKG1heFByaW9yaXR5RmVlUGVyR2FzICsgbWF4RmVlUGVyR2FzKSBtdXN0IGJlIHNldFxuICAgICAgICBnYXNQcmljZTogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGFsbG93TnVsbChpbmRleF9qc180LmdldEJpZ0ludCksXG4gICAgICAgIG1heEZlZVBlckdhczogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50KSxcbiAgICAgICAgZ2FzTGltaXQ6IGluZGV4X2pzXzQuZ2V0QmlnSW50LFxuICAgICAgICB0bzogYWxsb3dOdWxsKGluZGV4X2pzXzEuZ2V0QWRkcmVzcywgbnVsbCksXG4gICAgICAgIHZhbHVlOiBpbmRleF9qc180LmdldEJpZ0ludCxcbiAgICAgICAgbm9uY2U6IGluZGV4X2pzXzQuZ2V0TnVtYmVyLFxuICAgICAgICBkYXRhOiBmb3JtYXREYXRhLFxuICAgICAgICBjcmVhdGVzOiBhbGxvd051bGwoaW5kZXhfanNfMS5nZXRBZGRyZXNzLCBudWxsKSxcbiAgICAgICAgY2hhaW5JZDogYWxsb3dOdWxsKGluZGV4X2pzXzQuZ2V0QmlnSW50LCBudWxsKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW1wiaW5wdXRcIl0sXG4gICAgICAgIGdhc0xpbWl0OiBbXCJnYXNcIl1cbiAgICB9KSh2YWx1ZSk7XG4gICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB2YWx1ZVxuICAgIGlmIChyZXN1bHQudG8gPT0gbnVsbCAmJiByZXN1bHQuY3JlYXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5jcmVhdGVzID0gKDAsIGluZGV4X2pzXzEuZ2V0Q3JlYXRlQWRkcmVzcykocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IENoZWNrIGZlZSBkYXRhXG4gICAgLy8gQWRkIGFuIGFjY2VzcyBsaXN0IHRvIHN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICgodmFsdWUudHlwZSA9PT0gMSB8fCB2YWx1ZS50eXBlID09PSAyKSAmJiB2YWx1ZS5hY2Nlc3NMaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZSB0aGUgc2lnbmF0dXJlXG4gICAgaWYgKHZhbHVlLnNpZ25hdHVyZSkge1xuICAgICAgICByZXN1bHQuc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh2YWx1ZS5zaWduYXR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnNpZ25hdHVyZSA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBTb21lIGJhY2tlbmRzIG9taXQgQ2hhaW5JZCBvbiBsZWdhY3kgdHJhbnNhY3Rpb25zLCBidXQgd2UgY2FuIGNvbXB1dGUgaXRcbiAgICBpZiAocmVzdWx0LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gcmVzdWx0LnNpZ25hdHVyZS5sZWdhY3lDaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQFRPRE86IGNoZWNrIGNoYWluSURcbiAgICAvKlxuICAgIGlmICh2YWx1ZS5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGNoYWluSWQgPSB2YWx1ZS5jaGFpbklkO1xuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2hhaW5JZCA9IHZhbHVlLm5ldHdvcmtJZDtcblxuICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcbiAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjaGFpbklkID0gdmFsdWUuY2hhaW5JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7IGNoYWluSWQgPSAwOyB9XG4gICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7IGNoYWluSWQgPSAwOyB9XG5cbiAgICAgICAgcmVzdWx0LmNoYWluSWQgPSBjaGFpbklkO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIDB4MDAwMC4uLiBzaG91bGQgYWN0dWFsbHkgYmUgbnVsbFxuICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmICgwLCBpbmRleF9qc180LmdldEJpZ0ludCkocmVzdWx0LmJsb2NrSGFzaCkgPT09IEJOXzApIHtcbiAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UgPSBmb3JtYXRUcmFuc2FjdGlvblJlc3BvbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZvcm1hdFRyYW5zYWN0aW9uUmVzcG9uc2UiLCJmb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJmb3JtYXRSZWNlaXB0TG9nIiwiZm9ybWF0QmxvY2siLCJmb3JtYXRMb2ciLCJmb3JtYXRVaW50MjU2IiwiZm9ybWF0SGFzaCIsImZvcm1hdERhdGEiLCJmb3JtYXRCb29sZWFuIiwib2JqZWN0IiwiYXJyYXlPZiIsImFsbG93TnVsbCIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJpbmRleF9qc180IiwiQk5fMCIsIkJpZ0ludCIsImZvcm1hdCIsIm51bGxWYWx1ZSIsImFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJtYXAiLCJpIiwiYWx0TmFtZXMiLCJyZXN1bHQiLCJrZXkiLCJzcmNLZXkiLCJhbHRLZXkiLCJudiIsInVuZGVmaW5lZCIsImVycm9yIiwibWVzc2FnZSIsImFzc2VydCIsImFzc2VydEFyZ3VtZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImlzSGV4U3RyaW5nIiwiemVyb1BhZFZhbHVlIiwiX2Zvcm1hdExvZyIsImFkZHJlc3MiLCJnZXRBZGRyZXNzIiwiYmxvY2tIYXNoIiwiYmxvY2tOdW1iZXIiLCJnZXROdW1iZXIiLCJkYXRhIiwiaW5kZXgiLCJyZW1vdmVkIiwidG9waWNzIiwidHJhbnNhY3Rpb25IYXNoIiwidHJhbnNhY3Rpb25JbmRleCIsIl9mb3JtYXRCbG9jayIsImhhc2giLCJwYXJlbnRIYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwibm9uY2UiLCJkaWZmaWN1bHR5IiwiZ2V0QmlnSW50IiwiZ2FzTGltaXQiLCJnYXNVc2VkIiwibWluZXIiLCJleHRyYURhdGEiLCJiYXNlRmVlUGVyR2FzIiwidHJhbnNhY3Rpb25zIiwidHgiLCJfZm9ybWF0UmVjZWlwdExvZyIsIl9mb3JtYXRUcmFuc2FjdGlvblJlY2VpcHQiLCJ0byIsImZyb20iLCJjb250cmFjdEFkZHJlc3MiLCJyb290IiwiaGV4bGlmeSIsImxvZ3NCbG9vbSIsImxvZ3MiLCJjdW11bGF0aXZlR2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwic3RhdHVzIiwidHlwZSIsImFjY2Vzc0xpc3QiLCJhY2Nlc3NMaXN0aWZ5IiwiZ2FzUHJpY2UiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsImNyZWF0ZXMiLCJjaGFpbklkIiwiZ2V0Q3JlYXRlQWRkcmVzcyIsInNpZ25hdHVyZSIsIlNpZ25hdHVyZSIsImxlZ2FjeUNoYWluSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/format.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Provider** provides a connection to the blockchain, whch can be\n *  used to query its current state, simulate execution and send transactions\n *  to update the state.\n *\n *  It is one of the most fundamental components of interacting with a\n *  blockchain application, and there are many ways to connect, such as over\n *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).\n *\n *  @_section: api/providers:Providers  [about-providers]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;\nvar abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nObject.defineProperty(exports, \"AbstractProvider\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_provider_js_1.AbstractProvider;\n    }\n}));\nObject.defineProperty(exports, \"UnmanagedSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_provider_js_1.UnmanagedSubscriber;\n    }\n}));\nvar abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\nObject.defineProperty(exports, \"AbstractSigner\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_signer_js_1.AbstractSigner;\n    }\n}));\nObject.defineProperty(exports, \"VoidSigner\", ({\n    enumerable: true,\n    get: function() {\n        return abstract_signer_js_1.VoidSigner;\n    }\n}));\nvar community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nObject.defineProperty(exports, \"showThrottleMessage\", ({\n    enumerable: true,\n    get: function() {\n        return community_js_1.showThrottleMessage;\n    }\n}));\nvar default_provider_js_1 = __webpack_require__(/*! ./default-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/default-provider.js\");\nObject.defineProperty(exports, \"getDefaultProvider\", ({\n    enumerable: true,\n    get: function() {\n        return default_provider_js_1.getDefaultProvider;\n    }\n}));\nvar ens_resolver_js_1 = __webpack_require__(/*! ./ens-resolver.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/ens-resolver.js\");\nObject.defineProperty(exports, \"EnsResolver\", ({\n    enumerable: true,\n    get: function() {\n        return ens_resolver_js_1.EnsResolver;\n    }\n}));\nObject.defineProperty(exports, \"MulticoinProviderPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return ens_resolver_js_1.MulticoinProviderPlugin;\n    }\n}));\nvar network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nObject.defineProperty(exports, \"Network\", ({\n    enumerable: true,\n    get: function() {\n        return network_js_1.Network;\n    }\n}));\nvar signer_noncemanager_js_1 = __webpack_require__(/*! ./signer-noncemanager.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js\");\nObject.defineProperty(exports, \"NonceManager\", ({\n    enumerable: true,\n    get: function() {\n        return signer_noncemanager_js_1.NonceManager;\n    }\n}));\nvar plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\nObject.defineProperty(exports, \"NetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return plugins_network_js_1.NetworkPlugin;\n    }\n}));\nObject.defineProperty(exports, \"GasCostPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return plugins_network_js_1.GasCostPlugin;\n    }\n}));\nObject.defineProperty(exports, \"EnsPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return plugins_network_js_1.EnsPlugin;\n    }\n}));\nObject.defineProperty(exports, \"FeeDataNetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return plugins_network_js_1.FeeDataNetworkPlugin;\n    }\n}));\nObject.defineProperty(exports, \"FetchUrlFeeDataNetworkPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin;\n    }\n}));\nvar provider_js_1 = __webpack_require__(/*! ./provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\");\nObject.defineProperty(exports, \"Block\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.Block;\n    }\n}));\nObject.defineProperty(exports, \"FeeData\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.FeeData;\n    }\n}));\nObject.defineProperty(exports, \"Log\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.Log;\n    }\n}));\nObject.defineProperty(exports, \"TransactionReceipt\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.TransactionReceipt;\n    }\n}));\nObject.defineProperty(exports, \"TransactionResponse\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.TransactionResponse;\n    }\n}));\nObject.defineProperty(exports, \"copyRequest\", ({\n    enumerable: true,\n    get: function() {\n        return provider_js_1.copyRequest;\n    }\n}));\nvar provider_fallback_js_1 = __webpack_require__(/*! ./provider-fallback.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\");\nObject.defineProperty(exports, \"FallbackProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_fallback_js_1.FallbackProvider;\n    }\n}));\nvar provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nObject.defineProperty(exports, \"JsonRpcApiProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_jsonrpc_js_1.JsonRpcApiProvider;\n    }\n}));\nObject.defineProperty(exports, \"JsonRpcProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_jsonrpc_js_1.JsonRpcProvider;\n    }\n}));\nObject.defineProperty(exports, \"JsonRpcSigner\", ({\n    enumerable: true,\n    get: function() {\n        return provider_jsonrpc_js_1.JsonRpcSigner;\n    }\n}));\nvar provider_browser_js_1 = __webpack_require__(/*! ./provider-browser.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js\");\nObject.defineProperty(exports, \"BrowserProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_browser_js_1.BrowserProvider;\n    }\n}));\nvar provider_alchemy_js_1 = __webpack_require__(/*! ./provider-alchemy.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\");\nObject.defineProperty(exports, \"AlchemyProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_alchemy_js_1.AlchemyProvider;\n    }\n}));\nvar provider_ankr_js_1 = __webpack_require__(/*! ./provider-ankr.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\");\nObject.defineProperty(exports, \"AnkrProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_ankr_js_1.AnkrProvider;\n    }\n}));\nvar provider_cloudflare_js_1 = __webpack_require__(/*! ./provider-cloudflare.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\");\nObject.defineProperty(exports, \"CloudflareProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_cloudflare_js_1.CloudflareProvider;\n    }\n}));\nvar provider_etherscan_js_1 = __webpack_require__(/*! ./provider-etherscan.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\");\nObject.defineProperty(exports, \"EtherscanProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_etherscan_js_1.EtherscanProvider;\n    }\n}));\nObject.defineProperty(exports, \"EtherscanPlugin\", ({\n    enumerable: true,\n    get: function() {\n        return provider_etherscan_js_1.EtherscanPlugin;\n    }\n}));\nvar provider_infura_js_1 = __webpack_require__(/*! ./provider-infura.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\");\nObject.defineProperty(exports, \"InfuraProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_infura_js_1.InfuraProvider;\n    }\n}));\nObject.defineProperty(exports, \"InfuraWebSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_infura_js_1.InfuraWebSocketProvider;\n    }\n}));\nvar provider_pocket_js_1 = __webpack_require__(/*! ./provider-pocket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js\");\nObject.defineProperty(exports, \"PocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_pocket_js_1.PocketProvider;\n    }\n}));\nvar provider_quicknode_js_1 = __webpack_require__(/*! ./provider-quicknode.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\");\nObject.defineProperty(exports, \"QuickNodeProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_quicknode_js_1.QuickNodeProvider;\n    }\n}));\nconst provider_ipcsocket_js_1 = __webpack_require__(/*! ./provider-ipcsocket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js\"); /*-browser*/ \nObject.defineProperty(exports, \"IpcSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_ipcsocket_js_1.IpcSocketProvider;\n    }\n}));\nvar provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\nObject.defineProperty(exports, \"SocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_socket_js_1.SocketProvider;\n    }\n}));\nvar provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nObject.defineProperty(exports, \"WebSocketProvider\", ({\n    enumerable: true,\n    get: function() {\n        return provider_websocket_js_1.WebSocketProvider;\n    }\n}));\nvar provider_socket_js_2 = __webpack_require__(/*! ./provider-socket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\nObject.defineProperty(exports, \"SocketSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return provider_socket_js_2.SocketSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketBlockSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return provider_socket_js_2.SocketBlockSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketPendingSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return provider_socket_js_2.SocketPendingSubscriber;\n    }\n}));\nObject.defineProperty(exports, \"SocketEventSubscriber\", ({\n    enumerable: true,\n    get: function() {\n        return provider_socket_js_2.SocketEventSubscriber;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7OztDQVVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0EsK0JBQStCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSx5QkFBeUIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSwrQkFBK0IsR0FBR0Esc0JBQXNCLEdBQUdBLHVCQUF1QixHQUFHQSx5QkFBeUIsR0FBR0EsMEJBQTBCLEdBQUdBLG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLHFCQUFxQixHQUFHQSx1QkFBdUIsR0FBR0EsMEJBQTBCLEdBQUdBLHdCQUF3QixHQUFHQSxtQkFBbUIsR0FBR0EsMkJBQTJCLEdBQUdBLDBCQUEwQixHQUFHQSxXQUFXLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxvQ0FBb0MsR0FBR0EsNEJBQTRCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLG9CQUFvQixHQUFHQSxlQUFlLEdBQUdBLCtCQUErQixHQUFHQSxtQkFBbUIsR0FBR0EsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHQSxrQkFBa0IsR0FBR0Esc0JBQXNCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3psQyxJQUFJNEMseUJBQXlCQyxtQkFBT0EsQ0FBQyx1R0FBd0I7QUFDN0QvQyxvREFBbUQ7SUFBRWdELFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILHVCQUF1QkQsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUk3Qyx1REFBc0Q7SUFBRWdELFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILHVCQUF1QkYsbUJBQW1CO0lBQUU7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QUFBRSxDQUFDLEVBQUM7QUFDakosSUFBSTJELHVCQUF1QnRCLG1CQUFPQSxDQUFDLG1HQUFzQjtBQUN6RC9DLGtEQUFpRDtJQUFFZ0QsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLHFCQUFxQjVELGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SSxJQUFJNkQsMEJBQTBCdkIsbUJBQU9BLENBQUMseUdBQXlCO0FBQy9EL0MscURBQW9EO0lBQUVnRCxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPcUIsd0JBQXdCOUQsaUJBQWlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDakosSUFBSStELHVCQUF1QnhCLG1CQUFPQSxDQUFDLG1HQUFzQjtBQUN6RC9DLG9EQUFtRDtJQUFFZ0QsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT3NCLHFCQUFxQmhFLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVJUCx5REFBd0Q7SUFBRWdELFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9zQixxQkFBcUJqRSxxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0Sk4sMkRBQTBEO0lBQUVnRCxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPc0IscUJBQXFCbEUsdUJBQXVCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUpMLHlEQUF3RDtJQUFFZ0QsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT3NCLHFCQUFxQm5FLHFCQUFxQjtJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQ3RKLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9pbmRleC5qcz9mZWY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQSAqKlByb3ZpZGVyKiogcHJvdmlkZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBibG9ja2NoYWluLCB3aGNoIGNhbiBiZVxuICogIHVzZWQgdG8gcXVlcnkgaXRzIGN1cnJlbnQgc3RhdGUsIHNpbXVsYXRlIGV4ZWN1dGlvbiBhbmQgc2VuZCB0cmFuc2FjdGlvbnNcbiAqICB0byB1cGRhdGUgdGhlIHN0YXRlLlxuICpcbiAqICBJdCBpcyBvbmUgb2YgdGhlIG1vc3QgZnVuZGFtZW50YWwgY29tcG9uZW50cyBvZiBpbnRlcmFjdGluZyB3aXRoIGFcbiAqICBibG9ja2NoYWluIGFwcGxpY2F0aW9uLCBhbmQgdGhlcmUgYXJlIG1hbnkgd2F5cyB0byBjb25uZWN0LCBzdWNoIGFzIG92ZXJcbiAqICBIVFRQLCBXZWJTb2NrZXRzIG9yIGluamVjdGVkIHByb3ZpZGVycyBzdWNoIGFzIFtNZXRhTWFza10obGluay1tZXRhbWFzaykuXG4gKlxuICogIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVyczpQcm92aWRlcnMgIFthYm91dC1wcm92aWRlcnNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0RXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlciA9IGV4cG9ydHMuU29ja2V0QmxvY2tTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IGV4cG9ydHMuU29ja2V0UHJvdmlkZXIgPSBleHBvcnRzLklwY1NvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5RdWlja05vZGVQcm92aWRlciA9IGV4cG9ydHMuUG9ja2V0UHJvdmlkZXIgPSBleHBvcnRzLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5JbmZ1cmFQcm92aWRlciA9IGV4cG9ydHMuRXRoZXJzY2FuUGx1Z2luID0gZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSBleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IGV4cG9ydHMuQnJvd3NlclByb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gZXhwb3J0cy5Kc29uUnBjUHJvdmlkZXIgPSBleHBvcnRzLkpzb25ScGNBcGlQcm92aWRlciA9IGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IGV4cG9ydHMuY29weVJlcXVlc3QgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5GZWVEYXRhID0gZXhwb3J0cy5CbG9jayA9IGV4cG9ydHMuRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBleHBvcnRzLkVuc1BsdWdpbiA9IGV4cG9ydHMuR2FzQ29zdFBsdWdpbiA9IGV4cG9ydHMuTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuTm9uY2VNYW5hZ2VyID0gZXhwb3J0cy5OZXR3b3JrID0gZXhwb3J0cy5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbiA9IGV4cG9ydHMuRW5zUmVzb2x2ZXIgPSBleHBvcnRzLmdldERlZmF1bHRQcm92aWRlciA9IGV4cG9ydHMuc2hvd1Rocm90dGxlTWVzc2FnZSA9IGV4cG9ydHMuVm9pZFNpZ25lciA9IGV4cG9ydHMuQWJzdHJhY3RTaWduZXIgPSBleHBvcnRzLlVubWFuYWdlZFN1YnNjcmliZXIgPSBleHBvcnRzLkFic3RyYWN0UHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5tYW5hZ2VkU3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5Vbm1hbmFnZWRTdWJzY3JpYmVyOyB9IH0pO1xudmFyIGFic3RyYWN0X3NpZ25lcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qtc2lnbmVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFic3RyYWN0X3NpZ25lcl9qc18xLkFic3RyYWN0U2lnbmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVm9pZFNpZ25lclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJzdHJhY3Rfc2lnbmVyX2pzXzEuVm9pZFNpZ25lcjsgfSB9KTtcbnZhciBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNob3dUaHJvdHRsZU1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2U7IH0gfSk7XG52YXIgZGVmYXVsdF9wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vZGVmYXVsdC1wcm92aWRlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdF9wcm92aWRlcl9qc18xLmdldERlZmF1bHRQcm92aWRlcjsgfSB9KTtcbnZhciBlbnNfcmVzb2x2ZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Vucy1yZXNvbHZlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuc1Jlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnNfcmVzb2x2ZXJfanNfMS5FbnNSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpY29pblByb3ZpZGVyUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnNfcmVzb2x2ZXJfanNfMS5NdWx0aWNvaW5Qcm92aWRlclBsdWdpbjsgfSB9KTtcbnZhciBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmV0d29ya1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV0d29ya19qc18xLk5ldHdvcms7IH0gfSk7XG52YXIgc2lnbmVyX25vbmNlbWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4vc2lnbmVyLW5vbmNlbWFuYWdlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vbmNlTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmVyX25vbmNlbWFuYWdlcl9qc18xLk5vbmNlTWFuYWdlcjsgfSB9KTtcbnZhciBwbHVnaW5zX25ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5ldHdvcmtQbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdpbnNfbmV0d29ya19qc18xLk5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHYXNDb3N0UGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5HYXNDb3N0UGx1Z2luOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5zUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5FbnNQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZWVEYXRhTmV0d29ya1BsdWdpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGx1Z2luc19uZXR3b3JrX2pzXzEuRmVlRGF0YU5ldHdvcmtQbHVnaW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwbHVnaW5zX25ldHdvcmtfanNfMS5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luOyB9IH0pO1xudmFyIHByb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJsb2NrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLkJsb2NrOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVlRGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5GZWVEYXRhOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLkxvZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5UcmFuc2FjdGlvblJlY2VpcHQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblJlc3BvbnNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9qc18xLlRyYW5zYWN0aW9uUmVzcG9uc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UmVxdWVzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNfMS5jb3B5UmVxdWVzdDsgfSB9KTtcbnZhciBwcm92aWRlcl9mYWxsYmFja19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZmFsbGJhY2suanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGYWxsYmFja1Byb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9mYWxsYmFja19qc18xLkZhbGxiYWNrUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNBcGlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNBcGlQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfanNvbnJwY19qc18xLkpzb25ScGNQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpzb25ScGNTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjU2lnbmVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2Jyb3dzZXJfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWJyb3dzZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCcm93c2VyUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2Jyb3dzZXJfanNfMS5Ccm93c2VyUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfYWxjaGVteV9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItYWxjaGVteS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFsY2hlbXlQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfYWxjaGVteV9qc18xLkFsY2hlbXlQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9hbmtyX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1hbmtyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5rclByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9hbmtyX2pzXzEuQW5rclByb3ZpZGVyOyB9IH0pO1xudmFyIHByb3ZpZGVyX2Nsb3VkZmxhcmVfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWNsb3VkZmxhcmUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbG91ZGZsYXJlUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2Nsb3VkZmxhcmVfanNfMS5DbG91ZGZsYXJlUHJvdmlkZXI7IH0gfSk7XG52YXIgcHJvdmlkZXJfZXRoZXJzY2FuX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1ldGhlcnNjYW4uanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5Qcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfZXRoZXJzY2FuX2pzXzEuRXRoZXJzY2FuUHJvdmlkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcnNjYW5QbHVnaW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX2V0aGVyc2Nhbl9qc18xLkV0aGVyc2NhblBsdWdpbjsgfSB9KTtcbnZhciBwcm92aWRlcl9pbmZ1cmFfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWluZnVyYS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZnVyYVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9pbmZ1cmFfanNfMS5JbmZ1cmFQcm92aWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZnVyYVdlYlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9pbmZ1cmFfanNfMS5JbmZ1cmFXZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9wb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXBvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9wb2NrZXRfanNfMS5Qb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9xdWlja25vZGVfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXF1aWNrbm9kZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1aWNrTm9kZVByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9xdWlja25vZGVfanNfMS5RdWlja05vZGVQcm92aWRlcjsgfSB9KTtcbmNvbnN0IHByb3ZpZGVyX2lwY3NvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItaXBjc29ja2V0LmpzXCIpOyAvKi1icm93c2VyKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklwY1NvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9pcGNzb2NrZXRfanNfMS5JcGNTb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9zb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXNvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9zb2NrZXRfanNfMS5Tb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl93ZWJzb2NrZXRfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXdlYnNvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlYlNvY2tldFByb3ZpZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl93ZWJzb2NrZXRfanNfMS5XZWJTb2NrZXRQcm92aWRlcjsgfSB9KTtcbnZhciBwcm92aWRlcl9zb2NrZXRfanNfMiA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLXNvY2tldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFN1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3NvY2tldF9qc18yLlNvY2tldFN1YnNjcmliZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRCbG9ja1N1YnNjcmliZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3ZpZGVyX3NvY2tldF9qc18yLlNvY2tldEJsb2NrU3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlcl9zb2NrZXRfanNfMi5Tb2NrZXRQZW5kaW5nU3Vic2NyaWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldEV2ZW50U3Vic2NyaWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXJfc29ja2V0X2pzXzIuU29ja2V0RXZlbnRTdWJzY3JpYmVyOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU29ja2V0RXZlbnRTdWJzY3JpYmVyIiwiU29ja2V0UGVuZGluZ1N1YnNjcmliZXIiLCJTb2NrZXRCbG9ja1N1YnNjcmliZXIiLCJTb2NrZXRTdWJzY3JpYmVyIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJTb2NrZXRQcm92aWRlciIsIklwY1NvY2tldFByb3ZpZGVyIiwiUXVpY2tOb2RlUHJvdmlkZXIiLCJQb2NrZXRQcm92aWRlciIsIkluZnVyYVdlYlNvY2tldFByb3ZpZGVyIiwiSW5mdXJhUHJvdmlkZXIiLCJFdGhlcnNjYW5QbHVnaW4iLCJFdGhlcnNjYW5Qcm92aWRlciIsIkNsb3VkZmxhcmVQcm92aWRlciIsIkFua3JQcm92aWRlciIsIkFsY2hlbXlQcm92aWRlciIsIkJyb3dzZXJQcm92aWRlciIsIkpzb25ScGNTaWduZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJKc29uUnBjQXBpUHJvdmlkZXIiLCJGYWxsYmFja1Byb3ZpZGVyIiwiY29weVJlcXVlc3QiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiTG9nIiwiRmVlRGF0YSIsIkJsb2NrIiwiRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiIsIkZlZURhdGFOZXR3b3JrUGx1Z2luIiwiRW5zUGx1Z2luIiwiR2FzQ29zdFBsdWdpbiIsIk5ldHdvcmtQbHVnaW4iLCJOb25jZU1hbmFnZXIiLCJOZXR3b3JrIiwiTXVsdGljb2luUHJvdmlkZXJQbHVnaW4iLCJFbnNSZXNvbHZlciIsImdldERlZmF1bHRQcm92aWRlciIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJWb2lkU2lnbmVyIiwiQWJzdHJhY3RTaWduZXIiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiQWJzdHJhY3RQcm92aWRlciIsImFic3RyYWN0X3Byb3ZpZGVyX2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImFic3RyYWN0X3NpZ25lcl9qc18xIiwiY29tbXVuaXR5X2pzXzEiLCJkZWZhdWx0X3Byb3ZpZGVyX2pzXzEiLCJlbnNfcmVzb2x2ZXJfanNfMSIsIm5ldHdvcmtfanNfMSIsInNpZ25lcl9ub25jZW1hbmFnZXJfanNfMSIsInBsdWdpbnNfbmV0d29ya19qc18xIiwicHJvdmlkZXJfanNfMSIsInByb3ZpZGVyX2ZhbGxiYWNrX2pzXzEiLCJwcm92aWRlcl9qc29ucnBjX2pzXzEiLCJwcm92aWRlcl9icm93c2VyX2pzXzEiLCJwcm92aWRlcl9hbGNoZW15X2pzXzEiLCJwcm92aWRlcl9hbmtyX2pzXzEiLCJwcm92aWRlcl9jbG91ZGZsYXJlX2pzXzEiLCJwcm92aWRlcl9ldGhlcnNjYW5fanNfMSIsInByb3ZpZGVyX2luZnVyYV9qc18xIiwicHJvdmlkZXJfcG9ja2V0X2pzXzEiLCJwcm92aWRlcl9xdWlja25vZGVfanNfMSIsInByb3ZpZGVyX2lwY3NvY2tldF9qc18xIiwicHJvdmlkZXJfc29ja2V0X2pzXzEiLCJwcm92aWRlcl93ZWJzb2NrZXRfanNfMSIsInByb3ZpZGVyX3NvY2tldF9qc18yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/network.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Network = void 0;\nconst index_js_1 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/ const Networks = new Map();\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */ class Network {\n    #name;\n    #chainId;\n    #plugins;\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */ constructor(name, chainId){\n        this.#name = name;\n        this.#chainId = (0, index_js_2.getBigInt)(chainId);\n        this.#plugins = new Map();\n    }\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */ toJSON() {\n        return {\n            name: this.name,\n            chainId: String(this.chainId)\n        };\n    }\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */ get name() {\n        return this.#name;\n    }\n    set name(value) {\n        this.#name = value;\n    }\n    /**\n     *  The network chain ID.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0, index_js_2.getBigInt)(value, \"chainId\");\n    }\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */ matches(other) {\n        if (other == null) {\n            return false;\n        }\n        if (typeof other === \"string\") {\n            try {\n                return this.chainId === (0, index_js_2.getBigInt)(other);\n            } catch (error) {}\n            return this.name === other;\n        }\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\n            try {\n                return this.chainId === (0, index_js_2.getBigInt)(other);\n            } catch (error) {}\n            return false;\n        }\n        if (typeof other === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return this.chainId === (0, index_js_2.getBigInt)(other.chainId);\n                } catch (error) {}\n                return false;\n            }\n            if (other.name != null) {\n                return this.name === other.name;\n            }\n            return false;\n        }\n        return false;\n    }\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */ get plugins() {\n        return Array.from(this.#plugins.values());\n    }\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */ attachPlugin(plugin) {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */ getPlugin(name) {\n        return this.#plugins.get(name) || null;\n    }\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */ getPlugins(basename) {\n        return this.plugins.filter((p)=>p.name.split(\"#\")[0] === basename);\n    }\n    /**\n     *  Create a copy of this Network.\n     */ clone() {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin)=>{\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */ computeIntrinsicGas(tx) {\n        const costs = this.getPlugin(\"org.ethers.plugins.network.GasCost\") || new plugins_network_js_1.GasCostPlugin();\n        let gas = costs.txBase;\n        if (tx.to == null) {\n            gas += costs.txCreate;\n        }\n        if (tx.data) {\n            for(let i = 2; i < tx.data.length; i += 2){\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n        if (tx.accessList) {\n            const accessList = (0, index_js_1.accessListify)(tx.accessList);\n            for(const addr in accessList){\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n        return gas;\n    }\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */ static from(network) {\n        injectCommonNetworks();\n        // Default network\n        if (network == null) {\n            return Network.from(\"mainnet\");\n        }\n        // Canonical name or chain ID\n        if (typeof network === \"number\") {\n            network = BigInt(network);\n        }\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) {\n                return networkFunc();\n            }\n            if (typeof network === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n            (0, index_js_2.assertArgument)(false, \"unknown network\", \"network\", network);\n        }\n        // Clonable with network-like abilities\n        if (typeof network.clone === \"function\") {\n            const clone = network.clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n        // Networkish\n        if (typeof network === \"object\") {\n            (0, index_js_2.assertArgument)(typeof network.name === \"string\" && typeof network.chainId === \"number\", \"invalid network object name or chainId\", \"network\", network);\n            const custom = new Network(network.name, network.chainId);\n            if (network.ensAddress || network.ensNetwork != null) {\n                custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));\n            }\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n            return custom;\n        }\n        (0, index_js_2.assertArgument)(false, \"invalid network\", \"network\", network);\n    }\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */ static register(nameOrChainId, networkFunc) {\n        if (typeof nameOrChainId === \"number\") {\n            nameOrChainId = BigInt(nameOrChainId);\n        }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            (0, index_js_2.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\nexports.Network = Network;\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value, decimals) {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) {\n        comps.push(\"\");\n    }\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${_value}`);\n    }\n    // Pad the fraction to 9 decimalplaces\n    while(comps[1].length < decimals){\n        comps[1] += \"0\";\n    }\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) {\n            frac++;\n        }\n        comps[1] = frac.toString();\n    }\n    return BigInt(comps[0] + comps[1]);\n}\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url) {\n    return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request)=>{\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n        let response;\n        try {\n            const [_response, _feeData] = await Promise.all([\n                request.send(),\n                fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)\n            };\n            return feeData;\n        } catch (error) {\n            (0, index_js_2.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, \"SERVER_ERROR\", {\n                request,\n                response,\n                error\n            });\n        }\n    });\n}\n// Used by Optimism for a custom priority fee\nfunction getPriorityFeePlugin(maxPriorityFeePerGas) {\n    return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(\"data:\", async (fetchFeeData, provider, request)=>{\n        const feeData = await fetchFeeData();\n        // This should always fail\n        if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {\n            return feeData;\n        }\n        // Compute the corrected baseFee to recompute the updated values\n        const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;\n        return {\n            gasPrice: feeData.gasPrice,\n            maxFeePerGas: baseFee + maxPriorityFeePerGas,\n            maxPriorityFeePerGas\n        };\n    });\n}\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks() {\n    if (injected) {\n        return;\n    }\n    injected = true;\n    /// Register popular Ethereum networks\n    function registerEth(name, chainId, options) {\n        const func = function() {\n            const network = new Network(name, chainId);\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));\n            }\n            network.attachPlugin(new plugins_network_js_1.GasCostPlugin());\n            (options.plugins || []).forEach((plugin)=>{\n                network.attachPlugin(plugin);\n            });\n            return network;\n        };\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n        if (options.altNames) {\n            options.altNames.forEach((name)=>{\n                Network.register(name, func);\n            });\n        }\n    }\n    registerEth(\"mainnet\", 1, {\n        ensNetwork: 1,\n        altNames: [\n            \"homestead\"\n        ]\n    });\n    registerEth(\"ropsten\", 3, {\n        ensNetwork: 3\n    });\n    registerEth(\"rinkeby\", 4, {\n        ensNetwork: 4\n    });\n    registerEth(\"goerli\", 5, {\n        ensNetwork: 5\n    });\n    registerEth(\"kovan\", 42, {\n        ensNetwork: 42\n    });\n    registerEth(\"sepolia\", 11155111, {});\n    registerEth(\"classic\", 61, {});\n    registerEth(\"classicKotti\", 6, {});\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1\n    });\n    registerEth(\"arbitrum-goerli\", 421613, {});\n    registerEth(\"bnb\", 56, {\n        ensNetwork: 1\n    });\n    registerEth(\"bnbt\", 97, {});\n    registerEth(\"linea\", 59144, {\n        ensNetwork: 1\n    });\n    registerEth(\"linea-goerli\", 59140, {});\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [\n            \"maticMumbai\",\n            \"maticmum\"\n        ],\n        plugins: [\n            getGasStationPlugin(\"https://gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: [\n            getPriorityFeePlugin(BigInt(\"1000000\"))\n        ]\n    });\n    registerEth(\"optimism-goerli\", 420, {});\n    registerEth(\"xdai\", 100, {\n        ensNetwork: 1\n    });\n} //# sourceMappingURL=network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvbmV0d29yay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7OztDQUtDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw4RkFBeUI7QUFDcEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1FLHVCQUF1QkYsbUJBQU9BLENBQUMsbUdBQXNCO0FBQzNEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLEdBQ0EsTUFBTUcsV0FBVyxJQUFJQztBQUNyQjs7O0NBR0MsR0FDRCxNQUFNTjtJQUNGLENBQUNPLElBQUksQ0FBQztJQUNOLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE9BQU8sQ0FBQztJQUNUOztLQUVDLEdBQ0RDLFlBQVlILElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3ZCLElBQUksQ0FBQyxDQUFDRCxJQUFJLEdBQUdBO1FBQ2IsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBRyxDQUFDLEdBQUdMLFdBQVdRLFNBQVMsRUFBRUg7UUFDMUMsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBRyxJQUFJSDtJQUN4QjtJQUNBOztLQUVDLEdBQ0RNLFNBQVM7UUFDTCxPQUFPO1lBQUVMLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQUVDLFNBQVNLLE9BQU8sSUFBSSxDQUFDTCxPQUFPO1FBQUU7SUFDNUQ7SUFDQTs7Ozs7S0FLQyxHQUNELElBQUlELE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxJQUFJO0lBQUU7SUFDaEMsSUFBSUEsS0FBS1IsS0FBSyxFQUFFO1FBQUUsSUFBSSxDQUFDLENBQUNRLElBQUksR0FBR1I7SUFBTztJQUN0Qzs7S0FFQyxHQUNELElBQUlTLFVBQVU7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxPQUFPO0lB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QUFnQixHQUFHLENBQUM7SUFDaENBLFlBQVksWUFBWSxPQUFPO1FBQzNCekMsWUFBWTtJQUNoQjtJQUNBeUMsWUFBWSxtQkFBbUIsUUFBUSxDQUFDO0lBQ3hDQSxZQUFZLE9BQU8sSUFBSTtRQUFFekMsWUFBWTtJQUFFO0lBQ3ZDeUMsWUFBWSxRQUFRLElBQUksQ0FBQztJQUN6QkEsWUFBWSxTQUFTLE9BQU87UUFBRXpDLFlBQVk7SUFBRTtJQUM1Q3lDLFlBQVksZ0JBQWdCLE9BQU8sQ0FBQztJQUNwQ0EsWUFBWSxTQUFTLEtBQUs7UUFDdEJ6QyxZQUFZO1FBQ1puRCxTQUFTO1lBQ0xrRSxvQkFBb0I7U0FDdkI7SUFDTDtJQUNBMEIsWUFBWSxnQkFBZ0IsT0FBTztRQUMvQkcsVUFBVTtZQUFDO1lBQWU7U0FBVztRQUNyQy9GLFNBQVM7WUFDTGtFLG9CQUFvQjtTQUN2QjtJQUNMO0lBQ0EwQixZQUFZLFlBQVksSUFBSTtRQUN4QnpDLFlBQVk7UUFDWm5ELFNBQVM7WUFDTHlGLHFCQUFxQjNDLE9BQU87U0FDL0I7SUFDTDtJQUNBOEMsWUFBWSxtQkFBbUIsS0FBSyxDQUFDO0lBQ3JDQSxZQUFZLFFBQVEsS0FBSztRQUFFekMsWUFBWTtJQUFFO0FBQzdDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL25ldHdvcmsuanM/Y2JkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEEgKipOZXR3b3JrKiogZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgcmVxdWlyZWQgdG9cbiAqICBpbnRlcmFjdCB3aXRoIGEgc3BlY2lmaWMgY2hhaW4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVyczpOZXR3b3JrcyAgW25ldHdvcmtzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmsgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHBsdWdpbnNfbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vcGx1Z2lucy1uZXR3b3JrLmpzXCIpO1xuLyogKiAqICpcbi8vIE5ldHdvcmtzIHdoaWNoIG9wZXJhdGlvbiBhZ2FpbnN0IGFuIEwyIGNhbiB1c2UgdGhpcyBwbHVnaW4gdG9cbi8vIHNwZWNpZnkgaG93IHRvIGFjY2VzcyBMMSwgZm9yIHRoZSBwdXJwb3NlIG9mIHJlc29sdmluZyBFTlMsXG4vLyBmb3IgZXhhbXBsZS5cbmV4cG9ydCBjbGFzcyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSBwcm92aWRlciE6IFByb3ZpZGVyO1xuLy8gQFRPRE86IFJlbmFtZSB0byBDaGFpbkFjY2VzcyBhbmQgYWxsb3cgZm9yIGNvbm5lY3RpbmcgdG8gYW55IGNoYWluXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXI6IFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLmxheWVyLW9uZS1jb25uZWN0aW9uXCIpO1xuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzPExheWVyT25lQ29ubmVjdGlvblBsdWdpbj4odGhpcywgeyBwcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOiBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4ge1xuICAgICAgICByZXR1cm4gbmV3IExheWVyT25lQ29ubmVjdGlvblBsdWdpbih0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG59XG4qL1xuY29uc3QgTmV0d29ya3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqICBBICoqTmV0d29yayoqIHByb3ZpZGVzIGFjY2VzcyB0byBhIGNoYWluJ3MgcHJvcGVydGllcyBhbmQgYWxsb3dzXG4gKiAgZm9yIHBsdWctaW5zIHRvIGV4dGVuZCBmdW5jdGlvbmFsaXR5LlxuICovXG5jbGFzcyBOZXR3b3JrIHtcbiAgICAjbmFtZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjcGx1Z2lucztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmsqKiBmb3IgJSVuYW1lJSUgYW5kICUlY2hhaW5JZCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNoYWluSWQpIHtcbiAgICAgICAgdGhpcy4jbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKGNoYWluSWQpO1xuICAgICAgICB0aGlzLiNwbHVnaW5zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIE5ldHdvcmsuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBuYW1lOiB0aGlzLm5hbWUsIGNoYWluSWQ6IFN0cmluZyh0aGlzLmNoYWluSWQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjb21tb24gbmFtZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBjYW5vbmljYWwgbmFtZSwgYXMgbmV0d29ya3MgbWlnaCBoYXZlIG11bHRpcGxlXG4gICAgICogIG5hbWVzLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy4jbmFtZTsgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7IHRoaXMuI25hbWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmV0d29yayBjaGFpbiBJRC5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KSh2YWx1ZSwgXCJjaGFpbklkXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgbWF0Y2hlcyB0aGlzIG5ldHdvcmsuIEFueSBjaGFpbiBJRFxuICAgICAqICBtdXN0IG1hdGNoLCBhbmQgaWYgbm8gY2hhaW4gSUQgaXMgcHJlc2VudCwgdGhlIG5hbWUgbXVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjdXJyZW50bHkgY2hlY2sgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllcyxcbiAgICAgKiAgc3VjaCBhcyBFTlMgYWRkcmVzcyBvciBwbHVnLWluIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgbWF0Y2hlcyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhaW5JZCA9PT0gKDAsIGluZGV4X2pzXzIuZ2V0QmlnSW50KShvdGhlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lID09PSBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3RoZXIpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAob3RoZXIpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKG90aGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKG90aGVyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKG90aGVyLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFpbklkID09PSAoMCwgaW5kZXhfanNfMi5nZXRCaWdJbnQpKG90aGVyLmNoYWluSWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGxpc3Qgb2YgcGx1Z2lucyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBOZXR3b3JrLlxuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNwbHVnaW5zLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEF0dGFjaCBhIG5ldyAlJXBsdWdpbiUlIHRvIHRoaXMgTmV0d29yay4gVGhlIG5ldHdvcmsgbmFtZVxuICAgICAqICBtdXN0IGJlIHVuaXF1ZSwgZXhjbHVkaW5nIGFueSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBhdHRhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmICh0aGlzLiNwbHVnaW5zLmdldChwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlcGxhY2UgZXhpc3RpbmcgcGx1Z2luOiAke3BsdWdpbi5uYW1lfSBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwbHVnaW5zLnNldChwbHVnaW4ubmFtZSwgcGx1Z2luLmNsb25lKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiB0aGUgcGx1Z2luLCBpZiBhbnksIG1hdGNoaW5nICUlbmFtZSUlIGV4YWN0bHkuIFBsdWdpbnNcbiAgICAgKiAgd2l0aCBmcmFnbWVudHMgd2lsbCBub3QgYmUgcmV0dXJuZWQgdW5sZXNzICUlbmFtZSUlIGluY2x1ZGVzXG4gICAgICogIGEgZnJhZ21lbnQuXG4gICAgICovXG4gICAgZ2V0UGx1Z2luKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNwbHVnaW5zLmdldChuYW1lKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldHMgYSBsaXN0IG9mIGFsbCBwbHVnaW5zIHRoYXQgbWF0Y2ggJSVuYW1lJSUsIHdpdGggb3RyIHdpdGhvdXRcbiAgICAgKiAgYSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBnZXRQbHVnaW5zKGJhc2VuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wbHVnaW5zLmZpbHRlcigocCkgPT4gKHAubmFtZS5zcGxpdChcIiNcIilbMF0gPT09IGJhc2VuYW1lKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIE5ldHdvcmsuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IE5ldHdvcmsodGhpcy5uYW1lLCB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICBjbG9uZS5hdHRhY2hQbHVnaW4ocGx1Z2luLmNsb25lKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBBIEdhc0Nvc3RQbHVnaW4gY2FuIGJlIGF0dGFjaGVkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0XG4gICAgICogIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjb21wdXRlSW50cmluc2ljR2FzKHR4KSB7XG4gICAgICAgIGNvbnN0IGNvc3RzID0gdGhpcy5nZXRQbHVnaW4oXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5HYXNDb3N0XCIpIHx8IChuZXcgcGx1Z2luc19uZXR3b3JrX2pzXzEuR2FzQ29zdFBsdWdpbigpKTtcbiAgICAgICAgbGV0IGdhcyA9IGNvc3RzLnR4QmFzZTtcbiAgICAgICAgaWYgKHR4LnRvID09IG51bGwpIHtcbiAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eENyZWF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0eC5kYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gXCIwMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eERhdGFaZXJvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzICs9IGNvc3RzLnR4RGF0YU5vbnplcm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NMaXN0ID0gKDAsIGluZGV4X2pzXzEuYWNjZXNzTGlzdGlmeSkodHguYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHIgaW4gYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIGdhcyArPSBjb3N0cy50eEFjY2Vzc0xpc3RBZGRyZXNzICsgY29zdHMudHhBY2Nlc3NMaXN0U3RvcmFnZUtleSAqIGFjY2Vzc0xpc3RbYWRkcl0uc3RvcmFnZUtleXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IE5ldHdvcmsgZm9yIHRoZSAlJW5ldHdvcmslJSBuYW1lIG9yIGNoYWluSWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20obmV0d29yaykge1xuICAgICAgICBpbmplY3RDb21tb25OZXR3b3JrcygpO1xuICAgICAgICAvLyBEZWZhdWx0IG5ldHdvcmtcbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5ldHdvcmsuZnJvbShcIm1haW5uZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2Fub25pY2FsIG5hbWUgb3IgY2hhaW4gSURcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBCaWdJbnQobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIChuZXR3b3JrKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0Z1bmMgPSBOZXR3b3Jrcy5nZXQobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobmV0d29ya0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29ya0Z1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrKFwidW5rbm93blwiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bmtub3duIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsb25hYmxlIHdpdGggbmV0d29yay1saWtlIGFiaWxpdGllc1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNsb25lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IG5ldHdvcmsuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vaWYgKHR5cGVvZihuZXR3b3JrLm5hbWUpICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZihuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXR3b3JraXNoXG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChuZXR3b3JrLm5hbWUpID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiAobmV0d29yay5jaGFpbklkKSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIG5ldHdvcmsgb2JqZWN0IG5hbWUgb3IgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCBjdXN0b20gPSBuZXcgTmV0d29yaygobmV0d29yay5uYW1lKSwgKG5ldHdvcmsuY2hhaW5JZCkpO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBuZXR3b3JrLmVuc05ldHdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbS5hdHRhY2hQbHVnaW4obmV3IHBsdWdpbnNfbmV0d29ya19qc18xLkVuc1BsdWdpbihuZXR3b3JrLmVuc0FkZHJlc3MsIG5ldHdvcmsuZW5zTmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiAoKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAgICBjdXN0b20uYXR0YWNoUGx1Z2luKG5ldyBMYXllck9uZUNvbm5lY3Rpb25QbHVnaW4oKDxhbnk+bmV0d29yaykubGF5ZXJPbmVDb25uZWN0aW9uKSk7XG4gICAgICAgICAgICAvL31cbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZWdpc3RlciAlJW5hbWVPckNoYWluSWQlJSB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJuc1xuICAgICAqICBhbiBpbnN0YW5jZSBvZiBhIE5ldHdvcmsgcmVwcmVzZW50aW5nIHRoYXQgY2hhaW4uXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2lzdGVyKG5hbWVPckNoYWluSWQsIG5ldHdvcmtGdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWVPckNoYWluSWQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBuYW1lT3JDaGFpbklkID0gQmlnSW50KG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gTmV0d29ya3MuZ2V0KG5hbWVPckNoYWluSWQpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgYGNvbmZsaWN0aW5nIG5ldHdvcmsgZm9yICR7SlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcubmFtZSl9YCwgXCJuYW1lT3JDaGFpbklkXCIsIG5hbWVPckNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtzLnNldChuYW1lT3JDaGFpbklkLCBuZXR3b3JrRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrID0gTmV0d29yaztcbi8vIFdlIGRvbid0IHdhbnQgdG8gYnJpbmcgaW4gZm9ybWF0VW5pdHMgYmVjYXVzZSBpdCBpcyBiYWNrZWQgYnlcbi8vIEZpeGVkTnVtYmVyIGFuZCB3ZSB3YW50IHRvIGtlZXAgTmV0d29ya3MgdGlueS4gVGhlIHZhbHVlc1xuLy8gaW5jbHVkZWQgYnkgdGhlIEdhcyBTdGF0aW9ucyBhcmUgYWxzbyBJRUVFIDc1NCB3aXRoIGxvdHMgb2Zcbi8vIHJvdW5kaW5nIGlzc3VlcyBhbmQgZXhjZWVkIHRoZSBzdHJpY3QgY2hlY2tzIGZvcm1hdFVuaXRzIGhhcy5cbmZ1bmN0aW9uIHBhcnNlVW5pdHMoX3ZhbHVlLCBkZWNpbWFscykge1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKF92YWx1ZSk7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXlswLTkuXSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGd3ZWkgdmFsdWU6ICR7X3ZhbHVlfWApO1xuICAgIH1cbiAgICAvLyBCcmVhayBpbnRvIFsgd2hvbGUsIGZyYWN0aW9uIF1cbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbXBzLnB1c2goXCJcIik7XG4gICAgfVxuICAgIC8vIE1vcmUgdGhhbiAxIGRlY2ltYWwgcG9pbnQgb3IgdG9vIG1hbnkgZnJhY3Rpb25hbCBwb3NpdGlvbnNcbiAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBnd2VpIHZhbHVlOiAke192YWx1ZX1gKTtcbiAgICB9XG4gICAgLy8gUGFkIHRoZSBmcmFjdGlvbiB0byA5IGRlY2ltYWxwbGFjZXNcbiAgICB3aGlsZSAoY29tcHNbMV0ubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29tcHNbMV0gKz0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRvbyBtYW55IGRlY2ltYWxzIGFuZCBzb21lIG5vbi16ZXJvIGVuZGluZywgdGFrZSB0aGUgY2VpbGluZ1xuICAgIGlmIChjb21wc1sxXS5sZW5ndGggPiA5KSB7XG4gICAgICAgIGxldCBmcmFjID0gQmlnSW50KGNvbXBzWzFdLnN1YnN0cmluZygwLCA5KSk7XG4gICAgICAgIGlmICghY29tcHNbMV0uc3Vic3RyaW5nKDkpLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgIGZyYWMrKztcbiAgICAgICAgfVxuICAgICAgICBjb21wc1sxXSA9IGZyYWMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChjb21wc1swXSArIGNvbXBzWzFdKTtcbn1cbi8vIFVzZWQgYnkgUG9seWdvbiB0byB1c2UgYSBnYXMgc3RhdGlvbiBmb3IgZmVlIGRhdGFcbmZ1bmN0aW9uIGdldEdhc1N0YXRpb25QbHVnaW4odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKHVybCwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgLy8gUHJldmVudCBDbG91ZGZsYXJlIGZyb20gYmxvY2tpbmcgb3VyIHJlcXVlc3QgaW4gbm9kZS5qc1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcIlVzZXItQWdlbnRcIiwgXCJldGhlcnNcIik7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtfcmVzcG9uc2UsIF9mZWVEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKSwgZmV0Y2hGZWVEYXRhKClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzcG9uc2UuYm9keUpzb24uc3RhbmRhcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWVEYXRhID0ge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBfZmVlRGF0YS5nYXNQcmljZSxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcnNlVW5pdHMocGF5bG9hZC5tYXhGZWUsIDkpLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJzZVVuaXRzKHBheWxvYWQubWF4UHJpb3JpdHlGZWUsIDkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0KShmYWxzZSwgYGVycm9yIGVuY291bnRlcmVkIHdpdGggcG9seWdvbiBnYXMgc3RhdGlvbiAoJHtKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnVybCl9KWAsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBVc2VkIGJ5IE9wdGltaXNtIGZvciBhIGN1c3RvbSBwcmlvcml0eSBmZWVcbmZ1bmN0aW9uIGdldFByaW9yaXR5RmVlUGx1Z2luKG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgcmV0dXJuIG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luKFwiZGF0YTpcIiwgYXN5bmMgKGZldGNoRmVlRGF0YSwgcHJvdmlkZXIsIHJlcXVlc3QpID0+IHtcbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IGZldGNoRmVlRGF0YSgpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBhbHdheXMgZmFpbFxuICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgPT0gbnVsbCB8fCBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvcnJlY3RlZCBiYXNlRmVlIHRvIHJlY29tcHV0ZSB0aGUgdXBkYXRlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgYmFzZUZlZSA9IGZlZURhdGEubWF4RmVlUGVyR2FzIC0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBmZWVEYXRhLmdhc1ByaWNlLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiAoYmFzZUZlZSArIG1heFByaW9yaXR5RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xubGV0IGluamVjdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbmplY3RDb21tb25OZXR3b3JrcygpIHtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgLy8vIFJlZ2lzdGVyIHBvcHVsYXIgRXRoZXJldW0gbmV0d29ya3NcbiAgICBmdW5jdGlvbiByZWdpc3RlckV0aChuYW1lLCBjaGFpbklkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV3IE5ldHdvcmsobmFtZSwgY2hhaW5JZCk7XG4gICAgICAgICAgICAvLyBXZSB1c2UgMCB0byBkaXNhYmxlIEVOU1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5zTmV0d29yayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4obmV3IHBsdWdpbnNfbmV0d29ya19qc18xLkVuc1BsdWdpbihudWxsLCBvcHRpb25zLmVuc05ldHdvcmspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldHdvcmsuYXR0YWNoUGx1Z2luKG5ldyBwbHVnaW5zX25ldHdvcmtfanNfMS5HYXNDb3N0UGx1Z2luKCkpO1xuICAgICAgICAgICAgKG9wdGlvbnMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAgICAgbmV0d29yay5hdHRhY2hQbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXR3b3JrIGJ5IG5hbWUgYW5kIGNoYWluIElEXG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIobmFtZSwgZnVuYyk7XG4gICAgICAgIE5ldHdvcmsucmVnaXN0ZXIoY2hhaW5JZCwgZnVuYyk7XG4gICAgICAgIGlmIChvcHRpb25zLmFsdE5hbWVzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsdE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBOZXR3b3JrLnJlZ2lzdGVyKG5hbWUsIGZ1bmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJFdGgoXCJtYWlubmV0XCIsIDEsIHsgZW5zTmV0d29yazogMSwgYWx0TmFtZXM6IFtcImhvbWVzdGVhZFwiXSB9KTtcbiAgICByZWdpc3RlckV0aChcInJvcHN0ZW5cIiwgMywgeyBlbnNOZXR3b3JrOiAzIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwicmlua2VieVwiLCA0LCB7IGVuc05ldHdvcms6IDQgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJnb2VybGlcIiwgNSwgeyBlbnNOZXR3b3JrOiA1IH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwia292YW5cIiwgNDIsIHsgZW5zTmV0d29yazogNDIgfSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJzZXBvbGlhXCIsIDExMTU1MTExLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljXCIsIDYxLCB7fSk7XG4gICAgcmVnaXN0ZXJFdGgoXCJjbGFzc2ljS290dGlcIiwgNiwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYXJiaXRydW1cIiwgNDIxNjEsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICB9KTtcbiAgICByZWdpc3RlckV0aChcImFyYml0cnVtLWdvZXJsaVwiLCA0MjE2MTMsIHt9KTtcbiAgICByZWdpc3RlckV0aChcImJuYlwiLCA1NiwgeyBlbnNOZXR3b3JrOiAxIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwiYm5idFwiLCA5Nywge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibGluZWFcIiwgNTkxNDQsIHsgZW5zTmV0d29yazogMSB9KTtcbiAgICByZWdpc3RlckV0aChcImxpbmVhLWdvZXJsaVwiLCA1OTE0MCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWNcIiwgMTM3LCB7XG4gICAgICAgIGVuc05ldHdvcms6IDEsXG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGdldEdhc1N0YXRpb25QbHVnaW4oXCJodHRwczovXFwvZ2Fzc3RhdGlvbi5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwibWF0aWMtbXVtYmFpXCIsIDgwMDAxLCB7XG4gICAgICAgIGFsdE5hbWVzOiBbXCJtYXRpY011bWJhaVwiLCBcIm1hdGljbXVtXCJdLFxuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBnZXRHYXNTdGF0aW9uUGx1Z2luKFwiaHR0cHM6L1xcL2dhc3N0YXRpb24tdGVzdG5ldC5wb2x5Z29uLnRlY2hub2xvZ3kvdjJcIilcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc21cIiwgMTAsIHtcbiAgICAgICAgZW5zTmV0d29yazogMSxcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgZ2V0UHJpb3JpdHlGZWVQbHVnaW4oQmlnSW50KFwiMTAwMDAwMFwiKSlcbiAgICAgICAgXVxuICAgIH0pO1xuICAgIHJlZ2lzdGVyRXRoKFwib3B0aW1pc20tZ29lcmxpXCIsIDQyMCwge30pO1xuICAgIHJlZ2lzdGVyRXRoKFwieGRhaVwiLCAxMDAsIHsgZW5zTmV0d29yazogMSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTmV0d29yayIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsInBsdWdpbnNfbmV0d29ya19qc18xIiwiTmV0d29ya3MiLCJNYXAiLCJuYW1lIiwiY2hhaW5JZCIsInBsdWdpbnMiLCJjb25zdHJ1Y3RvciIsImdldEJpZ0ludCIsInRvSlNPTiIsIlN0cmluZyIsIm1hdGNoZXMiLCJvdGhlciIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYXR0YWNoUGx1Z2luIiwicGx1Z2luIiwiZ2V0IiwiRXJyb3IiLCJzZXQiLCJjbG9uZSIsImdldFBsdWdpbiIsImdldFBsdWdpbnMiLCJiYXNlbmFtZSIsImZpbHRlciIsInAiLCJzcGxpdCIsImZvckVhY2giLCJjb21wdXRlSW50cmluc2ljR2FzIiwidHgiLCJjb3N0cyIsIkdhc0Nvc3RQbHVnaW4iLCJnYXMiLCJ0eEJhc2UiLCJ0byIsInR4Q3JlYXRlIiwiZGF0YSIsImkiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ0eERhdGFaZXJvIiwidHhEYXRhTm9uemVybyIsImFjY2Vzc0xpc3QiLCJhY2Nlc3NMaXN0aWZ5IiwiYWRkciIsInR4QWNjZXNzTGlzdEFkZHJlc3MiLCJ0eEFjY2Vzc0xpc3RTdG9yYWdlS2V5Iiwic3RvcmFnZUtleXMiLCJuZXR3b3JrIiwiaW5qZWN0Q29tbW9uTmV0d29ya3MiLCJCaWdJbnQiLCJuZXR3b3JrRnVuYyIsImFzc2VydEFyZ3VtZW50IiwiY3VzdG9tIiwiZW5zQWRkcmVzcyIsImVuc05ldHdvcmsiLCJFbnNQbHVnaW4iLCJyZWdpc3RlciIsIm5hbWVPckNoYWluSWQiLCJleGlzdGluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZVVuaXRzIiwiX3ZhbHVlIiwiZGVjaW1hbHMiLCJtYXRjaCIsImNvbXBzIiwicHVzaCIsImZyYWMiLCJ0b1N0cmluZyIsImdldEdhc1N0YXRpb25QbHVnaW4iLCJ1cmwiLCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIiwiZmV0Y2hGZWVEYXRhIiwicHJvdmlkZXIiLCJyZXF1ZXN0Iiwic2V0SGVhZGVyIiwicmVzcG9uc2UiLCJfcmVzcG9uc2UiLCJfZmVlRGF0YSIsIlByb21pc2UiLCJhbGwiLCJzZW5kIiwicGF5bG9hZCIsImJvZHlKc29uIiwic3RhbmRhcmQiLCJmZWVEYXRhIiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJHYXMiLCJtYXhGZWUiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlIiwiYXNzZXJ0IiwiZ2V0UHJpb3JpdHlGZWVQbHVnaW4iLCJiYXNlRmVlIiwiaW5qZWN0ZWQiLCJyZWdpc3RlckV0aCIsIm9wdGlvbnMiLCJmdW5jIiwiYWx0TmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/plugins-network.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;\nconst properties_js_1 = __webpack_require__(/*! ../utils/properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */ class NetworkPlugin {\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */ constructor(name){\n        (0, properties_js_1.defineProperties)(this, {\n            name\n        });\n    }\n    /**\n     *  Creates a copy of this plugin.\n     */ clone() {\n        return new NetworkPlugin(this.name);\n    }\n}\nexports.NetworkPlugin = NetworkPlugin;\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */ class GasCostPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */ constructor(effectiveBlock, costs){\n        if (effectiveBlock == null) {\n            effectiveBlock = 0;\n        }\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);\n        const props = {\n            effectiveBlock\n        };\n        function set(name, nullish) {\n            let value = (costs || {})[name];\n            if (value == null) {\n                value = nullish;\n            }\n            (0, index_js_1.assertArgument)(typeof value === \"number\", `invalud value for ${name}`, \"costs\", costs);\n            props[name] = value;\n        }\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n        (0, properties_js_1.defineProperties)(this, props);\n    }\n    clone() {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\nexports.GasCostPlugin = GasCostPlugin;\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */ class EnsPlugin extends NetworkPlugin {\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */ constructor(address, targetNetwork){\n        super(\"org.ethers.plugins.network.Ens\");\n        (0, properties_js_1.defineProperties)(this, {\n            address: address || EnsAddress,\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork\n        });\n    }\n    clone() {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\nexports.EnsPlugin = EnsPlugin;\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */ class FeeDataNetworkPlugin extends NetworkPlugin {\n    #feeDataFunc;\n    /**\n     *  The fee data function provided to the constructor.\n     */ get feeDataFunc() {\n        return this.#feeDataFunc;\n    }\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */ constructor(feeDataFunc){\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n    /**\n     *  Resolves to the fee data.\n     */ async getFeeData(provider) {\n        return await this.#feeDataFunc(provider);\n    }\n    clone() {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\nexports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    #url;\n    #processFunc;\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */ get url() {\n        return this.#url;\n    }\n    /**\n     *  The callback to use when computing the FeeData.\n     */ get processFunc() {\n        return this.#processFunc;\n    }\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */ constructor(url, processFunc){\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n    // We are immutable, so we can serve as our own clone\n    clone() {\n        return this;\n    }\n}\nexports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin; /*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/  //# sourceMappingURL=plugins-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcGx1Z2lucy1uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQ0FBb0MsR0FBR0EsNEJBQTRCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMvSSxNQUFNTyxrQkFBa0JDLG1CQUFPQSxDQUFDLDRGQUF3QjtBQUN4RCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsYUFBYTtBQUNuQjs7Q0FFQyxHQUNELE1BQU1KO0lBUUY7O0tBRUMsR0FDREssWUFBWUMsSUFBSSxDQUFFO1FBQ2IsSUFBR0wsZ0JBQWdCTSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRUQ7UUFBSztJQUN2RDtJQUNBOztLQUVDLEdBQ0RFLFFBQVE7UUFDSixPQUFPLElBQUlSLGNBQWMsSUFBSSxDQUFDTSxJQUFJO0lBQ3RDO0FBQ0o7QUFDQVoscUJBQXFCLEdBQUdNO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1ELHNCQUFzQkM7SUFnQ3hCOzs7O0tBSUMsR0FDREssWUFBWUksY0FBYyxFQUFFQyxLQUFLLENBQUU7UUFDL0IsSUFBSUQsa0JBQWtCLE1BQU07WUFDeEJBLGlCQUFpQjtRQUNyQjtRQUNBLEtBQUssQ0FBQyxDQUFDLG1DQUFtQyxFQUFHQSxrQkFBa0IsRUFBRyxDQUFDO1FBQ25FLE1BQU1FLFFBQVE7WUFBRUY7UUFBZTtRQUMvQixTQUFTRyxJQUFJTixJQUFJLEVBQUVPLE9BQU87WUFDdEIsSUFBSWxCLFFBQVEsQ0FBQ2UsU0FBUyxDQUFDLEVBQUUsQ0FBQ0osS0FBSztZQUMvQixJQUFJWCxTQUFTLE1BQU07Z0JBQ2ZBLFFBQVFrQjtZQUNaO1lBQ0MsSUFBR1YsV0FBV1csY0FBYyxFQUFFLE9BQVFuQixVQUFXLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRVcsS0FBSyxDQUFDLEVBQUUsU0FBU0k7WUFDbEdDLEtBQUssQ0FBQ0wsS0FBSyxHQUFHWDtRQUNsQjtRQUNBaUIsSUFBSSxVQUFVO1FBQ2RBLElBQUksWUFBWTtRQUNoQkEsSUFBSSxjQUFjO1FBQ2xCQSxJQUFJLGlCQUFpQjtRQUNyQkEsSUFBSSwwQkFBMEI7UUFDOUJBLElBQUksdUJBQXVCO1FBQzFCLElBQUdYLGdCQUFnQk0sZ0JBQWdCLEVBQUUsSUFBSSxFQUFFSTtJQUNoRDtJQUNBSCxRQUFRO1FBQ0osT0FBTyxJQUFJVCxjQUFjLElBQUksQ0FBQ1UsY0FBYyxFQUFFLElBQUk7SUFDdEQ7QUFDSjtBQUNBZixxQkFBcUIsR0FBR0s7QUFDeEI7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNRCxrQkFBa0JFO0lBU3BCOzs7O0tBSUMsR0FDREssWUFBWVUsT0FBTyxFQUFFQyxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDO1FBQ0wsSUFBR2YsZ0JBQWdCTSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFDeENRLFNBQVVBLFdBQVdYO1lBQ3JCWSxlQUFnQixpQkFBa0IsT0FBUSxJQUFJQTtRQUNsRDtJQUNKO0lBQ0FSLFFBQVE7UUFDSixPQUFPLElBQUlWLFVBQVUsSUFBSSxDQUFDaUIsT0FBTyxFQUFFLElBQUksQ0FBQ0MsYUFBYTtJQUN6RDtBQUNKO0FBQ0F0QixpQkFBaUIsR0FBR0k7QUFDcEI7Ozs7OztDQU1DLEdBQ0QsTUFBTUQsNkJBQTZCRztJQUMvQixDQUFDaUIsV0FBVyxDQUFDO0lBQ2I7O0tBRUMsR0FDRCxJQUFJQSxjQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUM1QjtJQUNBOztLQUVDLEdBQ0RaLFlBQVlZLFdBQVcsQ0FBRTtRQUNyQixLQUFLLENBQUM7UUFDTixJQUFJLENBQUMsQ0FBQ0EsV0FBVyxHQUFHQTtJQUN4QjtJQUNBOztLQUVDLEdBQ0QsTUFBTUMsV0FBV0MsUUFBUSxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQ0YsV0FBVyxDQUFDRTtJQUNuQztJQUNBWCxRQUFRO1FBQ0osT0FBTyxJQUFJWCxxQkFBcUIsSUFBSSxDQUFDLENBQUNvQixXQUFXO0lBQ3JEO0FBQ0o7QUFDQXZCLDRCQUE0QixHQUFHRztBQUMvQixNQUFNRCxxQ0FBcUNJO0lBQ3ZDLENBQUNvQixHQUFHLENBQUM7SUFDTCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNELElBQUlELE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxHQUFHO0lBQUU7SUFDOUI7O0tBRUMsR0FDRCxJQUFJQyxjQUFjO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsV0FBVztJQUFFO0lBQzlDOzs7S0FHQyxHQUNEaEIsWUFBWWUsR0FBRyxFQUFFQyxXQUFXLENBQUU7UUFDMUIsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDLENBQUNELEdBQUcsR0FBR0E7UUFDWixJQUFJLENBQUMsQ0FBQ0MsV0FBVyxHQUFHQTtJQUN4QjtJQUNBLHFEQUFxRDtJQUNyRGIsUUFBUTtRQUFFLE9BQU8sSUFBSTtJQUFFO0FBQzNCO0FBQ0FkLG9DQUFvQyxHQUFHRSw4QkFDdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3BsdWdpbnMtbmV0d29yay5qcz9iMzI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luID0gZXhwb3J0cy5GZWVEYXRhTmV0d29ya1BsdWdpbiA9IGV4cG9ydHMuRW5zUGx1Z2luID0gZXhwb3J0cy5HYXNDb3N0UGx1Z2luID0gZXhwb3J0cy5OZXR3b3JrUGx1Z2luID0gdm9pZCAwO1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3Byb3BlcnRpZXMuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgRW5zQWRkcmVzcyA9IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCI7XG4vKipcbiAqICBBICoqTmV0d29ya1BsdWdpbioqIHByb3ZpZGVzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBvbiBhIFtbTmV0d29ya11dLlxuICovXG5jbGFzcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqICBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgcmV2ZXJzZS1kb21haW4tbm90YXRpb24sIHdoaWNoIHBlcm1pdHNcbiAgICAgKiAgdW5pcXVlIG5hbWVzIHdpdGggYSBrbm93biBhdXRob3JpdHkgYXMgd2VsbCBhcyBoaWVyYXJjaGFsIGVudHJpZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBuYW1lIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmV0d29ya1BsdWdpbih0aGlzLm5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29ya1BsdWdpbiA9IE5ldHdvcmtQbHVnaW47XG4vKipcbiAqICBBICoqR2FzQ29zdFBsdWdpbioqIGFsbG93cyBhIG5ldHdvcmsgdG8gcHJvdmlkZSBhbHRlcm5hdGl2ZSB2YWx1ZXMgd2hlblxuICogIGNvbXB1dGluZyB0aGUgaW50cmluc2ljIGdhcyByZXF1aXJlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqL1xuY2xhc3MgR2FzQ29zdFBsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgbnVtYmVyIHRvIHRyZWF0IHRoZXNlIHZhbHVlcyBhcyB2YWxpZCBmcm9tLlxuICAgICAqXG4gICAgICogIFRoaXMgYWxsb3dzIGEgaGFyZGZvcmsgdG8gaGF2ZSB1cGRhdGVkIHZhbHVlcyBpbmNsdWRlZCBhcyB3ZWxsIGFzXG4gICAgICogIG11bHV0aXBsZSBoYXJkZm9ya3MgdG8gYmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIGVmZmVjdGl2ZUJsb2NrO1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb25zIGJhc2UgZmVlLlxuICAgICAqL1xuICAgIHR4QmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBmb3IgY3JlYXRpbmcgYSBuZXcgYWNjb3VudC5cbiAgICAgKi9cbiAgICB0eENyZWF0ZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgemVyby1ieXRlIGluIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHR4RGF0YVplcm87XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIG5vbi16ZXJvLWJ5dGUgaW4gdGhlIGRhdGEuXG4gICAgICovXG4gICAgdHhEYXRhTm9uemVybztcbiAgICAvKipcbiAgICAgKiAgVGhlIGZlZSBwZXIgc3RvcmFnZSBrZXkgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdFN0b3JhZ2VLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgcGVyIGFkZHJlc3MgaW4gdGhlIFtbbGluay1laXAtMjkzMF1dIGFjY2VzcyBsaXN0LlxuICAgICAqL1xuICAgIHR4QWNjZXNzTGlzdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgR2FzQ29zdFBsdWdpbiBmcm9tICUlZWZmZWN0aXZlQmxvY2slJSB1bnRpbCB0aGVcbiAgICAgKiAgbGF0ZXN0IGJsb2NrIG9yIGFub3RoZXIgR2FzQ29zdFBsdWdpbiBzdXBlcmNlZGVzIHRoYXQgYmxvY2sgbnVtYmVyLFxuICAgICAqICB3aXRoIHRoZSBhc3NvY2lhdGVkICUlY29zdHMlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RpdmVCbG9jaywgY29zdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdGl2ZUJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUJsb2NrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihgb3JnLmV0aGVycy5uZXR3b3JrLnBsdWdpbnMuR2FzQ29zdCMkeyhlZmZlY3RpdmVCbG9jayB8fCAwKX1gKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7IGVmZmVjdGl2ZUJsb2NrIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChuYW1lLCBudWxsaXNoKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoY29zdHMgfHwge30pW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGxpc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIsIGBpbnZhbHVkIHZhbHVlIGZvciAke25hbWV9YCwgXCJjb3N0c1wiLCBjb3N0cyk7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNldChcInR4QmFzZVwiLCAyMTAwMCk7XG4gICAgICAgIHNldChcInR4Q3JlYXRlXCIsIDMyMDAwKTtcbiAgICAgICAgc2V0KFwidHhEYXRhWmVyb1wiLCA0KTtcbiAgICAgICAgc2V0KFwidHhEYXRhTm9uemVyb1wiLCAxNik7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdFN0b3JhZ2VLZXlcIiwgMTkwMCk7XG4gICAgICAgIHNldChcInR4QWNjZXNzTGlzdEFkZHJlc3NcIiwgMjQwMCk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgcHJvcHMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHYXNDb3N0UGx1Z2luKHRoaXMuZWZmZWN0aXZlQmxvY2ssIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2FzQ29zdFBsdWdpbiA9IEdhc0Nvc3RQbHVnaW47XG4vKipcbiAqICBBbiAqKkVuc1BsdWdpbioqIGFsbG93cyBhIFtbTmV0d29ya11dIHRvIHNwZWNpZnkgdGhlIEVOUyBSZWdpc3RyeVxuICogIENvbnRyYWN0IGFkZHJlc3MgYW5kIHRoZSB0YXJnZXQgbmV0d29yayB0byB1c2Ugd2hlbiB1c2luZyB0aGF0XG4gKiAgY29udHJhY3QuXG4gKlxuICogIFZhcmlvdXMgdGVzdG5ldHMgaGF2ZSB0aGVpciBvd24gaW5zdGFuY2Ugb2YgdGhlIGNvbnRyYWN0IHRvIHVzZSwgYnV0XG4gKiAgaW4gZ2VuZXJhbCwgdGhlIG1haW5uZXQgaW5zdGFuY2Ugc3VwcG9ydHMgbXVsdGktY2hhaW4gYWRkcmVzc2VzIGFuZFxuICogIHNob3VsZCBiZSB1c2VkLlxuICovXG5jbGFzcyBFbnNQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIEVOUyBSZWdpc3RydHkgQ29udHJhY3QgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhhdCB0aGUgRU5TIGNvbnRyYWN0IGxpdmVzIG9uLlxuICAgICAqL1xuICAgIHRhcmdldE5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFbnNQbHVnaW4qKiBjb25uZWN0ZWQgdG8gJSVhZGRyZXNzJSUgb24gdGhlXG4gICAgICogICUldGFyZ2V0TmV0d29yayUlLiBUaGUgZGVmYXVsdCBFTlMgYWRkcmVzcyBhbmQgbWFpbm5ldCBpcyB1c2VkXG4gICAgICogIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHRhcmdldE5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLnBsdWdpbnMubmV0d29yay5FbnNcIik7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgYWRkcmVzczogKGFkZHJlc3MgfHwgRW5zQWRkcmVzcyksXG4gICAgICAgICAgICB0YXJnZXROZXR3b3JrOiAoKHRhcmdldE5ldHdvcmsgPT0gbnVsbCkgPyAxIDogdGFyZ2V0TmV0d29yaylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVuc1BsdWdpbih0aGlzLmFkZHJlc3MsIHRoaXMudGFyZ2V0TmV0d29yayk7XG4gICAgfVxufVxuZXhwb3J0cy5FbnNQbHVnaW4gPSBFbnNQbHVnaW47XG4vKipcbiAqICBBICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiBhbGxvd3MgYSBuZXR3b3JrIHRvIHByb3ZpZGUgYW5kIGFsdGVybmF0ZVxuICogIG1lYW5zIHRvIHNwZWNpZnkgaXRzIGZlZSBkYXRhLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYSBuZXR3b3JrIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgW1tsaW5rLWVpcC0xNTU5XV0gbWF5XG4gKiAgY2hvb3NlIHRvIHVzZSBhIEdhcyBTdGF0aW9uIHNpdGUgdG8gYXBwcm94aW1hdGUgdGhlIGdhcyBwcmljZS5cbiAqL1xuY2xhc3MgRmVlRGF0YU5ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICAjZmVlRGF0YUZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZWUgZGF0YSBmdW5jdGlvbiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgZ2V0IGZlZURhdGFGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqRmVlRGF0YU5ldHdvcmtQbHVnaW4qKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihmZWVEYXRhRnVuYykge1xuICAgICAgICBzdXBlcihcIm9yZy5ldGhlcnMucGx1Z2lucy5uZXR3b3JrLkZlZURhdGFcIik7XG4gICAgICAgIHRoaXMuI2ZlZURhdGFGdW5jID0gZmVlRGF0YUZ1bmM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgZmVlIGRhdGEuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RmVlRGF0YShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmVlRGF0YUZ1bmMocHJvdmlkZXIpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGZWVEYXRhTmV0d29ya1BsdWdpbih0aGlzLiNmZWVEYXRhRnVuYyk7XG4gICAgfVxufVxuZXhwb3J0cy5GZWVEYXRhTmV0d29ya1BsdWdpbiA9IEZlZURhdGFOZXR3b3JrUGx1Z2luO1xuY2xhc3MgRmV0Y2hVcmxGZWVEYXRhTmV0d29ya1BsdWdpbiBleHRlbmRzIE5ldHdvcmtQbHVnaW4ge1xuICAgICN1cmw7XG4gICAgI3Byb2Nlc3NGdW5jO1xuICAgIC8qKlxuICAgICAqICBUaGUgVVJMIHRvIGluaXRpYWxpemUgdGhlIEZldGNoUmVxdWVzdCB3aXRoIGluICUlcHJvY2Vzc0Z1bmMlJS5cbiAgICAgKi9cbiAgICBnZXQgdXJsKCkgeyByZXR1cm4gdGhpcy4jdXJsOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBjYWxsYmFjayB0byB1c2Ugd2hlbiBjb21wdXRpbmcgdGhlIEZlZURhdGEuXG4gICAgICovXG4gICAgZ2V0IHByb2Nlc3NGdW5jKCkgeyByZXR1cm4gdGhpcy4jcHJvY2Vzc0Z1bmM7IH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4qKiB3aGljaCB3aWxsXG4gICAgICogIGJlIHVzZWQgd2hlbiBjb21wdXRpbmcgdGhlIGZlZSBkYXRhIGZvciB0aGUgbmV0d29yay5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHN1cGVyKFwib3JnLmV0aGVycy5wbHVnaW5zLm5ldHdvcmsuRmV0Y2hVcmxGZWVEYXRhUGx1Z2luXCIpO1xuICAgICAgICB0aGlzLiN1cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3NGdW5jID0gcHJvY2Vzc0Z1bmM7XG4gICAgfVxuICAgIC8vIFdlIGFyZSBpbW11dGFibGUsIHNvIHdlIGNhbiBzZXJ2ZSBhcyBvdXIgb3duIGNsb25lXG4gICAgY2xvbmUoKSB7IHJldHVybiB0aGlzOyB9XG59XG5leHBvcnRzLkZldGNoVXJsRmVlRGF0YU5ldHdvcmtQbHVnaW4gPSBGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luO1xuLypcbmV4cG9ydCBjbGFzcyBDdXN0b21CbG9ja05ldHdvcmtQbHVnaW4gZXh0ZW5kcyBOZXR3b3JrUGx1Z2luIHtcbiAgICByZWFkb25seSAjYmxvY2tGdW5jOiAocHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPikgPT4gQmxvY2s8c3RyaW5nPjtcbiAgICByZWFkb25seSAjYmxvY2tXaXRoVHhzRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KSA9PiBCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblxuICAgIGNvbnN0cnVjdG9yKGJsb2NrRnVuYzogKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPHN0cmluZz4pID0+IEJsb2NrPHN0cmluZz4sIGJsb2NrV2l0aFR4c0Z1bmM6IChwcm92aWRlcjogUHJvdmlkZXIsIGJsb2NrOiBCbG9ja1BhcmFtczxUcmFuc2FjdGlvblJlc3BvbnNlUGFyYW1zPikgPT4gQmxvY2s8VHJhbnNhY3Rpb25SZXNwb25zZT4pIHtcbiAgICAgICAgc3VwZXIoXCJvcmcuZXRoZXJzLm5ldHdvcmstcGx1Z2lucy5jdXN0b20tYmxvY2tcIik7XG4gICAgICAgIHRoaXMuI2Jsb2NrRnVuYyA9IGJsb2NrRnVuYztcbiAgICAgICAgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyA9IGJsb2NrV2l0aFR4c0Z1bmM7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2socHJvdmlkZXI6IFByb3ZpZGVyLCBibG9jazogQmxvY2tQYXJhbXM8c3RyaW5nPik6IFByb21pc2U8QmxvY2s8c3RyaW5nPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tGdW5jKHByb3ZpZGVyLCBibG9jayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QmxvY2tpb25zKHByb3ZpZGVyOiBQcm92aWRlciwgYmxvY2s6IEJsb2NrUGFyYW1zPFRyYW5zYWN0aW9uUmVzcG9uc2VQYXJhbXM+KTogUHJvbWlzZTxCbG9jazxUcmFuc2FjdGlvblJlc3BvbnNlPj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyhwcm92aWRlciwgYmxvY2spO1xuICAgIH1cblxuICAgIGNsb25lKCk6IEN1c3RvbUJsb2NrTmV0d29ya1BsdWdpbiB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tOZXR3b3JrUGx1Z2luKHRoaXMuI2Jsb2NrRnVuYywgdGhpcy4jYmxvY2tXaXRoVHhzRnVuYyk7XG4gICAgfVxufVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbnMtbmV0d29yay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGZXRjaFVybEZlZURhdGFOZXR3b3JrUGx1Z2luIiwiRmVlRGF0YU5ldHdvcmtQbHVnaW4iLCJFbnNQbHVnaW4iLCJHYXNDb3N0UGx1Z2luIiwiTmV0d29ya1BsdWdpbiIsInByb3BlcnRpZXNfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwiRW5zQWRkcmVzcyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImRlZmluZVByb3BlcnRpZXMiLCJjbG9uZSIsImVmZmVjdGl2ZUJsb2NrIiwiY29zdHMiLCJwcm9wcyIsInNldCIsIm51bGxpc2giLCJhc3NlcnRBcmd1bWVudCIsImFkZHJlc3MiLCJ0YXJnZXROZXR3b3JrIiwiZmVlRGF0YUZ1bmMiLCJnZXRGZWVEYXRhIiwicHJvdmlkZXIiLCJ1cmwiLCJwcm9jZXNzRnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AlchemyProvider = void 0;\n/**\n *  About Alchemy\n *\n *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]\n */ const index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nfunction getHost(name) {\n    switch(name){\n        case \"mainnet\":\n            return \"eth-mainnet.alchemyapi.io\";\n        case \"goerli\":\n            return \"eth-goerli.g.alchemy.com\";\n        case \"sepolia\":\n            return \"eth-sepolia.g.alchemy.com\";\n        case \"arbitrum\":\n            return \"arb-mainnet.g.alchemy.com\";\n        case \"arbitrum-goerli\":\n            return \"arb-goerli.g.alchemy.com\";\n        case \"matic\":\n            return \"polygon-mainnet.g.alchemy.com\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.g.alchemy.com\";\n        case \"optimism\":\n            return \"opt-mainnet.g.alchemy.com\";\n        case \"optimism-goerli\":\n            return \"opt-goerli.g.alchemy.com\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AlchemyProvider** connects to the [[link-alchemy]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-alchemy-signup).\n *\n *  @_docloc: api/providers/thirdparty\n */ class AlchemyProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    constructor(_network, apiKey){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = AlchemyProvider.getRequest(network, apiKey);\n        super(request, network, {\n            staticNetwork: network\n        });\n        (0, index_js_1.defineProperties)(this, {\n            apiKey\n        });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AlchemyProvider(chainId, this.apiKey);\n        } catch (error) {}\n        return super._getProvider(chainId);\n    }\n    async _perform(req) {\n        // https://docs.alchemy.com/reference/trace-transaction\n        if (req.method === \"getTransactionResult\") {\n            const { trace, tx } = await (0, index_js_1.resolveProperties)({\n                trace: this.send(\"trace_transaction\", [\n                    req.hash\n                ]),\n                tx: this.getTransaction(req.hash)\n            });\n            if (trace == null || tx == null) {\n                return null;\n            }\n            let data;\n            let error = false;\n            try {\n                data = trace[0].result.output;\n                error = trace[0].error === \"Reverted\";\n            } catch (error) {}\n            if (data) {\n                (0, index_js_1.assert)(!error, \"an error occurred during transaction executions\", \"CALL_EXCEPTION\", {\n                    action: \"getTransactionResult\",\n                    data,\n                    reason: null,\n                    transaction: tx,\n                    invocation: null,\n                    revert: null // @TODO\n                });\n                return data;\n            }\n            (0, index_js_1.assert)(false, \"could not parse trace result\", \"BAD_DATA\", {\n                value: trace\n            });\n        }\n        return await super._perform(req);\n    }\n    isCommunityResource() {\n        return this.apiKey === defaultApiKey;\n    }\n    static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v2/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt)=>{\n                (0, community_js_1.showThrottleMessage)(\"alchemy\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.AlchemyProvider = AlchemyProvider; //# sourceMappingURL=provider-alchemy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYWxjaGVteS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQjs7OztDQUlDLEdBQ0QsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsdUZBQWdCO0FBQy9DLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1HLHdCQUF3QkgsbUJBQU9BLENBQUMscUdBQXVCO0FBQzdELE1BQU1JLGdCQUFnQjtBQUN0QixTQUFTQyxRQUFRQyxJQUFJO0lBQ2pCLE9BQVFBO1FBQ0osS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO0lBQ2Y7SUFDQyxJQUFHUCxXQUFXUSxjQUFjLEVBQUUsT0FBTyx1QkFBdUIsV0FBV0Q7QUFDNUU7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTVIsd0JBQXdCSyxzQkFBc0JLLGVBQWU7SUFFL0RDLFlBQVlDLFFBQVEsRUFBRUMsTUFBTSxDQUFFO1FBQzFCLElBQUlELFlBQVksTUFBTTtZQUNsQkEsV0FBVztRQUNmO1FBQ0EsTUFBTUUsVUFBVVYsYUFBYVcsT0FBTyxDQUFDQyxJQUFJLENBQUNKO1FBQzFDLElBQUlDLFVBQVUsTUFBTTtZQUNoQkEsU0FBU1A7UUFDYjtRQUNBLE1BQU1XLFVBQVVqQixnQkFBZ0JrQixVQUFVLENBQUNKLFNBQVNEO1FBQ3BELEtBQUssQ0FBQ0ksU0FBU0gsU0FBUztZQUFFSyxlQUFlTDtRQUFRO1FBQ2hELElBQUdiLFdBQVdtQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRVA7UUFBTztJQUNwRDtJQUNBUSxhQUFhQyxPQUFPLEVBQUU7UUFDbEIsSUFBSTtZQUNBLE9BQU8sSUFBSXRCLGdCQUFnQnNCLFNBQVMsSUFBSSxDQUFDVCxNQUFNO1FBQ25ELEVBQ0EsT0FBT1UsT0FBTyxDQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDRixhQUFhQztJQUM5QjtJQUNBLE1BQU1FLFNBQVNDLEdBQUcsRUFBRTtRQUNoQix1REFBdUQ7UUFDdkQsSUFBSUEsSUFBSUMsTUFBTSxLQUFLLHdCQUF3QjtZQUN2QyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsRUFBRSxFQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUczQixXQUFXNEIsaUJBQWlCLEVBQUU7Z0JBQzFERixPQUFPLElBQUksQ0FBQ0csSUFBSSxDQUFDLHFCQUFxQjtvQkFBQ0wsSUFBSU0sSUFBSTtpQkFBQztnQkFDaERILElBQUksSUFBSSxDQUFDSSxjQUFjLENBQUNQLElBQUlNLElBQUk7WUFDcEM7WUFDQSxJQUFJSixTQUFTLFFBQVFDLE1BQU0sTUFBTTtnQkFDN0IsT0FBTztZQUNYO1lBQ0EsSUFBSUs7WUFDSixJQUFJVixRQUFRO1lBQ1osSUFBSTtnQkFDQVUsT0FBT04sS0FBSyxDQUFDLEVBQUUsQ0FBQ08sTUFBTSxDQUFDQyxNQUFNO2dCQUM3QlosUUFBU0ksS0FBSyxDQUFDLEVBQUUsQ0FBQ0osS0FBSyxLQUFLO1lBQ2hDLEVBQ0EsT0FBT0EsT0FBTyxDQUFFO1lBQ2hCLElBQUlVLE1BQU07Z0JBQ0wsSUFBR2hDLFdBQVdtQyxNQUFNLEVBQUUsQ0FBQ2IsT0FBTyxtREFBbUQsa0JBQWtCO29CQUNoR2MsUUFBUTtvQkFDUko7b0JBQ0FLLFFBQVE7b0JBQ1JDLGFBQWFYO29CQUNiWSxZQUFZO29CQUNaQyxRQUFRLEtBQUssUUFBUTtnQkFDekI7Z0JBQ0EsT0FBT1I7WUFDWDtZQUNDLElBQUdoQyxXQUFXbUMsTUFBTSxFQUFFLE9BQU8sZ0NBQWdDLFlBQVk7Z0JBQUVyQyxPQUFPNEI7WUFBTTtRQUM3RjtRQUNBLE9BQU8sTUFBTSxLQUFLLENBQUNILFNBQVNDO0lBQ2hDO0lBQ0FpQixzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUM3QixNQUFNLEtBQUtQO0lBQzVCO0lBQ0EsT0FBT1ksV0FBV0osT0FBTyxFQUFFRCxNQUFNLEVBQUU7UUFDL0IsSUFBSUEsVUFBVSxNQUFNO1lBQ2hCQSxTQUFTUDtRQUNiO1FBQ0EsTUFBTVcsVUFBVSxJQUFJaEIsV0FBVzBDLFlBQVksQ0FBQyxDQUFDLFNBQVMsRUFBRXBDLFFBQVFPLFFBQVFOLElBQUksRUFBRSxJQUFJLEVBQUVLLE9BQU8sQ0FBQztRQUM1RkksUUFBUTJCLFNBQVMsR0FBRztRQUNwQixJQUFJL0IsV0FBV1AsZUFBZTtZQUMxQlcsUUFBUTRCLFNBQVMsR0FBRyxPQUFPNUIsU0FBUzZCLFVBQVVDO2dCQUN6QyxJQUFHNUMsZUFBZTZDLG1CQUFtQixFQUFFO2dCQUN4QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU8vQjtJQUNYO0FBQ0o7QUFDQW5CLHVCQUF1QixHQUFHRSxpQkFDMUIsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWFsY2hlbXkuanM/MzllNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gdm9pZCAwO1xuLyoqXG4gKiAgQWJvdXQgQWxjaGVteVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpBbGNoZW15ICBbcHJvdmlkZXJzLWFsY2hlbXldXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiX2dnN3dTU2kwS01Cc2RLbkdWZkhEdWVxNnhNQjlFa0NcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoLW1haW5uZXQuYWxjaGVteWFwaS5pb1wiO1xuICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGgtZ29lcmxpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1zZXBvbGlhLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmItbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJhcmJpdHJ1bS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYi1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbXVtYmFpLmcuYWxjaGVteS5jb21cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJvcHQtbWFpbm5ldC5nLmFsY2hlbXkuY29tXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm9wdC1nb2VybGkuZy5hbGNoZW15LmNvbVwiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipBbGNoZW15UHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLWFsY2hlbXldXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLWFsY2hlbXktc2lnbnVwKS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eVxuICovXG5jbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBhcGlLZXk7XG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBpS2V5ID0gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gQWxjaGVteVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIocmVxdWVzdCwgbmV0d29yaywgeyBzdGF0aWNOZXR3b3JrOiBuZXR3b3JrIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFwaUtleSB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxjaGVteVByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL3JlZmVyZW5jZS90cmFjZS10cmFuc2FjdGlvblxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYWNlLCB0eCB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICB0cmFjZTogdGhpcy5zZW5kKFwidHJhY2VfdHJhbnNhY3Rpb25cIiwgW3JlcS5oYXNoXSksXG4gICAgICAgICAgICAgICAgdHg6IHRoaXMuZ2V0VHJhbnNhY3Rpb24ocmVxLmhhc2gpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PSBudWxsIHx8IHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0cmFjZVswXS5yZXN1bHQub3V0cHV0O1xuICAgICAgICAgICAgICAgIGVycm9yID0gKHRyYWNlWzBdLmVycm9yID09PSBcIlJldmVydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSghZXJyb3IsIFwiYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbnNcIiwgXCJDQUxMX0VYQ0VQVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJnZXRUcmFuc2FjdGlvblJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0OiBudWxsIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcImNvdWxkIG5vdCBwYXJzZSB0cmFjZSByZXN1bHRcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0cmFjZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuX3BlcmZvcm0ocmVxKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS92Mi8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlKShcImFsY2hlbXlcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gQWxjaGVteVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItYWxjaGVteS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBbGNoZW15UHJvdmlkZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImNvbW11bml0eV9qc18xIiwibmV0d29ya19qc18xIiwicHJvdmlkZXJfanNvbnJwY19qc18xIiwiZGVmYXVsdEFwaUtleSIsImdldEhvc3QiLCJuYW1lIiwiYXNzZXJ0QXJndW1lbnQiLCJKc29uUnBjUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsIl9uZXR3b3JrIiwiYXBpS2V5IiwibmV0d29yayIsIk5ldHdvcmsiLCJmcm9tIiwicmVxdWVzdCIsImdldFJlcXVlc3QiLCJzdGF0aWNOZXR3b3JrIiwiZGVmaW5lUHJvcGVydGllcyIsIl9nZXRQcm92aWRlciIsImNoYWluSWQiLCJlcnJvciIsIl9wZXJmb3JtIiwicmVxIiwibWV0aG9kIiwidHJhY2UiLCJ0eCIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2VuZCIsImhhc2giLCJnZXRUcmFuc2FjdGlvbiIsImRhdGEiLCJyZXN1bHQiLCJvdXRwdXQiLCJhc3NlcnQiLCJhY3Rpb24iLCJyZWFzb24iLCJ0cmFuc2FjdGlvbiIsImludm9jYXRpb24iLCJyZXZlcnQiLCJpc0NvbW11bml0eVJlc291cmNlIiwiRmV0Y2hSZXF1ZXN0IiwiYWxsb3dHemlwIiwicmV0cnlGdW5jIiwicmVzcG9uc2UiLCJhdHRlbXB0Iiwic2hvd1Rocm90dGxlTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-alchemy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-ankr.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AnkrProvider = void 0;\n/**\n *  [[link-ankr]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Polygon (``matic``)\n *  - Arbitrum (``arbitrum``)\n *\n *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]\n */ const index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch(name){\n        case \"mainnet\":\n            return \"rpc.ankr.com/eth\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **AnkrProvider** connects to the [[link-ankr]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-ankr-signup).\n */ class AnkrProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  Create a new **AnkrProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */ constructor(_network, apiKey){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        // Ankr does not support filterId, so we force polling\n        const options = {\n            polling: true,\n            staticNetwork: network\n        };\n        const request = AnkrProvider.getRequest(network, apiKey);\n        super(request, network, options);\n        (0, index_js_1.defineProperties)(this, {\n            apiKey\n        });\n    }\n    _getProvider(chainId) {\n        try {\n            return new AnkrProvider(chainId, this.apiKey);\n        } catch (error) {}\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%apiKey%%.\n     */ static getRequest(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/${apiKey}`);\n        request.allowGzip = true;\n        if (apiKey === defaultApiKey) {\n            request.retryFunc = async (request, response, attempt)=>{\n                (0, community_js_1.showThrottleMessage)(\"AnkrProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    getRpcError(payload, error) {\n        if (payload.method === \"eth_sendRawTransaction\") {\n            if (error && error.error && error.error.message === \"INTERNAL_ERROR: could not replace existing tx\") {\n                error.error.message = \"replacement transaction underpriced\";\n            }\n        }\n        return super.getRpcError(payload, error);\n    }\n    isCommunityResource() {\n        return this.apiKey === defaultApiKey;\n    }\n}\nexports.AnkrProvider = AnkrProvider; //# sourceMappingURL=provider-ankr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1Qjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDL0MsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsbUZBQWM7QUFDM0MsTUFBTUcsd0JBQXdCSCxtQkFBT0EsQ0FBQyxxR0FBdUI7QUFDN0QsTUFBTUksZ0JBQWdCO0FBQ3RCLFNBQVNDLFFBQVFDLElBQUk7SUFDakIsT0FBUUE7UUFDSixLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztJQUNmO0lBQ0MsSUFBR1AsV0FBV1EsY0FBYyxFQUFFLE9BQU8sdUJBQXVCLFdBQVdEO0FBQzVFO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNUixxQkFBcUJLLHNCQUFzQkssZUFBZTtJQUs1RDs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLE1BQU0sQ0FBRTtRQUMxQixJQUFJRCxZQUFZLE1BQU07WUFDbEJBLFdBQVc7UUFDZjtRQUNBLE1BQU1FLFVBQVVWLGFBQWFXLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDSjtRQUMxQyxJQUFJQyxVQUFVLE1BQU07WUFDaEJBLFNBQVNQO1FBQ2I7UUFDQSxzREFBc0Q7UUFDdEQsTUFBTVcsVUFBVTtZQUFFQyxTQUFTO1lBQU1DLGVBQWVMO1FBQVE7UUFDeEQsTUFBTU0sVUFBVXBCLGFBQWFxQixVQUFVLENBQUNQLFNBQVNEO1FBQ2pELEtBQUssQ0FBQ08sU0FBU04sU0FBU0c7UUFDdkIsSUFBR2hCLFdBQVdxQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRVQ7UUFBTztJQUNwRDtJQUNBVSxhQUFhQyxPQUFPLEVBQUU7UUFDbEIsSUFBSTtZQUNBLE9BQU8sSUFBSXhCLGFBQWF3QixTQUFTLElBQUksQ0FBQ1gsTUFBTTtRQUNoRCxFQUNBLE9BQU9ZLE9BQU8sQ0FBRTtRQUNoQixPQUFPLEtBQUssQ0FBQ0YsYUFBYUM7SUFDOUI7SUFDQTs7O0tBR0MsR0FDRCxPQUFPSCxXQUFXUCxPQUFPLEVBQUVELE1BQU0sRUFBRTtRQUMvQixJQUFJQSxVQUFVLE1BQU07WUFDaEJBLFNBQVNQO1FBQ2I7UUFDQSxNQUFNYyxVQUFVLElBQUluQixXQUFXeUIsWUFBWSxDQUFDLENBQUMsU0FBUyxFQUFFbkIsUUFBUU8sUUFBUU4sSUFBSSxFQUFFLENBQUMsRUFBRUssT0FBTyxDQUFDO1FBQ3pGTyxRQUFRTyxTQUFTLEdBQUc7UUFDcEIsSUFBSWQsV0FBV1AsZUFBZTtZQUMxQmMsUUFBUVEsU0FBUyxHQUFHLE9BQU9SLFNBQVNTLFVBQVVDO2dCQUN6QyxJQUFHM0IsZUFBZTRCLG1CQUFtQixFQUFFO2dCQUN4QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU9YO0lBQ1g7SUFDQVksWUFBWUMsT0FBTyxFQUFFUixLQUFLLEVBQUU7UUFDeEIsSUFBSVEsUUFBUUMsTUFBTSxLQUFLLDBCQUEwQjtZQUM3QyxJQUFJVCxTQUFTQSxNQUFNQSxLQUFLLElBQUlBLE1BQU1BLEtBQUssQ0FBQ1UsT0FBTyxLQUFLLGlEQUFpRDtnQkFDakdWLE1BQU1BLEtBQUssQ0FBQ1UsT0FBTyxHQUFHO1lBQzFCO1FBQ0o7UUFDQSxPQUFPLEtBQUssQ0FBQ0gsWUFBWUMsU0FBU1I7SUFDdEM7SUFDQVcsc0JBQXNCO1FBQ2xCLE9BQVEsSUFBSSxDQUFDdkIsTUFBTSxLQUFLUDtJQUM1QjtBQUNKO0FBQ0FSLG9CQUFvQixHQUFHRSxjQUN2Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYW5rci5qcz9lODM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BbmtyUHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstYW5rcl1dIHByb3ZpZGVzIGEgdGhpcmQtcGFydHkgc2VydmljZSBmb3IgY29ubmVjdGluZyB0b1xuICogIHZhcmlvdXMgYmxvY2tjaGFpbnMgb3ZlciBKU09OLVJQQy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpBbmtyICBbcHJvdmlkZXJzLWFua3JdXG4gKi9cbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBjb21tdW5pdHlfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW11bml0eS5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuY29uc3QgZGVmYXVsdEFwaUtleSA9IFwiOWY3ZDkyOWIwMThjZGZmYjMzODUxN2VmYTA2ZjU4MzU5ZTg2ZmYxZmZkMzUwYmM4ODk3Mzg1MjM2NTllNzk3MlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vZXRoXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcInJwYy5hbmtyLmNvbS9ldGhfZ29lcmxpXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwicnBjLmFua3IuY29tL3BvbHlnb25cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJycGMuYW5rci5jb20vYXJiaXRydW1cIjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqQW5rclByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1hbmtyXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1hbmtyLXNpZ251cCkuXG4gKi9cbmNsYXNzIEFua3JQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgQVBJIGtleSBmb3IgdGhlIEFua3IgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhcGlLZXk7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKkFua3JQcm92aWRlcioqLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQgY29ubmVjdGluZyB0byBgYG1haW5uZXRgYCB3aXRoIGEgaGlnaGx5IHRocm90dGxlZFxuICAgICAqICBBUEkga2V5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5rciBkb2VzIG5vdCBzdXBwb3J0IGZpbHRlcklkLCBzbyB3ZSBmb3JjZSBwb2xsaW5nXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHBvbGxpbmc6IHRydWUsIHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IEFua3JQcm92aWRlci5nZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFwaUtleSB9KTtcbiAgICB9XG4gICAgX2dldFByb3ZpZGVyKGNoYWluSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5rclByb3ZpZGVyKGNoYWluSWQsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSUgd2l0aFxuICAgICAqICAlJWFwaUtleSUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwaUtleSA9IGRlZmF1bHRBcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBpbmRleF9qc18xLkZldGNoUmVxdWVzdChgaHR0cHM6L1xcLyR7Z2V0SG9zdChuZXR3b3JrLm5hbWUpfS8ke2FwaUtleX1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJldHJ5RnVuYyA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBjb21tdW5pdHlfanNfMS5zaG93VGhyb3R0bGVNZXNzYWdlKShcIkFua3JQcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGdldFJwY0Vycm9yKHBheWxvYWQsIGVycm9yKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5lcnJvciAmJiBlcnJvci5lcnJvci5tZXNzYWdlID09PSBcIklOVEVSTkFMX0VSUk9SOiBjb3VsZCBub3QgcmVwbGFjZSBleGlzdGluZyB0eFwiKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG59XG5leHBvcnRzLkFua3JQcm92aWRlciA9IEFua3JQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWFua3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQW5rclByb3ZpZGVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJjb21tdW5pdHlfanNfMSIsIm5ldHdvcmtfanNfMSIsInByb3ZpZGVyX2pzb25ycGNfanNfMSIsImRlZmF1bHRBcGlLZXkiLCJnZXRIb3N0IiwibmFtZSIsImFzc2VydEFyZ3VtZW50IiwiSnNvblJwY1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJfbmV0d29yayIsImFwaUtleSIsIm5ldHdvcmsiLCJOZXR3b3JrIiwiZnJvbSIsIm9wdGlvbnMiLCJwb2xsaW5nIiwic3RhdGljTmV0d29yayIsInJlcXVlc3QiLCJnZXRSZXF1ZXN0IiwiZGVmaW5lUHJvcGVydGllcyIsIl9nZXRQcm92aWRlciIsImNoYWluSWQiLCJlcnJvciIsIkZldGNoUmVxdWVzdCIsImFsbG93R3ppcCIsInJldHJ5RnVuYyIsInJlc3BvbnNlIiwiYXR0ZW1wdCIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJnZXRScGNFcnJvciIsInBheWxvYWQiLCJtZXRob2QiLCJtZXNzYWdlIiwiaXNDb21tdW5pdHlSZXNvdXJjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ankr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BrowserProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n;\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */ class BrowserProvider extends provider_jsonrpc_js_1.JsonRpcApiPollingProvider {\n    #request;\n    /**\n     *  Connnect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */ constructor(ethereum, network){\n        super(network, {\n            batchMaxCount: 1\n        });\n        this.#request = async (method, params)=>{\n            const payload = {\n                method,\n                params\n            };\n            this.emit(\"debug\", {\n                action: \"sendEip1193Request\",\n                payload\n            });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Result\",\n                    result\n                });\n                return result;\n            } catch (e) {\n                const error = new Error(e.message);\n                error.code = e.code;\n                error.data = e.data;\n                error.payload = payload;\n                this.emit(\"debug\", {\n                    action: \"receiveEip1193Error\",\n                    error\n                });\n                throw error;\n            }\n        };\n    }\n    async send(method, params) {\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        (0, index_js_1.assertArgument)(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n        try {\n            const result = await this.#request(payload.method, payload.params || []);\n            return [\n                {\n                    id: payload.id,\n                    result\n                }\n            ];\n        } catch (e) {\n            return [\n                {\n                    id: payload.id,\n                    error: {\n                        code: e.code,\n                        data: e.data,\n                        message: e.message\n                    }\n                }\n            ];\n        }\n    }\n    getRpcError(payload, error) {\n        error = JSON.parse(JSON.stringify(error));\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into \n        switch(error.error.code || -1){\n            case 4001:\n                error.error.message = `ethers-user-denied: ${error.error.message}`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${error.error.message}`;\n                break;\n        }\n        return super.getRpcError(payload, error);\n    }\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */ async hasSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accounts = await this.send(\"eth_accounts\", []);\n        if (typeof address === \"number\") {\n            return accounts.length > address;\n        }\n        address = address.toLowerCase();\n        return accounts.filter((a)=>a.toLowerCase() === address).length !== 0;\n    }\n    async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        if (!await this.hasSigner(address)) {\n            try {\n                //const resp = \n                await this.#request(\"eth_requestAccounts\", []);\n            //console.log(\"RESP\", resp);\n            } catch (error) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, {\n                    id: payload.id,\n                    error\n                });\n            }\n        }\n        return await super.getSigner(address);\n    }\n}\nexports.BrowserProvider = BrowserProvider; //# sourceMappingURL=provider-browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMsd0JBQXdCRCxtQkFBT0EsQ0FBQyxxR0FBdUI7O0FBRTdEOzs7O0NBSUMsR0FDRCxNQUFNRix3QkFBd0JHLHNCQUFzQkMseUJBQXlCO0lBQ3pFLENBQUNDLE9BQU8sQ0FBQztJQUNUOzs7S0FHQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLE9BQU8sQ0FBRTtRQUMzQixLQUFLLENBQUNBLFNBQVM7WUFBRUMsZUFBZTtRQUFFO1FBQ2xDLElBQUksQ0FBQyxDQUFDSixPQUFPLEdBQUcsT0FBT0ssUUFBUUM7WUFDM0IsTUFBTUMsVUFBVTtnQkFBRUY7Z0JBQVFDO1lBQU87WUFDakMsSUFBSSxDQUFDRSxJQUFJLENBQUMsU0FBUztnQkFBRUMsUUFBUTtnQkFBc0JGO1lBQVE7WUFDM0QsSUFBSTtnQkFDQSxNQUFNRyxTQUFTLE1BQU1SLFNBQVNGLE9BQU8sQ0FBQ087Z0JBQ3RDLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVM7b0JBQUVDLFFBQVE7b0JBQXdCQztnQkFBTztnQkFDNUQsT0FBT0E7WUFDWCxFQUNBLE9BQU9DLEdBQUc7Z0JBQ04sTUFBTUMsUUFBUSxJQUFJQyxNQUFNRixFQUFFRyxPQUFPO2dCQUNqQ0YsTUFBTUcsSUFBSSxHQUFHSixFQUFFSSxJQUFJO2dCQUNuQkgsTUFBTUksSUFBSSxHQUFHTCxFQUFFSyxJQUFJO2dCQUNuQkosTUFBTUwsT0FBTyxHQUFHQTtnQkFDaEIsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBUztvQkFBRUMsUUFBUTtvQkFBdUJHO2dCQUFNO2dCQUMxRCxNQUFNQTtZQUNWO1FBQ0o7SUFDSjtJQUNBLE1BQU1LLEtBQUtaLE1BQU0sRUFBRUMsTUFBTSxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxDQUFDWSxNQUFNO1FBQ2pCLE9BQU8sTUFBTSxLQUFLLENBQUNELEtBQUtaLFFBQVFDO0lBQ3BDO0lBQ0EsTUFBTWEsTUFBTVosT0FBTyxFQUFFO1FBQ2hCLElBQUdYLFdBQVd3QixjQUFjLEVBQUUsQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDZixVQUFVLDJDQUEyQyxXQUFXQTtRQUM5RyxJQUFJO1lBQ0EsTUFBTUcsU0FBUyxNQUFNLElBQUksQ0FBQyxDQUFDVixPQUFPLENBQUNPLFFBQVFGLE1BQU0sRUFBRUUsUUFBUUQsTUFBTSxJQUFJLEVBQUU7WUFDdkUsT0FBTztnQkFBQztvQkFBRWlCLElBQUloQixRQUFRZ0IsRUFBRTtvQkFBRWI7Z0JBQU87YUFBRTtRQUN2QyxFQUNBLE9BQU9DLEdBQUc7WUFDTixPQUFPO2dCQUFDO29CQUNBWSxJQUFJaEIsUUFBUWdCLEVBQUU7b0JBQ2RYLE9BQU87d0JBQUVHLE1BQU1KLEVBQUVJLElBQUk7d0JBQUVDLE1BQU1MLEVBQUVLLElBQUk7d0JBQUVGLFNBQVNILEVBQUVHLE9BQU87b0JBQUM7Z0JBQzVEO2FBQUU7UUFDVjtJQUNKO0lBQ0FVLFlBQVlqQixPQUFPLEVBQUVLLEtBQUssRUFBRTtRQUN4QkEsUUFBUWEsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNmO1FBQ2xDLGtFQUFrRTtRQUNsRSxhQUFhO1FBQ2IsT0FBUUEsTUFBTUEsS0FBSyxDQUFDRyxJQUFJLElBQUksQ0FBQztZQUN6QixLQUFLO2dCQUNESCxNQUFNQSxLQUFLLENBQUNFLE9BQU8sR0FBRyxDQUFDLG9CQUFvQixFQUFFRixNQUFNQSxLQUFLLENBQUNFLE9BQU8sQ0FBQyxDQUFDO2dCQUNsRTtZQUNKLEtBQUs7Z0JBQ0RGLE1BQU1BLEtBQUssQ0FBQ0UsT0FBTyxHQUFHLENBQUMsb0JBQW9CLEVBQUVGLE1BQU1BLEtBQUssQ0FBQ0UsT0FBTyxDQUFDLENBQUM7Z0JBQ2xFO1FBQ1I7UUFDQSxPQUFPLEtBQUssQ0FBQ1UsWUFBWWpCLFNBQVNLO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNZ0IsVUFBVUMsT0FBTyxFQUFFO1FBQ3JCLElBQUlBLFdBQVcsTUFBTTtZQUNqQkEsVUFBVTtRQUNkO1FBQ0EsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ2IsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1FBQ25ELElBQUksT0FBUVksWUFBYSxVQUFVO1lBQy9CLE9BQVFDLFNBQVNDLE1BQU0sR0FBR0Y7UUFDOUI7UUFDQUEsVUFBVUEsUUFBUUcsV0FBVztRQUM3QixPQUFPRixTQUFTRyxNQUFNLENBQUMsQ0FBQ0MsSUFBT0EsRUFBRUYsV0FBVyxPQUFPSCxTQUFVRSxNQUFNLEtBQUs7SUFDNUU7SUFDQSxNQUFNSSxVQUFVTixPQUFPLEVBQUU7UUFDckIsSUFBSUEsV0FBVyxNQUFNO1lBQ2pCQSxVQUFVO1FBQ2Q7UUFDQSxJQUFJLENBQUUsTUFBTSxJQUFJLENBQUNELFNBQVMsQ0FBQ0MsVUFBVztZQUNsQyxJQUFJO2dCQUNBLGVBQWU7Z0JBQ2YsTUFBTSxJQUFJLENBQUMsQ0FBQzdCLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRTtZQUM3Qyw0QkFBNEI7WUFDaEMsRUFDQSxPQUFPWSxPQUFPO2dCQUNWLE1BQU1MLFVBQVVLLE1BQU1MLE9BQU87Z0JBQzdCLE1BQU0sSUFBSSxDQUFDaUIsV0FBVyxDQUFDakIsU0FBUztvQkFBRWdCLElBQUloQixRQUFRZ0IsRUFBRTtvQkFBRVg7Z0JBQU07WUFDNUQ7UUFDSjtRQUNBLE9BQU8sTUFBTSxLQUFLLENBQUN1QixVQUFVTjtJQUNqQztBQUNKO0FBQ0FwQyx1QkFBdUIsR0FBR0UsaUJBQzFCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1icm93c2VyLmpzPzY5MDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJyb3dzZXJQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBwcm92aWRlcl9qc29ucnBjX2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1qc29ucnBjLmpzXCIpO1xuO1xuLyoqXG4gKiAgQSAqKkJyb3dzZXJQcm92aWRlcioqIGlzIGludGVuZGVkIHRvIHdyYXAgYW4gaW5qZWN0ZWQgcHJvdmlkZXIgd2hpY2hcbiAqICBhZGhlcmVzIHRvIHRoZSBbW2xpbmstZWlwLTExOTNdXSBzdGFuZGFyZCwgd2hpY2ggbW9zdCAoaWYgbm90IGFsbClcbiAqICBjdXJyZW50bHkgZG8uXG4gKi9cbmNsYXNzIEJyb3dzZXJQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjcmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiAgQ29ubm5lY3QgdG8gdGhlICUlZXRoZXJldW0lJSBwcm92aWRlciwgb3B0aW9uYWxseSBmb3JjaW5nIHRoZVxuICAgICAqICAlJW5ldHdvcmslJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihldGhlcmV1bSwgbmV0d29yaykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCB7IGJhdGNoTWF4Q291bnQ6IDEgfSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSBhc3luYyAobWV0aG9kLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJzZW5kRWlwMTE5M1JlcXVlc3RcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXRoZXJldW0ucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRWlwMTE5M1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgZXJyb3IucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVpcDExOTNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kKHBheWxvYWQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCFBcnJheS5pc0FycmF5KHBheWxvYWQpLCBcIkVJUC0xMTkzIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2ggcmVxdWVzdFwiLCBcInBheWxvYWRcIiwgcGF5bG9hZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0KHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyB8fCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW3sgaWQ6IHBheWxvYWQuaWQsIHJlc3VsdCB9XTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBjb2RlOiBlLmNvZGUsIGRhdGE6IGUuZGF0YSwgbWVzc2FnZTogZS5tZXNzYWdlIH1cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBlcnJvcikge1xuICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgICAgLy8gRUlQLTExOTMgZ2l2ZXMgdXMgc29tZSBtYWNoaW5lLXJlYWRhYmxlIGVycm9yIGNvZGVzLCBzbyByZXdyaXRlXG4gICAgICAgIC8vIHRoZW0gaW50byBcbiAgICAgICAgc3dpdGNoIChlcnJvci5lcnJvci5jb2RlIHx8IC0xKSB7XG4gICAgICAgICAgICBjYXNlIDQwMDE6XG4gICAgICAgICAgICAgICAgZXJyb3IuZXJyb3IubWVzc2FnZSA9IGBldGhlcnMtdXNlci1kZW5pZWQ6ICR7ZXJyb3IuZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MjAwOlxuICAgICAgICAgICAgICAgIGVycm9yLmVycm9yLm1lc3NhZ2UgPSBgZXRoZXJzLXVuc3VwcG9ydGVkOiAke2Vycm9yLmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0UnBjRXJyb3IocGF5bG9hZCwgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gYGB0cnVlYGAgaWYgdGhlIHByb3ZpZGVyIG1hbmFnZXMgdGhlICUlYWRkcmVzcyUlLlxuICAgICAqL1xuICAgIGFzeW5jIGhhc1NpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYWNjb3VudHMubGVuZ3RoID4gYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzLmZpbHRlcigoYSkgPT4gKGEudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcykpLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2lnbmVyKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5oYXNTaWduZXIoYWRkcmVzcykpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vY29uc3QgcmVzcCA9IFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3JlcXVlc3QoXCJldGhfcmVxdWVzdEFjY291bnRzXCIsIFtdKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVTUFwiLCByZXNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBlcnJvci5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgeyBpZDogcGF5bG9hZC5pZCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLmdldFNpZ25lcihhZGRyZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJQcm92aWRlciA9IEJyb3dzZXJQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQnJvd3NlclByb3ZpZGVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJwcm92aWRlcl9qc29ucnBjX2pzXzEiLCJKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIiwicmVxdWVzdCIsImNvbnN0cnVjdG9yIiwiZXRoZXJldW0iLCJuZXR3b3JrIiwiYmF0Y2hNYXhDb3VudCIsIm1ldGhvZCIsInBhcmFtcyIsInBheWxvYWQiLCJlbWl0IiwiYWN0aW9uIiwicmVzdWx0IiwiZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImRhdGEiLCJzZW5kIiwiX3N0YXJ0IiwiX3NlbmQiLCJhc3NlcnRBcmd1bWVudCIsIkFycmF5IiwiaXNBcnJheSIsImlkIiwiZ2V0UnBjRXJyb3IiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoYXNTaWduZXIiLCJhZGRyZXNzIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImZpbHRlciIsImEiLCJnZXRTaWduZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  About Cloudflare\n *\n *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CloudflareProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n/**\n *  About Cloudflare...\n */ class CloudflareProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    constructor(_network){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        (0, index_js_1.assertArgument)(network.name === \"mainnet\", \"unsupported network\", \"network\", _network);\n        super(\"https://cloudflare-eth.com/\", network, {\n            staticNetwork: network\n        });\n    }\n}\nexports.CloudflareProvider = CloudflareProvider; //# sourceMappingURL=provider-cloudflare.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItY2xvdWRmbGFyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7O0NBSUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1FLHdCQUF3QkYsbUJBQU9BLENBQUMscUdBQXVCO0FBQzdEOztDQUVDLEdBQ0QsTUFBTUYsMkJBQTJCSSxzQkFBc0JDLGVBQWU7SUFDbEVDLFlBQVlDLFFBQVEsQ0FBRTtRQUNsQixJQUFJQSxZQUFZLE1BQU07WUFDbEJBLFdBQVc7UUFDZjtRQUNBLE1BQU1DLFVBQVVMLGFBQWFNLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDSDtRQUN6QyxJQUFHTixXQUFXVSxjQUFjLEVBQUVILFFBQVFJLElBQUksS0FBSyxXQUFXLHVCQUF1QixXQUFXTDtRQUM3RixLQUFLLENBQUMsK0JBQWdDQyxTQUFTO1lBQUVLLGVBQWVMO1FBQVE7SUFDNUU7QUFDSjtBQUNBViwwQkFBMEIsR0FBR0Usb0JBQzdCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1jbG91ZGZsYXJlLmpzPzBmNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBBYm91dCBDbG91ZGZsYXJlXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OkNsb3VkZmxhcmUgIFtwcm92aWRlcnMtY2xvdWRmbGFyZV1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbG91ZGZsYXJlUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG4vKipcbiAqICBBYm91dCBDbG91ZGZsYXJlLi4uXG4gKi9cbmNsYXNzIENsb3VkZmxhcmVQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKF9uZXR3b3JrKSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKG5ldHdvcmsubmFtZSA9PT0gXCJtYWlubmV0XCIsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgX25ldHdvcmspO1xuICAgICAgICBzdXBlcihcImh0dHBzOi9cXC9jbG91ZGZsYXJlLWV0aC5jb20vXCIsIG5ldHdvcmssIHsgc3RhdGljTmV0d29yazogbmV0d29yayB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNsb3VkZmxhcmVQcm92aWRlciA9IENsb3VkZmxhcmVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWNsb3VkZmxhcmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2xvdWRmbGFyZVByb3ZpZGVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJuZXR3b3JrX2pzXzEiLCJwcm92aWRlcl9qc29ucnBjX2pzXzEiLCJKc29uUnBjUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsIl9uZXR3b3JrIiwibmV0d29yayIsIk5ldHdvcmsiLCJmcm9tIiwiYXNzZXJ0QXJndW1lbnQiLCJuYW1lIiwic3RhdGljTmV0d29yayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  [[link-etherscan]] provides a third-party service for connecting to\n *  various blockchains over a combination of JSON-RPC and custom API\n *  endpoints.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EtherscanProvider = exports.EtherscanPlugin = void 0;\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../contract/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/contract/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst plugins_network_js_1 = __webpack_require__(/*! ./plugins-network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/plugins-network.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst THROTTLE = 2000;\nfunction isPromise(value) {\n    return value && typeof value.then === \"function\";\n}\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\";\n/**\n *  A Network can include an **EtherscanPlugin** to provide\n *  a custom base URL.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */ class EtherscanPlugin extends plugins_network_js_1.NetworkPlugin {\n    /**\n     *  Creates a new **EtherscanProvider** which will use\n     *  %%baseUrl%%.\n     */ constructor(baseUrl){\n        super(EtherscanPluginId);\n        (0, index_js_4.defineProperties)(this, {\n            baseUrl\n        });\n    }\n    clone() {\n        return new EtherscanPlugin(this.baseUrl);\n    }\n}\nexports.EtherscanPlugin = EtherscanPlugin;\nconst skipKeys = [\n    \"enableCcipRead\"\n];\nlet nextId = 1;\n/**\n *  The **EtherscanBaseProvider** is the super-class of\n *  [[EtherscanProvider]], which should generally be used instead.\n *\n *  Since the **EtherscanProvider** includes additional code for\n *  [[Contract]] access, in //rare cases// that contracts are not\n *  used, this class can reduce code size.\n *\n *  @_docloc: api/providers/thirdparty:Etherscan\n */ class EtherscanProvider extends abstract_provider_js_1.AbstractProvider {\n    #plugin;\n    /**\n     *  Creates a new **EtherscanBaseProvider**.\n     */ constructor(_network, _apiKey){\n        const apiKey = _apiKey != null ? _apiKey : null;\n        super();\n        const network = network_js_1.Network.from(_network);\n        this.#plugin = network.getPlugin(EtherscanPluginId);\n        (0, index_js_4.defineProperties)(this, {\n            apiKey,\n            network\n        });\n        // Test that the network is supported by Etherscan\n        this.getBaseUrl();\n    }\n    /**\n     *  Returns the base URL.\n     *\n     *  If an [[EtherscanPlugin]] is configured on the\n     *  [[EtherscanBaseProvider_network]], returns the plugin's\n     *  baseUrl.\n     */ getBaseUrl() {\n        if (this.#plugin) {\n            return this.#plugin.baseUrl;\n        }\n        switch(this.network.name){\n            case \"mainnet\":\n                return \"https://api.etherscan.io\";\n            case \"goerli\":\n                return \"https://api-goerli.etherscan.io\";\n            case \"sepolia\":\n                return \"https://api-sepolia.etherscan.io\";\n            case \"arbitrum\":\n                return \"https://api.arbiscan.io\";\n            case \"arbitrum-goerli\":\n                return \"https://api-goerli.arbiscan.io\";\n            case \"matic\":\n                return \"https://api.polygonscan.com\";\n            case \"matic-mumbai\":\n                return \"https://api-testnet.polygonscan.com\";\n            case \"optimism\":\n                return \"https://api-optimistic.etherscan.io\";\n            case \"optimism-goerli\":\n                return \"https://api-goerli-optimistic.etherscan.io\";\n            case \"bnb\":\n                return \"http://api.bscscan.com\";\n            case \"bnbt\":\n                return \"http://api-testnet.bscscan.com\";\n            default:\n        }\n        (0, index_js_4.assertArgument)(false, \"unsupported network\", \"network\", this.network);\n    }\n    /**\n     *  Returns the URL for the %%module%% and %%params%%.\n     */ getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key)=>{\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : \"\";\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;\n    }\n    /**\n     *  Returns the URL for using POST requests.\n     */ getPostUrl() {\n        return `${this.getBaseUrl()}/api`;\n    }\n    /**\n     *  Returns the parameters for using POST requests.\n     */ getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    async detectNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the result of calling %%module%% with %%params%%.\n     *\n     *  If %%post%%, the request is made as a POST request.\n     */ async fetch(module, params, post) {\n        const id = nextId++;\n        const url = post ? this.getPostUrl() : this.getUrl(module, params);\n        const payload = post ? this.getPostData(module, params) : null;\n        this.emit(\"debug\", {\n            action: \"sendRequest\",\n            id,\n            url,\n            payload: payload\n        });\n        const request = new index_js_4.FetchRequest(url);\n        request.setThrottleParams({\n            slotInterval: 1000\n        });\n        request.retryFunc = (req, resp, attempt)=>{\n            if (this.isCommunityResource()) {\n                (0, community_js_1.showThrottleMessage)(\"Etherscan\");\n            }\n            return Promise.resolve(true);\n        };\n        request.processFunc = async (request, response)=>{\n            const result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};\n            const throttle = (typeof result.result === \"string\" ? result.result : \"\").toLowerCase().indexOf(\"rate limit\") >= 0;\n            if (module === \"proxy\") {\n                // This JSON response indicates we are being throttled\n                if (result && result.status == 0 && result.message == \"NOTOK\" && throttle) {\n                    this.emit(\"debug\", {\n                        action: \"receiveError\",\n                        id,\n                        reason: \"proxy-NOTOK\",\n                        error: result\n                    });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            } else {\n                if (throttle) {\n                    this.emit(\"debug\", {\n                        action: \"receiveError\",\n                        id,\n                        reason: \"null result\",\n                        error: result.result\n                    });\n                    response.throwThrottleError(result.result, THROTTLE);\n                }\n            }\n            return response;\n        };\n        if (payload) {\n            request.setHeader(\"content-type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\n            request.body = Object.keys(payload).map((k)=>`${k}=${payload[k]}`).join(\"&\");\n        }\n        const response = await request.send();\n        try {\n            response.assertOk();\n        } catch (error) {\n            this.emit(\"debug\", {\n                action: \"receiveError\",\n                id,\n                error,\n                reason: \"assertOk\"\n            });\n            (0, index_js_4.assert)(false, \"response error\", \"SERVER_ERROR\", {\n                request,\n                response\n            });\n        }\n        if (!response.hasBody()) {\n            this.emit(\"debug\", {\n                action: \"receiveError\",\n                id,\n                error: \"missing body\",\n                reason: \"null body\"\n            });\n            (0, index_js_4.assert)(false, \"missing response\", \"SERVER_ERROR\", {\n                request,\n                response\n            });\n        }\n        const result = JSON.parse((0, index_js_4.toUtf8String)(response.body));\n        if (module === \"proxy\") {\n            if (result.jsonrpc != \"2.0\") {\n                this.emit(\"debug\", {\n                    action: \"receiveError\",\n                    id,\n                    result,\n                    reason: \"invalid JSON-RPC\"\n                });\n                (0, index_js_4.assert)(false, \"invalid JSON-RPC response (missing jsonrpc='2.0')\", \"SERVER_ERROR\", {\n                    request,\n                    response,\n                    info: {\n                        result\n                    }\n                });\n            }\n            if (result.error) {\n                this.emit(\"debug\", {\n                    action: \"receiveError\",\n                    id,\n                    result,\n                    reason: \"JSON-RPC error\"\n                });\n                (0, index_js_4.assert)(false, \"error response\", \"SERVER_ERROR\", {\n                    request,\n                    response,\n                    info: {\n                        result\n                    }\n                });\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRequest\",\n                id,\n                result\n            });\n            return result.result;\n        } else {\n            // getLogs, getHistory have weird success responses\n            if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n                this.emit(\"debug\", {\n                    action: \"receiveRequest\",\n                    id,\n                    result\n                });\n                return result.result;\n            }\n            if (result.status != 1 || typeof result.message === \"string\" && !result.message.match(/^OK/)) {\n                this.emit(\"debug\", {\n                    action: \"receiveError\",\n                    id,\n                    result\n                });\n                (0, index_js_4.assert)(false, \"error response\", \"SERVER_ERROR\", {\n                    request,\n                    response,\n                    info: {\n                        result\n                    }\n                });\n            }\n            this.emit(\"debug\", {\n                action: \"receiveRequest\",\n                id,\n                result\n            });\n            return result.result;\n        }\n    }\n    /**\n     *  Returns %%transaction%% normalized for the Etherscan API.\n     */ _getTransactionPostData(transaction) {\n        const result = {};\n        for(let key in transaction){\n            if (skipKeys.indexOf(key) >= 0) {\n                continue;\n            }\n            if (transaction[key] == null) {\n                continue;\n            }\n            let value = transaction[key];\n            if (key === \"type\" && value === 0) {\n                continue;\n            }\n            if (key === \"blockTag\" && value === \"latest\") {\n                continue;\n            }\n            // Quantity-types require no leading zero, unless 0\n            if (({\n                type: true,\n                gasLimit: true,\n                gasPrice: true,\n                maxFeePerGs: true,\n                maxPriorityFeePerGas: true,\n                nonce: true,\n                value: true\n            })[key]) {\n                value = (0, index_js_4.toQuantity)(value);\n            } else if (key === \"accessList\") {\n                value = \"[\" + (0, index_js_3.accessListify)(value).map((set)=>{\n                    return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n                }).join(\",\") + \"]\";\n            } else {\n                value = (0, index_js_4.hexlify)(value);\n            }\n            result[key] = value;\n        }\n        return result;\n    }\n    /**\n     *  Throws the normalized Etherscan error.\n     */ _checkError(req, error, transaction) {\n        // Pull any message out if, possible\n        let message = \"\";\n        if ((0, index_js_4.isError)(error, \"SERVER_ERROR\")) {\n            // Check for an error emitted by a proxy call\n            try {\n                message = error.info.result.error.message;\n            } catch (e) {}\n            if (!message) {\n                try {\n                    message = error.info.message;\n                } catch (e) {}\n            }\n        }\n        if (req.method === \"estimateGas\") {\n            if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {\n                (0, index_js_4.assert)(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: req.transaction\n                });\n            }\n        }\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            if (message.match(/execution reverted/i)) {\n                let data = \"\";\n                try {\n                    data = error.info.result.error.data;\n                } catch (error) {}\n                const e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);\n                e.info = {\n                    request: req,\n                    error\n                };\n                throw e;\n            }\n        }\n        if (message) {\n            if (req.method === \"broadcastTransaction\") {\n                const transaction = index_js_3.Transaction.from(req.signedTransaction);\n                if (message.match(/replacement/i) && message.match(/underpriced/i)) {\n                    (0, index_js_4.assert)(false, \"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                        transaction\n                    });\n                }\n                if (message.match(/insufficient funds/)) {\n                    (0, index_js_4.assert)(false, \"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                        transaction\n                    });\n                }\n                if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n                    (0, index_js_4.assert)(false, \"nonce has already been used\", \"NONCE_EXPIRED\", {\n                        transaction\n                    });\n                }\n            }\n        }\n        // Something we could not process\n        throw error;\n    }\n    async _detectNetwork() {\n        return this.network;\n    }\n    async _perform(req) {\n        switch(req.method){\n            case \"chainId\":\n                return this.network.chainId;\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_blockNumber\"\n                });\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_gasPrice\"\n                });\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: req.address,\n                    tag: req.blockTag\n                });\n            case \"getStorage\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: req.address,\n                    position: req.position,\n                    tag: req.blockTag\n                });\n            case \"broadcastTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: req.signedTransaction\n                }, true).catch((error)=>{\n                    return this._checkError(req, error, req.signedTransaction);\n                });\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: req.blockTag,\n                        boolean: req.includeTransactions ? \"true\" : \"false\"\n                    });\n                }\n                (0, index_js_4.assert)(false, \"getBlock by blockHash not supported by Etherscan\", \"UNSUPPORTED_OPERATION\", {\n                    operation: \"getBlock(blockHash)\"\n                });\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: req.hash\n                });\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: req.hash\n                });\n            case \"call\":\n                {\n                    if (req.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = this._getTransactionPostData(req.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return await this.fetch(\"proxy\", postData, true);\n                    } catch (error) {\n                        return this._checkError(req, error, req.transaction);\n                    }\n                }\n            case \"estimateGas\":\n                {\n                    const postData = this._getTransactionPostData(req.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return await this.fetch(\"proxy\", postData, true);\n                    } catch (error) {\n                        return this._checkError(req, error, req.transaction);\n                    }\n                }\n            /*\n                        case \"getLogs\": {\n                            // Needs to complain if more than one address is passed in\n                            const args: Record<string, any> = { action: \"getLogs\" }\n            \n                            if (params.filter.fromBlock) {\n                                args.fromBlock = checkLogTag(params.filter.fromBlock);\n                            }\n            \n                            if (params.filter.toBlock) {\n                                args.toBlock = checkLogTag(params.filter.toBlock);\n                            }\n            \n                            if (params.filter.address) {\n                                args.address = params.filter.address;\n                            }\n            \n                            // @TODO: We can handle slightly more complicated logs using the logs API\n                            if (params.filter.topics && params.filter.topics.length > 0) {\n                                if (params.filter.topics.length > 1) {\n                                    logger.throwError(\"unsupported topic count\", Logger.Errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                                }\n                                if (params.filter.topics.length === 1) {\n                                    const topic0 = params.filter.topics[0];\n                                    if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                                        logger.throwError(\"unsupported topic format\", Logger.Errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                                    }\n                                    args.topic0 = topic0;\n                                }\n                            }\n            \n                            const logs: Array<any> = await this.fetch(\"logs\", args);\n            \n                            // Cache txHash => blockHash\n                            let blocks: { [tag: string]: string } = {};\n            \n                            // Add any missing blockHash to the logs\n                            for (let i = 0; i < logs.length; i++) {\n                                const log = logs[i];\n                                if (log.blockHash != null) { continue; }\n                                if (blocks[log.blockNumber] == null) {\n                                    const block = await this.getBlock(log.blockNumber);\n                                    if (block) {\n                                        blocks[log.blockNumber] = block.hash;\n                                    }\n                                }\n            \n                                log.blockHash = blocks[log.blockNumber];\n                            }\n            \n                            return logs;\n                        }\n            */ default:\n                break;\n        }\n        return super._perform(req);\n    }\n    async getNetwork() {\n        return this.network;\n    }\n    /**\n     *  Resolves to the current price of ether.\n     *\n     *  This returns ``0`` on any network other than ``mainnet``.\n     */ async getEtherPrice() {\n        if (this.network.name !== \"mainnet\") {\n            return 0.0;\n        }\n        return parseFloat((await this.fetch(\"stats\", {\n            action: \"ethprice\"\n        })).ethusd);\n    }\n    /**\n     *  Resolves to a [Contract]] for %%address%%, using the\n     *  Etherscan API to retreive the Contract ABI.\n     */ async getContract(_address) {\n        let address = this._getAddress(_address);\n        if (isPromise(address)) {\n            address = await address;\n        }\n        try {\n            const resp = await this.fetch(\"contract\", {\n                action: \"getabi\",\n                address\n            });\n            const abi = JSON.parse(resp);\n            return new index_js_2.Contract(address, abi, this);\n        } catch (error) {\n            return null;\n        }\n    }\n    isCommunityResource() {\n        return this.apiKey == null;\n    }\n}\nexports.EtherscanProvider = EtherscanProvider; //# sourceMappingURL=provider-etherscan.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZXRoZXJzY2FuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDM0QsTUFBTUksYUFBYUMsbUJBQU9BLENBQUMsOEVBQWlCO0FBQzVDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHdGQUFzQjtBQUNqRCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw4RkFBeUI7QUFDcEQsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1JLHlCQUF5QkosbUJBQU9BLENBQUMsdUdBQXdCO0FBQy9ELE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1NLHVCQUF1Qk4sbUJBQU9BLENBQUMsbUdBQXNCO0FBQzNELE1BQU1PLGlCQUFpQlAsbUJBQU9BLENBQUMsdUZBQWdCO0FBQy9DLE1BQU1RLFdBQVc7QUFDakIsU0FBU0MsVUFBVWIsS0FBSztJQUNwQixPQUFRQSxTQUFTLE9BQVFBLE1BQU1jLElBQUksS0FBTTtBQUM3QztBQUNBLE1BQU1DLG9CQUFvQjtBQUMxQjs7Ozs7Q0FLQyxHQUNELE1BQU1iLHdCQUF3QlEscUJBQXFCTSxhQUFhO0lBSzVEOzs7S0FHQyxHQUNEQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDSDtRQUNMLElBQUdSLFdBQVdZLGdCQUFnQixFQUFFLElBQUksRUFBRTtZQUFFRDtRQUFRO0lBQ3JEO0lBQ0FFLFFBQVE7UUFDSixPQUFPLElBQUlsQixnQkFBZ0IsSUFBSSxDQUFDZ0IsT0FBTztJQUMzQztBQUNKO0FBQ0FuQix1QkFBdUIsR0FBR0c7QUFDMUIsTUFBTW1CLFdBQVc7SUFBQztDQUFpQjtBQUNuQyxJQUFJQyxT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ZixPQUFPLElBQUksQ0FBQ3RHLE9BQU87SUFDdkI7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTXVHLGdCQUFnQjtRQUNsQixJQUFJLElBQUksQ0FBQ3ZHLE9BQU8sQ0FBQ0ssSUFBSSxLQUFLLFdBQVc7WUFDakMsT0FBTztRQUNYO1FBQ0EsT0FBT21HLFdBQVcsQ0FBQyxNQUFNLElBQUksQ0FBQ3JGLEtBQUssQ0FBQyxTQUFTO1lBQUVNLFFBQVE7UUFBVyxFQUFDLEVBQUdnRixNQUFNO0lBQ2hGO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTUMsWUFBWUMsUUFBUSxFQUFFO1FBQ3hCLElBQUloQyxVQUFVLElBQUksQ0FBQ2lDLFdBQVcsQ0FBQ0Q7UUFDL0IsSUFBSTFILFVBQVUwRixVQUFVO1lBQ3BCQSxVQUFVLE1BQU1BO1FBQ3BCO1FBQ0EsSUFBSTtZQUNBLE1BQU0zQyxPQUFPLE1BQU0sSUFBSSxDQUFDYixLQUFLLENBQUMsWUFBWTtnQkFDdENNLFFBQVE7Z0JBQVVrRDtZQUN0QjtZQUNBLE1BQU1rQyxNQUFNbkUsS0FBS0MsS0FBSyxDQUFDWDtZQUN2QixPQUFPLElBQUl2RCxXQUFXcUksUUFBUSxDQUFDbkMsU0FBU2tDLEtBQUssSUFBSTtRQUNyRCxFQUNBLE9BQU96RCxPQUFPO1lBQ1YsT0FBTztRQUNYO0lBQ0o7SUFDQWxCLHNCQUFzQjtRQUNsQixPQUFRLElBQUksQ0FBQ25DLE1BQU0sSUFBSTtJQUMzQjtBQUNKO0FBQ0E1Qix5QkFBeUIsR0FBR0UsbUJBQzVCLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci1ldGhlcnNjYW4uanM/MTAzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFtbbGluay1ldGhlcnNjYW5dXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgYSBjb21iaW5hdGlvbiBvZiBKU09OLVJQQyBhbmQgY3VzdG9tIEFQSVxuICogIGVuZHBvaW50cy5cbiAqXG4gKiAgKipTdXBwb3J0ZWQgTmV0d29ya3MqKlxuICpcbiAqICAtIEV0aGVyZXVtIE1haW5uZXQgKGBgbWFpbm5ldGBgKVxuICogIC0gR29lcmxpIFRlc3RuZXQgKGBgZ29lcmxpYGApXG4gKiAgLSBTZXBvbGlhIFRlc3RuZXQgKGBgc2Vwb2xpYWBgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqICAtIEFyYml0cnVtIEdvZXJsaSBUZXN0bmV0IChgYGFyYml0cnVtLWdvZXJsaWBgKVxuICogIC0gT3B0aW1pc20gKGBgb3B0aW1pc21gYClcbiAqICAtIE9wdGltaXNtIEdvZXJsaSBUZXN0bmV0IChgYG9wdGltaXNtLWdvZXJsaWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gUG9seWdvbiBNdW1iYWkgVGVzdG5ldCAoYGBtYXRpYy1tdW1iYWlgYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW4gIFtwcm92aWRlcnMtZXRoZXJzY2FuXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXhwb3J0cy5FdGhlcnNjYW5QbHVnaW4gPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY29udHJhY3QvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18zID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1wcm92aWRlci5qc1wiKTtcbmNvbnN0IG5ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL25ldHdvcmsuanNcIik7XG5jb25zdCBwbHVnaW5zX25ldHdvcmtfanNfMSA9IHJlcXVpcmUoXCIuL3BsdWdpbnMtbmV0d29yay5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgVEhST1RUTEUgPSAyMDAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnRoZW4pID09PSBcImZ1bmN0aW9uXCIpO1xufVxuY29uc3QgRXRoZXJzY2FuUGx1Z2luSWQgPSBcIm9yZy5ldGhlcnMucGx1Z2lucy5wcm92aWRlci5FdGhlcnNjYW5cIjtcbi8qKlxuICogIEEgTmV0d29yayBjYW4gaW5jbHVkZSBhbiAqKkV0aGVyc2NhblBsdWdpbioqIHRvIHByb3ZpZGVcbiAqICBhIGN1c3RvbSBiYXNlIFVSTC5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpFdGhlcnNjYW5cbiAqL1xuY2xhc3MgRXRoZXJzY2FuUGx1Z2luIGV4dGVuZHMgcGx1Z2luc19uZXR3b3JrX2pzXzEuTmV0d29ya1BsdWdpbiB7XG4gICAgLyoqXG4gICAgICogIFRoZSBFdGhlcnNjYW4gQVBJIGJhc2UgVVJMLlxuICAgICAqL1xuICAgIGJhc2VVcmw7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFdGhlcnNjYW5Qcm92aWRlcioqIHdoaWNoIHdpbGwgdXNlXG4gICAgICogICUlYmFzZVVybCUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwpIHtcbiAgICAgICAgc3VwZXIoRXRoZXJzY2FuUGx1Z2luSWQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGJhc2VVcmwgfSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEV0aGVyc2NhblBsdWdpbih0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXRoZXJzY2FuUGx1Z2luID0gRXRoZXJzY2FuUGx1Z2luO1xuY29uc3Qgc2tpcEtleXMgPSBbXCJlbmFibGVDY2lwUmVhZFwiXTtcbmxldCBuZXh0SWQgPSAxO1xuLyoqXG4gKiAgVGhlICoqRXRoZXJzY2FuQmFzZVByb3ZpZGVyKiogaXMgdGhlIHN1cGVyLWNsYXNzIG9mXG4gKiAgW1tFdGhlcnNjYW5Qcm92aWRlcl1dLCB3aGljaCBzaG91bGQgZ2VuZXJhbGx5IGJlIHVzZWQgaW5zdGVhZC5cbiAqXG4gKiAgU2luY2UgdGhlICoqRXRoZXJzY2FuUHJvdmlkZXIqKiBpbmNsdWRlcyBhZGRpdGlvbmFsIGNvZGUgZm9yXG4gKiAgW1tDb250cmFjdF1dIGFjY2VzcywgaW4gLy9yYXJlIGNhc2VzLy8gdGhhdCBjb250cmFjdHMgYXJlIG5vdFxuICogIHVzZWQsIHRoaXMgY2xhc3MgY2FuIHJlZHVjZSBjb2RlIHNpemUuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6RXRoZXJzY2FuXG4gKi9cbmNsYXNzIEV0aGVyc2NhblByb3ZpZGVyIGV4dGVuZHMgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5BYnN0cmFjdFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBuZXR3b3JrLlxuICAgICAqL1xuICAgIG5ldHdvcms7XG4gICAgLyoqXG4gICAgICogIFRoZSBBUEkga2V5IG9yIG51bGwgaWYgdXNpbmcgdGhlIGNvbW11bml0eSBwcm92aWRlZCBiYW5kd2lkdGguXG4gICAgICovXG4gICAgYXBpS2V5O1xuICAgICNwbHVnaW47XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipFdGhlcnNjYW5CYXNlUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgX2FwaUtleSkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSAoX2FwaUtleSAhPSBudWxsKSA/IF9hcGlLZXkgOiBudWxsO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIHRoaXMuI3BsdWdpbiA9IG5ldHdvcmsuZ2V0UGx1Z2luKEV0aGVyc2NhblBsdWdpbklkKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhcGlLZXksIG5ldHdvcmsgfSk7XG4gICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgbmV0d29yayBpcyBzdXBwb3J0ZWQgYnkgRXRoZXJzY2FuXG4gICAgICAgIHRoaXMuZ2V0QmFzZVVybCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgYmFzZSBVUkwuXG4gICAgICpcbiAgICAgKiAgSWYgYW4gW1tFdGhlcnNjYW5QbHVnaW5dXSBpcyBjb25maWd1cmVkIG9uIHRoZVxuICAgICAqICBbW0V0aGVyc2NhbkJhc2VQcm92aWRlcl9uZXR3b3JrXV0sIHJldHVybnMgdGhlIHBsdWdpbidzXG4gICAgICogIGJhc2VVcmwuXG4gICAgICovXG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3BsdWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BsdWdpbi5iYXNlVXJsO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5uZXR3b3JrLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJzZXBvbGlhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1zZXBvbGlhLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5hcmJpc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmFyYmlzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLnBvbHlnb25zY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktdGVzdG5ldC5wb2x5Z29uc2Nhbi5jb21cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktb3B0aW1pc3RpYy5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1nb2VybGlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWdvZXJsaS1vcHRpbWlzdGljLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImJuYlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHA6L1xcL2FwaS5ic2NzY2FuLmNvbVwiO1xuICAgICAgICAgICAgY2FzZSBcImJuYnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9hcGktdGVzdG5ldC5ic2NzY2FuLmNvbVwiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgdGhpcy5uZXR3b3JrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIFVSTCBmb3IgdGhlICUlbW9kdWxlJSUgYW5kICUlcGFyYW1zJSUuXG4gICAgICovXG4gICAgZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmtleXMocGFyYW1zKS5yZWR1Y2UoKGFjY3VtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFjY3VtICs9IGAmJHtrZXl9PSR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9ICgodGhpcy5hcGlLZXkpID8gYCZhcGlrZXk9JHt0aGlzLmFwaUtleX1gIDogXCJcIik7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEJhc2VVcmwoKX0vYXBpP21vZHVsZT0ke21vZHVsZX0ke3F1ZXJ5fSR7YXBpS2V5fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBVUkwgZm9yIHVzaW5nIFBPU1QgcmVxdWVzdHMuXG4gICAgICovXG4gICAgZ2V0UG9zdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0QmFzZVVybCgpfS9hcGlgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgcGFyYW1ldGVycyBmb3IgdXNpbmcgUE9TVCByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBnZXRQb3N0RGF0YShtb2R1bGUsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICBwYXJhbXMuYXBpa2V5ID0gdGhpcy5hcGlLZXk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgJSVtb2R1bGUlJSB3aXRoICUlcGFyYW1zJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwb3N0JSUsIHRoZSByZXF1ZXN0IGlzIG1hZGUgYXMgYSBQT1NUIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2gobW9kdWxlLCBwYXJhbXMsIHBvc3QpIHtcbiAgICAgICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICAgICAgY29uc3QgdXJsID0gKHBvc3QgPyB0aGlzLmdldFBvc3RVcmwoKSA6IHRoaXMuZ2V0VXJsKG1vZHVsZSwgcGFyYW1zKSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSAocG9zdCA/IHRoaXMuZ2V0UG9zdERhdGEobW9kdWxlLCBwYXJhbXMpIDogbnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRSZXF1ZXN0XCIsIGlkLCB1cmwsIHBheWxvYWQ6IHBheWxvYWQgfSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfNC5GZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgcmVxdWVzdC5zZXRUaHJvdHRsZVBhcmFtcyh7IHNsb3RJbnRlcnZhbDogMTAwMCB9KTtcbiAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSAocmVxLCByZXNwLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbW11bml0eVJlc291cmNlKCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJFdGhlcnNjYW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LnByb2Nlc3NGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5oYXNCb2R5KCkgPyBKU09OLnBhcnNlKCgwLCBpbmRleF9qc180LnRvVXRmOFN0cmluZykocmVzcG9uc2UuYm9keSkpIDoge307XG4gICAgICAgICAgICBjb25zdCB0aHJvdHRsZSA9ICgodHlwZW9mIChyZXN1bHQucmVzdWx0KSA9PT0gXCJzdHJpbmdcIikgPyByZXN1bHQucmVzdWx0IDogXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwicmF0ZSBsaW1pdFwiKSA+PSAwO1xuICAgICAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBKU09OIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdHVzID09IDAgJiYgcmVzdWx0Lm1lc3NhZ2UgPT0gXCJOT1RPS1wiICYmIHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcInByb3h5LU5PVE9LXCIsIGVycm9yOiByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcihyZXN1bHQucmVzdWx0LCBUSFJPVFRMRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVhc29uOiBcIm51bGwgcmVzdWx0XCIsIGVycm9yOiByZXN1bHQucmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS50aHJvd1Rocm90dGxlRXJyb3IocmVzdWx0LnJlc3VsdCwgVEhST1RUTEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5ID0gT2JqZWN0LmtleXMocGF5bG9hZCkubWFwKChrKSA9PiBgJHtrfT0ke3BheWxvYWRba119YCkuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIGVycm9yLCByZWFzb246IFwiYXNzZXJ0T2tcIiB9KTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwicmVzcG9uc2UgZXJyb3JcIiwgXCJTRVJWRVJfRVJST1JcIiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZUVycm9yXCIsIGlkLCBlcnJvcjogXCJtaXNzaW5nIGJvZHlcIiwgcmVhc29uOiBcIm51bGwgYm9keVwiIH0pO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJtaXNzaW5nIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgoMCwgaW5kZXhfanNfNC50b1V0ZjhTdHJpbmcpKHJlc3BvbnNlLmJvZHkpKTtcbiAgICAgICAgaWYgKG1vZHVsZSA9PT0gXCJwcm94eVwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiaW52YWxpZCBKU09OLVJQQ1wiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwiaW52YWxpZCBKU09OLVJQQyByZXNwb25zZSAobWlzc2luZyBqc29ucnBjPScyLjAnKVwiLCBcIlNFUlZFUl9FUlJPUlwiLCB7IHJlcXVlc3QsIHJlc3BvbnNlLCBpbmZvOiB7IHJlc3VsdCB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVFcnJvclwiLCBpZCwgcmVzdWx0LCByZWFzb246IFwiSlNPTi1SUEMgZXJyb3JcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImVycm9yIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gMSB8fCAodHlwZW9mIChyZXN1bHQubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgIXJlc3VsdC5tZXNzYWdlLm1hdGNoKC9eT0svKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlRXJyb3JcIiwgaWQsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImVycm9yIHJlc3BvbnNlXCIsIFwiU0VSVkVSX0VSUk9SXCIsIHsgcmVxdWVzdCwgcmVzcG9uc2UsIGluZm86IHsgcmVzdWx0IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7IGFjdGlvbjogXCJyZWNlaXZlUmVxdWVzdFwiLCBpZCwgcmVzdWx0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0cmFuc2FjdGlvbiUlIG5vcm1hbGl6ZWQgZm9yIHRoZSBFdGhlcnNjYW4gQVBJLlxuICAgICAqL1xuICAgIF9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChza2lwS2V5cy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdHJhbnNhY3Rpb25ba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrVGFnXCIgJiYgdmFsdWUgPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFF1YW50aXR5LXR5cGVzIHJlcXVpcmUgbm8gbGVhZGluZyB6ZXJvLCB1bmxlc3MgMFxuICAgICAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICgwLCBpbmRleF9qc180LnRvUXVhbnRpdHkpKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJhY2Nlc3NMaXN0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiW1wiICsgKDAsIGluZGV4X2pzXzMuYWNjZXNzTGlzdGlmeSkodmFsdWUpLm1hcCgoc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBge2FkZHJlc3M6XCIke3NldC5hZGRyZXNzfVwiLHN0b3JhZ2VLZXlzOltcIiR7c2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJyl9XCJdfWA7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIHRoZSBub3JtYWxpemVkIEV0aGVyc2NhbiBlcnJvci5cbiAgICAgKi9cbiAgICBfY2hlY2tFcnJvcihyZXEsIGVycm9yLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBQdWxsIGFueSBtZXNzYWdlIG91dCBpZiwgcG9zc2libGVcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICBpZiAoKDAsIGluZGV4X2pzXzQuaXNFcnJvcikoZXJyb3IsIFwiU0VSVkVSX0VSUk9SXCIpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYW4gZXJyb3IgZW1pdHRlZCBieSBhIHByb3h5IGNhbGxcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmluZm8ucmVzdWx0LmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IuaW5mby5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLm1hdGNoKC9yZXZlcnQvaSkgJiYgbWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzL2kpKSB7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJpbnN1ZmZpY2llbnQgZnVuZHNcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogcmVxLnRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgPT09IFwiY2FsbFwiIHx8IHJlcS5tZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiByZXZlcnRlZC9pKSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXJyb3IuaW5mby5yZXN1bHQuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICBjb25zdCBlID0gaW5kZXhfanNfMS5BYmlDb2Rlci5nZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbihyZXEubWV0aG9kLCByZXEudHJhbnNhY3Rpb24sIGRhdGEpO1xuICAgICAgICAgICAgICAgIGUuaW5mbyA9IHsgcmVxdWVzdDogcmVxLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImJyb2FkY2FzdFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGluZGV4X2pzXzMuVHJhbnNhY3Rpb24uZnJvbShyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudC9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHMvKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9zYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWR8dHJhbnNhY3Rpb24gbm9uY2UgaXMgdG9vIGxvd3xub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShmYWxzZSwgXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgXCJOT05DRV9FWFBJUkVEXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTb21ldGhpbmcgd2UgY291bGQgbm90IHByb2Nlc3NcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIF9kZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrO1xuICAgIH1cbiAgICBhc3luYyBfcGVyZm9ybShyZXEpIHtcbiAgICAgICAgc3dpdGNoIChyZXEubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwgeyBhY3Rpb246IFwiZXRoX2Jsb2NrTnVtYmVyXCIgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHsgYWN0aW9uOiBcImV0aF9nYXNQcmljZVwiIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGJhc2UtMTAgcmVzdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJhY2NvdW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVxLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXEuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlcS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGFnOiByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBoZXg6IHJlcS5zaWduZWRUcmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIH0sIHRydWUpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tFcnJvcihyZXEsIGVycm9yLCByZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKFwiYmxvY2tUYWdcIiBpbiByZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcmVxLmJsb2NrVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogKHJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnQpKGZhbHNlLCBcImdldEJsb2NrIGJ5IGJsb2NrSGFzaCBub3Qgc3VwcG9ydGVkIGJ5IEV0aGVyc2NhblwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRCbG9jayhibG9ja0hhc2gpXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIHR4aGFzaDogcmVxLmhhc2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgICAgICAgICAgdHhoYXNoOiByZXEuaGFzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIGlmIChyZXEuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJzY2FuUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBibG9ja1RhZyBmb3IgY2FsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdERhdGEgPSB0aGlzLl9nZXRUcmFuc2FjdGlvblBvc3REYXRhKHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEubW9kdWxlID0gXCJwcm94eVwiO1xuICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0RGF0YSA9IHRoaXMuX2dldFRyYW5zYWN0aW9uUG9zdERhdGEocmVxLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG4gICAgICAgICAgICAgICAgcG9zdERhdGEuYWN0aW9uID0gXCJldGhfZXN0aW1hdGVHYXNcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0Vycm9yKHJlcSwgZXJyb3IsIHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkcyB0byBjb21wbGFpbiBpZiBtb3JlIHRoYW4gb25lIGFkZHJlc3MgaXMgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnczogUmVjb3JkPHN0cmluZywgYW55PiA9IHsgYWN0aW9uOiBcImdldExvZ3NcIiB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5mcm9tQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLnRvQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5hZGRyZXNzID0gcGFyYW1zLmZpbHRlci5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXZSBjYW4gaGFuZGxlIHNsaWdodGx5IG1vcmUgY29tcGxpY2F0ZWQgbG9ncyB1c2luZyB0aGUgbG9ncyBBUElcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MgJiYgcGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBjb3VudFwiLCBMb2dnZXIuRXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpY3M6IHBhcmFtcy5maWx0ZXIudG9waWNzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvcGljMCA9IHBhcmFtcy5maWx0ZXIudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZih0b3BpYzApICE9PSBcInN0cmluZ1wiIHx8IHRvcGljMC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCB0b3BpYyBmb3JtYXRcIiwgTG9nZ2VyLkVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWMwOiB0b3BpYzAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnRvcGljMCA9IHRvcGljMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3M6IEFycmF5PGFueT4gPSBhd2FpdCB0aGlzLmZldGNoKFwibG9nc1wiLCBhcmdzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHR4SGFzaCA9PiBibG9ja0hhc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tzOiB7IFt0YWc6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IG1pc3NpbmcgYmxvY2tIYXNoIHRvIHRoZSBsb2dzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGxvZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tIYXNoICE9IG51bGwpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2xvZy5ibG9ja051bWJlcl0gPSBibG9jay5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9wZXJmb3JtKHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgY3VycmVudCBwcmljZSBvZiBldGhlci5cbiAgICAgKlxuICAgICAqICBUaGlzIHJldHVybnMgYGAwYGAgb24gYW55IG5ldHdvcmsgb3RoZXIgdGhhbiBgYG1haW5uZXRgYC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRFdGhlclByaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgIT09IFwibWFpbm5ldFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KChhd2FpdCB0aGlzLmZldGNoKFwic3RhdHNcIiwgeyBhY3Rpb246IFwiZXRocHJpY2VcIiB9KSkuZXRodXNkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0NvbnRyYWN0XV0gZm9yICUlYWRkcmVzcyUlLCB1c2luZyB0aGVcbiAgICAgKiAgRXRoZXJzY2FuIEFQSSB0byByZXRyZWl2ZSB0aGUgQ29udHJhY3QgQUJJLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbnRyYWN0KF9hZGRyZXNzKSB7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgICAgIGlmIChpc1Byb21pc2UoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5mZXRjaChcImNvbnRyYWN0XCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwiZ2V0YWJpXCIsIGFkZHJlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWJpID0gSlNPTi5wYXJzZShyZXNwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW5kZXhfanNfMi5Db250cmFjdChhZGRyZXNzLCBhYmksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PSBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gRXRoZXJzY2FuUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1ldGhlcnNjYW4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRXRoZXJzY2FuUHJvdmlkZXIiLCJFdGhlcnNjYW5QbHVnaW4iLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiaW5kZXhfanNfNCIsImFic3RyYWN0X3Byb3ZpZGVyX2pzXzEiLCJuZXR3b3JrX2pzXzEiLCJwbHVnaW5zX25ldHdvcmtfanNfMSIsImNvbW11bml0eV9qc18xIiwiVEhST1RUTEUiLCJpc1Byb21pc2UiLCJ0aGVuIiwiRXRoZXJzY2FuUGx1Z2luSWQiLCJOZXR3b3JrUGx1Z2luIiwiY29uc3RydWN0b3IiLCJiYXNlVXJsIiwiZGVmaW5lUHJvcGVydGllcyIsImNsb25lIiwic2tpcEtleXMiLCJuZXh0SWQiLCJBYnN0cmFjdFByb3ZpZGVyIiwicGx1Z2luIiwiX25ldHdvcmsiLCJfYXBpS2V5IiwiYXBpS2V5IiwibmV0d29yayIsIk5ldHdvcmsiLCJmcm9tIiwiZ2V0UGx1Z2luIiwiZ2V0QmFzZVVybCIsIm5hbWUiLCJhc3NlcnRBcmd1bWVudCIsImdldFVybCIsIm1vZHVsZSIsInBhcmFtcyIsInF1ZXJ5Iiwia2V5cyIsInJlZHVjZSIsImFjY3VtIiwia2V5IiwiZ2V0UG9zdFVybCIsImdldFBvc3REYXRhIiwiYXBpa2V5IiwiZGV0ZWN0TmV0d29yayIsImZldGNoIiwicG9zdCIsImlkIiwidXJsIiwicGF5bG9hZCIsImVtaXQiLCJhY3Rpb24iLCJyZXF1ZXN0IiwiRmV0Y2hSZXF1ZXN0Iiwic2V0VGhyb3R0bGVQYXJhbXMiLCJzbG90SW50ZXJ2YWwiLCJyZXRyeUZ1bmMiLCJyZXEiLCJyZXNwIiwiYXR0ZW1wdCIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJzaG93VGhyb3R0bGVNZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcm9jZXNzRnVuYyIsInJlc3BvbnNlIiwicmVzdWx0IiwiaGFzQm9keSIsIkpTT04iLCJwYXJzZSIsInRvVXRmOFN0cmluZyIsImJvZHkiLCJ0aHJvdHRsZSIsInRvTG93ZXJDYXNlIiwiaW5kZXhPZiIsInN0YXR1cyIsIm1lc3NhZ2UiLCJyZWFzb24iLCJlcnJvciIsInRocm93VGhyb3R0bGVFcnJvciIsInNldEhlYWRlciIsIm1hcCIsImsiLCJqb2luIiwic2VuZCIsImFzc2VydE9rIiwiYXNzZXJ0IiwianNvbnJwYyIsImluZm8iLCJtYXRjaCIsIl9nZXRUcmFuc2FjdGlvblBvc3REYXRhIiwidHJhbnNhY3Rpb24iLCJ0eXBlIiwiZ2FzTGltaXQiLCJnYXNQcmljZSIsIm1heEZlZVBlckdzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJub25jZSIsInRvUXVhbnRpdHkiLCJhY2Nlc3NMaXN0aWZ5Iiwic2V0IiwiYWRkcmVzcyIsInN0b3JhZ2VLZXlzIiwiaGV4bGlmeSIsIl9jaGVja0Vycm9yIiwiaXNFcnJvciIsImUiLCJtZXRob2QiLCJkYXRhIiwiQWJpQ29kZXIiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsIlRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJfZGV0ZWN0TmV0d29yayIsIl9wZXJmb3JtIiwiY2hhaW5JZCIsInRhZyIsImJsb2NrVGFnIiwicG9zaXRpb24iLCJoZXgiLCJjYXRjaCIsImJvb2xlYW4iLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwib3BlcmF0aW9uIiwidHhoYXNoIiwiaGFzaCIsIkVycm9yIiwicG9zdERhdGEiLCJnZXROZXR3b3JrIiwiZ2V0RXRoZXJQcmljZSIsInBhcnNlRmxvYXQiLCJldGh1c2QiLCJnZXRDb250cmFjdCIsIl9hZGRyZXNzIiwiX2dldEFkZHJlc3MiLCJhYmkiLCJDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-etherscan.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-fallback.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FallbackProvider = void 0;\n/**\n *  A **FallbackProvider** providers resiliance, security and performatnce\n *  in a way that is customizable and configurable.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */ const index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n    for(let i = array.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction stringify(value) {\n    return JSON.stringify(value, (key, value)=>{\n        if (typeof value === \"bigint\") {\n            return {\n                type: \"bigint\",\n                value: value.toString()\n            };\n        }\n        return value;\n    });\n}\n;\nconst defaultConfig = {\n    stallTimeout: 400,\n    priority: 1,\n    weight: 1\n};\nconst defaultState = {\n    blockNumber: -2,\n    requests: 0,\n    lateResponses: 0,\n    errorResponses: 0,\n    outOfSync: -1,\n    unsupportedEvents: 0,\n    rollingDuration: 0,\n    score: 0,\n    _network: null,\n    _updateNumber: null,\n    _totalTime: 0,\n    _lastFatalError: null,\n    _lastFatalErrorTimestamp: 0\n};\nasync function waitForSync(config, blockNumber) {\n    while(config.blockNumber < 0 || config.blockNumber < blockNumber){\n        if (!config._updateNumber) {\n            config._updateNumber = (async ()=>{\n                try {\n                    const blockNumber = await config.provider.getBlockNumber();\n                    if (blockNumber > config.blockNumber) {\n                        config.blockNumber = blockNumber;\n                    }\n                } catch (error) {\n                    config.blockNumber = -2;\n                    config._lastFatalError = error;\n                    config._lastFatalErrorTimestamp = getTime();\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n        if (config._lastFatalError) {\n            break;\n        }\n    }\n}\nfunction _normalize(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[\" + value.map(_normalize).join(\",\") + \"]\";\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return _normalize(value.toJSON());\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n        case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{\" + keys.map((k)=>`${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n            }\n    }\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(value) {\n    if (\"error\" in value) {\n        const error = value.error;\n        return {\n            tag: _normalize(error),\n            value: error\n        };\n    }\n    const result = value.result;\n    return {\n        tag: _normalize(result),\n        value: result\n    };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n    const tally = new Map();\n    for (const { value, tag, weight } of results){\n        const t = tally.get(tag) || {\n            value,\n            weight: 0\n        };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n    let best = null;\n    for (const r of tally.values()){\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n    if (best) {\n        return best.value;\n    }\n    return undefined;\n}\nfunction getMedian(quorum, results) {\n    let resultWeight = 0;\n    const errorMap = new Map();\n    let bestError = null;\n    const values = [];\n    for (const { value, tag, weight } of results){\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || {\n                value,\n                weight: 0\n            };\n            e.weight += weight;\n            errorMap.set(tag, e);\n            if (bestError == null || e.weight > bestError.weight) {\n                bestError = e;\n            }\n        } else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) {\n            return bestError.value;\n        }\n        // We do not have quorum for a result\n        return undefined;\n    }\n    // Get the sorted values\n    values.sort((a, b)=>a < b ? -1 : b > a ? 1 : 0);\n    const mid = Math.floor(values.length / 2);\n    // Odd-length; take the middle value\n    if (values.length % 2) {\n        return values[mid];\n    }\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) {\n        return result;\n    }\n    // Otherwise, do we have any result?\n    for (const r of results){\n        if (r.value) {\n            return r.value;\n        }\n    }\n    // Nope!\n    return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n    if (quorum === 1) {\n        return (0, index_js_1.getNumber)(getMedian(quorum, results), \"%internal\");\n    }\n    const tally = new Map();\n    const add = (result, weight)=>{\n        const t = tally.get(result) || {\n            result,\n            weight: 0\n        };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n    for (const { weight, value } of results){\n        const r = (0, index_js_1.getNumber)(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n    let bestWeight = 0;\n    let bestResult = undefined;\n    for (const { weight, result } of tally.values()){\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n    return bestResult;\n}\n/**\n *  A **FallbackProvider** manages several [[Providers]] providing\n *  resiliance by switching between slow or misbehaving nodes, security\n *  by requiring multiple backends to aggree and performance by allowing\n *  faster backends to respond earlier.\n *\n */ class FallbackProvider extends abstract_provider_js_1.AbstractProvider {\n    #configs;\n    #height;\n    #initialSyncPromise;\n    /**\n     *  Creates a new **FallbackProvider** with %%providers%% connected to\n     *  %%network%%.\n     *\n     *  If a [[Provider]] is included in %%providers%%, defaults are used\n     *  for the configuration.\n     */ constructor(providers, network, options){\n        super(network, options);\n        this.#configs = providers.map((p)=>{\n            if (p instanceof abstract_provider_js_1.AbstractProvider) {\n                return Object.assign({\n                    provider: p\n                }, defaultConfig, defaultState);\n            } else {\n                return Object.assign({}, defaultConfig, p, defaultState);\n            }\n        });\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n        if (options && options.quorum != null) {\n            this.quorum = options.quorum;\n        } else {\n            this.quorum = Math.ceil(this.#configs.reduce((accum, config)=>{\n                accum += config.weight;\n                return accum;\n            }, 0) / 2);\n        }\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n        (0, index_js_1.assertArgument)(this.quorum <= this.#configs.reduce((a, c)=>a + c.weight, 0), \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n    }\n    get providerConfigs() {\n        return this.#configs.map((c)=>{\n            const result = Object.assign({}, c);\n            for(const key in result){\n                if (key[0] === \"_\") {\n                    delete result[key];\n                }\n            }\n            return result;\n        });\n    }\n    async _detectNetwork() {\n        return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({\n            method: \"chainId\"\n        })));\n    }\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n    /**\n     *  Transforms a %%req%% into the correct method call on %%provider%%.\n     */ async _translatePerform(provider, req) {\n        switch(req.method){\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({}, req.transaction, {\n                    blockTag: req.blockTag\n                }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\":\n                {\n                    const block = \"blockHash\" in req ? req.blockHash : req.blockTag;\n                    return await provider.getBlock(block, req.includeTransactions);\n                }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running) {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n        const configs = Array.from(running).map((r)=>r.config);\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b)=>a.priority - b.priority);\n        for (const config of allConfigs){\n            if (config._lastFatalError) {\n                continue;\n            }\n            if (configs.indexOf(config) === -1) {\n                return config;\n            }\n        }\n        return null;\n    }\n    // Adds a new runner (if available) to running.\n    #addRunner(running, req) {\n        const config = this.#getNextConfig(running);\n        // No runners available\n        if (config == null) {\n            return null;\n        }\n        // Create a new runner\n        const runner = {\n            config,\n            result: null,\n            didBump: false,\n            perform: null,\n            staller: null\n        };\n        const now = getTime();\n        // Start performing this operation\n        runner.perform = (async ()=>{\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = {\n                    result\n                };\n            } catch (error) {\n                config.errorResponses++;\n                runner.result = {\n                    error\n                };\n            }\n            const dt = getTime() - now;\n            config._totalTime += dt;\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n            runner.perform = null;\n        })();\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async ()=>{\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n        running.add(runner);\n        return runner;\n    }\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync() {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises = [];\n            this.#configs.forEach((config)=>{\n                promises.push((async ()=>{\n                    await waitForSync(config, 0);\n                    if (!config._lastFatalError) {\n                        config._network = await config.provider.getNetwork();\n                    }\n                })());\n            });\n            this.#initialSyncPromise = initialSync = (async ()=>{\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n                // Check all the networks match\n                let chainId = null;\n                for (const config of this.#configs){\n                    if (config._lastFatalError) {\n                        continue;\n                    }\n                    const network = config._network;\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    } else if (network.chainId !== chainId) {\n                        (0, index_js_1.assert)(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n        await initialSync;\n    }\n    async #checkQuorum(running, req) {\n        // Get all the result objects\n        const results = [];\n        for (const runner of running){\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(runner.result);\n                results.push({\n                    tag,\n                    value,\n                    weight: runner.config.weight\n                });\n            }\n        }\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r)=>a + r.weight, 0) < this.quorum) {\n            return undefined;\n        }\n        switch(req.method){\n            case \"getBlockNumber\":\n                {\n                    // We need to get the bootstrap block height\n                    if (this.#height === -2) {\n                        this.#height = Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, this.#configs.filter((c)=>!c._lastFatalError).map((c)=>({\n                                value: c.blockNumber,\n                                tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),\n                                weight: c.weight\n                            })))));\n                    }\n                    // Find the mode across all the providers, allowing for\n                    // a little drift between block heights\n                    const mode = getFuzzyMode(this.quorum, results);\n                    if (mode === undefined) {\n                        return undefined;\n                    }\n                    if (mode > this.#height) {\n                        this.#height = mode;\n                    }\n                    return this.#height;\n                }\n            case \"getGasPrice\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n        (0, index_js_1.assert)(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${stringify(req.method)})`\n        });\n    }\n    async #waitForQuorum(running, req) {\n        if (running.size === 0) {\n            throw new Error(\"no runners?!\");\n        }\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting = [];\n        let newRunners = 0;\n        for (const runner of running){\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n            // This runner has already triggered another runner\n            if (runner.didBump) {\n                continue;\n            }\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) {\n                throw value;\n            }\n            return value;\n        }\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for(let i = 0; i < newRunners; i++){\n            this.#addRunner(running, req);\n        }\n        // All providers have returned, and we have no result\n        (0, index_js_1.assert)(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: {\n                request: req,\n                results: Array.from(running).map((r)=>stringify(r.result))\n            }\n        });\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n    async _perform(req) {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            const results = await Promise.all(this.#configs.map(async ({ provider, weight })=>{\n                try {\n                    const result = await provider._perform(req);\n                    return Object.assign(normalizeResult({\n                        result\n                    }), {\n                        weight\n                    });\n                } catch (error) {\n                    return Object.assign(normalizeResult({\n                        error\n                    }), {\n                        weight\n                    });\n                }\n            }));\n            const result = getAnyResult(this.quorum, results);\n            (0, index_js_1.assert)(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: {\n                    request: req,\n                    results: results.map(stringify)\n                }\n            });\n            if (result instanceof Error) {\n                throw result;\n            }\n            return result;\n        }\n        await this.#initialSync();\n        // Bootstrap enough runners to meet quorum\n        const running = new Set();\n        for(let i = 0; i < this.quorum; i++){\n            this.#addRunner(running, req);\n        }\n        const result = await this.#waitForQuorum(running, req);\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running){\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n        return result;\n    }\n    async destroy() {\n        for (const { provider } of this.#configs){\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\nexports.FallbackProvider = FallbackProvider; //# sourceMappingURL=provider-fallback.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEM7Ozs7O0NBS0MsR0FDRCxNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMseUJBQXlCRCxtQkFBT0EsQ0FBQyx1R0FBd0I7QUFDL0QsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsbUZBQWM7QUFDM0MsTUFBTUcsT0FBT0MsT0FBTztBQUNwQixNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLFNBQVNFLFFBQVFDLEtBQUs7SUFDbEIsSUFBSyxJQUFJQyxJQUFJRCxNQUFNRSxNQUFNLEdBQUcsR0FBR0QsSUFBSSxHQUFHQSxJQUFLO1FBQ3ZDLE1BQU1FLElBQUlDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNTCxDQUFBQSxJQUFJO1FBQzFDLE1BQU1NLE1BQU1QLEtBQUssQ0FBQ0MsRUFBRTtRQUNwQkQsS0FBSyxDQUFDQyxFQUFFLEdBQUdELEtBQUssQ0FBQ0csRUFBRTtRQUNuQkgsS0FBSyxDQUFDRyxFQUFFLEdBQUdJO0lBQ2Y7QUFDSjtBQUNBLFNBQVNDLE1BQU1DLFFBQVE7SUFDbkIsT0FBTyxJQUFJQyxRQUFRLENBQUNDO1FBQWNDLFdBQVdELFNBQVNGO0lBQVc7QUFDckU7QUFDQSxTQUFTSTtJQUFZLE9BQU8sSUFBS0MsT0FBUUQsT0FBTztBQUFJO0FBQ3BELFNBQVNFLFVBQVV6QixLQUFLO0lBQ3BCLE9BQU8wQixLQUFLRCxTQUFTLENBQUN6QixPQUFPLENBQUMyQixLQUFLM0I7UUFDL0IsSUFBSSxPQUFRQSxVQUFXLFVBQVU7WUFDN0IsT0FBTztnQkFBRTRCLE1BQU07Z0JBQVU1QixPQUFPQSxNQUFNNkIsUUFBUTtZQUFHO1FBQ3JEO1FBQ0Es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QzFCLElBQUlLLE9BQU9FLE9BQU8sSUFBSUYsT0FBT3RGLE1BQU0sSUFBSSxNQUFNO2dCQUN6Q3NGLE9BQU94RyxNQUFNLENBQUNaLGFBQWE7WUFDL0I7UUFDSjtRQUNBLE9BQU84QjtJQUNYO0lBQ0EsTUFBTTJHLFVBQVU7UUFDWixLQUFLLE1BQU0sRUFBRTVILFFBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDOEMsT0FBTyxDQUFFO1lBQ3RDOUMsU0FBUzRILE9BQU87UUFDcEI7UUFDQSxLQUFLLENBQUNBO0lBQ1Y7QUFDSjtBQUNBL0ssd0JBQXdCLEdBQUdFLGtCQUMzQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItZmFsbGJhY2suanM/ZGY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogIEEgKipGYWxsYmFja1Byb3ZpZGVyKiogcHJvdmlkZXJzIHJlc2lsaWFuY2UsIHNlY3VyaXR5IGFuZCBwZXJmb3JtYXRuY2VcbiAqICBpbiBhIHdheSB0aGF0IGlzIGN1c3RvbWl6YWJsZSBhbmQgY29uZmlndXJhYmxlLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS9wcm92aWRlcnMvZmFsbGJhY2stcHJvdmlkZXI6RmFsbGJhY2sgUHJvdmlkZXIgW2Fib3V0LWZhbGxiYWNrLXByb3ZpZGVyXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IEJOXzEgPSBCaWdJbnQoXCIxXCIpO1xuY29uc3QgQk5fMiA9IEJpZ0ludChcIjJcIik7XG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0bXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0bXA7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0VGltZSgpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpZ2ludFwiLCB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbjtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7IHN0YWxsVGltZW91dDogNDAwLCBwcmlvcml0eTogMSwgd2VpZ2h0OiAxIH07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgYmxvY2tOdW1iZXI6IC0yLCByZXF1ZXN0czogMCwgbGF0ZVJlc3BvbnNlczogMCwgZXJyb3JSZXNwb25zZXM6IDAsXG4gICAgb3V0T2ZTeW5jOiAtMSwgdW5zdXBwb3J0ZWRFdmVudHM6IDAsIHJvbGxpbmdEdXJhdGlvbjogMCwgc2NvcmU6IDAsXG4gICAgX25ldHdvcms6IG51bGwsIF91cGRhdGVOdW1iZXI6IG51bGwsIF90b3RhbFRpbWU6IDAsXG4gICAgX2xhc3RGYXRhbEVycm9yOiBudWxsLCBfbGFzdEZhdGFsRXJyb3JUaW1lc3RhbXA6IDBcbn07XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XG4gICAgd2hpbGUgKGNvbmZpZy5ibG9ja051bWJlciA8IDAgfHwgY29uZmlnLmJsb2NrTnVtYmVyIDwgYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgaWYgKCFjb25maWcuX3VwZGF0ZU51bWJlcikge1xuICAgICAgICAgICAgY29uZmlnLl91cGRhdGVOdW1iZXIgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgY29uZmlnLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IGNvbmZpZy5ibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ibG9ja051bWJlciA9IC0yO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2xhc3RGYXRhbEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fbGFzdEZhdGFsRXJyb3JUaW1lc3RhbXAgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fdXBkYXRlTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29uZmlnLl91cGRhdGVOdW1iZXI7XG4gICAgICAgIGNvbmZpZy5vdXRPZlN5bmMrKztcbiAgICAgICAgaWYgKGNvbmZpZy5fbGFzdEZhdGFsRXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArICh2YWx1ZS5tYXAoX25vcm1hbGl6ZSkpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKHZhbHVlLnRvSlNPTikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gX25vcm1hbGl6ZSh2YWx1ZS50b0pTT04oKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAga2V5cy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBrZXlzLm1hcCgoaykgPT4gYCR7SlNPTi5zdHJpbmdpZnkoayl9OiR7X25vcm1hbGl6ZSh2YWx1ZVtrXSl9YCkuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBzZXJpYWxpemVcIiwgdmFsdWUpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkhtbS4uLlwiKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc3VsdCh2YWx1ZSkge1xuICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBfbm9ybWFsaXplKGVycm9yKSwgdmFsdWU6IGVycm9yIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLnJlc3VsdDtcbiAgICByZXR1cm4geyB0YWc6IF9ub3JtYWxpemUocmVzdWx0KSwgdmFsdWU6IHJlc3VsdCB9O1xufVxuLy8gVGhpcyBzdHJhdGVneSBwaWNrcyB0aGUgaGlnaGVzdCB3ZWlnaHQgcmVzdWx0LCBhcyBsb25nIGFzIHRoZSB3ZWlnaHQgaXNcbi8vIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBxdW9ydW1cbmZ1bmN0aW9uIGNoZWNrUXVvcnVtKHF1b3J1bSwgcmVzdWx0cykge1xuICAgIGNvbnN0IHRhbGx5ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgdGFnLCB3ZWlnaHQgfSBvZiByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0YWxseS5nZXQodGFnKSB8fCB7IHZhbHVlLCB3ZWlnaHQ6IDAgfTtcbiAgICAgICAgdC53ZWlnaHQgKz0gd2VpZ2h0O1xuICAgICAgICB0YWxseS5zZXQodGFnLCB0KTtcbiAgICB9XG4gICAgbGV0IGJlc3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgciBvZiB0YWxseS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoci53ZWlnaHQgPj0gcXVvcnVtICYmICghYmVzdCB8fCByLndlaWdodCA+IGJlc3Qud2VpZ2h0KSkge1xuICAgICAgICAgICAgYmVzdCA9IHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3QpIHtcbiAgICAgICAgcmV0dXJuIGJlc3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRNZWRpYW4ocXVvcnVtLCByZXN1bHRzKSB7XG4gICAgbGV0IHJlc3VsdFdlaWdodCA9IDA7XG4gICAgY29uc3QgZXJyb3JNYXAgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGJlc3RFcnJvciA9IG51bGw7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChjb25zdCB7IHZhbHVlLCB0YWcsIHdlaWdodCB9IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcnJvck1hcC5nZXQodGFnKSB8fCB7IHZhbHVlLCB3ZWlnaHQ6IDAgfTtcbiAgICAgICAgICAgIGUud2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgICAgIGVycm9yTWFwLnNldCh0YWcsIGUpO1xuICAgICAgICAgICAgaWYgKGJlc3RFcnJvciA9PSBudWxsIHx8IGUud2VpZ2h0ID4gYmVzdEVycm9yLndlaWdodCkge1xuICAgICAgICAgICAgICAgIGJlc3RFcnJvciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChCaWdJbnQodmFsdWUpKTtcbiAgICAgICAgICAgIHJlc3VsdFdlaWdodCArPSB3ZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdFdlaWdodCA8IHF1b3J1bSkge1xuICAgICAgICAvLyBXZSBoYXZlIHF1b3J1bSBmb3IgYW4gZXJyb3JcbiAgICAgICAgaWYgKGJlc3RFcnJvciAmJiBiZXN0RXJyb3Iud2VpZ2h0ID49IHF1b3J1bSkge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RFcnJvci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkbyBub3QgaGF2ZSBxdW9ydW0gZm9yIGEgcmVzdWx0XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc29ydGVkIHZhbHVlc1xuICAgIHZhbHVlcy5zb3J0KChhLCBiKSA9PiAoKGEgPCBiKSA/IC0xIDogKGIgPiBhKSA/IDEgOiAwKSk7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgLy8gT2RkLWxlbmd0aDsgdGFrZSB0aGUgbWlkZGxlIHZhbHVlXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbbWlkXTtcbiAgICB9XG4gICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGNlaWxpbmcgb2YgdGhlIG1lYW4gb2YgdGhlIGNlbnRlciB0d28gdmFsdWVzXG4gICAgcmV0dXJuICh2YWx1ZXNbbWlkIC0gMV0gKyB2YWx1ZXNbbWlkXSArIEJOXzEpIC8gQk5fMjtcbn1cbmZ1bmN0aW9uIGdldEFueVJlc3VsdChxdW9ydW0sIHJlc3VsdHMpIHtcbiAgICAvLyBJZiBhbnkgdmFsdWUgb3IgZXJyb3IgbWVldHMgcXVvcnVtLCB0aGF0IGlzIG91ciBwcmVmZXJyZWQgcmVzdWx0XG4gICAgY29uc3QgcmVzdWx0ID0gY2hlY2tRdW9ydW0ocXVvcnVtLCByZXN1bHRzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBkbyB3ZSBoYXZlIGFueSByZXN1bHQ/XG4gICAgZm9yIChjb25zdCByIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHIudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vcGUhXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEZ1enp5TW9kZShxdW9ydW0sIHJlc3VsdHMpIHtcbiAgICBpZiAocXVvcnVtID09PSAxKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXROdW1iZXIpKGdldE1lZGlhbihxdW9ydW0sIHJlc3VsdHMpLCBcIiVpbnRlcm5hbFwiKTtcbiAgICB9XG4gICAgY29uc3QgdGFsbHkgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYWRkID0gKHJlc3VsdCwgd2VpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSB0YWxseS5nZXQocmVzdWx0KSB8fCB7IHJlc3VsdCwgd2VpZ2h0OiAwIH07XG4gICAgICAgIHQud2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgdGFsbHkuc2V0KHJlc3VsdCwgdCk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHsgd2VpZ2h0LCB2YWx1ZSB9IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgciA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikodmFsdWUpO1xuICAgICAgICBhZGQociAtIDEsIHdlaWdodCk7XG4gICAgICAgIGFkZChyLCB3ZWlnaHQpO1xuICAgICAgICBhZGQociArIDEsIHdlaWdodCk7XG4gICAgfVxuICAgIGxldCBiZXN0V2VpZ2h0ID0gMDtcbiAgICBsZXQgYmVzdFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IHsgd2VpZ2h0LCByZXN1bHQgfSBvZiB0YWxseS52YWx1ZXMoKSkge1xuICAgICAgICAvLyBVc2UgdGhpcyByZXN1bHQsIGlmIHRoaXMgcmVzdWx0IG1lZXRzIHF1b3J1bSBhbmQgaGFzIGVpdGhlcjpcbiAgICAgICAgLy8gLSBhIGJldHRlciB3ZWlnaHRcbiAgICAgICAgLy8gLSBvciBlcXVhbCB3ZWlnaHQsIGJ1dCB0aGUgcmVzdWx0IGlzIGxhcmdlclxuICAgICAgICBpZiAod2VpZ2h0ID49IHF1b3J1bSAmJiAod2VpZ2h0ID4gYmVzdFdlaWdodCB8fCAoYmVzdFJlc3VsdCAhPSBudWxsICYmIHdlaWdodCA9PT0gYmVzdFdlaWdodCAmJiByZXN1bHQgPiBiZXN0UmVzdWx0KSkpIHtcbiAgICAgICAgICAgIGJlc3RXZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICAgICAgICBiZXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0UmVzdWx0O1xufVxuLyoqXG4gKiAgQSAqKkZhbGxiYWNrUHJvdmlkZXIqKiBtYW5hZ2VzIHNldmVyYWwgW1tQcm92aWRlcnNdXSBwcm92aWRpbmdcbiAqICByZXNpbGlhbmNlIGJ5IHN3aXRjaGluZyBiZXR3ZWVuIHNsb3cgb3IgbWlzYmVoYXZpbmcgbm9kZXMsIHNlY3VyaXR5XG4gKiAgYnkgcmVxdWlyaW5nIG11bHRpcGxlIGJhY2tlbmRzIHRvIGFnZ3JlZSBhbmQgcGVyZm9ybWFuY2UgYnkgYWxsb3dpbmdcbiAqICBmYXN0ZXIgYmFja2VuZHMgdG8gcmVzcG9uZCBlYXJsaWVyLlxuICpcbiAqL1xuY2xhc3MgRmFsbGJhY2tQcm92aWRlciBleHRlbmRzIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuQWJzdHJhY3RQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgYmFja2VuZHMgdGhhdCBtdXN0IGFncmVlIG9uIGEgdmFsdWUgYmVmb3JlIGl0IGlzXG4gICAgICogIGFjY3BldGVkLlxuICAgICAqL1xuICAgIHF1b3J1bTtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZXZlbnRRdW9ydW07XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGV2ZW50V29ya2VycztcbiAgICAjY29uZmlncztcbiAgICAjaGVpZ2h0O1xuICAgICNpbml0aWFsU3luY1Byb21pc2U7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGYWxsYmFja1Byb3ZpZGVyKiogd2l0aCAlJXByb3ZpZGVycyUlIGNvbm5lY3RlZCB0b1xuICAgICAqICAlJW5ldHdvcmslJS5cbiAgICAgKlxuICAgICAqICBJZiBhIFtbUHJvdmlkZXJdXSBpcyBpbmNsdWRlZCBpbiAlJXByb3ZpZGVycyUlLCBkZWZhdWx0cyBhcmUgdXNlZFxuICAgICAqICBmb3IgdGhlIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJzLCBuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNjb25maWdzID0gcHJvdmlkZXJzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBhYnN0cmFjdF9wcm92aWRlcl9qc18xLkFic3RyYWN0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHByb3ZpZGVyOiBwIH0sIGRlZmF1bHRDb25maWcsIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgcCwgZGVmYXVsdFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2hlaWdodCA9IC0yO1xuICAgICAgICB0aGlzLiNpbml0aWFsU3luY1Byb21pc2UgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5xdW9ydW0gPSBNYXRoLmNlaWwodGhpcy4jY29uZmlncy5yZWR1Y2UoKGFjY3VtLCBjb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bSArPSBjb25maWcud2VpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIDApIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1b3J1bSA9IDE7XG4gICAgICAgIHRoaXMuZXZlbnRXb3JrZXJzID0gMTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKHRoaXMucXVvcnVtIDw9IHRoaXMuI2NvbmZpZ3MucmVkdWNlKChhLCBjKSA9PiAoYSArIGMud2VpZ2h0KSwgMCksIFwicXVvcnVtIGV4Y2VlZCBwcm92aWRlciB3aWVnaHRcIiwgXCJxdW9ydW1cIiwgdGhpcy5xdW9ydW0pO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXJDb25maWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29uZmlncy5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oKDAsIGluZGV4X2pzXzEuZ2V0QmlnSW50KShhd2FpdCB0aGlzLl9wZXJmb3JtKHsgbWV0aG9kOiBcImNoYWluSWRcIiB9KSkpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogQWRkIHN1cHBvcnQgdG8gc2VsZWN0IHByb3ZpZGVycyB0byBiZSB0aGUgZXZlbnQgc3Vic2NyaWJlclxuICAgIC8vX2dldFN1YnNjcmliZXIoc3ViOiBTdWJzY3JpcHRpb24pOiBTdWJzY3JpYmVyIHtcbiAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoXCJAVE9ET1wiKTtcbiAgICAvL31cbiAgICAvKipcbiAgICAgKiAgVHJhbnNmb3JtcyBhICUlcmVxJSUgaW50byB0aGUgY29ycmVjdCBtZXRob2QgY2FsbCBvbiAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgYXN5bmMgX3RyYW5zbGF0ZVBlcmZvcm0ocHJvdmlkZXIsIHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5icm9hZGNhc3RUcmFuc2FjdGlvbihyZXEuc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuY2FsbChPYmplY3QuYXNzaWduKHt9LCByZXEudHJhbnNhY3Rpb24sIHsgYmxvY2tUYWc6IHJlcS5ibG9ja1RhZyB9KSk7XG4gICAgICAgICAgICBjYXNlIFwiY2hhaW5JZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJvdmlkZXIuZ2V0TmV0d29yaygpKS5jaGFpbklkO1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmVzdGltYXRlR2FzKHJlcS50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IChcImJsb2NrSGFzaFwiIGluIHJlcSkgPyByZXEuYmxvY2tIYXNoIDogcmVxLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCbG9jayhibG9jaywgcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRDb2RlKHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcm92aWRlci5nZXRGZWVEYXRhKCkpLmdhc1ByaWNlO1xuICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuZ2V0TG9ncyhyZXEuZmlsdGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFN0b3JhZ2UocmVxLmFkZHJlc3MsIHJlcS5wb3NpdGlvbiwgcmVxLmJsb2NrVGFnKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvbihyZXEuaGFzaCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHJlcS5hZGRyZXNzLCByZXEuYmxvY2tUYWcpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQocmVxLmhhc2gpO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVzdWx0KHJlcS5oYXNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHcmFiIHRoZSBuZXh0IChyYW5kb20pIGNvbmZpZyB0aGF0IGlzIG5vdCBhbHJlYWR5IHBhcnQgb2ZcbiAgICAvLyB0aGUgcnVubmluZyBzZXRcbiAgICAjZ2V0TmV4dENvbmZpZyhydW5uaW5nKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNYXliZSBkbyBhIGNoZWNrIGhlcmUgdG8gZmF2b3VyIChoZWF2aWx5KSBwcm92aWRlcnMgdGhhdFxuICAgICAgICAvLyAgICAgICAgZG8gbm90IHJlcXVpcmUgd2FpdEZvclN5bmMgYW5kIGRpc2Zhdm91ciBwcm92aWRlcnMgdGhhdFxuICAgICAgICAvLyAgICAgICAgc2VlbSBkb3duLWlzaCBvciBhcmUgYmVoYXZpbmcgc2xvd2x5XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBBcnJheS5mcm9tKHJ1bm5pbmcpLm1hcCgocikgPT4gci5jb25maWcpO1xuICAgICAgICAvLyBTaHVmZmxlIHRoZSBzdGF0ZXMsIHNvcnRlZCBieSBwcmlvcml0eVxuICAgICAgICBjb25zdCBhbGxDb25maWdzID0gdGhpcy4jY29uZmlncy5zbGljZSgpO1xuICAgICAgICBzaHVmZmxlKGFsbENvbmZpZ3MpO1xuICAgICAgICBhbGxDb25maWdzLnNvcnQoKGEsIGIpID0+IChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBhbGxDb25maWdzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl9sYXN0RmF0YWxFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZ3MuaW5kZXhPZihjb25maWcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEFkZHMgYSBuZXcgcnVubmVyIChpZiBhdmFpbGFibGUpIHRvIHJ1bm5pbmcuXG4gICAgI2FkZFJ1bm5lcihydW5uaW5nLCByZXEpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy4jZ2V0TmV4dENvbmZpZyhydW5uaW5nKTtcbiAgICAgICAgLy8gTm8gcnVubmVycyBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcnVubmVyXG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IHtcbiAgICAgICAgICAgIGNvbmZpZywgcmVzdWx0OiBudWxsLCBkaWRCdW1wOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcmZvcm06IG51bGwsIHN0YWxsZXI6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFydCBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uXG4gICAgICAgIHJ1bm5lci5wZXJmb3JtID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnJlcXVlc3RzKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fdHJhbnNsYXRlUGVyZm9ybShjb25maWcucHJvdmlkZXIsIHJlcSk7XG4gICAgICAgICAgICAgICAgcnVubmVyLnJlc3VsdCA9IHsgcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZXJyb3JSZXNwb25zZXMrKztcbiAgICAgICAgICAgICAgICBydW5uZXIucmVzdWx0ID0geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHQgPSAoZ2V0VGltZSgpIC0gbm93KTtcbiAgICAgICAgICAgIGNvbmZpZy5fdG90YWxUaW1lICs9IGR0O1xuICAgICAgICAgICAgY29uZmlnLnJvbGxpbmdEdXJhdGlvbiA9IDAuOTUgKiBjb25maWcucm9sbGluZ0R1cmF0aW9uICsgMC4wNSAqIGR0O1xuICAgICAgICAgICAgcnVubmVyLnBlcmZvcm0gPSBudWxsO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBTdGFydCBhIHN0YWxsZXI7IHdoZW4gdGhpcyB0aW1lcyBvdXQsIGl0J3MgdGltZSB0byBmb3JjZVxuICAgICAgICAvLyBraWNraW5nIG9mZiBhbm90aGVyIHJ1bm5lciBiZWNhdXNlIHdlIGFyZSB0YWtpbmcgdG9vIGxvbmdcbiAgICAgICAgcnVubmVyLnN0YWxsZXIgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgc3RhbGwoY29uZmlnLnN0YWxsVGltZW91dCk7XG4gICAgICAgICAgICBydW5uZXIuc3RhbGxlciA9IG51bGw7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJ1bm5pbmcuYWRkKHJ1bm5lcik7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemVzIHRoZSBibG9ja051bWJlciBhbmQgbmV0d29yayBmb3IgZWFjaCBydW5uZXIgYW5kXG4gICAgLy8gYmxvY2tzIHVudGlsIGluaXRpYWxpemVkXG4gICAgYXN5bmMgI2luaXRpYWxTeW5jKCkge1xuICAgICAgICBsZXQgaW5pdGlhbFN5bmMgPSB0aGlzLiNpbml0aWFsU3luY1Byb21pc2U7XG4gICAgICAgIGlmICghaW5pdGlhbFN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICB0aGlzLiNjb25maWdzLmZvckVhY2goKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd2FpdEZvclN5bmMoY29uZmlnLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuX25ldHdvcmsgPSBhd2FpdCBjb25maWcucHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxTeW5jUHJvbWlzZSA9IGluaXRpYWxTeW5jID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBhbGwgcHJvdmlkZXJzIHRvIGhhdmUgYSBibG9jayBudW1iZXIgYW5kIG5ldHdvcmtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIHRoZSBuZXR3b3JrcyBtYXRjaFxuICAgICAgICAgICAgICAgIGxldCBjaGFpbklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiB0aGlzLiNjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuX2xhc3RGYXRhbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gKGNvbmZpZy5fbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV0d29yay5jaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcImNhbm5vdCBtaXggcHJvdmlkZXJzIG9uIGRpZmZlcmVudCBuZXR3b3Jrc1wiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGYWxsYmFja1Byb3ZpZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBpbml0aWFsU3luYztcbiAgICB9XG4gICAgYXN5bmMgI2NoZWNrUXVvcnVtKHJ1bm5pbmcsIHJlcSkge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSByZXN1bHQgb2JqZWN0c1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcnVubmVyIG9mIHJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGlmIChydW5uZXIucmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhZywgdmFsdWUgfSA9IG5vcm1hbGl6ZVJlc3VsdChydW5uZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyB0YWcsIHZhbHVlLCB3ZWlnaHQ6IHJ1bm5lci5jb25maWcud2VpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFyZSB0aGVyZSBlbm91Z2ggcmVzdWx0cyB0byBldmVudCBtZWV0IHF1b3J1bT9cbiAgICAgICAgaWYgKHJlc3VsdHMucmVkdWNlKChhLCByKSA9PiAoYSArIHIud2VpZ2h0KSwgMCkgPCB0aGlzLnF1b3J1bSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgdGhlIGJvb3RzdHJhcCBibG9jayBoZWlnaHRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGVpZ2h0ID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWlnaHQgPSBNYXRoLmNlaWwoKDAsIGluZGV4X2pzXzEuZ2V0TnVtYmVyKShnZXRNZWRpYW4odGhpcy5xdW9ydW0sIHRoaXMuI2NvbmZpZ3MuZmlsdGVyKChjKSA9PiAoIWMuX2xhc3RGYXRhbEVycm9yKSkubWFwKChjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGMuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikoYy5ibG9ja051bWJlcikudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodDogYy53ZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSkpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtb2RlIGFjcm9zcyBhbGwgdGhlIHByb3ZpZGVycywgYWxsb3dpbmcgZm9yXG4gICAgICAgICAgICAgICAgLy8gYSBsaXR0bGUgZHJpZnQgYmV0d2VlbiBibG9jayBoZWlnaHRzXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZSA9IGdldEZ1enp5TW9kZSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZSA+IHRoaXMuI2hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWlnaHQgPSBtb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVkaWFuKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgYmxvY2tzIGFyZSBpbiB0aGUgbWVtcG9vbCBhbmQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHF1aXRlIHVudHJ1c3R3b3J0aHk7IGp1c3QgZ3JhYiBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxICYmIHJlcS5ibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEFueVJlc3VsdCh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1F1b3J1bSh0aGlzLnF1b3J1bSwgcmVzdWx0cyk7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFwiOlxuICAgICAgICAgICAgY2FzZSBcImNoYWluSWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUXVvcnVtKHRoaXMucXVvcnVtLCByZXN1bHRzKTtcbiAgICAgICAgICAgIGNhc2UgXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbnlSZXN1bHQodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYF9wZXJmb3JtKCR7c3RyaW5naWZ5KHJlcS5tZXRob2QpfSlgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyAjd2FpdEZvclF1b3J1bShydW5uaW5nLCByZXEpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmcuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gcnVubmVycz8hXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFueSBwcm9taXNlcyB0aGF0IGFyZSBpbnRlcmVzdGluZyB0byB3YXRjaCBmb3I7IGFuIGV4cGlyZWQgc3RhbGxcbiAgICAgICAgLy8gb3IgYSBzdWNjZXNzZnVsIHBlcmZvcm1cbiAgICAgICAgY29uc3QgaW50ZXJlc3RpbmcgPSBbXTtcbiAgICAgICAgbGV0IG5ld1J1bm5lcnMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5lciBvZiBydW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBObyByZXNwb25zZXMsIHlldDsga2VlcCBhbiBleWUgb24gaXRcbiAgICAgICAgICAgIGlmIChydW5uZXIucGVyZm9ybSkge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnBlcmZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RpbGwgc3RhbGxpbmcuLi5cbiAgICAgICAgICAgIGlmIChydW5uZXIuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgIGludGVyZXN0aW5nLnB1c2gocnVubmVyLnN0YWxsZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBydW5uZXIgaGFzIGFscmVhZHkgdHJpZ2dlcmVkIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBpZiAocnVubmVyLmRpZEJ1bXApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdvdCBhIHJlc3BvbnNlIChyZXN1bHQgb3IgZXJyb3IpIG9yIHN0YWxsZWQ7IGtpY2sgb2ZmIGFub3RoZXIgcnVubmVyXG4gICAgICAgICAgICBydW5uZXIuZGlkQnVtcCA9IHRydWU7XG4gICAgICAgICAgICBuZXdSdW5uZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIHF1b3J1bSBvbiBhIHJlc3VsdCAob3IgZXJyb3IpXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy4jY2hlY2tRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFueSBuZXcgcnVubmVycywgYmVjYXVzZSBhIHN0YWxsZXIgdGltZWQgb3V0IG9yIGEgcmVzdWx0XG4gICAgICAgIC8vIG9yIGVycm9yIHJlc3BvbnNlIGNhbWUgaW4uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3UnVubmVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLiNhZGRSdW5uZXIocnVubmluZywgcmVxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgcHJvdmlkZXJzIGhhdmUgcmV0dXJuZWQsIGFuZCB3ZSBoYXZlIG5vIHJlc3VsdFxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGludGVyZXN0aW5nLmxlbmd0aCA+IDAsIFwicXVvcnVtIG5vdCBtZXRcIiwgXCJTRVJWRVJfRVJST1JcIiwge1xuICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBpbmZvOiB7IHJlcXVlc3Q6IHJlcSwgcmVzdWx0czogQXJyYXkuZnJvbShydW5uaW5nKS5tYXAoKHIpID0+IHN0cmluZ2lmeShyLnJlc3VsdCkpIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHNvbWVvbmUgdG8gZWl0aGVyIGNvbXBsZXRlIGl0cyBwZXJmb3JtIG9yIHN0YWxsIG91dFxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoaW50ZXJlc3RpbmcpO1xuICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZSwgYnV0IGF0IHdvcnN0IGNhc2UgdGhlIGRlcHRoIGlzIDJ4IHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcHJvdmlkZXJzIChlYWNoIGhhcyBhIHBlcmZvcm0gYW5kIGEgc3RhbGxlcilcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIEJyb2FkY2FzdGluZyBhIHRyYW5zYWN0aW9uIGlzIHJhcmUgKGlzaCkgYW5kIGFscmVhZHkgaW5jdXJzXG4gICAgICAgIC8vIGEgY29zdCBvbiB0aGUgdXNlciwgc28gc3BhbW1pbmcgaXMgc2FmZS1pc2guIEp1c3Qgc2VuZCBpdCB0b1xuICAgICAgICAvLyBldmVyeSBiYWNrZW5kLlxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJicm9hZGNhc3RUcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy4jY29uZmlncy5tYXAoYXN5bmMgKHsgcHJvdmlkZXIsIHdlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuX3BlcmZvcm0ocmVxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obm9ybWFsaXplUmVzdWx0KHsgcmVzdWx0IH0pLCB7IHdlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZVJlc3VsdCh7IGVycm9yIH0pLCB7IHdlaWdodCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRBbnlSZXN1bHQodGhpcy5xdW9ydW0sIHJlc3VsdHMpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KShyZXN1bHQgIT09IHVuZGVmaW5lZCwgXCJwcm9ibGVtIG11bHRpLWJyb2FkY2FzdGluZ1wiLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogXCIlc3ViLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyByZXF1ZXN0OiByZXEsIHJlc3VsdHM6IHJlc3VsdHMubWFwKHN0cmluZ2lmeSkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI2luaXRpYWxTeW5jKCk7XG4gICAgICAgIC8vIEJvb3RzdHJhcCBlbm91Z2ggcnVubmVycyB0byBtZWV0IHF1b3J1bVxuICAgICAgICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucXVvcnVtOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuI2FkZFJ1bm5lcihydW5uaW5nLCByZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3dhaXRGb3JRdW9ydW0ocnVubmluZywgcmVxKTtcbiAgICAgICAgLy8gVHJhY2sgcmVxdWVzdHMgc2VudCB0byBhIHByb3ZpZGVyIHRoYXQgYXJlIHN0aWxsXG4gICAgICAgIC8vIG91dHN0YW5kaW5nIGFmdGVyIHF1b3J1bSBoYXMgYmVlbiBvdGhlcndpc2UgZm91bmRcbiAgICAgICAgZm9yIChjb25zdCBydW5uZXIgb2YgcnVubmluZykge1xuICAgICAgICAgICAgaWYgKHJ1bm5lci5wZXJmb3JtICYmIHJ1bm5lci5yZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5jb25maWcubGF0ZVJlc3BvbnNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBwcm92aWRlciB9IG9mIHRoaXMuI2NvbmZpZ3MpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gRmFsbGJhY2tQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWZhbGxiYWNrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZhbGxiYWNrUHJvdmlkZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImFic3RyYWN0X3Byb3ZpZGVyX2pzXzEiLCJuZXR3b3JrX2pzXzEiLCJCTl8xIiwiQmlnSW50IiwiQk5fMiIsInNodWZmbGUiLCJhcnJheSIsImkiLCJsZW5ndGgiLCJqIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG1wIiwic3RhbGwiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldFRpbWUiLCJEYXRlIiwic3RyaW5naWZ5IiwiSlNPTiIsImtleSIsInR5cGUiLCJ0b1N0cmluZyIsImRlZmF1bHRDb25maWciLCJzdGFsbFRpbWVvdXQiLCJwcmlvcml0eSIsIndlaWdodCIsImRlZmF1bHRTdGF0ZSIsImJsb2NrTnVtYmVyIiwicmVxdWVzdHMiLCJsYXRlUmVzcG9uc2VzIiwiZXJyb3JSZXNwb25zZXMiLCJvdXRPZlN5bmMiLCJ1bnN1cHBvcnRlZEV2ZW50cyIsInJvbGxpbmdEdXJhdGlvbiIsInNjb3JlIiwiX25ldHdvcmsiLCJfdXBkYXRlTnVtYmVyIiwiX3RvdGFsVGltZSIsIl9sYXN0RmF0YWxFcnJvciIsIl9sYXN0RmF0YWxFcnJvclRpbWVzdGFtcCIsIndhaXRGb3JTeW5jIiwiY29uZmlnIiwicHJvdmlkZXIiLCJnZXRCbG9ja051bWJlciIsImVycm9yIiwiX25vcm1hbGl6ZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImpvaW4iLCJ0b0pTT04iLCJrZXlzIiwic29ydCIsImsiLCJjb25zb2xlIiwibG9nIiwiRXJyb3IiLCJub3JtYWxpemVSZXN1bHQiLCJ0YWciLCJyZXN1bHQiLCJjaGVja1F1b3J1bSIsInF1b3J1bSIsInJlc3VsdHMiLCJ0YWxseSIsIk1hcCIsInQiLCJnZXQiLCJzZXQiLCJiZXN0IiwiciIsInZhbHVlcyIsInVuZGVmaW5lZCIsImdldE1lZGlhbiIsInJlc3VsdFdlaWdodCIsImVycm9yTWFwIiwiYmVzdEVycm9yIiwiZSIsInB1c2giLCJhIiwiYiIsIm1pZCIsImdldEFueVJlc3VsdCIsImdldEZ1enp5TW9kZSIsImdldE51bWJlciIsImFkZCIsImJlc3RXZWlnaHQiLCJiZXN0UmVzdWx0IiwiQWJzdHJhY3RQcm92aWRlciIsImNvbmZpZ3MiLCJoZWlnaHQiLCJpbml0aWFsU3luY1Byb21pc2UiLCJjb25zdHJ1Y3RvciIsInByb3ZpZGVycyIsIm5ldHdvcmsiLCJvcHRpb25zIiwicCIsImFzc2lnbiIsImNlaWwiLCJyZWR1Y2UiLCJhY2N1bSIsImV2ZW50UXVvcnVtIiwiZXZlbnRXb3JrZXJzIiwiYXNzZXJ0QXJndW1lbnQiLCJjIiwicHJvdmlkZXJDb25maWdzIiwiX2RldGVjdE5ldHdvcmsiLCJOZXR3b3JrIiwiZnJvbSIsImdldEJpZ0ludCIsIl9wZXJmb3JtIiwibWV0aG9kIiwiX3RyYW5zbGF0ZVBlcmZvcm0iLCJyZXEiLCJicm9hZGNhc3RUcmFuc2FjdGlvbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwiY2FsbCIsInRyYW5zYWN0aW9uIiwiYmxvY2tUYWciLCJnZXROZXR3b3JrIiwiY2hhaW5JZCIsImVzdGltYXRlR2FzIiwiZ2V0QmFsYW5jZSIsImFkZHJlc3MiLCJibG9jayIsImJsb2NrSGFzaCIsImdldEJsb2NrIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImdldENvZGUiLCJnZXRGZWVEYXRhIiwiZ2FzUHJpY2UiLCJnZXRMb2dzIiwiZmlsdGVyIiwiZ2V0U3RvcmFnZSIsInBvc2l0aW9uIiwiZ2V0VHJhbnNhY3Rpb24iLCJoYXNoIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImdldFRyYW5zYWN0aW9uUmVzdWx0IiwiZ2V0TmV4dENvbmZpZyIsInJ1bm5pbmciLCJhbGxDb25maWdzIiwic2xpY2UiLCJpbmRleE9mIiwiYWRkUnVubmVyIiwicnVubmVyIiwiZGlkQnVtcCIsInBlcmZvcm0iLCJzdGFsbGVyIiwibm93IiwiZHQiLCJpbml0aWFsU3luYyIsInByb21pc2VzIiwiZm9yRWFjaCIsImFsbCIsImFzc2VydCIsIm9wZXJhdGlvbiIsIm1vZGUiLCJ3YWl0Rm9yUXVvcnVtIiwic2l6ZSIsImludGVyZXN0aW5nIiwibmV3UnVubmVycyIsInJlcXVlc3QiLCJpbmZvIiwicmFjZSIsIlNldCIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-fallback.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-infura.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;\n/**\n *  [[link-infura]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Sepolia Testnet (``sepolia``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]\n */ const index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst provider_websocket_js_1 = __webpack_require__(/*! ./provider-websocket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\");\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nfunction getHost(name) {\n    switch(name){\n        case \"mainnet\":\n            return \"mainnet.infura.io\";\n        case \"goerli\":\n            return \"goerli.infura.io\";\n        case \"sepolia\":\n            return \"sepolia.infura.io\";\n        case \"arbitrum\":\n            return \"arbitrum-mainnet.infura.io\";\n        case \"arbitrum-goerli\":\n            return \"arbitrum-goerli.infura.io\";\n        case \"linea\":\n            return \"linea-mainnet.infura.io\";\n        case \"linea-goerli\":\n            return \"linea-goerli.infura.io\";\n        case \"matic\":\n            return \"polygon-mainnet.infura.io\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai.infura.io\";\n        case \"optimism\":\n            return \"optimism-mainnet.infura.io\";\n        case \"optimism-goerli\":\n            return \"optimism-goerli.infura.io\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **InfuraWebSocketProvider** connects to the [[link-infura]]\n *  WebSocket end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */ class InfuraWebSocketProvider extends provider_websocket_js_1.WebSocketProvider {\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */ constructor(network, projectId){\n        const provider = new InfuraProvider(network, projectId);\n        const req = provider._getConnection();\n        (0, index_js_1.assert)(!req.credentials, \"INFURA WebSocket project secrets unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"InfuraProvider.getWebSocketProvider()\"\n        });\n        const url = req.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        (0, index_js_1.defineProperties)(this, {\n            projectId: provider.projectId,\n            projectSecret: provider.projectSecret\n        });\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n}\nexports.InfuraWebSocketProvider = InfuraWebSocketProvider;\n/**\n *  The **InfuraProvider** connects to the [[link-infura]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-infura-signup).\n */ class InfuraProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  Creates a new **InfuraProvider**.\n     */ constructor(_network, projectId, projectSecret){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = InfuraProvider.getRequest(network, projectId, projectSecret);\n        super(request, network, {\n            staticNetwork: network\n        });\n        (0, index_js_1.defineProperties)(this, {\n            projectId,\n            projectSecret\n        });\n    }\n    _getProvider(chainId) {\n        try {\n            return new InfuraProvider(chainId, this.projectId, this.projectSecret);\n        } catch (error) {}\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n    /**\n     *  Creates a new **InfuraWebSocketProvider**.\n     */ static getWebSocketProvider(network, projectId) {\n        return new InfuraWebSocketProvider(network, projectId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%%\n     *  with %%projectId%% and %%projectSecret%%.\n     */ static getRequest(network, projectId, projectSecret) {\n        if (projectId == null) {\n            projectId = defaultProjectId;\n        }\n        if (projectSecret == null) {\n            projectSecret = null;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v3/${projectId}`);\n        request.allowGzip = true;\n        if (projectSecret) {\n            request.setCredentials(\"\", projectSecret);\n        }\n        if (projectId === defaultProjectId) {\n            request.retryFunc = async (request, response, attempt)=>{\n                (0, community_js_1.showThrottleMessage)(\"InfuraProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.InfuraProvider = InfuraProvider; //# sourceMappingURL=provider-infura.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaW5mdXJhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsK0JBQStCLEdBQUcsS0FBSztBQUNoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMsaUJBQWlCRCxtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDL0MsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsbUZBQWM7QUFDM0MsTUFBTUcsd0JBQXdCSCxtQkFBT0EsQ0FBQyxxR0FBdUI7QUFDN0QsTUFBTUksMEJBQTBCSixtQkFBT0EsQ0FBQyx5R0FBeUI7QUFDakUsTUFBTUssbUJBQW1CO0FBQ3pCLFNBQVNDLFFBQVFDLElBQUk7SUFDakIsT0FBUUE7UUFDSixLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO0lBQ2Y7SUFDQyxJQUFHUixXQUFXUyxjQUFjLEVBQUUsT0FBTyx1QkFBdUIsV0FBV0Q7QUFDNUU7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1ULGdDQUFnQ00sd0JBQXdCSyxpQkFBaUI7SUFZM0U7O0tBRUMsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxTQUFTLENBQUU7UUFDNUIsTUFBTUMsV0FBVyxJQUFJaEIsZUFBZWMsU0FBU0M7UUFDN0MsTUFBTUUsTUFBTUQsU0FBU0UsY0FBYztRQUNsQyxJQUFHaEIsV0FBV2lCLE1BQU0sRUFBRSxDQUFDRixJQUFJRyxXQUFXLEVBQUUsZ0RBQWdELHlCQUF5QjtZQUFFQyxXQUFXO1FBQXdDO1FBQ3ZLLE1BQU1DLE1BQU1MLElBQUlLLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLFVBQVUsTUFBTUEsT0FBTyxDQUFDLFFBQVE7UUFDNUQsS0FBSyxDQUFDRCxLQUFLUjtRQUNWLElBQUdaLFdBQVdzQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFDbkNULFdBQVdDLFNBQVNELFNBQVM7WUFDN0JVLGVBQWVULFNBQVNTLGFBQWE7UUFDekM7SUFDSjtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNYLFNBQVMsS0FBS1A7SUFDL0I7QUFDSjtBQUNBViwrQkFBK0IsR0FBR0c7QUFDbEM7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNRCx1QkFBdUJNLHNCQUFzQnFCLGVBQWU7SUFZOUQ7O0tBRUMsR0FDRGQsWUFBWWUsUUFBUSxFQUFFYixTQUFTLEVBQUVVLGFBQWEsQ0FBRTtRQUM1QyxJQUFJRyxZQUFZLE1BQU07WUFDbEJBLFdBQVc7UUFDZjtRQUNBLE1BQU1kLFVBQVVULGFBQWF3QixPQUFPLENBQUNDLElBQUksQ0FBQ0Y7UUFDMUMsSUFBSWIsYUFBYSxNQUFNO1lBQ25CQSxZQUFZUDtRQUNoQjtRQUNBLElBQUlpQixpQkFBaUIsTUFBTTtZQUN2QkEsZ0JBQWdCO1FBQ3BCO1FBQ0EsTUFBTU0sVUFBVS9CLGVBQWVnQyxVQUFVLENBQUNsQixTQUFTQyxXQUFXVTtRQUM5RCxLQUFLLENBQUNNLFNBQVNqQixTQUFTO1lBQUVtQixlQUFlbkI7UUFBUTtRQUNoRCxJQUFHWixXQUFXc0IsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQUVUO1lBQVdVO1FBQWM7SUFDdEU7SUFDQVMsYUFBYUMsT0FBTyxFQUFFO1FBQ2xCLElBQUk7WUFDQSxPQUFPLElBQUluQyxlQUFlbUMsU0FBUyxJQUFJLENBQUNwQixTQUFTLEVBQUUsSUFBSSxDQUFDVSxhQUFhO1FBQ3pFLEVBQ0EsT0FBT1csT0FBTyxDQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDRixhQUFhQztJQUM5QjtJQUNBVCxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNYLFNBQVMsS0FBS1A7SUFDL0I7SUFDQTs7S0FFQyxHQUNELE9BQU82QixxQkFBcUJ2QixPQUFPLEVBQUVDLFNBQVMsRUFBRTtRQUM1QyxPQUFPLElBQUlkLHdCQUF3QmEsU0FBU0M7SUFDaEQ7SUFDQTs7O0tBR0MsR0FDRCxPQUFPaUIsV0FBV2xCLE9BQU8sRUFBRUMsU0FBUyxFQUFFVSxhQUFhLEVBQUU7UUFDakQsSUFBSVYsYUFBYSxNQUFNO1lBQ25CQSxZQUFZUDtRQUNoQjtRQUNBLElBQUlpQixpQkFBaUIsTUFBTTtZQUN2QkEsZ0JBQWdCO1FBQ3BCO1FBQ0EsTUFBTU0sVUFBVSxJQUFJN0IsV0FBV29DLFlBQVksQ0FBQyxDQUFDLFNBQVMsRUFBRTdCLFFBQVFLLFFBQVFKLElBQUksRUFBRSxJQUFJLEVBQUVLLFVBQVUsQ0FBQztRQUMvRmdCLFFBQVFRLFNBQVMsR0FBRztRQUNwQixJQUFJZCxlQUFlO1lBQ2ZNLFFBQVFTLGNBQWMsQ0FBQyxJQUFJZjtRQUMvQjtRQUNBLElBQUlWLGNBQWNQLGtCQUFrQjtZQUNoQ3VCLFFBQVFVLFNBQVMsR0FBRyxPQUFPVixTQUFTVyxVQUFVQztnQkFDekMsSUFBR3ZDLGVBQWV3QyxtQkFBbUIsRUFBRTtnQkFDeEMsT0FBTztZQUNYO1FBQ0o7UUFDQSxPQUFPYjtJQUNYO0FBQ0o7QUFDQWpDLHNCQUFzQixHQUFHRSxnQkFDekIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLWluZnVyYS5qcz8zMTU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmZ1cmFQcm92aWRlciA9IGV4cG9ydHMuSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG4vKipcbiAqICBbW2xpbmstaW5mdXJhXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIEpTT04tUlBDLlxuICpcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXG4gKlxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcbiAqICAtIFNlcG9saWEgVGVzdG5ldCAoYGBzZXBvbGlhYGApXG4gKiAgLSBBcmJpdHJ1bSAoYGBhcmJpdHJ1bWBgKVxuICogIC0gQXJiaXRydW0gR29lcmxpIFRlc3RuZXQgKGBgYXJiaXRydW0tZ29lcmxpYGApXG4gKiAgLSBPcHRpbWlzbSAoYGBvcHRpbWlzbWBgKVxuICogIC0gT3B0aW1pc20gR29lcmxpIFRlc3RuZXQgKGBgb3B0aW1pc20tZ29lcmxpYGApXG4gKiAgLSBQb2x5Z29uIChgYG1hdGljYGApXG4gKiAgLSBQb2x5Z29uIE11bWJhaSBUZXN0bmV0IChgYG1hdGljLW11bWJhaWBgKVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvdGhpcmRwYXJ0eTpJTkZVUkEgIFtwcm92aWRlcnMtaW5mdXJhXVxuICovXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX3dlYnNvY2tldF9qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItd2Vic29ja2V0LmpzXCIpO1xuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcbmZ1bmN0aW9uIGdldEhvc3QobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwic2Vwb2xpYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwic2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJhcmJpdHJ1bS1nb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJsaW5lYVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibGluZWEtbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImxpbmVhLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibGluZWEtZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInBvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWkuaW5mdXJhLmlvXCI7XG4gICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc20tZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmFtZSk7XG59XG4vKipcbiAqICBUaGUgKipJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstaW5mdXJhXV1cbiAqICBXZWJTb2NrZXQgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSBrZXkgaXMgdXNlZCwgd2hpY2ggaXNcbiAqICBhcHByb3ByaWF0ZSBmb3IgcXVpY2sgcHJvdG90eXBlcyBhbmQgc2ltcGxlIHNjcmlwdHMuIFRvXG4gKiAgZ2FpbiBhY2Nlc3MgdG8gYW4gaW5jcmVhc2VkIHJhdGUtbGltaXQsIGl0IGlzIGhpZ2hseVxuICogIHJlY29tbWVuZGVkIHRvIFtzaWduIHVwIGhlcmVdKGxpbmstaW5mdXJhLXNpZ251cCkuXG4gKi9cbmNsYXNzIEluZnVyYVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfd2Vic29ja2V0X2pzXzEuV2ViU29ja2V0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgUHJvamVjdCBJRCBmb3IgdGhlIElORlVSQSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHByb2plY3RJZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgU2VjcmV0LlxuICAgICAqXG4gICAgICogIElmIG51bGwsIG5vIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdHMgYXJlIG1hZGUuIFRoaXMgc2hvdWxkIG5vdFxuICAgICAqICBiZSB1c2VkIG91dHNpZGUgb2YgcHJpdmF0ZSBjb250ZXh0cy5cbiAgICAgKi9cbiAgICBwcm9qZWN0U2VjcmV0O1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBwcm9qZWN0SWQpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgcHJvamVjdElkKTtcbiAgICAgICAgY29uc3QgcmVxID0gcHJvdmlkZXIuX2dldENvbm5lY3Rpb24oKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSghcmVxLmNyZWRlbnRpYWxzLCBcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIiB9KTtcbiAgICAgICAgY29uc3QgdXJsID0gcmVxLnVybC5yZXBsYWNlKC9eaHR0cC9pLCBcIndzXCIpLnJlcGxhY2UoXCIvdjMvXCIsIFwiL3dzL3YzL1wiKTtcbiAgICAgICAgc3VwZXIodXJsLCBuZXR3b3JrKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywge1xuICAgICAgICAgICAgcHJvamVjdElkOiBwcm92aWRlci5wcm9qZWN0SWQsXG4gICAgICAgICAgICBwcm9qZWN0U2VjcmV0OiBwcm92aWRlci5wcm9qZWN0U2VjcmV0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9XG59XG5leHBvcnRzLkluZnVyYVdlYlNvY2tldFByb3ZpZGVyID0gSW5mdXJhV2ViU29ja2V0UHJvdmlkZXI7XG4vKipcbiAqICBUaGUgKipJbmZ1cmFQcm92aWRlcioqIGNvbm5lY3RzIHRvIHRoZSBbW2xpbmstaW5mdXJhXV1cbiAqICBKU09OLVJQQyBlbmQtcG9pbnRzLlxuICpcbiAqICBCeSBkZWZhdWx0LCBhIGhpZ2hseS10aHJvdHRsZWQgQVBJIGtleSBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1pbmZ1cmEtc2lnbnVwKS5cbiAqL1xuY2xhc3MgSW5mdXJhUHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9qc29ucnBjX2pzXzEuSnNvblJwY1Byb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIFByb2plY3QgSUQgZm9yIHRoZSBJTkZVUkEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBwcm9qZWN0SWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBQcm9qZWN0IFNlY3JldC5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCBubyBhdXRoZW50aWNhdGVkIHJlcXVlc3RzIGFyZSBtYWRlLiBUaGlzIHNob3VsZCBub3RcbiAgICAgKiAgYmUgdXNlZCBvdXRzaWRlIG9mIHByaXZhdGUgY29udGV4dHMuXG4gICAgICovXG4gICAgcHJvamVjdFNlY3JldDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkluZnVyYVByb3ZpZGVyKiouXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIHByb2plY3RJZCwgcHJvamVjdFNlY3JldCkge1xuICAgICAgICBpZiAoX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgX25ldHdvcmsgPSBcIm1haW5uZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gbmV0d29ya19qc18xLk5ldHdvcmsuZnJvbShfbmV0d29yayk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvamVjdElkID0gZGVmYXVsdFByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdFNlY3JldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9qZWN0U2VjcmV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gSW5mdXJhUHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgcHJvamVjdElkLCBwcm9qZWN0U2VjcmV0IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFQcm92aWRlcihjaGFpbklkLCB0aGlzLnByb2plY3RJZCwgdGhpcy5wcm9qZWN0U2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFByb3ZpZGVyKGNoYWluSWQpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcioqLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBwcm9qZWN0SWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBwcm9qZWN0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHByZXBhcmVkIHJlcXVlc3QgZm9yIGNvbm5lY3RpbmcgdG8gJSVuZXR3b3JrJSVcbiAgICAgKiAgd2l0aCAlJXByb2plY3RJZCUlIGFuZCAlJXByb2plY3RTZWNyZXQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmVxdWVzdChuZXR3b3JrLCBwcm9qZWN0SWQsIHByb2plY3RTZWNyZXQpIHtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWQgPSBkZWZhdWx0UHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0U2VjcmV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2plY3RTZWNyZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfMS5GZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vdjMvJHtwcm9qZWN0SWR9YCk7XG4gICAgICAgIHJlcXVlc3QuYWxsb3dHemlwID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb2plY3RTZWNyZXQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgcHJvamVjdFNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJJbmZ1cmFQcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5JbmZ1cmFQcm92aWRlciA9IEluZnVyYVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItaW5mdXJhLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkluZnVyYVByb3ZpZGVyIiwiSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImNvbW11bml0eV9qc18xIiwibmV0d29ya19qc18xIiwicHJvdmlkZXJfanNvbnJwY19qc18xIiwicHJvdmlkZXJfd2Vic29ja2V0X2pzXzEiLCJkZWZhdWx0UHJvamVjdElkIiwiZ2V0SG9zdCIsIm5hbWUiLCJhc3NlcnRBcmd1bWVudCIsIldlYlNvY2tldFByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJuZXR3b3JrIiwicHJvamVjdElkIiwicHJvdmlkZXIiLCJyZXEiLCJfZ2V0Q29ubmVjdGlvbiIsImFzc2VydCIsImNyZWRlbnRpYWxzIiwib3BlcmF0aW9uIiwidXJsIiwicmVwbGFjZSIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9qZWN0U2VjcmV0IiwiaXNDb21tdW5pdHlSZXNvdXJjZSIsIkpzb25ScGNQcm92aWRlciIsIl9uZXR3b3JrIiwiTmV0d29yayIsImZyb20iLCJyZXF1ZXN0IiwiZ2V0UmVxdWVzdCIsInN0YXRpY05ldHdvcmsiLCJfZ2V0UHJvdmlkZXIiLCJjaGFpbklkIiwiZXJyb3IiLCJnZXRXZWJTb2NrZXRQcm92aWRlciIsIkZldGNoUmVxdWVzdCIsImFsbG93R3ppcCIsInNldENyZWRlbnRpYWxzIiwicmV0cnlGdW5jIiwicmVzcG9uc2UiLCJhdHRlbXB0Iiwic2hvd1Rocm90dGxlTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-infura.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IpcSocketProvider = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data) {\n    const messages = [];\n    let lastStart = 0;\n    while(true){\n        const nl = data.indexOf(10, lastStart);\n        if (nl === -1) {\n            break;\n        }\n        messages.push(data.subarray(lastStart, nl).toString().trim());\n        lastStart = nl + 1;\n    }\n    return {\n        messages,\n        remaining: data.subarray(lastStart)\n    };\n}\n/**\n *  An **IpcSocketProvider** connects over an IPC socket on the host\n *  which provides fast access to the node, but requires the node and\n *  the script run on the same machine.\n */ class IpcSocketProvider extends provider_socket_js_1.SocketProvider {\n    #socket;\n    /**\n     *  The connected socket.\n     */ get socket() {\n        return this.#socket;\n    }\n    constructor(path, network){\n        super(network);\n        this.#socket = (0, net_1.connect)(path);\n        this.socket.on(\"ready\", async ()=>{\n            try {\n                await this._start();\n            } catch (error) {\n                console.log(\"failed to start IpcSocketProvider\", error);\n            // @TODO: Now what? Restart?\n            }\n        });\n        let response = Buffer.alloc(0);\n        this.socket.on(\"data\", (data)=>{\n            response = Buffer.concat([\n                response,\n                data\n            ]);\n            const { messages, remaining } = splitBuffer(response);\n            messages.forEach((message)=>{\n                this._processMessage(message);\n            });\n            response = remaining;\n        });\n        this.socket.on(\"end\", ()=>{\n            this.emit(\"close\");\n            this.socket.destroy();\n            this.socket.end();\n        });\n    }\n    destroy() {\n        this.socket.destroy();\n        this.socket.end();\n        super.destroy();\n    }\n    async _write(message) {\n        this.socket.write(message);\n    }\n}\nexports.IpcSocketProvider = IpcSocketProvider; //# sourceMappingURL=provider-ipcsocket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLE1BQU1HLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsbUdBQXNCO0FBQzNELHlFQUF5RTtBQUN6RSwwQ0FBMEM7QUFDMUMsU0FBU0UsWUFBWUMsSUFBSTtJQUNyQixNQUFNQyxXQUFXLEVBQUU7SUFDbkIsSUFBSUMsWUFBWTtJQUNoQixNQUFPLEtBQU07UUFDVCxNQUFNQyxLQUFLSCxLQUFLSSxPQUFPLENBQUMsSUFBSUY7UUFDNUIsSUFBSUMsT0FBTyxDQUFDLEdBQUc7WUFDWDtRQUNKO1FBQ0FGLFNBQVNJLElBQUksQ0FBQ0wsS0FBS00sUUFBUSxDQUFDSixXQUFXQyxJQUFJSSxRQUFRLEdBQUdDLElBQUk7UUFDMUROLFlBQVlDLEtBQUs7SUFDckI7SUFDQSxPQUFPO1FBQUVGO1FBQVVRLFdBQVdULEtBQUtNLFFBQVEsQ0FBQ0o7SUFBVztBQUMzRDtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNUCwwQkFBMEJHLHFCQUFxQlksY0FBYztJQUMvRCxDQUFDQyxNQUFNLENBQUM7SUFDUjs7S0FFQyxHQUNELElBQUlBLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxNQUFNO0lBQUU7SUFDcENDLFlBQVlDLElBQUksRUFBRUMsT0FBTyxDQUFFO1FBQ3ZCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUMsQ0FBQ0gsTUFBTSxHQUFHLENBQUMsR0FBR2YsTUFBTW1CLE9BQU8sRUFBRUY7UUFDbEMsSUFBSSxDQUFDRixNQUFNLENBQUNLLEVBQUUsQ0FBQyxTQUFTO1lBQ3BCLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUNDLE1BQU07WUFDckIsRUFDQSxPQUFPQyxPQUFPO2dCQUNWQyxRQUFRQyxHQUFHLENBQUMscUNBQXFDRjtZQUNqRCw0QkFBNEI7WUFDaEM7UUFDSjtRQUNBLElBQUlHLFdBQVdDLE9BQU9DLEtBQUssQ0FBQztRQUM1QixJQUFJLENBQUNaLE1BQU0sQ0FBQ0ssRUFBRSxDQUFDLFFBQVEsQ0FBQ2hCO1lBQ3BCcUIsV0FBV0MsT0FBT0UsTUFBTSxDQUFDO2dCQUFDSDtnQkFBVXJCO2FBQUs7WUFDekMsTUFBTSxFQUFFQyxRQUFRLEVBQUVRLFNBQVMsRUFBRSxHQUFHVixZQUFZc0I7WUFDNUNwQixTQUFTd0IsT0FBTyxDQUFDLENBQUNDO2dCQUNkLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtZQUN6QjtZQUNBTCxXQUFXWjtRQUNmO1FBQ0EsSUFBSSxDQUFDRSxNQUFNLENBQUNLLEVBQUUsQ0FBQyxPQUFPO1lBQ2xCLElBQUksQ0FBQ1ksSUFBSSxDQUFDO1lBQ1YsSUFBSSxDQUFDakIsTUFBTSxDQUFDa0IsT0FBTztZQUNuQixJQUFJLENBQUNsQixNQUFNLENBQUNtQixHQUFHO1FBQ25CO0lBQ0o7SUFDQUQsVUFBVTtRQUNOLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ2tCLE9BQU87UUFDbkIsSUFBSSxDQUFDbEIsTUFBTSxDQUFDbUIsR0FBRztRQUNmLEtBQUssQ0FBQ0Q7SUFDVjtJQUNBLE1BQU1FLE9BQU9MLE9BQU8sRUFBRTtRQUNsQixJQUFJLENBQUNmLE1BQU0sQ0FBQ3FCLEtBQUssQ0FBQ047SUFDdEI7QUFDSjtBQUNBakMseUJBQXlCLEdBQUdFLG1CQUM1Qiw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItaXBjc29ja2V0LmpzPzYzYTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklwY1NvY2tldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgcHJvdmlkZXJfc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG4vLyBAVE9ETzogSXMgdGhpcyBzdWZmaWNpZW50PyBJcyB0aGlzIHJvYnVzdD8gV2lsbCBuZXdsaW5lcyBvY2N1ciBiZXR3ZWVuXG4vLyBhbGwgcGF5bG9hZHMgYW5kIG9ubHkgYmV0d2VlbiBwYXlsb2Fkcz9cbmZ1bmN0aW9uIHNwbGl0QnVmZmVyKGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGxldCBsYXN0U3RhcnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5sID0gZGF0YS5pbmRleE9mKDEwLCBsYXN0U3RhcnQpO1xuICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlcy5wdXNoKGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0LCBubCkudG9TdHJpbmcoKS50cmltKCkpO1xuICAgICAgICBsYXN0U3RhcnQgPSBubCArIDE7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VzLCByZW1haW5pbmc6IGRhdGEuc3ViYXJyYXkobGFzdFN0YXJ0KSB9O1xufVxuLyoqXG4gKiAgQW4gKipJcGNTb2NrZXRQcm92aWRlcioqIGNvbm5lY3RzIG92ZXIgYW4gSVBDIHNvY2tldCBvbiB0aGUgaG9zdFxuICogIHdoaWNoIHByb3ZpZGVzIGZhc3QgYWNjZXNzIHRvIHRoZSBub2RlLCBidXQgcmVxdWlyZXMgdGhlIG5vZGUgYW5kXG4gKiAgdGhlIHNjcmlwdCBydW4gb24gdGhlIHNhbWUgbWFjaGluZS5cbiAqL1xuY2xhc3MgSXBjU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcl9zb2NrZXRfanNfMS5Tb2NrZXRQcm92aWRlciB7XG4gICAgI3NvY2tldDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbm5lY3RlZCBzb2NrZXQuXG4gICAgICovXG4gICAgZ2V0IHNvY2tldCgpIHsgcmV0dXJuIHRoaXMuI3NvY2tldDsgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIobmV0d29yayk7XG4gICAgICAgIHRoaXMuI3NvY2tldCA9ICgwLCBuZXRfMS5jb25uZWN0KShwYXRoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJyZWFkeVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBzdGFydCBJcGNTb2NrZXRQcm92aWRlclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQFRPRE86IE5vdyB3aGF0PyBSZXN0YXJ0P1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gQnVmZmVyLmNvbmNhdChbcmVzcG9uc2UsIGRhdGFdKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZXMsIHJlbWFpbmluZyB9ID0gc3BsaXRCdWZmZXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHJlbWFpbmluZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuSXBjU29ja2V0UHJvdmlkZXIgPSBJcGNTb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWlwY3NvY2tldC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJcGNTb2NrZXRQcm92aWRlciIsIm5ldF8xIiwicmVxdWlyZSIsInByb3ZpZGVyX3NvY2tldF9qc18xIiwic3BsaXRCdWZmZXIiLCJkYXRhIiwibWVzc2FnZXMiLCJsYXN0U3RhcnQiLCJubCIsImluZGV4T2YiLCJwdXNoIiwic3ViYXJyYXkiLCJ0b1N0cmluZyIsInRyaW0iLCJyZW1haW5pbmciLCJTb2NrZXRQcm92aWRlciIsInNvY2tldCIsImNvbnN0cnVjdG9yIiwicGF0aCIsIm5ldHdvcmsiLCJjb25uZWN0Iiwib24iLCJfc3RhcnQiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsIkJ1ZmZlciIsImFsbG9jIiwiY29uY2F0IiwiZm9yRWFjaCIsIm1lc3NhZ2UiLCJfcHJvY2Vzc01lc3NhZ2UiLCJlbWl0IiwiZGVzdHJveSIsImVuZCIsIl93cml0ZSIsIndyaXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-ipcsocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js":
/*!************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nconst index_js_1 = __webpack_require__(/*! ../abi/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/abi/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst subscriber_filterid_js_1 = __webpack_require__(/*! ./subscriber-filterid.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy(value) {\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\n        return value;\n    }\n    // Keep any Addressable\n    if (typeof value.getAddress === \"function\") {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(deepCopy);\n    }\n    if (typeof value === \"object\") {\n        return Object.keys(value).reduce((accum, key)=>{\n            accum[key] = value[key];\n            return accum;\n        }, {});\n    }\n    throw new Error(`should not happen: ${value} (${typeof value})`);\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nfunction isPollable(value) {\n    return value && typeof value.pollingInterval === \"number\";\n}\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n    batchStallTime: 10,\n    batchMaxSize: 1 << 20,\n    batchMaxCount: 100,\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n// @TODO: Unchecked Signers\nclass JsonRpcSigner extends abstract_signer_js_1.AbstractSigner {\n    constructor(provider, address){\n        super(provider);\n        address = (0, index_js_2.getAddress)(address);\n        (0, index_js_5.defineProperties)(this, {\n            address\n        });\n    }\n    connect(provider) {\n        (0, index_js_5.assert)(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n    async getAddress() {\n        return this.address;\n    }\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx) {\n        return await this.populateCall(tx);\n    }\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        const promises = [];\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async ()=>{\n                const from = await (0, index_js_2.resolveAddress)(_from, this.provider);\n                (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async ()=>{\n                tx.gasLimit = await this.provider.estimateGas({\n                    ...tx,\n                    from: this.address\n                });\n            })());\n        }\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async ()=>{\n                tx.to = await (0, index_js_2.resolveAddress)(_to, this.provider);\n            })());\n        }\n        // Wait until all of our properties are filled in\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return this.provider.send(\"eth_sendTransaction\", [\n            hexTx\n        ]);\n    }\n    async sendTransaction(tx) {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await new Promise((resolve, reject)=>{\n            const timeouts = [\n                1000,\n                100\n            ];\n            const checkTx = async ()=>{\n                // Try getting the transaction\n                const tx = await this.provider.getTransaction(hash);\n                if (tx != null) {\n                    resolve(tx.replaceableTransaction(blockNumber));\n                    return;\n                }\n                // Wait another 4 seconds\n                this.provider._setTimeout(()=>{\n                    checkTx();\n                }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        });\n    }\n    async signTransaction(_tx) {\n        const tx = deepCopy(_tx);\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await (0, index_js_2.resolveAddress)(tx.from, this.provider);\n            (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [\n            hexTx\n        ]);\n    }\n    async signMessage(_message) {\n        const message = typeof _message === \"string\" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"personal_sign\", [\n            (0, index_js_5.hexlify)(message),\n            this.address.toLowerCase()\n        ]);\n    }\n    async signTypedData(domain, types, _value) {\n        const value = deepCopy(_value);\n        // Populate any ENS names (in-place)\n        const populated = await index_js_3.TypedDataEncoder.resolveNames(domain, types, value, async (value)=>{\n            const address = await (0, index_js_2.resolveAddress)(value);\n            (0, index_js_5.assertArgument)(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n    async unlock(password) {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(),\n            password,\n            null\n        ]);\n    }\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message) {\n        const message = typeof _message === \"string\" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(),\n            (0, index_js_5.hexlify)(message)\n        ]);\n    }\n}\nexports.JsonRpcSigner = JsonRpcSigner;\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */ class JsonRpcApiProvider extends abstract_provider_js_1.AbstractProvider {\n    #options;\n    // The next ID to use for the JSON-RPC ID field\n    #nextId;\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads;\n    #drainTimer;\n    #notReady;\n    #network;\n    #scheduleDrain() {\n        if (this.#drainTimer) {\n            return;\n        }\n        // If we aren't using batching, no hard in sending it immeidately\n        const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n        this.#drainTimer = setTimeout(()=>{\n            this.#drainTimer = null;\n            const payloads = this.#payloads;\n            this.#payloads = [];\n            while(payloads.length){\n                // Create payload batches that satisfy our batch constraints\n                const batch = [\n                    payloads.shift()\n                ];\n                while(payloads.length){\n                    if (batch.length === this.#options.batchMaxCount) {\n                        break;\n                    }\n                    batch.push(payloads.shift());\n                    const bytes = JSON.stringify(batch.map((p)=>p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(batch.pop());\n                        break;\n                    }\n                }\n                // Process the result to each payload\n                (async ()=>{\n                    const payload = batch.length === 1 ? batch[0].payload : batch.map((p)=>p.payload);\n                    this.emit(\"debug\", {\n                        action: \"sendRpcPayload\",\n                        payload\n                    });\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcResult\",\n                            result\n                        });\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch){\n                            if (this.destroyed) {\n                                reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                                    operation: payload.method\n                                }));\n                                continue;\n                            }\n                            // Find the matching result\n                            const resp = result.filter((r)=>r.id === payload.id)[0];\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = (0, index_js_5.makeError)(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result,\n                                    info: {\n                                        payload\n                                    }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n                    } catch (error) {\n                        this.emit(\"debug\", {\n                            action: \"receiveRpcError\",\n                            error\n                        });\n                        for (const { reject } of batch){\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n    constructor(network, options){\n        super(network, options);\n        this.#nextId = 1;\n        this.#options = Object.assign({}, defaultOptions, options || {});\n        this.#payloads = [];\n        this.#drainTimer = null;\n        this.#network = null;\n        {\n            let resolve = null;\n            const promise = new Promise((_resolve)=>{\n                resolve = _resolve;\n            });\n            this.#notReady = {\n                promise,\n                resolve\n            };\n        }\n        // Make sure any static network is compatbile with the provided netwrok\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (staticNetwork) {\n            (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */ _getOption(key) {\n        return this.#options[key];\n    }\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */ get _network() {\n        (0, index_js_5.assert)(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */ async _perform(req) {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type)) {\n                // If there are no EIP-1559 properties, it might be non-EIP-a559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({}, req, {\n                            transaction: Object.assign({}, tx, {\n                                type: undefined\n                            })\n                        });\n                    }\n                }\n            }\n        }\n        const request = this.getRpcRequest(req);\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n        return super._perform(req);\n    }\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */ async _detectNetwork() {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            return network;\n        }\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            return network_js_1.Network.from((0, index_js_5.getBigInt)(await this.send(\"eth_chainId\", [])));\n        }\n        // We are not ready yet; use the primitive _send\n        const payload = {\n            id: this.#nextId++,\n            method: \"eth_chainId\",\n            params: [],\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"sendRpcPayload\",\n            payload\n        });\n        let result;\n        try {\n            result = (await this._send(payload))[0];\n        } catch (error) {\n            this.emit(\"debug\", {\n                action: \"receiveRpcError\",\n                error\n            });\n            throw error;\n        }\n        this.emit(\"debug\", {\n            action: \"receiveRpcResult\",\n            result\n        });\n        if (\"result\" in result) {\n            return network_js_1.Network.from((0, index_js_5.getBigInt)(result.result));\n        }\n        throw this.getRpcError(payload, result);\n    }\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */ _start() {\n        if (this.#notReady == null || this.#notReady.resolve == null) {\n            return;\n        }\n        this.#notReady.resolve();\n        this.#notReady = null;\n        (async ()=>{\n            // Bootstrap the network\n            while(this.#network == null && !this.destroyed){\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) {\n                        break;\n                    }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", (0, index_js_5.makeError)(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", {\n                        event: \"initial-network-discovery\",\n                        info: {\n                            error\n                        }\n                    }));\n                    await stall(1000);\n                }\n            }\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */ async _waitUntilReady() {\n        if (this.#notReady == null) {\n            return;\n        }\n        return await this.#notReady.promise;\n    }\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */ _getSubscriber(sub) {\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") {\n            return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);\n        }\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);\n            }\n            return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);\n        }\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new abstract_provider_js_1.UnmanagedSubscriber(\"orphan\");\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */ get ready() {\n        return this.#notReady == null;\n    }\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */ getRpcTransaction(tx) {\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            let dstKey = key;\n            if (key === \"gasLimit\") {\n                dstKey = \"gas\";\n            }\n            result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], `tx.${key}`));\n        });\n        // Make sure addresses and data are lowercase\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach((key)=>{\n            if (tx[key] == null) {\n                return;\n            }\n            result[key] = (0, index_js_5.hexlify)(tx[key]);\n        });\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = (0, index_js_4.accessListify)(tx.accessList);\n        }\n        return result;\n    }\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */ getRpcRequest(req) {\n        switch(req.method){\n            case \"chainId\":\n                return {\n                    method: \"eth_chainId\",\n                    args: []\n                };\n            case \"getBlockNumber\":\n                return {\n                    method: \"eth_blockNumber\",\n                    args: []\n                };\n            case \"getGasPrice\":\n                return {\n                    method: \"eth_gasPrice\",\n                    args: []\n                };\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [\n                        getLowerCase(req.address),\n                        req.blockTag\n                    ]\n                };\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        \"0x\" + req.position.toString(16),\n                        req.blockTag\n                    ]\n                };\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [\n                        req.signedTransaction\n                    ]\n                };\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [\n                            req.blockTag,\n                            !!req.includeTransactions\n                        ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [\n                            req.blockHash,\n                            !!req.includeTransactions\n                        ]\n                    };\n                }\n                break;\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [\n                        req.hash\n                    ]\n                };\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [\n                        this.getRpcTransaction(req.transaction),\n                        req.blockTag\n                    ]\n                };\n            case \"estimateGas\":\n                {\n                    return {\n                        method: \"eth_estimateGas\",\n                        args: [\n                            this.getRpcTransaction(req.transaction)\n                        ]\n                    };\n                }\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return {\n                    method: \"eth_getLogs\",\n                    args: [\n                        req.filter\n                    ]\n                };\n        }\n        return null;\n    }\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */ getRpcError(payload, _error) {\n        const { method } = payload;\n        const { error } = _error;\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return (0, index_js_5.makeError)(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: payload.params[0],\n                    info: {\n                        payload,\n                        error\n                    }\n                });\n            }\n        }\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n            const e = index_js_1.AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n            e.info = {\n                error,\n                payload\n            };\n            return e;\n        }\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n        const message = JSON.stringify(spelunkMessage(error));\n        if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\"\n            };\n            return (0, index_js_5.makeError)(`user rejected action`, \"ACTION_REJECTED\", {\n                action: actionMap[method] || \"unknown\",\n                reason: \"rejected\",\n                info: {\n                    payload,\n                    error\n                }\n            });\n        }\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = payload.params[0];\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return (0, index_js_5.makeError)(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return (0, index_js_5.makeError)(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return (0, index_js_5.makeError)(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n                    transaction,\n                    info: {\n                        error\n                    }\n                });\n            }\n            if (message.match(/only replay-protected/i)) {\n                return (0, index_js_5.makeError)(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method,\n                    info: {\n                        transaction,\n                        info: {\n                            error\n                        }\n                    }\n                });\n            }\n        }\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && error.details && error.details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n        if (unsupported) {\n            return (0, index_js_5.makeError)(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method,\n                info: {\n                    error,\n                    payload\n                }\n            });\n        }\n        return (0, index_js_5.makeError)(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n            error,\n            payload\n        });\n    }\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */ send(method, params) {\n        // @TODO: cache chainId?? purge on switch_networks\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: method\n            }));\n        }\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject)=>{\n            this.#payloads.push({\n                resolve,\n                reject,\n                payload: {\n                    method,\n                    params,\n                    id,\n                    jsonrpc: \"2.0\"\n                }\n            });\n        });\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n        return promise;\n    }\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */ async getSigner(address) {\n        if (address == null) {\n            address = 0;\n        }\n        const accountsPromise = this.send(\"eth_accounts\", []);\n        // Account index\n        if (typeof address === \"number\") {\n            const accounts = await accountsPromise;\n            if (address >= accounts.length) {\n                throw new Error(\"no such account\");\n            }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n        const { accounts } = await (0, index_js_5.resolveProperties)({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n        // Account address\n        address = (0, index_js_2.getAddress)(address);\n        for (const account of accounts){\n            if ((0, index_js_2.getAddress)(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n        throw new Error(\"invalid account\");\n    }\n    async listAccounts() {\n        const accounts = await this.send(\"eth_accounts\", []);\n        return accounts.map((a)=>new JsonRpcSigner(this, a));\n    }\n    destroy() {\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads){\n            reject((0, index_js_5.makeError)(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method\n            }));\n        }\n        this.#payloads = [];\n        // Parent clean-up\n        super.destroy();\n    }\n}\nexports.JsonRpcApiProvider = JsonRpcApiProvider;\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */ class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval;\n    constructor(network, options){\n        super(network, options);\n        this.#pollingInterval = 4000;\n    }\n    _getSubscriber(sub) {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n    /**\n     *  The polling interval (default: 4000 ms)\n     */ get pollingInterval() {\n        return this.#pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (!Number.isInteger(value) || value < 0) {\n            throw new Error(\"invalid interval\");\n        }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub)=>{\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\nexports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */ class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect;\n    constructor(url, network, options){\n        if (url == null) {\n            url = \"http://localhost:8545\";\n        }\n        super(network, options);\n        if (typeof url === \"string\") {\n            this.#connect = new index_js_5.FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n    _getConnection() {\n        return this.#connect.clone();\n    }\n    async send(method, params) {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n        return await super.send(method, params);\n    }\n    async _send(payload) {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) {\n            resp = [\n                resp\n            ];\n        }\n        return resp;\n    }\n}\nexports.JsonRpcProvider = JsonRpcProvider;\nfunction spelunkData(value) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {\n        return {\n            message: value.message,\n            data: value.data\n        };\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunkData(value[key]);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) {}\n    }\n    return null;\n}\nfunction _spelunkMessage(value, result) {\n    if (value == null) {\n        return;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\") {\n        result.push(value.message);\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            _spelunkMessage(value[key], result);\n        }\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) {}\n    }\n}\nfunction spelunkMessage(value) {\n    const result = [];\n    _spelunkMessage(value, result);\n    return result;\n} //# sourceMappingURL=provider-jsonrpc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7O0NBVUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxpQ0FBaUMsR0FBR0EsMEJBQTBCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDeEgsU0FBUztBQUNULHlCQUF5QjtBQUN6Qix5UUFBeVE7QUFDelEsTUFBTU0sYUFBYUMsbUJBQU9BLENBQUMsOEVBQWlCO0FBQzVDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHNGQUFxQjtBQUNoRCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxnRkFBa0I7QUFDN0MsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNSyx5QkFBeUJMLG1CQUFPQSxDQUFDLHVHQUF3QjtBQUMvRCxNQUFNTSx1QkFBdUJOLG1CQUFPQSxDQUFDLG1HQUFzQjtBQUMzRCxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxtRkFBYztBQUMzQyxNQUFNUSwyQkFBMkJSLG1CQUFPQSxDQUFDLDJHQUEwQjtBQUNuRSxNQUFNUywwQkFBMEJULG1CQUFPQSxDQUFDLHlHQUF5QjtBQUNqRSxNQUFNVSxZQUFZLCtDQUErQ0MsS0FBSyxDQUFDO0FBQ3ZFLGdEQUFnRDtBQUNoRCxTQUFTQyxTQUFTbEIsS0FBSztJQUNuQixJQUFJQSxTQUFTLFFBQVFnQixVQUFVRyxPQUFPLENBQUMsT0FBUW5CLFVBQVcsR0FBRztRQUN6RCxPQUFPQTtJQUNYO0lBQ0EsdUJBQXVCO0lBQ3ZCLElBQUksT0FBUUEsTUFBTW9CLFVBQVUsS0FBTSxZQUFZO1FBQzFDLE9BQU9wQjtJQUNYO0lBQ0EsSUFBSXFCLE1BQU1DLE9BQU8sQ0FBQ3RCLFFBQVE7UUFDdEIs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QUNyQ2tDLE9BQU81RCxJQUFJLENBQUM3RCxNQUFNdUYsT0FBTztJQUM3QjtJQUNBLHFCQUFxQjtJQUNyQixJQUFJLE9BQVF2RixVQUFXLFVBQVU7UUFDN0IsSUFBSyxNQUFNMkIsT0FBTzNCLE1BQU87WUFDckJpTyxnQkFBZ0JqTyxLQUFLLENBQUMyQixJQUFJLEVBQUU4RjtRQUNoQztJQUNKO0lBQ0EsbURBQW1EO0lBQ25ELElBQUksT0FBUXpILFVBQVcsVUFBVTtRQUM3QixJQUFJO1lBQ0EsT0FBT2lPLGdCQUFnQmhJLEtBQUsrSCxLQUFLLENBQUNoTyxRQUFReUg7UUFDOUMsRUFDQSxPQUFPUyxPQUFPLENBQUU7SUFDcEI7QUFDSjtBQUNBLFNBQVN5RCxlQUFlM0wsS0FBSztJQUN6QixNQUFNeUgsU0FBUyxFQUFFO0lBQ2pCd0csZ0JBQWdCak8sT0FBT3lIO0lBQ3ZCLE9BQU9BO0FBQ1gsRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItanNvbnJwYy5qcz9jMjU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgT25lIG9mIHRoZSBtb3N0IGNvbW1vbiB3YXlzIHRvIGludGVyYWN0IHdpdGggdGhlIGJsb2NrY2hhaW4gaXNcbiAqICBieSBhIG5vZGUgcnVubmluZyBhIEpTT04tUlBDIGludGVyZmFjZSB3aGljaCBjYW4gYmUgY29ubmVjdGVkIHRvLFxuICogIGJhc2VkIG9uIHRoZSB0cmFuc3BvcnQsIHVzaW5nOlxuICpcbiAqICAtIEhUVFAgb3IgSFRUUFMgLSBbW0pzb25ScGNQcm92aWRlcl1dXG4gKiAgLSBXZWJTb2NrZXQgLSBbW1dlYlNvY2tldFByb3ZpZGVyXV1cbiAqICAtIElQQyAtIFtbSXBjU29ja2V0UHJvdmlkZXJdXVxuICpcbiAqIEBfc2VjdGlvbjogYXBpL3Byb3ZpZGVycy9qc29ucnBjOkpTT04tUlBDIFByb3ZpZGVyICBbYWJvdXQtanNvbnJwY1Byb3ZpZGVyXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25ScGNQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciA9IGV4cG9ydHMuSnNvblJwY0FwaVByb3ZpZGVyID0gZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0gdm9pZCAwO1xuLy8gQFRPRE86XG4vLyAtIEFkZCB0aGUgYmF0Y2hpbmcgQVBJXG4vLyBodHRwczovL3BsYXlncm91bmQub3Blbi1ycGMub3JnLz9zY2hlbWFVcmw9aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2V0aGVyZXVtL2V0aDEuMC1hcGlzL2Fzc2VtYmxlZC1zcGVjL29wZW5ycGMuanNvbiZ1aVNjaGVtYSU1QmFwcEJhciU1RCU1QnVpOnNwbGl0VmlldyU1RD10cnVlJnVpU2NoZW1hJTVCYXBwQmFyJTVEJTVCdWk6aW5wdXQlNUQ9ZmFsc2UmdWlTY2hlbWElNUJhcHBCYXIlNUQlNUJ1aTpleGFtcGxlc0Ryb3Bkb3duJTVEPWZhbHNlXG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FiaS9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzQgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc181ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgYWJzdHJhY3RfcHJvdmlkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXByb3ZpZGVyLmpzXCIpO1xuY29uc3QgYWJzdHJhY3Rfc2lnbmVyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC1zaWduZXIuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3Qgc3Vic2NyaWJlcl9maWx0ZXJpZF9qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1maWx0ZXJpZC5qc1wiKTtcbmNvbnN0IHN1YnNjcmliZXJfcG9sbGluZ19qc18xID0gcmVxdWlyZShcIi4vc3Vic2NyaWJlci1wb2xsaW5nLmpzXCIpO1xuY29uc3QgUHJpbWl0aXZlID0gXCJiaWdpbnQsYm9vbGVhbixmdW5jdGlvbixudW1iZXIsc3RyaW5nLHN5bWJvbFwiLnNwbGl0KC8sL2cpO1xuLy9jb25zdCBNZXRob2RzID0gXCJnZXRBZGRyZXNzLHRoZW5cIi5zcGxpdCgvLC9nKTtcbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgUHJpbWl0aXZlLmluZGV4T2YodHlwZW9mICh2YWx1ZSkpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBLZWVwIGFueSBBZGRyZXNzYWJsZVxuICAgIGlmICh0eXBlb2YgKHZhbHVlLmdldEFkZHJlc3MpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZS5tYXAoZGVlcENvcHkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkucmVkdWNlKChhY2N1bSwga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHNob3VsZCBub3QgaGFwcGVuOiAke3ZhbHVlfSAoJHt0eXBlb2YgKHZhbHVlKX0pYCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzUG9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucG9sbGluZ0ludGVydmFsKSA9PT0gXCJudW1iZXJcIik7XG59XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwb2xsaW5nOiBmYWxzZSxcbiAgICBzdGF0aWNOZXR3b3JrOiBudWxsLFxuICAgIGJhdGNoU3RhbGxUaW1lOiAxMCxcbiAgICBiYXRjaE1heFNpemU6ICgxIDw8IDIwKSxcbiAgICBiYXRjaE1heENvdW50OiAxMDAsXG4gICAgY2FjaGVUaW1lb3V0OiAyNTAsXG4gICAgcG9sbGluZ0ludGVydmFsOiA0MDAwXG59O1xuLy8gQFRPRE86IFVuY2hlY2tlZCBTaWduZXJzXG5jbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgYWJzdHJhY3Rfc2lnbmVyX2pzXzEuQWJzdHJhY3RTaWduZXIge1xuICAgIGFkZHJlc3M7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzIuZ2V0QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgICgwLCBpbmRleF9qc181LmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGZhbHNlLCBcImNhbm5vdCByZWNvbm5lY3QgSnNvblJwY1NpZ25lclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzcztcbiAgICB9XG4gICAgLy8gSlNPTi1SUEMgd2lsbCBhdXRvbWF0aWFsbHkgZmlsbCBpbiBub25jZSwgZXRjLiBzbyB3ZSBqdXN0IGNoZWNrIGZyb21cbiAgICBhc3luYyBwb3B1bGF0ZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvcHVsYXRlQ2FsbCh0eCk7XG4gICAgfVxuICAgIC8vIFJldHVybnMganVzdCB0aGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgc2VudCwgd2hpY2ggaXMgd2hhdFxuICAgIC8vIHRoZSBiYXJlIEpTT04tUlBDIEFQSSBkb2VzO1xuICAgIGFzeW5jIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbihfdHgpIHtcbiAgICAgICAgY29uc3QgdHggPSBkZWVwQ29weShfdHgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZyb20gbWF0Y2hlcyB0aGUgc2VuZGVyXG4gICAgICAgIGlmICh0eC5mcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBfZnJvbSA9IHR4LmZyb207XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShfZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKGZyb20gIT0gbnVsbCAmJiBmcm9tLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIF90eCk7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IGZyb207XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoeyAuLi50eCwgZnJvbTogdGhpcy5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGFkZHJlc3MgbWF5IGJlIGFuIEVOUyBuYW1lIG9yIEFkZHJlc3NhYmxlXG4gICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBfdG8gPSB0eC50bztcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0eC50byA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnJlc29sdmVBZGRyZXNzKShfdG8sIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBhbGwgb2Ygb3VyIHByb3BlcnRpZXMgYXJlIGZpbGxlZCBpblxuICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmdldFJwY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICAvLyBUaGlzIGNhbm5vdCBiZSBtaW5lZCBhbnkgZWFybGllciB0aGFuIGFueSByZWNlbnQgYmxvY2tcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIEpTT04tUlBDIG9ubHkgcHJvdmlkZXMgYW5kIG9wYXF1ZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgIHJldHVybiBhd2FpdCAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dHMgPSBbMTAwMCwgMTAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrVHggPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpO1xuICAgICAgICAgICAgICAgIGlmICh0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHgucmVwbGFjZWFibGVUcmFuc2FjdGlvbihibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5vdGhlciA0IHNlY29uZHNcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9zZXRUaW1lb3V0KCgpID0+IHsgY2hlY2tUeCgpOyB9LCB0aW1lb3V0cy5wb3AoKSB8fCA0MDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGVja1R4KCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKF90eCkge1xuICAgICAgICBjb25zdCB0eCA9IGRlZXBDb3B5KF90eCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZnJvbSBtYXRjaGVzIHRoZSBzZW5kZXJcbiAgICAgICAgaWYgKHR4LmZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodHguZnJvbSwgdGhpcy5wcm92aWRlcik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnRBcmd1bWVudCkoZnJvbSAhPSBudWxsICYmIGZyb20udG9Mb3dlckNhc2UoKSA9PT0gdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgX3R4KTtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuZ2V0UnBjVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLCBbaGV4VHhdKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UoX21lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgodHlwZW9mIChfbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gKDAsIGluZGV4X2pzXzUudG9VdGY4Qnl0ZXMpKF9tZXNzYWdlKSA6IF9tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkobWVzc2FnZSksIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIF92YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZXBDb3B5KF92YWx1ZSk7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxuICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSBhd2FpdCBpbmRleF9qc18zLlR5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5yZXNvbHZlQWRkcmVzcykodmFsdWUpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKGFkZHJlc3MgIT0gbnVsbCwgXCJUeXBlZERhdGEgZG9lcyBub3Qgc3VwcG9ydCBudWxsIGFkZHJlc3NcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGluZGV4X2pzXzMuVHlwZWREYXRhRW5jb2Rlci5nZXRQYXlsb2FkKHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCBwb3B1bGF0ZWQudmFsdWUpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgIGFzeW5jIF9sZWdhY3lTaWduTWVzc2FnZShfbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKCh0eXBlb2YgKF9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyAoMCwgaW5kZXhfanNfNS50b1V0ZjhCeXRlcykoX21lc3NhZ2UpIDogX21lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25cIiwgW1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzLnRvTG93ZXJDYXNlKCksICgwLCBpbmRleF9qc181LmhleGxpZnkpKG1lc3NhZ2UpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblJwY1NpZ25lciA9IEpzb25ScGNTaWduZXI7XG4vKipcbiAqICBUaGUgSnNvblJwY0FwaVByb3ZpZGVyIGlzIGFuIGFic3RyYWN0IGNsYXNzIGFuZCAqKk1VU1QqKiBiZVxuICogIHN1Yi1jbGFzc2VkLlxuICpcbiAqICBJdCBwcm92aWRlcyB0aGUgYmFzZSBmb3IgYWxsIEpTT04tUlBDLWJhc2VkIFByb3ZpZGVyIGludGVyYWN0aW9uLlxuICpcbiAqICBTdWItY2xhc3NpbmcgTm90ZXM6XG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIF9zZW5kXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKi9cbmNsYXNzIEpzb25ScGNBcGlQcm92aWRlciBleHRlbmRzIGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuQWJzdHJhY3RQcm92aWRlciB7XG4gICAgI29wdGlvbnM7XG4gICAgLy8gVGhlIG5leHQgSUQgdG8gdXNlIGZvciB0aGUgSlNPTi1SUEMgSUQgZmllbGRcbiAgICAjbmV4dElkO1xuICAgIC8vIFBheWxvYWRzIGFyZSBxdWV1ZWQgYW5kIHRyaWdnZXJlZCBpbiBiYXRjaGVzIHVzaW5nIHRoZSBkcmFpblRpbWVyXG4gICAgI3BheWxvYWRzO1xuICAgICNkcmFpblRpbWVyO1xuICAgICNub3RSZWFkeTtcbiAgICAjbmV0d29yaztcbiAgICAjc2NoZWR1bGVEcmFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuI2RyYWluVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgYmF0Y2hpbmcsIG5vIGhhcmQgaW4gc2VuZGluZyBpdCBpbW1laWRhdGVseVxuICAgICAgICBjb25zdCBzdGFsbFRpbWUgPSAodGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hNYXhDb3VudFwiKSA9PT0gMSkgPyAwIDogdGhpcy5fZ2V0T3B0aW9uKFwiYmF0Y2hTdGFsbFRpbWVcIik7XG4gICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2RyYWluVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0aGlzLiNwYXlsb2FkcztcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHBheWxvYWQgYmF0Y2hlcyB0aGF0IHNhdGlzZnkgb3VyIGJhdGNoIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBbKHBheWxvYWRzLnNoaWZ0KCkpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPT09IHRoaXMuI29wdGlvbnMuYmF0Y2hNYXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gucHVzaCgocGF5bG9hZHMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IEpTT04uc3RyaW5naWZ5KGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLiNvcHRpb25zLmJhdGNoTWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZHMudW5zaGlmdCgoYmF0Y2gucG9wKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHJlc3VsdCB0byBlYWNoIHBheWxvYWRcbiAgICAgICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gKChiYXRjaC5sZW5ndGggPT09IDEpID8gYmF0Y2hbMF0ucGF5bG9hZCA6IGJhdGNoLm1hcCgocCkgPT4gcC5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInNlbmRScGNQYXlsb2FkXCIsIHBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY1Jlc3VsdFwiLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgaW4gYmF0Y2ggb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZXNvbHZlLCByZWplY3QsIHBheWxvYWQgfSBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IHBheWxvYWQubWV0aG9kIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1hdGNoaW5nIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSByZXN1bHQuZmlsdGVyKChyKSA9PiAoci5pZCA9PT0gcGF5bG9hZC5pZCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdDsgdGhlIG5vZGUgZmFpbGVkIHVzIGluIHVuZXhwZWN0ZWQgd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwibWlzc2luZyByZXNwb25zZSBmb3IgcmVxdWVzdFwiLCBcIkJBRF9EQVRBXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsIGluZm86IHsgcGF5bG9hZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHJlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzcCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGdvb2Q7IHNlbmQgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwicmVjZWl2ZVJwY0Vycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IGF1Z21lbnQgdGhlIGVycm9yIHdpdGggdGhlIHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhbGxUaW1lKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy4jbmV4dElkID0gMTtcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuI25ldHdvcmsgPSBudWxsO1xuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNub3RSZWFkeSA9IHsgcHJvbWlzZSwgcmVzb2x2ZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3RhdGljIG5ldHdvcmsgaXMgY29tcGF0YmlsZSB3aXRoIHRoZSBwcm92aWRlZCBuZXR3cm9rXG4gICAgICAgIGNvbnN0IHN0YXRpY05ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAoc3RhdGljTmV0d29yaykge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0QXJndW1lbnQpKG5ldHdvcmsgPT0gbnVsbCB8fCBzdGF0aWNOZXR3b3JrLm1hdGNoZXMobmV0d29yayksIFwic3RhdGljTmV0d29yayBNVVNUIG1hdGNoIG5ldHdvcmsgb2JqZWN0XCIsIFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuI25ldHdvcmsgPSBzdGF0aWNOZXR3b3JrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG9wdGlvbiAlJWtleSUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIGNhbiB1c2UgdGhpcyB0byBpbnF1aXJlIGFib3V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBfZ2V0T3B0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0cyB0aGUgW1tOZXR3b3JrXV0gdGhpcyBwcm92aWRlciBoYXMgY29tbWl0dGVkIHRvLiBPbiBlYWNoIGNhbGwsIHRoZSBuZXR3b3JrXG4gICAgICogIGlzIGRldGVjdGVkLCBhbmQgaWYgaXQgaGFzIGNoYW5nZWQsIHRoZSBjYWxsIHdpbGwgcmVqZWN0LlxuICAgICAqL1xuICAgIGdldCBfbmV0d29yaygpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KSh0aGlzLiNuZXR3b3JrLCBcIm5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZSB5ZXRcIiwgXCJORVRXT1JLX0VSUk9SXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy4jbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBub24tbm9ybWFsaXplZCB2YWx1ZSBieSBwZXJmb3JtaW5nICUlcmVxJSUuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gbW9kaWZ5IGJlaGF2aW9yIG9mIGFjdGlvbnMsXG4gICAgICogIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGNhbGwgYGBzdXBlci5fcGVyZm9ybWBgIGFzIGEgZmFsbGJhY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BlcmZvcm0ocmVxKSB7XG4gICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSBcImNhbGxcIiB8fCByZXEubWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGxldCB0eCA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgKDAsIGluZGV4X2pzXzUuZ2V0QmlnSW50KSh0eC50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLWE1NTlcbiAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0gYXdhaXQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IE9iamVjdC5hc3NpZ24oe30sIHR4LCB7IHR5cGU6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UnBjUmVxdWVzdChyZXEpO1xuICAgICAgICBpZiAocmVxdWVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5fcGVyZm9ybShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXM7IGl0IGRldGVjdHMgdGhlICphY3R1YWwqIG5ldHdvcmsgdGhhdFxuICAgICAqICB3ZSBhcmUgKipjdXJyZW50bHkqKiBjb25uZWN0ZWQgdG8uXG4gICAgICpcbiAgICAgKiAgS2VlcCBpbiBtaW5kIHRoYXQgW1tzZW5kXV0gbWF5IG9ubHkgYmUgdXNlZCBvbmNlIFtbcmVhZHldXSwgb3RoZXJ3aXNlIHRoZVxuICAgICAqICBfc2VuZCBwcmltaXRpdmUgbXVzdCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgX2RldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLl9nZXRPcHRpb24oXCJzdGF0aWNOZXR3b3JrXCIpO1xuICAgICAgICBpZiAobmV0d29yaykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlYWR5LCB1c2UgYGBzZW5kYGAsIHdoaWNoIGVuYWJsZWQgcmVxdWVzdHMgdG8gYmUgYmF0Y2hlZFxuICAgICAgICBpZiAodGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oKDAsIGluZGV4X2pzXzUuZ2V0QmlnSW50KShhd2FpdCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhcmUgbm90IHJlYWR5IHlldDsgdXNlIHRoZSBwcmltaXRpdmUgX3NlbmRcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLiNuZXh0SWQrKywgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIHBhcmFtczogW10sIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwgeyBhY3Rpb246IFwic2VuZFJwY1BheWxvYWRcIiwgcGF5bG9hZCB9KTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChhd2FpdCB0aGlzLl9zZW5kKHBheWxvYWQpKVswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNFcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHsgYWN0aW9uOiBcInJlY2VpdmVScGNSZXN1bHRcIiwgcmVzdWx0IH0pO1xuICAgICAgICBpZiAoXCJyZXN1bHRcIiBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKCgwLCBpbmRleF9qc181LmdldEJpZ0ludCkocmVzdWx0LnJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuZ2V0UnBjRXJyb3IocGF5bG9hZCwgcmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqTVVTVCoqIGNhbGwgdGhpcy4gVW50aWwgW1tfc3RhcnRdXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNhbGxzXG4gICAgICogIHdpbGwgYmUgcGFzc2VkIHRvIFtbX3NlbmRdXSBmcm9tIFtbc2VuZF1dLiBJZiBpdCBpcyBvdmVycmlkZGVuLCB0aGVuXG4gICAgICogIGBgc3VwZXIuX3N0YXJ0KClgYCAqKk1VU1QqKiBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgQ2FsbGluZyBpdCBtdWx0aXBsZSB0aW1lcyBpcyBzYWZlIGFuZCBoYXMgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIF9zdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI25vdFJlYWR5ID09IG51bGwgfHwgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbm90UmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLiNub3RSZWFkeSA9IG51bGw7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgdGhlIG5ldHdvcmtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNuZXR3b3JrID09IG51bGwgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IGF3YWl0IHRoaXMuX2RldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJKc29uUnBjUHJvdmlkZXIgZmFpbGVkIHRvIGRldGVjdCBuZXR3b3JrIGFuZCBjYW5ub3Qgc3RhcnQgdXA7IHJldHJ5IGluIDFzIChwZXJoYXBzIHRoZSBVUkwgaXMgd3Jvbmcgb3IgdGhlIG5vZGUgaXMgbm90IHN0YXJ0ZWQpXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwiZmFpbGVkIHRvIGJvb3RzdHJhcCBuZXR3b3JrIGRldGVjdGlvblwiLCBcIk5FVFdPUktfRVJST1JcIiwgeyBldmVudDogXCJpbml0aWFsLW5ldHdvcmstZGlzY292ZXJ5XCIsIGluZm86IHsgZXJyb3IgfSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0YWxsKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGRpc3BhdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyBvbmNlIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC4gVGhpcyBjYW4gYmUgdXNlZCBpblxuICAgICAqICBzdWItY2xhc3NlcyB0byBkZWZlciBzZW5kaW5nIGRhdGEgdW50aWwgdGhlIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICAgKiAgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3dhaXRVbnRpbFJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy4jbm90UmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNub3RSZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgU3Vic2NyaWJlciB0aGF0IHdpbGwgbWFuYWdlIHRoZSAlJXN1YiUlLlxuICAgICAqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIG1vZGlmeSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgKiAgc3Vic2NyaXB0aW9uIG1hbmFnZW1lbnQuXG4gICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIC8vIFBlbmRpbmcgRmlsdGVycyBhcmVuJ3QgYXZhaWxibGUgdmlhIHBvbGxpbmdcbiAgICAgICAgaWYgKHN1Yi50eXBlID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdWJzY3JpYmVyX2ZpbHRlcmlkX2pzXzEuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViLnR5cGUgPT09IFwiZXZlbnRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9wdGlvbihcInBvbGxpbmdcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfcG9sbGluZ19qc18xLlBvbGxpbmdFdmVudFN1YnNjcmliZXIodGhpcywgc3ViLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN1YnNjcmliZXJfZmlsdGVyaWRfanNfMS5GaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcih0aGlzLCBzdWIuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcnBoYW5lZCBMb2dzIGFyZSBoYW5kbGVkIGF1dG9tYXRpY2FsbHksIGJ5IHRoZSBmaWx0ZXIsIHNpbmNlXG4gICAgICAgIC8vIGxvZ3Mgd2l0aCByZW1vdmVkIGFyZSBlbWl0dGVkIGJ5IGl0XG4gICAgICAgIGlmIChzdWIudHlwZSA9PT0gXCJvcnBoYW5cIiAmJiBzdWIuZmlsdGVyLm9ycGhhbiA9PT0gXCJkcm9wLWxvZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcihcIm9ycGhhblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBvbmx5IGlmIHRoZSBbW19zdGFydF1dIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVhZHkoKSB7IHJldHVybiB0aGlzLiNub3RSZWFkeSA9PSBudWxsOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgJSV0eCUlIGFzIGEgbm9ybWFsaXplZCBKU09OLVJQQyB0cmFuc2FjdGlvbiByZXF1ZXN0LFxuICAgICAqICB3aGljaCBoYXMgYWxsIHZhbHVlcyBoZXhsaWZpZWQgYW5kIGFueSBudW1lcmljIHZhbHVlcyBjb252ZXJ0ZWRcbiAgICAgKiAgdG8gUXVhbnRpdHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldFJwY1RyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAvLyBKU09OLVJQQyBub3cgcmVxdWlyZXMgbnVtZXJpYyB2YWx1ZXMgdG8gYmUgXCJxdWFudGl0eVwiIHZhbHVlc1xuICAgICAgICBbXCJjaGFpbklkXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcInR5cGVcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidmFsdWVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRzdEtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGRzdEtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZHN0S2V5XSA9ICgwLCBpbmRleF9qc181LnRvUXVhbnRpdHkpKCgwLCBpbmRleF9qc181LmdldEJpZ0ludCkodHhba2V5XSwgYHR4LiR7a2V5fWApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhZGRyZXNzZXMgYW5kIGRhdGEgYXJlIGxvd2VyY2FzZVxuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gKDAsIGluZGV4X2pzXzUuaGV4bGlmeSkodHhba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGFjY2VzcyBsaXN0IG9iamVjdFxuICAgICAgICBpZiAodHguYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9ICgwLCBpbmRleF9qc180LmFjY2Vzc0xpc3RpZnkpKHR4LmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSByZXF1ZXN0IG1ldGhvZCBhbmQgYXJndW1lbnRzIHJlcXVpcmVkIHRvIHBlcmZvcm1cbiAgICAgKiAgJSVyZXElJS5cbiAgICAgKi9cbiAgICBnZXRScGNSZXF1ZXN0KHJlcSkge1xuICAgICAgICBzd2l0Y2ggKHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjaGFpbklkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9jaGFpbklkXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRob2Q6IFwiZXRoX2dhc1ByaWNlXCIsIGFyZ3M6IFtdIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbZ2V0TG93ZXJDYXNlKHJlcS5hZGRyZXNzKSwgcmVxLmJsb2NrVGFnXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0U3RvcmFnZUF0XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldExvd2VyQ2FzZShyZXEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIweFwiICsgcmVxLnBvc2l0aW9uLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuYmxvY2tUYWdcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRjYXN0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLnNpZ25lZFRyYW5zYWN0aW9uXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAoXCJibG9ja1RhZ1wiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmJsb2NrVGFnLCAhIXJlcS5pbmNsdWRlVHJhbnNhY3Rpb25zXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImJsb2NrSGFzaFwiIGluIHJlcSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja0J5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3JlcS5ibG9ja0hhc2gsICEhcmVxLmluY2x1ZGVUcmFuc2FjdGlvbnNdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbcmVxLmhhc2hdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbiksIHJlcS5ibG9ja1RhZ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2VzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt0aGlzLmdldFJwY1RyYW5zYWN0aW9uKHJlcS50cmFuc2FjdGlvbildXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5maWx0ZXIgJiYgcmVxLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLmZpbHRlci5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gcmVxLmZpbHRlci5hZGRyZXNzLm1hcChnZXRMb3dlckNhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHJlcS5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0aG9kOiBcImV0aF9nZXRMb2dzXCIsIGFyZ3M6IFtyZXEuZmlsdGVyXSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhbiBldGhlcnMtc3R5bGUgRXJyb3IgZm9yIHRoZSBnaXZlbiBKU09OLVJQQyBlcnJvclxuICAgICAqICAlJXBheWxvYWQlJSwgY29hbGVzY2luZyB0aGUgdmFyaW91cyBzdHJpbmdzIGFuZCBlcnJvciBzaGFwZXNcbiAgICAgKiAgdGhhdCBkaWZmZXJlbnQgbm9kZXMgcmV0dXJuLCBjb2VyY2luZyB0aGVtIGludG8gYSBtYWNoaW5lLXJlYWRhYmxlXG4gICAgICogIHN0YW5kYXJkaXplZCBlcnJvci5cbiAgICAgKi9cbiAgICBnZXRScGNFcnJvcihwYXlsb2FkLCBfZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IF9lcnJvcjtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJldGhfZXN0aW1hdGVHYXNcIiAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtc2cubWF0Y2goL3JldmVydC9pKSAmJiBtc2cubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwiaW5zdWZmaWNpZW50IGZ1bmRzXCIsIFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IChwYXlsb2FkLnBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgcGF5bG9hZCwgZXJyb3IgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX2NhbGxcIiB8fCBtZXRob2QgPT09IFwiZXRoX2VzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmtEYXRhKGVycm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBpbmRleF9qc18xLkFiaUNvZGVyLmdldEJ1aWx0aW5DYWxsRXhjZXB0aW9uKChtZXRob2QgPT09IFwiZXRoX2NhbGxcIikgPyBcImNhbGxcIiA6IFwiZXN0aW1hdGVHYXNcIiwgKHBheWxvYWQucGFyYW1zWzBdKSwgKHJlc3VsdCA/IHJlc3VsdC5kYXRhIDogbnVsbCkpO1xuICAgICAgICAgICAgZS5pbmZvID0geyBlcnJvciwgcGF5bG9hZCB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBlc3RpbWF0ZUdhcyBhbmQgY2FsbCBjYW4gcmV0dXJuIGFyYml0cmFyeSBjb250cmFjdC1kZWZpbmVkIHRleHQsIHNvIG5vdyB3ZVxuICAgICAgICAvLyB3ZSBjYW4gcHJvY2VzcyB0ZXh0IHNhZmVseS5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHNwZWx1bmtNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkfGV0aGVycy11c2VyLWRlbmllZC9pKSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTWFwID0ge1xuICAgICAgICAgICAgICAgIGV0aF9zaWduOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgcGVyc29uYWxfc2lnbjogXCJzaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBcInNpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXRoX3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgd2FsbGV0X3JlcXVlc3RBY2NvdW50czogXCJyZXF1ZXN0QWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoYHVzZXIgcmVqZWN0ZWQgYWN0aW9uYCwgXCJBQ1RJT05fUkVKRUNURURcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKGFjdGlvbk1hcFttZXRob2RdIHx8IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICByZWFzb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBpbmZvOiB7IHBheWxvYWQsIGVycm9yIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiIHx8IG1ldGhvZCA9PT0gXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gKHBheWxvYWQucGFyYW1zWzBdKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgXCJJTlNVRkZJQ0lFTlRfRlVORFNcIiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UvaSkgJiYgbWVzc2FnZS5tYXRjaCgvdG9vIGxvdy9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIFwiTk9OQ0VfRVhQSVJFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hdGNoKC9yZXBsYWNlbWVudCB0cmFuc2FjdGlvbi9pKSAmJiBtZXNzYWdlLm1hdGNoKC91bmRlcnByaWNlZC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNS5tYWtlRXJyb3IpKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiLCB7IHRyYW5zYWN0aW9uLCBpbmZvOiB7IGVycm9yIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1ldGhvZCwgaW5mbzogeyB0cmFuc2FjdGlvbiwgaW5mbzogeyBlcnJvciB9IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zdXBwb3J0ZWQgPSAhIW1lc3NhZ2UubWF0Y2goL3RoZSBtZXRob2QgLiogZG9lcyBub3QgZXhpc3QvaSk7XG4gICAgICAgIGlmICghdW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5kZXRhaWxzICYmIGVycm9yLmRldGFpbHMuc3RhcnRzV2l0aChcIlVuYXV0aG9yaXplZCBtZXRob2Q6XCIpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogcGF5bG9hZC5tZXRob2QsIGluZm86IHsgZXJyb3IsIHBheWxvYWQgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJjb3VsZCBub3QgY29hbGVzY2UgZXJyb3JcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgZXJyb3IsIHBheWxvYWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXF1ZXN0cyB0aGUgJSVtZXRob2QlJSB3aXRoICUlcGFyYW1zJSUgdmlhIHRoZSBKU09OLVJQQyBwcm90b2NvbFxuICAgICAqICBvdmVyIHRoZSB1bmRlcmx5aW5nIGNoYW5uZWwuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsbCBtZXRob2RzXG4gICAgICogIG9uIHRoZSBiYWNrZW5kIHRoYXQgZG8gbm90IGhhdmUgYSBoaWdoLWxldmVsIEFQSSB3aXRoaW4gdGhlIFByb3ZpZGVyXG4gICAgICogIEFQSS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBxdWV1ZXMgcmVxdWVzdHMgYWNjb3JkaW5nIHRvIHRoZSBiYXRjaCBjb25zdHJhaW50c1xuICAgICAqICBpbiB0aGUgb3B0aW9ucywgYXNzaWducyB0aGUgcmVxdWVzdCBhIHVuaXF1ZSBJRC5cbiAgICAgKlxuICAgICAqICAqKkRvIE5PVCBvdmVycmlkZSoqIHRoaXMgbWV0aG9kIGluIHN1Yi1jbGFzc2VzOyBpbnN0ZWFkXG4gICAgICogIG92ZXJyaWRlIFtbX3NlbmRdXSBvciBmb3JjZSB0aGUgb3B0aW9ucyB2YWx1ZXMgaW4gdGhlXG4gICAgICogIGNhbGwgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gQFRPRE86IGNhY2hlIGNoYWluSWQ/PyBwdXJnZSBvbiBzd2l0Y2hfbmV0d29ya3NcbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIGRlc3Ryb3llZDsgbm8gb3BlcmF0aW9ucyBhcmUgc3VwcG9ydGVkIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKDAsIGluZGV4X2pzXzUubWFrZUVycm9yKShcInByb3ZpZGVyIGRlc3Ryb3llZDsgY2FuY2VsbGVkIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IG1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLiNuZXh0SWQrKztcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3BheWxvYWRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlc29sdmUsIHJlamVjdCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IG1ldGhvZCwgcGFyYW1zLCBpZCwganNvbnJwYzogXCIyLjBcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdCBhIHBlbmRpbmcgZHJhaW5UaW1lciwgc2V0IG9uZVxuICAgICAgICB0aGlzLiNzY2hlZHVsZURyYWluKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIFtbU2lnbmVyXV0gYWNjb3VudCBmb3IgICUlYWRkcmVzcyUlIG1hbmFnZWQgYnlcbiAgICAgKiAgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqICBJZiB0aGUgJSVhZGRyZXNzJSUgaXMgYSBudW1iZXIsIGl0IGlzIHVzZWQgYXMgYW4gaW5kZXggaW4gdGhlXG4gICAgICogIHRoZSBhY2NvdW50cyBmcm9tIFtbbGlzdEFjY291bnRzXV0uXG4gICAgICpcbiAgICAgKiAgVGhpcyBjYW4gb25seSBiZSB1c2VkIG9uIGNsaWVudHMgd2hpY2ggbWFuYWdlIGFjY291bnRzIChzdWNoIGFzXG4gICAgICogIEdldGggd2l0aCBpbXBvcnRlZCBhY2NvdW50IG9yIE1ldGFNYXNrKS5cbiAgICAgKlxuICAgICAqICBUaHJvd3MgaWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50c1Byb21pc2UgPSB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICAvLyBBY2NvdW50IGluZGV4XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IChhd2FpdCBhY2NvdW50c1Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPj0gYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCBhY2NvdW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKHRoaXMsIGFjY291bnRzW2FkZHJlc3NdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSBhd2FpdCAoMCwgaW5kZXhfanNfNS5yZXNvbHZlUHJvcGVydGllcykoe1xuICAgICAgICAgICAgbmV0d29yazogdGhpcy5nZXROZXR3b3JrKCksXG4gICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHNQcm9taXNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBY2NvdW50IGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBpbmRleF9qc18yLmdldEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMi5nZXRBZGRyZXNzKShhY2NvdW50KSA9PT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFjY291bnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pO1xuICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiBuZXcgSnNvblJwY1NpZ25lcih0aGlzLCBhKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFN0b3AgcHJvY2Vzc2luZyByZXF1ZXN0c1xuICAgICAgICBpZiAodGhpcy4jZHJhaW5UaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RyYWluVGltZXIpO1xuICAgICAgICAgICAgdGhpcy4jZHJhaW5UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FuY2VsIGFsbCBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkLCByZWplY3QgfSBvZiB0aGlzLiNwYXlsb2Fkcykge1xuICAgICAgICAgICAgcmVqZWN0KCgwLCBpbmRleF9qc181Lm1ha2VFcnJvcikoXCJwcm92aWRlciBkZXN0cm95ZWQ7IGNhbmNlbGxlZCByZXF1ZXN0XCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBwYXlsb2FkLm1ldGhvZCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF5bG9hZHMgPSBbXTtcbiAgICAgICAgLy8gUGFyZW50IGNsZWFuLXVwXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNBcGlQcm92aWRlciA9IEpzb25ScGNBcGlQcm92aWRlcjtcbi8vIEBUT0RPOiByZW1vdmUgdGhpcyBpbiB2NywgaXQgaXMgbm90IGV4cG9ydGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbmFsaXR5XG4vLyBpcyBleHBvc2VkIGluIHRoZSBKc29uUnBjQXBpUHJvdmlkZXIgYnkgc2V0dGluZyBwb2xsaW5nIHRvIHRydWUuIEl0IHNob3VsZFxuLy8gYmUgc2FmZSB0byByZW1vdmUgcmVnYXJkbGVzcywgYmVjYXVzZSBpdCBpc24ndCByZWFjaGFibGUsIGJ1dCBqdXN0IGluIGNhc2UuXG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuY2xhc3MgSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciBleHRlbmRzIEpzb25ScGNBcGlQcm92aWRlciB7XG4gICAgI3BvbGxpbmdJbnRlcnZhbDtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiNwb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgIH1cbiAgICBfZ2V0U3Vic2NyaWJlcihzdWIpIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHN1cGVyLl9nZXRTdWJzY3JpYmVyKHN1Yik7XG4gICAgICAgIGlmIChpc1BvbGxhYmxlKHN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBwb2xsaW5nIGludGVydmFsIChkZWZhdWx0OiA0MDAwIG1zKVxuICAgICAqL1xuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7IHJldHVybiB0aGlzLiNwb2xsaW5nSW50ZXJ2YWw7IH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludGVydmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3BvbGxpbmdJbnRlcnZhbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoU3Vic2NyaWJlcigoc3ViKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQb2xsYWJsZShzdWIpKSB7XG4gICAgICAgICAgICAgICAgc3ViLnBvbGxpbmdJbnRlcnZhbCA9IHRoaXMuI3BvbGxpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyID0gSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlcjtcbi8qKlxuICogIFRoZSBKc29uUnBjUHJvdmlkZXIgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbiBQcm92aWRlcnMsXG4gKiAgd2hpY2ggcGVyZm9ybXMgYWxsIG9wZXJhdGlvbnMgb3ZlciBIVFRQIChvciBIVFRQUykgcmVxdWVzdHMuXG4gKlxuICogIEV2ZW50cyBhcmUgcHJvY2Vzc2VkIGJ5IHBvbGxpbmcgdGhlIGJhY2tlbmQgZm9yIHRoZSBjdXJyZW50IGJsb2NrXG4gKiAgbnVtYmVyOyB3aGVuIGl0IGFkdmFuY2VzLCBhbGwgYmxvY2stYmFzZSBldmVudHMgYXJlIHRoZW4gY2hlY2tlZFxuICogIGZvciB1cGRhdGVzLlxuICovXG5jbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjQXBpUG9sbGluZ1Byb3ZpZGVyIHtcbiAgICAjY29ubmVjdDtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29yaywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSBuZXcgaW5kZXhfanNfNS5GZXRjaFJlcXVlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Nvbm5lY3QgPSB1cmwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Nvbm5lY3QuY2xvbmUoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICAvLyBBbGwgcmVxdWVzdHMgYXJlIG92ZXIgSFRUUCwgc28gd2UgY2FuIGp1c3Qgc3RhcnQgaGFuZGxpbmcgcmVxdWVzdHNcbiAgICAgICAgLy8gV2UgZG8gdGhpcyBoZXJlIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYW55XG4gICAgICAgIC8vIHJlcXVlc3RzIHRvIHRoZSBuZXR3b3JrIChpLmUuIGV0aF9jaGFpbklkKSB1bnRpbCB3ZSBhYnNvbHV0ZWx5IGhhdmUgdG8uXG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmQocGF5bG9hZCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYSBQT1NUIGNvbm5lY3Rpb24gZm9yIHRoZSByZXF1ZXN0ZWQgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICByZXF1ZXN0LnNldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgIHJlc3BvbnNlLmFzc2VydE9rKCk7XG4gICAgICAgIGxldCByZXNwID0gcmVzcG9uc2UuYm9keUpzb247XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwKSkge1xuICAgICAgICAgICAgcmVzcCA9IFtyZXNwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNQcm92aWRlciA9IEpzb25ScGNQcm92aWRlcjtcbmZ1bmN0aW9uIHNwZWx1bmtEYXRhKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWVzc2FnZS5tYXRjaCgvcmV2ZXJ0L2kpICYmICgwLCBpbmRleF9qc181LmlzSGV4U3RyaW5nKSh2YWx1ZS5kYXRhKSkge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhOiB2YWx1ZS5kYXRhIH07XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3BlbHVua0RhdGEodmFsdWVba2V5XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlbHVua0RhdGEoSlNPTi5wYXJzZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX3NwZWx1bmtNZXNzYWdlKHZhbHVlLCByZXN1bHQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFNwZWx1bmsgZnVydGhlci4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX3NwZWx1bmtNZXNzYWdlKHZhbHVlW2tleV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTWlnaHQgYmUgYSBKU09OIHN0cmluZyB3ZSBjYW4gZnVydGhlciBkZXNjZW5kLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gX3NwZWx1bmtNZXNzYWdlKEpTT04ucGFyc2UodmFsdWUpLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3BlbHVua01lc3NhZ2UodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBfc3BlbHVua01lc3NhZ2UodmFsdWUsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLWpzb25ycGMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSnNvblJwY1Byb3ZpZGVyIiwiSnNvblJwY0FwaVBvbGxpbmdQcm92aWRlciIsIkpzb25ScGNBcGlQcm92aWRlciIsIkpzb25ScGNTaWduZXIiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiaW5kZXhfanNfNCIsImluZGV4X2pzXzUiLCJhYnN0cmFjdF9wcm92aWRlcl9qc18xIiwiYWJzdHJhY3Rfc2lnbmVyX2pzXzEiLCJuZXR3b3JrX2pzXzEiLCJzdWJzY3JpYmVyX2ZpbHRlcmlkX2pzXzEiLCJzdWJzY3JpYmVyX3BvbGxpbmdfanNfMSIsIlByaW1pdGl2ZSIsInNwbGl0IiwiZGVlcENvcHkiLCJpbmRleE9mIiwiZ2V0QWRkcmVzcyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImtleXMiLCJyZWR1Y2UiLCJhY2N1bSIsImtleSIsIkVycm9yIiwic3RhbGwiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldExvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwiaXNQb2xsYWJsZSIsInBvbGxpbmdJbnRlcnZhbCIsImRlZmF1bHRPcHRpb25zIiwicG9sbGluZyIsInN0YXRpY05ldHdvcmsiLCJiYXRjaFN0YWxsVGltZSIsImJhdGNoTWF4U2l6ZSIsImJhdGNoTWF4Q291bnQiLCJjYWNoZVRpbWVvdXQiLCJBYnN0cmFjdFNpZ25lciIsImNvbnN0cnVjdG9yIiwicHJvdmlkZXIiLCJhZGRyZXNzIiwiZGVmaW5lUHJvcGVydGllcyIsImNvbm5lY3QiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwidHgiLCJwb3B1bGF0ZUNhbGwiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJfdHgiLCJwcm9taXNlcyIsImZyb20iLCJfZnJvbSIsInB1c2giLCJyZXNvbHZlQWRkcmVzcyIsImFzc2VydEFyZ3VtZW50IiwiZ2FzTGltaXQiLCJlc3RpbWF0ZUdhcyIsInRvIiwiX3RvIiwibGVuZ3RoIiwiYWxsIiwiaGV4VHgiLCJnZXRScGNUcmFuc2FjdGlvbiIsInNlbmQiLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsImdldEJsb2NrTnVtYmVyIiwiaGFzaCIsInJlamVjdCIsInRpbWVvdXRzIiwiY2hlY2tUeCIsImdldFRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGVUcmFuc2FjdGlvbiIsIl9zZXRUaW1lb3V0IiwicG9wIiwic2lnblRyYW5zYWN0aW9uIiwic2lnbk1lc3NhZ2UiLCJfbWVzc2FnZSIsIm1lc3NhZ2UiLCJ0b1V0ZjhCeXRlcyIsImhleGxpZnkiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJfdmFsdWUiLCJwb3B1bGF0ZWQiLCJUeXBlZERhdGFFbmNvZGVyIiwicmVzb2x2ZU5hbWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFBheWxvYWQiLCJ1bmxvY2siLCJwYXNzd29yZCIsIl9sZWdhY3lTaWduTWVzc2FnZSIsIkFic3RyYWN0UHJvdmlkZXIiLCJvcHRpb25zIiwibmV4dElkIiwicGF5bG9hZHMiLCJkcmFpblRpbWVyIiwibm90UmVhZHkiLCJuZXR3b3JrIiwic2NoZWR1bGVEcmFpbiIsInN0YWxsVGltZSIsIl9nZXRPcHRpb24iLCJiYXRjaCIsInNoaWZ0IiwiYnl0ZXMiLCJwIiwicGF5bG9hZCIsInVuc2hpZnQiLCJlbWl0IiwiYWN0aW9uIiwicmVzdWx0IiwiX3NlbmQiLCJkZXN0cm95ZWQiLCJtYWtlRXJyb3IiLCJtZXRob2QiLCJyZXNwIiwiZmlsdGVyIiwiciIsImlkIiwiZXJyb3IiLCJpbmZvIiwiZ2V0UnBjRXJyb3IiLCJhc3NpZ24iLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJtYXRjaGVzIiwiX25ldHdvcmsiLCJfcGVyZm9ybSIsInJlcSIsInRyYW5zYWN0aW9uIiwidHlwZSIsImdldEJpZ0ludCIsIm1heEZlZVBlckdhcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0IiwiZ2V0UnBjUmVxdWVzdCIsImFyZ3MiLCJfZGV0ZWN0TmV0d29yayIsInJlYWR5IiwiTmV0d29yayIsInBhcmFtcyIsImpzb25ycGMiLCJfc3RhcnQiLCJjb25zb2xlIiwibG9nIiwiZXZlbnQiLCJfd2FpdFVudGlsUmVhZHkiLCJfZ2V0U3Vic2NyaWJlciIsInN1YiIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiLCJQb2xsaW5nRXZlbnRTdWJzY3JpYmVyIiwiRmlsdGVySWRFdmVudFN1YnNjcmliZXIiLCJvcnBoYW4iLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwiZm9yRWFjaCIsImRzdEtleSIsInRvUXVhbnRpdHkiLCJhY2Nlc3NMaXN0IiwiYWNjZXNzTGlzdGlmeSIsImJsb2NrVGFnIiwicG9zaXRpb24iLCJ0b1N0cmluZyIsInNpZ25lZFRyYW5zYWN0aW9uIiwiaW5jbHVkZVRyYW5zYWN0aW9ucyIsImJsb2NrSGFzaCIsIl9lcnJvciIsIm1zZyIsIm1hdGNoIiwic3BlbHVua0RhdGEiLCJlIiwiQWJpQ29kZXIiLCJnZXRCdWlsdGluQ2FsbEV4Y2VwdGlvbiIsImRhdGEiLCJzcGVsdW5rTWVzc2FnZSIsImFjdGlvbk1hcCIsImV0aF9zaWduIiwicGVyc29uYWxfc2lnbiIsImV0aF9zaWduVHlwZWREYXRhX3Y0IiwiZXRoX3NpZ25UcmFuc2FjdGlvbiIsImV0aF9zZW5kVHJhbnNhY3Rpb24iLCJldGhfcmVxdWVzdEFjY291bnRzIiwid2FsbGV0X3JlcXVlc3RBY2NvdW50cyIsInJlYXNvbiIsInVuc3VwcG9ydGVkIiwiZGV0YWlscyIsInN0YXJ0c1dpdGgiLCJnZXRTaWduZXIiLCJhY2NvdW50c1Byb21pc2UiLCJhY2NvdW50cyIsInJlc29sdmVQcm9wZXJ0aWVzIiwiZ2V0TmV0d29yayIsImFjY291bnQiLCJsaXN0QWNjb3VudHMiLCJhIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsInN1YnNjcmliZXIiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJfZm9yRWFjaFN1YnNjcmliZXIiLCJ1cmwiLCJGZXRjaFJlcXVlc3QiLCJjbG9uZSIsIl9nZXRDb25uZWN0aW9uIiwiYm9keSIsInNldEhlYWRlciIsInJlc3BvbnNlIiwiYXNzZXJ0T2siLCJib2R5SnNvbiIsImlzSGV4U3RyaW5nIiwicGFyc2UiLCJfc3BlbHVua01lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-pocket.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PocketProvider = void 0;\n/**\n *  [[link-pocket]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Polygon (``matic``)\n *  - Arbitrum (``arbitrum``)\n *\n *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]\n */ const index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\";\nfunction getHost(name) {\n    switch(name){\n        case \"mainnet\":\n            return \"eth-mainnet.gateway.pokt.network\";\n        case \"goerli\":\n            return \"eth-goerli.gateway.pokt.network\";\n        case \"matic\":\n            return \"poly-mainnet.gateway.pokt.network\";\n        case \"matic-mumbai\":\n            return \"polygon-mumbai-rpc.gateway.pokt.network\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **PocketProvider** connects to the [[link-pocket]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API key is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-pocket-signup).\n */ class PocketProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  Create a new **PocketProvider**.\n     *\n     *  By default connecting to ``mainnet`` with a highly throttled\n     *  API key.\n     */ constructor(_network, applicationId, applicationSecret){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        if (applicationSecret == null) {\n            applicationSecret = null;\n        }\n        const options = {\n            staticNetwork: network\n        };\n        const request = PocketProvider.getRequest(network, applicationId, applicationSecret);\n        super(request, network, options);\n        (0, index_js_1.defineProperties)(this, {\n            applicationId,\n            applicationSecret\n        });\n    }\n    _getProvider(chainId) {\n        try {\n            return new PocketProvider(chainId, this.applicationId, this.applicationSecret);\n        } catch (error) {}\n        return super._getProvider(chainId);\n    }\n    /**\n     *  Returns a prepared request for connecting to %%network%% with\n     *  %%applicationId%%.\n     */ static getRequest(network, applicationId, applicationSecret) {\n        if (applicationId == null) {\n            applicationId = defaultApplicationId;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`);\n        request.allowGzip = true;\n        if (applicationSecret) {\n            request.setCredentials(\"\", applicationSecret);\n        }\n        if (applicationId === defaultApplicationId) {\n            request.retryFunc = async (request, response, attempt)=>{\n                (0, community_js_1.showThrottleMessage)(\"PocketProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n    isCommunityResource() {\n        return this.applicationId === defaultApplicationId;\n    }\n}\nexports.PocketProvider = PocketProvider; //# sourceMappingURL=provider-pocket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItcG9ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQyxpQkFBaUJELG1CQUFPQSxDQUFDLHVGQUFnQjtBQUMvQyxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyxtRkFBYztBQUMzQyxNQUFNRyx3QkFBd0JILG1CQUFPQSxDQUFDLHFHQUF1QjtBQUM3RCxNQUFNSSx1QkFBdUI7QUFDN0IsU0FBU0MsUUFBUUMsSUFBSTtJQUNqQixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO0lBQ2Y7SUFDQyxJQUFHUCxXQUFXUSxjQUFjLEVBQUUsT0FBTyx1QkFBdUIsV0FBV0Q7QUFDNUU7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1SLHVCQUF1Qkssc0JBQXNCSyxlQUFlO0lBVTlEOzs7OztLQUtDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUIsQ0FBRTtRQUNwRCxJQUFJRixZQUFZLE1BQU07WUFDbEJBLFdBQVc7UUFDZjtRQUNBLE1BQU1HLFVBQVVYLGFBQWFZLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDTDtRQUMxQyxJQUFJQyxpQkFBaUIsTUFBTTtZQUN2QkEsZ0JBQWdCUDtRQUNwQjtRQUNBLElBQUlRLHFCQUFxQixNQUFNO1lBQzNCQSxvQkFBb0I7UUFDeEI7UUFDQSxNQUFNSSxVQUFVO1lBQUVDLGVBQWVKO1FBQVE7UUFDekMsTUFBTUssVUFBVXBCLGVBQWVxQixVQUFVLENBQUNOLFNBQVNGLGVBQWVDO1FBQ2xFLEtBQUssQ0FBQ00sU0FBU0wsU0FBU0c7UUFDdkIsSUFBR2pCLFdBQVdxQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRVQ7WUFBZUM7UUFBa0I7SUFDOUU7SUFDQVMsYUFBYUMsT0FBTyxFQUFFO1FBQ2xCLElBQUk7WUFDQSxPQUFPLElBQUl4QixlQUFld0IsU0FBUyxJQUFJLENBQUNYLGFBQWEsRUFBRSxJQUFJLENBQUNDLGlCQUFpQjtRQUNqRixFQUNBLE9BQU9XLE9BQU8sQ0FBRTtRQUNoQixPQUFPLEtBQUssQ0FBQ0YsYUFBYUM7SUFDOUI7SUFDQTs7O0tBR0MsR0FDRCxPQUFPSCxXQUFXTixPQUFPLEVBQUVGLGFBQWEsRUFBRUMsaUJBQWlCLEVBQUU7UUFDekQsSUFBSUQsaUJBQWlCLE1BQU07WUFDdkJBLGdCQUFnQlA7UUFDcEI7UUFDQSxNQUFNYyxVQUFVLElBQUluQixXQUFXeUIsWUFBWSxDQUFDLENBQUMsU0FBUyxFQUFFbkIsUUFBUVEsUUFBUVAsSUFBSSxFQUFFLE9BQU8sRUFBRUssY0FBYyxDQUFDO1FBQ3RHTyxRQUFRTyxTQUFTLEdBQUc7UUFDcEIsSUFBSWIsbUJBQW1CO1lBQ25CTSxRQUFRUSxjQUFjLENBQUMsSUFBSWQ7UUFDL0I7UUFDQSxJQUFJRCxrQkFBa0JQLHNCQUFzQjtZQUN4Q2MsUUFBUVMsU0FBUyxHQUFHLE9BQU9ULFNBQVNVLFVBQVVDO2dCQUN6QyxJQUFHNUIsZUFBZTZCLG1CQUFtQixFQUFFO2dCQUN4QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU9aO0lBQ1g7SUFDQWEsc0JBQXNCO1FBQ2xCLE9BQVEsSUFBSSxDQUFDcEIsYUFBYSxLQUFLUDtJQUNuQztBQUNKO0FBQ0FSLHNCQUFzQixHQUFHRSxnQkFDekIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLXBvY2tldC5qcz8xN2I5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2NrZXRQcm92aWRlciA9IHZvaWQgMDtcbi8qKlxuICogIFtbbGluay1wb2NrZXRdXSBwcm92aWRlcyBhIHRoaXJkLXBhcnR5IHNlcnZpY2UgZm9yIGNvbm5lY3RpbmcgdG9cbiAqICB2YXJpb3VzIGJsb2NrY2hhaW5zIG92ZXIgSlNPTi1SUEMuXG4gKlxuICogICoqU3VwcG9ydGVkIE5ldHdvcmtzKipcbiAqXG4gKiAgLSBFdGhlcmV1bSBNYWlubmV0IChgYG1haW5uZXRgYClcbiAqICAtIEdvZXJsaSBUZXN0bmV0IChgYGdvZXJsaWBgKVxuICogIC0gUG9seWdvbiAoYGBtYXRpY2BgKVxuICogIC0gQXJiaXRydW0gKGBgYXJiaXRydW1gYClcbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvcHJvdmlkZXJzL3RoaXJkcGFydHk6UG9ja2V0ICBbcHJvdmlkZXJzLXBvY2tldF1cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGNvbW11bml0eV9qc18xID0gcmVxdWlyZShcIi4vY29tbXVuaXR5LmpzXCIpO1xuY29uc3QgbmV0d29ya19qc18xID0gcmVxdWlyZShcIi4vbmV0d29yay5qc1wiKTtcbmNvbnN0IHByb3ZpZGVyX2pzb25ycGNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWpzb25ycGMuanNcIik7XG5jb25zdCBkZWZhdWx0QXBwbGljYXRpb25JZCA9IFwiNjJlMWFkNTFiMzdiOGUwMDM5NGJkYTNiXCI7XG5mdW5jdGlvbiBnZXRIb3N0KG5hbWUpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1tYWlubmV0LmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aC1nb2VybGkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJwb2x5LW1haW5uZXQuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgY2FzZSBcIm1hdGljLW11bWJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvbi1tdW1iYWktcnBjLmdhdGV3YXkucG9rdC5uZXR3b3JrXCI7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuYW1lKTtcbn1cbi8qKlxuICogIFRoZSAqKlBvY2tldFByb3ZpZGVyKiogY29ubmVjdHMgdG8gdGhlIFtbbGluay1wb2NrZXRdXVxuICogIEpTT04tUlBDIGVuZC1wb2ludHMuXG4gKlxuICogIEJ5IGRlZmF1bHQsIGEgaGlnaGx5LXRocm90dGxlZCBBUEkga2V5IGlzIHVzZWQsIHdoaWNoIGlzXG4gKiAgYXBwcm9wcmlhdGUgZm9yIHF1aWNrIHByb3RvdHlwZXMgYW5kIHNpbXBsZSBzY3JpcHRzLiBUb1xuICogIGdhaW4gYWNjZXNzIHRvIGFuIGluY3JlYXNlZCByYXRlLWxpbWl0LCBpdCBpcyBoaWdobHlcbiAqICByZWNvbW1lbmRlZCB0byBbc2lnbiB1cCBoZXJlXShsaW5rLXBvY2tldC1zaWdudXApLlxuICovXG5jbGFzcyBQb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgQXBwbGljYXRpb24gSUQgZm9yIHRoZSBQb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhcHBsaWNhdGlvbklkO1xuICAgIC8qKlxuICAgICAqICBUaGUgQXBwbGljYXRpb24gU2VjcmV0IGZvciBtYWtpbmcgYXV0aGVudGljYXRlZCByZXF1ZXN0c1xuICAgICAqICB0byB0aGUgUG9ja2V0IGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgYXBwbGljYXRpb25TZWNyZXQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvY2tldFByb3ZpZGVyKiouXG4gICAgICpcbiAgICAgKiAgQnkgZGVmYXVsdCBjb25uZWN0aW5nIHRvIGBgbWFpbm5ldGBgIHdpdGggYSBoaWdobHkgdGhyb3R0bGVkXG4gICAgICogIEFQSSBrZXkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25ldHdvcmssIGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uU2VjcmV0KSB7XG4gICAgICAgIGlmIChfbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICBfbmV0d29yayA9IFwibWFpbm5ldFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrX2pzXzEuTmV0d29yay5mcm9tKF9uZXR3b3JrKTtcbiAgICAgICAgaWYgKGFwcGxpY2F0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZCA9IGRlZmF1bHRBcHBsaWNhdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBsaWNhdGlvblNlY3JldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhcHBsaWNhdGlvblNlY3JldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgc3RhdGljTmV0d29yazogbmV0d29yayB9O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gUG9ja2V0UHJvdmlkZXIuZ2V0UmVxdWVzdChuZXR3b3JrLCBhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvblNlY3JldCk7XG4gICAgICAgIHN1cGVyKHJlcXVlc3QsIG5ldHdvcmssIG9wdGlvbnMpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uU2VjcmV0IH0pO1xuICAgIH1cbiAgICBfZ2V0UHJvdmlkZXIoY2hhaW5JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2NrZXRQcm92aWRlcihjaGFpbklkLCB0aGlzLmFwcGxpY2F0aW9uSWQsIHRoaXMuYXBwbGljYXRpb25TZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgcHJlcGFyZWQgcmVxdWVzdCBmb3IgY29ubmVjdGluZyB0byAlJW5ldHdvcmslJSB3aXRoXG4gICAgICogICUlYXBwbGljYXRpb25JZCUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSZXF1ZXN0KG5ldHdvcmssIGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uU2VjcmV0KSB7XG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGluZGV4X2pzXzEuRmV0Y2hSZXF1ZXN0KGBodHRwczovXFwvJHtnZXRIb3N0KG5ldHdvcmsubmFtZSl9L3YxL2xiLyR7YXBwbGljYXRpb25JZH1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICBpZiAoYXBwbGljYXRpb25TZWNyZXQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgYXBwbGljYXRpb25TZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBsaWNhdGlvbklkID09PSBkZWZhdWx0QXBwbGljYXRpb25JZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZXRyeUZ1bmMgPSBhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY29tbXVuaXR5X2pzXzEuc2hvd1Rocm90dGxlTWVzc2FnZSkoXCJQb2NrZXRQcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcHBsaWNhdGlvbklkID09PSBkZWZhdWx0QXBwbGljYXRpb25JZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2NrZXRQcm92aWRlciA9IFBvY2tldFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItcG9ja2V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvY2tldFByb3ZpZGVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJjb21tdW5pdHlfanNfMSIsIm5ldHdvcmtfanNfMSIsInByb3ZpZGVyX2pzb25ycGNfanNfMSIsImRlZmF1bHRBcHBsaWNhdGlvbklkIiwiZ2V0SG9zdCIsIm5hbWUiLCJhc3NlcnRBcmd1bWVudCIsIkpzb25ScGNQcm92aWRlciIsImNvbnN0cnVjdG9yIiwiX25ldHdvcmsiLCJhcHBsaWNhdGlvbklkIiwiYXBwbGljYXRpb25TZWNyZXQiLCJuZXR3b3JrIiwiTmV0d29yayIsImZyb20iLCJvcHRpb25zIiwic3RhdGljTmV0d29yayIsInJlcXVlc3QiLCJnZXRSZXF1ZXN0IiwiZGVmaW5lUHJvcGVydGllcyIsIl9nZXRQcm92aWRlciIsImNoYWluSWQiLCJlcnJvciIsIkZldGNoUmVxdWVzdCIsImFsbG93R3ppcCIsInNldENyZWRlbnRpYWxzIiwicmV0cnlGdW5jIiwicmVzcG9uc2UiLCJhdHRlbXB0Iiwic2hvd1Rocm90dGxlTWVzc2FnZSIsImlzQ29tbXVuaXR5UmVzb3VyY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-pocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  [[link-quicknode]] provides a third-party service for connecting to\n *  various blockchains over JSON-RPC.\n *\n *  **Supported Networks**\n *\n *  - Ethereum Mainnet (``mainnet``)\n *  - Goerli Testnet (``goerli``)\n *  - Arbitrum (``arbitrum``)\n *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)\n *  - Optimism (``optimism``)\n *  - Optimism Goerli Testnet (``optimism-goerli``)\n *  - Polygon (``matic``)\n *  - Polygon Mumbai Testnet (``matic-mumbai``)\n *\n *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QuickNodeProvider = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst community_js_1 = __webpack_require__(/*! ./community.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/community.js\");\nconst network_js_1 = __webpack_require__(/*! ./network.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/network.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\nconst defaultToken = \"919b412a057b5e9c9b6dce193c5a60242d6efadb\";\nfunction getHost(name) {\n    switch(name){\n        case \"mainnet\":\n            return \"ethers.quiknode.pro\";\n        case \"goerli\":\n            return \"ethers.ethereum-goerli.quiknode.pro\";\n        //case \"sepolia\":\n        //    return \"sepolia.infura.io\";\n        case \"arbitrum\":\n            return \"ethers.arbitrum-mainnet.quiknode.pro\";\n        case \"arbitrum-goerli\":\n            return \"ethers.arbitrum-goerli.quiknode.pro\";\n        case \"matic\":\n            return \"ethers.matic.quiknode.pro\";\n        case \"matic-mumbai\":\n            return \"ethers.matic-testnet.quiknode.pro\";\n        case \"optimism\":\n            return \"ethers.optimism.quiknode.pro\";\n        case \"optimism-goerli\":\n            return \"ethers.optimism-goerli.quiknode.pro\";\n    }\n    (0, index_js_1.assertArgument)(false, \"unsupported network\", \"network\", name);\n}\n/**\n *  The **QuickNodeProvider** connects to the [[link-quicknode]]\n *  JSON-RPC end-points.\n *\n *  By default, a highly-throttled API token is used, which is\n *  appropriate for quick prototypes and simple scripts. To\n *  gain access to an increased rate-limit, it is highly\n *  recommended to [sign up here](link-quicknode).\n */ class QuickNodeProvider extends provider_jsonrpc_js_1.JsonRpcProvider {\n    /**\n     *  Creates a new **QuickNodeProvider**.\n     */ constructor(_network, token){\n        if (_network == null) {\n            _network = \"mainnet\";\n        }\n        const network = network_js_1.Network.from(_network);\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = QuickNodeProvider.getRequest(network, token);\n        super(request, network, {\n            staticNetwork: network\n        });\n        (0, index_js_1.defineProperties)(this, {\n            token\n        });\n    }\n    _getProvider(chainId) {\n        try {\n            return new QuickNodeProvider(chainId, this.token);\n        } catch (error) {}\n        return super._getProvider(chainId);\n    }\n    isCommunityResource() {\n        return this.token === defaultToken;\n    }\n    /**\n     *  Returns a new request prepared for %%network%% and the\n     *  %%token%%.\n     */ static getRequest(network, token) {\n        if (token == null) {\n            token = defaultToken;\n        }\n        const request = new index_js_1.FetchRequest(`https:/\\/${getHost(network.name)}/${token}`);\n        request.allowGzip = true;\n        //if (projectSecret) { request.setCredentials(\"\", projectSecret); }\n        if (token === defaultToken) {\n            request.retryFunc = async (request, response, attempt)=>{\n                (0, community_js_1.showThrottleMessage)(\"QuickNodeProvider\");\n                return true;\n            };\n        }\n        return request;\n    }\n}\nexports.QuickNodeProvider = QuickNodeProvider; //# sourceMappingURL=provider-quicknode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsdUZBQWdCO0FBQy9DLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1HLHdCQUF3QkgsbUJBQU9BLENBQUMscUdBQXVCO0FBQzdELE1BQU1JLGVBQWU7QUFDckIsU0FBU0MsUUFBUUMsSUFBSTtJQUNqQixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxpQkFBaUI7UUFDakIsaUNBQWlDO1FBQ2pDLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztJQUNmO0lBQ0MsSUFBR1AsV0FBV1EsY0FBYyxFQUFFLE9BQU8sdUJBQXVCLFdBQVdEO0FBQzVFO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNUiwwQkFBMEJLLHNCQUFzQkssZUFBZTtJQUtqRTs7S0FFQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssQ0FBRTtRQUN6QixJQUFJRCxZQUFZLE1BQU07WUFDbEJBLFdBQVc7UUFDZjtRQUNBLE1BQU1FLFVBQVVWLGFBQWFXLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDSjtRQUMxQyxJQUFJQyxTQUFTLE1BQU07WUFDZkEsUUFBUVA7UUFDWjtRQUNBLE1BQU1XLFVBQVVqQixrQkFBa0JrQixVQUFVLENBQUNKLFNBQVNEO1FBQ3RELEtBQUssQ0FBQ0ksU0FBU0gsU0FBUztZQUFFSyxlQUFlTDtRQUFRO1FBQ2hELElBQUdiLFdBQVdtQixnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRVA7UUFBTTtJQUNuRDtJQUNBUSxhQUFhQyxPQUFPLEVBQUU7UUFDbEIsSUFBSTtZQUNBLE9BQU8sSUFBSXRCLGtCQUFrQnNCLFNBQVMsSUFBSSxDQUFDVCxLQUFLO1FBQ3BELEVBQ0EsT0FBT1UsT0FBTyxDQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDRixhQUFhQztJQUM5QjtJQUNBRSxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNYLEtBQUssS0FBS1A7SUFDM0I7SUFDQTs7O0tBR0MsR0FDRCxPQUFPWSxXQUFXSixPQUFPLEVBQUVELEtBQUssRUFBRTtRQUM5QixJQUFJQSxTQUFTLE1BQU07WUFDZkEsUUFBUVA7UUFDWjtRQUNBLE1BQU1XLFVBQVUsSUFBSWhCLFdBQVd3QixZQUFZLENBQUMsQ0FBQyxTQUFTLEVBQUVsQixRQUFRTyxRQUFRTixJQUFJLEVBQUUsQ0FBQyxFQUFFSyxNQUFNLENBQUM7UUFDeEZJLFFBQVFTLFNBQVMsR0FBRztRQUNwQixtRUFBbUU7UUFDbkUsSUFBSWIsVUFBVVAsY0FBYztZQUN4QlcsUUFBUVUsU0FBUyxHQUFHLE9BQU9WLFNBQVNXLFVBQVVDO2dCQUN6QyxJQUFHMUIsZUFBZTJCLG1CQUFtQixFQUFFO2dCQUN4QyxPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU9iO0lBQ1g7QUFDSjtBQUNBbkIseUJBQXlCLEdBQUdFLG1CQUM1Qiw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItcXVpY2tub2RlLmpzPzlkZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBbW2xpbmstcXVpY2tub2RlXV0gcHJvdmlkZXMgYSB0aGlyZC1wYXJ0eSBzZXJ2aWNlIGZvciBjb25uZWN0aW5nIHRvXG4gKiAgdmFyaW91cyBibG9ja2NoYWlucyBvdmVyIEpTT04tUlBDLlxuICpcbiAqICAqKlN1cHBvcnRlZCBOZXR3b3JrcyoqXG4gKlxuICogIC0gRXRoZXJldW0gTWFpbm5ldCAoYGBtYWlubmV0YGApXG4gKiAgLSBHb2VybGkgVGVzdG5ldCAoYGBnb2VybGlgYClcbiAqICAtIEFyYml0cnVtIChgYGFyYml0cnVtYGApXG4gKiAgLSBBcmJpdHJ1bSBHb2VybGkgVGVzdG5ldCAoYGBhcmJpdHJ1bS1nb2VybGlgYClcbiAqICAtIE9wdGltaXNtIChgYG9wdGltaXNtYGApXG4gKiAgLSBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldCAoYGBvcHRpbWlzbS1nb2VybGlgYClcbiAqICAtIFBvbHlnb24gKGBgbWF0aWNgYClcbiAqICAtIFBvbHlnb24gTXVtYmFpIFRlc3RuZXQgKGBgbWF0aWMtbXVtYmFpYGApXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3Byb3ZpZGVycy90aGlyZHBhcnR5OlF1aWNrTm9kZSAgW3Byb3ZpZGVycy1xdWlja25vZGVdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgY29tbXVuaXR5X2pzXzEgPSByZXF1aXJlKFwiLi9jb21tdW5pdHkuanNcIik7XG5jb25zdCBuZXR3b3JrX2pzXzEgPSByZXF1aXJlKFwiLi9uZXR3b3JrLmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbmNvbnN0IGRlZmF1bHRUb2tlbiA9IFwiOTE5YjQxMmEwNTdiNWU5YzliNmRjZTE5M2M1YTYwMjQyZDZlZmFkYlwiO1xuZnVuY3Rpb24gZ2V0SG9zdChuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCJtYWlubmV0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5ldGhlcmV1bS1nb2VybGkucXVpa25vZGUucHJvXCI7XG4gICAgICAgIC8vY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgLy8gICAgcmV0dXJuIFwic2Vwb2xpYS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMuYXJiaXRydW0tbWFpbm5ldC5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLmFyYml0cnVtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJldGhlcnMubWF0aWMucXVpa25vZGUucHJvXCI7XG4gICAgICAgIGNhc2UgXCJtYXRpYy1tdW1iYWlcIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5tYXRpYy10ZXN0bmV0LnF1aWtub2RlLnByb1wiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgIHJldHVybiBcImV0aGVycy5vcHRpbWlzbS5xdWlrbm9kZS5wcm9cIjtcbiAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJzLm9wdGltaXNtLWdvZXJsaS5xdWlrbm9kZS5wcm9cIjtcbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xufVxuLyoqXG4gKiAgVGhlICoqUXVpY2tOb2RlUHJvdmlkZXIqKiBjb25uZWN0cyB0byB0aGUgW1tsaW5rLXF1aWNrbm9kZV1dXG4gKiAgSlNPTi1SUEMgZW5kLXBvaW50cy5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgYSBoaWdobHktdGhyb3R0bGVkIEFQSSB0b2tlbiBpcyB1c2VkLCB3aGljaCBpc1xuICogIGFwcHJvcHJpYXRlIGZvciBxdWljayBwcm90b3R5cGVzIGFuZCBzaW1wbGUgc2NyaXB0cy4gVG9cbiAqICBnYWluIGFjY2VzcyB0byBhbiBpbmNyZWFzZWQgcmF0ZS1saW1pdCwgaXQgaXMgaGlnaGx5XG4gKiAgcmVjb21tZW5kZWQgdG8gW3NpZ24gdXAgaGVyZV0obGluay1xdWlja25vZGUpLlxuICovXG5jbGFzcyBRdWlja05vZGVQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgQVBJIHRva2VuLlxuICAgICAqL1xuICAgIHRva2VuO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3ICoqUXVpY2tOb2RlUHJvdmlkZXIqKi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfbmV0d29yaywgdG9rZW4pIHtcbiAgICAgICAgaWYgKF9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgIF9uZXR3b3JrID0gXCJtYWlubmV0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtfanNfMS5OZXR3b3JrLmZyb20oX25ldHdvcmspO1xuICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4gPSBkZWZhdWx0VG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IFF1aWNrTm9kZVByb3ZpZGVyLmdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pO1xuICAgICAgICBzdXBlcihyZXF1ZXN0LCBuZXR3b3JrLCB7IHN0YXRpY05ldHdvcms6IG5ldHdvcmsgfSk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHsgdG9rZW4gfSk7XG4gICAgfVxuICAgIF9nZXRQcm92aWRlcihjaGFpbklkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1aWNrTm9kZVByb3ZpZGVyKGNoYWluSWQsIHRoaXMudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBzdXBlci5fZ2V0UHJvdmlkZXIoY2hhaW5JZCk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50b2tlbiA9PT0gZGVmYXVsdFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgcmVxdWVzdCBwcmVwYXJlZCBmb3IgJSVuZXR3b3JrJSUgYW5kIHRoZVxuICAgICAqICAlJXRva2VuJSUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFJlcXVlc3QobmV0d29yaywgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHRva2VuID0gZGVmYXVsdFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgaW5kZXhfanNfMS5GZXRjaFJlcXVlc3QoYGh0dHBzOi9cXC8ke2dldEhvc3QobmV0d29yay5uYW1lKX0vJHt0b2tlbn1gKTtcbiAgICAgICAgcmVxdWVzdC5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICAvL2lmIChwcm9qZWN0U2VjcmV0KSB7IHJlcXVlc3Quc2V0Q3JlZGVudGlhbHMoXCJcIiwgcHJvamVjdFNlY3JldCk7IH1cbiAgICAgICAgaWYgKHRva2VuID09PSBkZWZhdWx0VG9rZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3QucmV0cnlGdW5jID0gYXN5bmMgKHJlcXVlc3QsIHJlc3BvbnNlLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNvbW11bml0eV9qc18xLnNob3dUaHJvdHRsZU1lc3NhZ2UpKFwiUXVpY2tOb2RlUHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuUXVpY2tOb2RlUHJvdmlkZXIgPSBRdWlja05vZGVQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLXF1aWNrbm9kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJRdWlja05vZGVQcm92aWRlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiY29tbXVuaXR5X2pzXzEiLCJuZXR3b3JrX2pzXzEiLCJwcm92aWRlcl9qc29ucnBjX2pzXzEiLCJkZWZhdWx0VG9rZW4iLCJnZXRIb3N0IiwibmFtZSIsImFzc2VydEFyZ3VtZW50IiwiSnNvblJwY1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJfbmV0d29yayIsInRva2VuIiwibmV0d29yayIsIk5ldHdvcmsiLCJmcm9tIiwicmVxdWVzdCIsImdldFJlcXVlc3QiLCJzdGF0aWNOZXR3b3JrIiwiZGVmaW5lUHJvcGVydGllcyIsIl9nZXRQcm92aWRlciIsImNoYWluSWQiLCJlcnJvciIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJGZXRjaFJlcXVlc3QiLCJhbGxvd0d6aXAiLCJyZXRyeUZ1bmMiLCJyZXNwb25zZSIsImF0dGVtcHQiLCJzaG93VGhyb3R0bGVNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-quicknode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-socket.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;\nconst abstract_provider_js_1 = __webpack_require__(/*! ./abstract-provider.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-provider.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst provider_jsonrpc_js_1 = __webpack_require__(/*! ./provider-jsonrpc.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js\");\n/**\n *  A **SocketSubscriber** uses a socket transport to handle events and\n *  should use [[_emit]] to manage the events.\n */ class SocketSubscriber {\n    #provider;\n    #filter;\n    /**\n     *  The filter.\n     */ get filter() {\n        return JSON.parse(this.#filter);\n    }\n    #filterId;\n    #paused;\n    #emitPromise;\n    /**\n     *  Creates a new **SocketSubscriber** attached to %%provider%% listening\n     *  to %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n    start() {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId)=>{\n            ;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n    stop() {\n        this.#filterId.then((filterId)=>{\n            this.#provider.send(\"eth_unsubscribe\", [\n                filterId\n            ]);\n        });\n        this.#filterId = null;\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused) {\n        (0, index_js_1.assert)(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"pause(false)\"\n        });\n        this.#paused = !!dropWhilePaused;\n    }\n    resume() {\n        this.#paused = null;\n    }\n    /**\n     *  @_ignore:\n     */ _handleMessage(message) {\n        if (this.#filterId == null) {\n            return;\n        }\n        if (this.#paused === null) {\n            let emitPromise = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            } else {\n                emitPromise = emitPromise.then(async ()=>{\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(()=>{\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to emit the events on the\n     *  provider.\n     */ async _emit(provider, message) {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\nexports.SocketSubscriber = SocketSubscriber;\n/**\n *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits\n *  ``\"block\"`` events.\n */ class SocketBlockSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */ constructor(provider){\n        super(provider, [\n            \"newHeads\"\n        ]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\nexports.SocketBlockSubscriber = SocketBlockSubscriber;\n/**\n *  A **SocketPendingSubscriber** listens for pending transacitons and emits\n *  ``\"pending\"`` events.\n */ class SocketPendingSubscriber extends SocketSubscriber {\n    /**\n     *  @_ignore:\n     */ constructor(provider){\n        super(provider, [\n            \"newPendingTransactions\"\n        ]);\n    }\n    async _emit(provider, message) {\n        provider.emit(\"pending\", message);\n    }\n}\nexports.SocketPendingSubscriber = SocketPendingSubscriber;\n/**\n *  A **SocketEventSubscriber** listens for event logs.\n */ class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter;\n    /**\n     *  The filter.\n     */ get logFilter() {\n        return JSON.parse(this.#logFilter);\n    }\n    /**\n     *  @_ignore:\n     */ constructor(provider, filter){\n        super(provider, [\n            \"logs\",\n            filter\n        ]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n    async _emit(provider, message) {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\nexports.SocketEventSubscriber = SocketEventSubscriber;\n/**\n *  A **SocketProvider** is backed by a long-lived connection over a\n *  socket, which can subscribe and receive real-time messages over\n *  its communication channel.\n */ class SocketProvider extends provider_jsonrpc_js_1.JsonRpcApiProvider {\n    #callbacks;\n    // Maps each filterId to its subscriber\n    #subs;\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending;\n    /**\n     *  Creates a new **SocketProvider** connected to %%network%%.\n     *\n     *  If unspecified, the network will be discovered.\n     */ constructor(network){\n        super(network, {\n            batchMaxCount: 1\n        });\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */ _getSubscriber(sub) {\n        switch(sub.type){\n            case \"close\":\n                return new abstract_provider_js_1.UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new abstract_provider_js_1.UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n    /**\n     *  Register a new subscriber. This is used internalled by Subscribers\n     *  and generally is unecessary unless extending capabilities.\n     */ _register(filterId, subscriber) {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending){\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n    async _send(payload) {\n        // WebSocket provider doesn't accept batches\n        (0, index_js_1.assertArgument)(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n        // @TODO: stringify payloads here and store to prevent mutations\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject)=>{\n            this.#callbacks.set(payload.id, {\n                payload,\n                resolve,\n                reject\n            });\n        });\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n        return [\n            await promise\n        ];\n    }\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */ /**\n     *  Sub-classes **must** call this with messages received over their\n     *  transport to be processed and dispatched.\n     */ async _processMessage(message) {\n        const result = JSON.parse(message);\n        if (result && typeof result === \"object\" && \"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                this.emit(\"error\", (0, index_js_1.makeError)(\"received result for unknown id\", \"UNKNOWN_ERROR\", {\n                    reasonCode: \"UNKNOWN_ID\",\n                    result\n                }));\n                return;\n            }\n            this.#callbacks.delete(result.id);\n            callback.resolve(result);\n        } else if (result && result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            } else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n        } else {\n            this.emit(\"error\", (0, index_js_1.makeError)(\"received unexpected message\", \"UNKNOWN_ERROR\", {\n                reasonCode: \"UNEXPECTED_MESSAGE\",\n                result\n            }));\n            return;\n        }\n    }\n    /**\n     *  Sub-classes **must** override this to send %%message%% over their\n     *  transport.\n     */ async _write(message) {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\nexports.SocketProvider = SocketProvider; //# sourceMappingURL=provider-socket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItc29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7OztDQVNDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsNkJBQTZCLEdBQUdBLCtCQUErQixHQUFHQSw2QkFBNkIsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUMzSixNQUFNTyx5QkFBeUJDLG1CQUFPQSxDQUFDLHVHQUF3QjtBQUMvRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUUsd0JBQXdCRixtQkFBT0EsQ0FBQyxxR0FBdUI7QUFDN0Q7OztDQUdDLEdBQ0QsTUFBTUY7SUFDRixDQUFDSyxRQUFRLENBQUM7SUFDVixDQUFDQyxNQUFNLENBQUM7SUFDUjs7S0FFQyxHQUNELElBQUlBLFNBQVM7UUFBRSxPQUFPQyxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUNGLE1BQU07SUFBRztJQUNoRCxDQUFDRyxRQUFRLENBQUM7SUFDVixDQUFDQyxNQUFNLENBQUM7SUFDUixDQUFDQyxXQUFXLENBQUM7SUFDYjs7O0tBR0MsR0FDREMsWUFBWVAsUUFBUSxFQUFFQyxNQUFNLENBQUU7UUFDMUIsSUFBSSxDQUFDLENBQUNELFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNDLE1BQU0sR0FBR0MsS0FBS00sU0FBUyxDQUFDUDtRQUM5QixJQUFJLENBQUMsQ0FBQ0csUUFBUSxHQUFHO1FBQ2pCLElBQUksQ0FBQyxDQUFDQyxNQUFNLEdBQUc7UUFDZixJQUFJLENBQUMsQ0FBQ0MsV0FBVyxHQUFHO0lBQ3hCO0lBQ0FHLFFBQVE7UUFDSixJQUFJLENBQUMsQ0FBQ0wsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDSixRQUFRLENBQUNVLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDVCxNQUFNLEVB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O0FBQ0o7QUFDQWpDLHNCQUFzQixHQUFHRSxnQkFDekIsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLXNvY2tldC5qcz9iYmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgR2VuZXJpYyBsb25nLWxpdmVkIHNvY2tldCBwcm92aWRlci5cbiAqXG4gKiAgU3ViLWNsYXNzaW5nIG5vdGVzXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIGNhbGwgdGhlIGBfc3RhcnQoKWAgbWV0aG9kIG9uY2UgY29ubmVjdGVkXG4gKiAgLSBhIHN1Yi1jbGFzcyBNVVNUIG92ZXJyaWRlIHRoZSBgX3dyaXRlKHN0cmluZylgIG1ldGhvZFxuICogIC0gYSBzdWItY2xhc3MgTVVTVCBjYWxsIGBfcHJvY2Vzc01lc3NhZ2Uoc3RyaW5nKWAgZm9yIGVhY2ggbWVzc2FnZVxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXI6U29ja2V0IFByb3ZpZGVycyAgW2Fib3V0LXNvY2tldFByb3ZpZGVyXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldFByb3ZpZGVyID0gZXhwb3J0cy5Tb2NrZXRFdmVudFN1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldFBlbmRpbmdTdWJzY3JpYmVyID0gZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLlNvY2tldFN1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCBhYnN0cmFjdF9wcm92aWRlcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QtcHJvdmlkZXIuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgcHJvdmlkZXJfanNvbnJwY19qc18xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItanNvbnJwYy5qc1wiKTtcbi8qKlxuICogIEEgKipTb2NrZXRTdWJzY3JpYmVyKiogdXNlcyBhIHNvY2tldCB0cmFuc3BvcnQgdG8gaGFuZGxlIGV2ZW50cyBhbmRcbiAqICBzaG91bGQgdXNlIFtbX2VtaXRdXSB0byBtYW5hZ2UgdGhlIGV2ZW50cy5cbiAqL1xuY2xhc3MgU29ja2V0U3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaWx0ZXIuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHsgcmV0dXJuIEpTT04ucGFyc2UodGhpcy4jZmlsdGVyKTsgfVxuICAgICNmaWx0ZXJJZDtcbiAgICAjcGF1c2VkO1xuICAgICNlbWl0UHJvbWlzZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFN1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUgbGlzdGVuaW5nXG4gICAgICogIHRvICUlZmlsdGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXIgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkID0gdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9zdWJzY3JpYmVcIiwgdGhpcy5maWx0ZXIpLnRoZW4oKGZpbHRlcklkKSA9PiB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLiNwcm92aWRlci5fcmVnaXN0ZXIoZmlsdGVySWQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgKHRoaXMuI2ZpbHRlcklkKS50aGVuKChmaWx0ZXJJZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ZpbHRlcklkID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQFRPRE86IHBhdXNlIHNob3VsZCB0cmFwIHRoZSBjdXJyZW50IGJsb2NrTnVtYmVyLCB1bnN1YiwgYW5kIG9uIHJlc3VtZSB1c2UgZ2V0TG9nc1xuICAgIC8vICAgICAgICBhbmQgcmVzdW1lXG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZHJvcFdoaWxlUGF1c2VkLCBcInByZXNlcnZlIGxvZ3Mgd2hpbGUgcGF1c2VkIG5vdCBzdXBwb3J0ZWQgYnkgU29ja2V0U3Vic2NyaWJlciB5ZXRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicGF1c2UoZmFsc2UpXCIgfSk7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9ICEhZHJvcFdoaWxlUGF1c2VkO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuI3BhdXNlZCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLiNmaWx0ZXJJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3BhdXNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGVtaXRQcm9taXNlID0gdGhpcy4jZW1pdFByb21pc2U7XG4gICAgICAgICAgICBpZiAoZW1pdFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVtaXRQcm9taXNlID0gdGhpcy5fZW1pdCh0aGlzLiNwcm92aWRlciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0UHJvbWlzZSA9IGVtaXRQcm9taXNlLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9lbWl0KHRoaXMuI3Byb3ZpZGVyLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2VtaXRQcm9taXNlID0gZW1pdFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2VtaXRQcm9taXNlID09PSBlbWl0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNlbWl0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgdG8gZW1pdCB0aGUgZXZlbnRzIG9uIHRoZVxuICAgICAqICBwcm92aWRlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZW1pdChwcm92aWRlciwgbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudGUgdGhpczsgX2VtaXRcIik7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRTdWJzY3JpYmVyID0gU29ja2V0U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRCbG9ja1N1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBgYG5ld0hlYWRzYGAgZXZlbnRzIGFuZCBlbWl0c1xuICogIGBgXCJibG9ja1wiYGAgZXZlbnRzLlxuICovXG5jbGFzcyBTb2NrZXRCbG9ja1N1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIsIFtcIm5ld0hlYWRzXCJdKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIHBhcnNlSW50KG1lc3NhZ2UubnVtYmVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXRCbG9ja1N1YnNjcmliZXIgPSBTb2NrZXRCbG9ja1N1YnNjcmliZXI7XG4vKipcbiAqICBBICoqU29ja2V0UGVuZGluZ1N1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBwZW5kaW5nIHRyYW5zYWNpdG9ucyBhbmQgZW1pdHNcbiAqICBgYFwicGVuZGluZ1wiYGAgZXZlbnRzLlxuICovXG5jbGFzcyBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIFNvY2tldFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSk7XG4gICAgfVxuICAgIGFzeW5jIF9lbWl0KHByb3ZpZGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIHByb3ZpZGVyLmVtaXQoXCJwZW5kaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0UGVuZGluZ1N1YnNjcmliZXIgPSBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRFdmVudFN1YnNjcmliZXIqKiBsaXN0ZW5zIGZvciBldmVudCBsb2dzLlxuICovXG5jbGFzcyBTb2NrZXRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBTb2NrZXRTdWJzY3JpYmVyIHtcbiAgICAjbG9nRmlsdGVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgZmlsdGVyLlxuICAgICAqL1xuICAgIGdldCBsb2dGaWx0ZXIoKSB7IHJldHVybiBKU09OLnBhcnNlKHRoaXMuI2xvZ0ZpbHRlcik7IH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlciwgW1wibG9nc1wiLCBmaWx0ZXJdKTtcbiAgICAgICAgdGhpcy4jbG9nRmlsdGVyID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXQocHJvdmlkZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvdmlkZXIuZW1pdCh0aGlzLmxvZ0ZpbHRlciwgcHJvdmlkZXIuX3dyYXBMb2cobWVzc2FnZSwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldEV2ZW50U3Vic2NyaWJlciA9IFNvY2tldEV2ZW50U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipTb2NrZXRQcm92aWRlcioqIGlzIGJhY2tlZCBieSBhIGxvbmctbGl2ZWQgY29ubmVjdGlvbiBvdmVyIGFcbiAqICBzb2NrZXQsIHdoaWNoIGNhbiBzdWJzY3JpYmUgYW5kIHJlY2VpdmUgcmVhbC10aW1lIG1lc3NhZ2VzIG92ZXJcbiAqICBpdHMgY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICovXG5jbGFzcyBTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2pzb25ycGNfanNfMS5Kc29uUnBjQXBpUHJvdmlkZXIge1xuICAgICNjYWxsYmFja3M7XG4gICAgLy8gTWFwcyBlYWNoIGZpbHRlcklkIHRvIGl0cyBzdWJzY3JpYmVyXG4gICAgI3N1YnM7XG4gICAgLy8gSWYgYW55IGV2ZW50cyBjb21lIGluIGJlZm9yZSBhIHN1YnNjcmliZXIgaGFzIGZpbmlzaGVkXG4gICAgLy8gcmVnaXN0ZXJpbmcsIHF1ZXVlIHRoZW1cbiAgICAjcGVuZGluZztcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKlNvY2tldFByb3ZpZGVyKiogY29ubmVjdGVkIHRvICUlbmV0d29yayUlLlxuICAgICAqXG4gICAgICogIElmIHVuc3BlY2lmaWVkLCB0aGUgbmV0d29yayB3aWxsIGJlIGRpc2NvdmVyZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaykge1xuICAgICAgICBzdXBlcihuZXR3b3JrLCB7IGJhdGNoTWF4Q291bnQ6IDEgfSk7XG4gICAgICAgIHRoaXMuI2NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jc3VicyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy4jcGVuZGluZyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBvbmx5IHZhbGlkIGFmdGVyIF9zdGFydCBoYXMgYmVlbiBjYWxsZWRcbiAgICAvKlxuICAgIGdldCBfbmV0d29yaygpOiBOZXR3b3JrIHtcbiAgICAgICAgaWYgKHRoaXMuI25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNuZXR3b3JrLmNsb25lKCk7XG4gICAgfVxuICAgICovXG4gICAgX2dldFN1YnNjcmliZXIoc3ViKSB7XG4gICAgICAgIHN3aXRjaCAoc3ViLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWJzdHJhY3RfcHJvdmlkZXJfanNfMS5Vbm1hbmFnZWRTdWJzY3JpYmVyKFwiY2xvc2VcIik7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvY2tldEJsb2NrU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTb2NrZXRQZW5kaW5nU3Vic2NyaWJlcih0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ja2V0RXZlbnRTdWJzY3JpYmVyKHRoaXMsIHN1Yi5maWx0ZXIpO1xuICAgICAgICAgICAgY2FzZSBcIm9ycGhhblwiOlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgYXV0by1tYXRpY2FsbHkgd2l0aGluIEFic3RyYWN0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBsb2cucmVtb3ZlZCA9IHRydWVcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmZpbHRlci5vcnBoYW4gPT09IFwiZHJvcC1sb2dcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0X3Byb3ZpZGVyX2pzXzEuVW5tYW5hZ2VkU3Vic2NyaWJlcihcImRyb3AtbG9nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX2dldFN1YnNjcmliZXIoc3ViKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlZ2lzdGVyIGEgbmV3IHN1YnNjcmliZXIuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGxlZCBieSBTdWJzY3JpYmVyc1xuICAgICAqICBhbmQgZ2VuZXJhbGx5IGlzIHVuZWNlc3NhcnkgdW5sZXNzIGV4dGVuZGluZyBjYXBhYmlsaXRpZXMuXG4gICAgICovXG4gICAgX3JlZ2lzdGVyKGZpbHRlcklkLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuI3N1YnMuc2V0KGZpbHRlcklkLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMuI3BlbmRpbmcuZ2V0KGZpbHRlcklkKTtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3BlbmRpbmcuZGVsZXRlKGZpbHRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIC8vIFdlYlNvY2tldCBwcm92aWRlciBkb2Vzbid0IGFjY2VwdCBiYXRjaGVzXG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KSghQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgXCJXZWJTb2NrZXQgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaCBzZW5kXCIsIFwicGF5bG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgICAgLy8gQFRPRE86IHN0cmluZ2lmeSBwYXlsb2FkcyBoZXJlIGFuZCBzdG9yZSB0byBwcmV2ZW50IG11dGF0aW9uc1xuICAgICAgICAvLyBQcmVwYXJlIGEgcHJvbWlzZSB0byByZXNwb25kIHRvXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNjYWxsYmFja3Muc2V0KHBheWxvYWQuaWQsIHsgcGF5bG9hZCwgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FpdCB1bnRpbCB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBiZWZvcmUgd3JpdGluZyB0byBpdFxuICAgICAgICBhd2FpdCB0aGlzLl93YWl0VW50aWxSZWFkeSgpO1xuICAgICAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCB0byB0aGUgc29ja2V0XG4gICAgICAgIGF3YWl0IHRoaXMuX3dyaXRlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgcmV0dXJuIFthd2FpdCBwcm9taXNlXTtcbiAgICB9XG4gICAgLy8gU3ViLWNsYXNzZXMgbXVzdCBjYWxsIHRoaXMgb25jZSB0aGV5IGFyZSBjb25uZWN0ZWRcbiAgICAvKlxuICAgIGFzeW5jIF9zdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKHRoaXMuI3JlYWR5KSB7IHJldHVybjsgfVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBwYXlsb2FkIH0gb2YgdGhpcy4jY2FsbGJhY2tzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl93cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNyZWFkeSA9IChhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF3YWl0IHN1cGVyLl9zdGFydCgpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAqL1xuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBjYWxsIHRoaXMgd2l0aCBtZXNzYWdlcyByZWNlaXZlZCBvdmVyIHRoZWlyXG4gICAgICogIHRyYW5zcG9ydCB0byBiZSBwcm9jZXNzZWQgYW5kIGRpc3BhdGNoZWQuXG4gICAgICovXG4gICAgYXN5bmMgX3Byb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKEpTT04ucGFyc2UobWVzc2FnZSkpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiAocmVzdWx0KSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuI2NhbGxiYWNrcy5nZXQocmVzdWx0LmlkKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgKDAsIGluZGV4X2pzXzEubWFrZUVycm9yKShcInJlY2VpdmVkIHJlc3VsdCBmb3IgdW5rbm93biBpZFwiLCBcIlVOS05PV05fRVJST1JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25Db2RlOiBcIlVOS05PV05fSURcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5kZWxldGUocmVzdWx0LmlkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgJiYgcmVzdWx0Lm1ldGhvZCA9PT0gXCJldGhfc3Vic2NyaXB0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcklkID0gcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb247XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gdGhpcy4jc3Vicy5nZXQoZmlsdGVySWQpO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLl9oYW5kbGVNZXNzYWdlKHJlc3VsdC5wYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy4jcGVuZGluZy5nZXQoZmlsdGVySWQpO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNwZW5kaW5nLnNldChmaWx0ZXJJZCwgcGVuZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCAoMCwgaW5kZXhfanNfMS5tYWtlRXJyb3IpKFwicmVjZWl2ZWQgdW5leHBlY3RlZCBtZXNzYWdlXCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7XG4gICAgICAgICAgICAgICAgcmVhc29uQ29kZTogXCJVTkVYUEVDVEVEX01FU1NBR0VcIixcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3ViLWNsYXNzZXMgKiptdXN0Kiogb3ZlcnJpZGUgdGhpcyB0byBzZW5kICUlbWVzc2FnZSUlIG92ZXIgdGhlaXJcbiAgICAgKiAgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldFByb3ZpZGVyID0gU29ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1zb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU29ja2V0UHJvdmlkZXIiLCJTb2NrZXRFdmVudFN1YnNjcmliZXIiLCJTb2NrZXRQZW5kaW5nU3Vic2NyaWJlciIsIlNvY2tldEJsb2NrU3Vic2NyaWJlciIsIlNvY2tldFN1YnNjcmliZXIiLCJhYnN0cmFjdF9wcm92aWRlcl9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzEiLCJwcm92aWRlcl9qc29ucnBjX2pzXzEiLCJwcm92aWRlciIsImZpbHRlciIsIkpTT04iLCJwYXJzZSIsImZpbHRlcklkIiwicGF1c2VkIiwiZW1pdFByb21pc2UiLCJjb25zdHJ1Y3RvciIsInN0cmluZ2lmeSIsInN0YXJ0Iiwic2VuZCIsInRoZW4iLCJfcmVnaXN0ZXIiLCJzdG9wIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJyZXN1bWUiLCJfaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2UiLCJfZW1pdCIsIkVycm9yIiwiZW1pdCIsInBhcnNlSW50IiwibnVtYmVyIiwibG9nRmlsdGVyIiwiX3dyYXBMb2ciLCJfbmV0d29yayIsIkpzb25ScGNBcGlQcm92aWRlciIsImNhbGxiYWNrcyIsInN1YnMiLCJwZW5kaW5nIiwibmV0d29yayIsImJhdGNoTWF4Q291bnQiLCJNYXAiLCJfZ2V0U3Vic2NyaWJlciIsInN1YiIsInR5cGUiLCJVbm1hbmFnZWRTdWJzY3JpYmVyIiwib3JwaGFuIiwic3Vic2NyaWJlciIsInNldCIsImdldCIsImRlbGV0ZSIsIl9zZW5kIiwicGF5bG9hZCIsImFzc2VydEFyZ3VtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaWQiLCJfd2FpdFVudGlsUmVhZHkiLCJfd3JpdGUiLCJfcHJvY2Vzc01lc3NhZ2UiLCJyZXN1bHQiLCJjYWxsYmFjayIsIm1ha2VFcnJvciIsInJlYXNvbkNvZGUiLCJtZXRob2QiLCJwYXJhbXMiLCJzdWJzY3JpcHRpb24iLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider-websocket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocketProvider = void 0;\nconst ws_js_1 = __webpack_require__(/*! ./ws.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/ws.js\"); /*-browser*/ \nconst provider_socket_js_1 = __webpack_require__(/*! ./provider-socket.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-socket.js\");\n/**\n *  A JSON-RPC provider which is backed by a WebSocket.\n *\n *  WebSockets are often preferred because they retain a live connection\n *  to a server, which permits more instant access to events.\n *\n *  However, this incurs higher server infrasturture costs, so additional\n *  resources may be required to host your own WebSocket nodes and many\n *  third-party services charge additional fees for WebSocket endpoints.\n */ class WebSocketProvider extends provider_socket_js_1.SocketProvider {\n    #connect;\n    #websocket;\n    get websocket() {\n        if (this.#websocket == null) {\n            throw new Error(\"websocket closed\");\n        }\n        return this.#websocket;\n    }\n    constructor(url, network){\n        super(network);\n        if (typeof url === \"string\") {\n            this.#connect = ()=>{\n                return new ws_js_1.WebSocket(url);\n            };\n            this.#websocket = this.#connect();\n        } else if (typeof url === \"function\") {\n            this.#connect = url;\n            this.#websocket = url();\n        } else {\n            this.#connect = null;\n            this.#websocket = url;\n        }\n        this.websocket.onopen = async ()=>{\n            try {\n                await this._start();\n                this.resume();\n            } catch (error) {\n                console.log(\"failed to start WebsocketProvider\", error);\n            // @TODO: now what? Attempt reconnect?\n            }\n        };\n        this.websocket.onmessage = (message)=>{\n            this._processMessage(message.data);\n        };\n    /*\n                this.websocket.onclose = (event) => {\n                    // @TODO: What event.code should we reconnect on?\n                    const reconnect = false;\n                    if (reconnect) {\n                        this.pause(true);\n                        if (this.#connect) {\n                            this.#websocket = this.#connect();\n                            this.#websocket.onopen = ...\n                            // @TODO: this requires the super class to rebroadcast; move it there\n                        }\n                        this._reconnect();\n                    }\n                };\n        */ }\n    async _write(message) {\n        this.websocket.send(message);\n    }\n    async destroy() {\n        if (this.#websocket != null) {\n            this.#websocket.close();\n            this.#websocket = null;\n        }\n        super.destroy();\n    }\n}\nexports.WebSocketProvider = WebSocketProvider; //# sourceMappingURL=provider-websocket.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXItd2Vic29ja2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLHlFQUFTLEdBQUcsVUFBVTtBQUM5QyxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLG1HQUFzQjtBQUMzRDs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRiwwQkFBMEJHLHFCQUFxQkMsY0FBYztJQUMvRCxDQUFDQyxPQUFPLENBQUM7SUFDVCxDQUFDQyxTQUFTLENBQUM7SUFDWCxJQUFJQSxZQUFZO1FBQ1osSUFBSSxJQUFJLENBQUMsQ0FBQ0EsU0FBUyxJQUFJLE1BQU07WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQ0QsU0FBUztJQUMxQjtJQUNBRSxZQUFZQyxHQUFHLEVBQUVDLE9BQU8sQ0FBRTtRQUN0QixLQUFLLENBQUNBO1FBQ04sSUFBSSxPQUFRRCxRQUFTLFVBQVU7WUFDM0IsSUFBSSxDQUFDLENBQUNKLE9BQU8sR0FBRztnQkFBUSxPQUFPLElBQUlKLFFBQVFVLFNBQVMsQ0FBQ0Y7WUFBTTtZQUMzRCxJQUFJLENBQUMsQ0FBQ0gsU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDRCxPQUFPO1FBQ25DLE9BQ0ssSUFBSSxPQUFRSSxRQUFTLFlBQVk7WUFDbEMsSUFBSSxDQUFDLENBQUNKLE9BQU8sR0FBR0k7WUFDaEIsSUFBSSxDQUFDLENBQUNILFNBQVMsR0FBR0c7UUFDdEIsT0FDSztZQUNELElBQUksQ0FBQyxDQUFDSixPQUFPLEdBQUc7WUFDaEIsSUFBSSxDQUFDLENBQUNDLFNBQVMsR0FBR0c7UUFDdEI7UUFDQSxJQUFJLENBQUNILFNBQVMsQ0FBQ00sTUFBTSxHQUFHO1lBQ3BCLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUNDLE1BQU07Z0JBQ2pCLElBQUksQ0FBQ0MsTUFBTTtZQUNmLEVBQ0EsT0FBT0MsT0FBTztnQkFDVkMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQ0Y7WUFDakQsc0NBQXNDO1lBQzFDO1FBQ0o7UUFDQSxJQUFJLENBQUNULFNBQVMsQ0FBQ1ksU0FBUyxHQUFHLENBQUNDO1lBQ3hCLElBQUksQ0FBQ0MsZUFBZSxDQUFDRCxRQUFRRSxJQUFJO1FBQ3JDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O1FBY0EsR0FDSjtJQUNBLE1BQU1DLE9BQU9ILE9BQU8sRUFBRTtRQUNsQixJQUFJLENBQUNiLFNBQVMsQ0FBQ2lCLElBQUksQ0FBQ0o7SUFDeEI7SUFDQSxNQUFNSyxVQUFVO1FBQ1osSUFBSSxJQUFJLENBQUMsQ0FBQ2xCLFNBQVMsSUFBSSxNQUFNO1lBQ3pCLElBQUksQ0FBQyxDQUFDQSxTQUFTLENBQUNtQixLQUFLO1lBQ3JCLElBQUksQ0FBQyxDQUFDbkIsU0FBUyxHQUFHO1FBQ3RCO1FBQ0EsS0FBSyxDQUFDa0I7SUFDVjtBQUNKO0FBQ0ExQix5QkFBeUIsR0FBR0UsbUJBQzVCLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9wcm92aWRlci13ZWJzb2NrZXQuanM/Mzc1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB3c19qc18xID0gcmVxdWlyZShcIi4vd3MuanNcIik7IC8qLWJyb3dzZXIqL1xuY29uc3QgcHJvdmlkZXJfc29ja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlci1zb2NrZXQuanNcIik7XG4vKipcbiAqICBBIEpTT04tUlBDIHByb3ZpZGVyIHdoaWNoIGlzIGJhY2tlZCBieSBhIFdlYlNvY2tldC5cbiAqXG4gKiAgV2ViU29ja2V0cyBhcmUgb2Z0ZW4gcHJlZmVycmVkIGJlY2F1c2UgdGhleSByZXRhaW4gYSBsaXZlIGNvbm5lY3Rpb25cbiAqICB0byBhIHNlcnZlciwgd2hpY2ggcGVybWl0cyBtb3JlIGluc3RhbnQgYWNjZXNzIHRvIGV2ZW50cy5cbiAqXG4gKiAgSG93ZXZlciwgdGhpcyBpbmN1cnMgaGlnaGVyIHNlcnZlciBpbmZyYXN0dXJ0dXJlIGNvc3RzLCBzbyBhZGRpdGlvbmFsXG4gKiAgcmVzb3VyY2VzIG1heSBiZSByZXF1aXJlZCB0byBob3N0IHlvdXIgb3duIFdlYlNvY2tldCBub2RlcyBhbmQgbWFueVxuICogIHRoaXJkLXBhcnR5IHNlcnZpY2VzIGNoYXJnZSBhZGRpdGlvbmFsIGZlZXMgZm9yIFdlYlNvY2tldCBlbmRwb2ludHMuXG4gKi9cbmNsYXNzIFdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfc29ja2V0X2pzXzEuU29ja2V0UHJvdmlkZXIge1xuICAgICNjb25uZWN0O1xuICAgICN3ZWJzb2NrZXQ7XG4gICAgZ2V0IHdlYnNvY2tldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3dlYnNvY2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3ZWJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiN3ZWJzb2NrZXQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBzdXBlcihuZXR3b3JrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCA9ICgpID0+IHsgcmV0dXJuIG5ldyB3c19qc18xLldlYlNvY2tldCh1cmwpOyB9O1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gdGhpcy4jY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gdXJsO1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0ID0gdXJsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHN0YXJ0IFdlYnNvY2tldFByb3ZpZGVyXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETzogbm93IHdoYXQ/IEF0dGVtcHQgcmVjb25uZWN0P1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc01lc3NhZ2UobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBXaGF0IGV2ZW50LmNvZGUgc2hvdWxkIHdlIHJlY29ubmVjdCBvbj9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3dlYnNvY2tldCA9IHRoaXMuI2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQub25vcGVuID0gLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IHRoaXMgcmVxdWlyZXMgdGhlIHN1cGVyIGNsYXNzIHRvIHJlYnJvYWRjYXN0OyBtb3ZlIGl0IHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICovXG4gICAgfVxuICAgIGFzeW5jIF93cml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLiN3ZWJzb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLiN3ZWJzb2NrZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gV2ViU29ja2V0UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci13ZWJzb2NrZXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJ3c19qc18xIiwicmVxdWlyZSIsInByb3ZpZGVyX3NvY2tldF9qc18xIiwiU29ja2V0UHJvdmlkZXIiLCJjb25uZWN0Iiwid2Vic29ja2V0IiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInVybCIsIm5ldHdvcmsiLCJXZWJTb2NrZXQiLCJvbm9wZW4iLCJfc3RhcnQiLCJyZXN1bWUiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJvbm1lc3NhZ2UiLCJtZXNzYWdlIiwiX3Byb2Nlc3NNZXNzYWdlIiwiZGF0YSIsIl93cml0ZSIsInNlbmQiLCJkZXN0cm95IiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider-websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/provider.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;\n//import { resolveAddress } from \"@ethersproject/address\";\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */ class FeeData {\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */ constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas){\n        (0, index_js_1.defineProperties)(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)\n        };\n    }\n}\nexports.FeeData = FeeData;\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */ function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = (0, index_js_1.hexlify)(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0, index_js_1.getBigInt)(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys){\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = (0, index_js_1.getNumber)(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = (0, index_js_2.accessListify)(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    return result;\n}\nexports.copyRequest = copyRequest;\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */ class Block {\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */ constructor(block, provider){\n        this.#transactions = block.transactions.map((tx)=>{\n            if (typeof tx !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        (0, index_js_1.defineProperties)(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            miner: block.miner,\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas)\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */ get transactions() {\n        return this.#transactions.map((tx)=>{\n            if (typeof tx === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */ get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        (0, index_js_1.assert)(typeof txs[0] === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */ toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, nonce, number, parentHash, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            hash,\n            miner,\n            nonce,\n            number,\n            parentHash,\n            timestamp,\n            transactions\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: txs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */ get length() {\n        return this.#transactions.length;\n    }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */ get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */ async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof indexOrHash === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        } else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions){\n                if (typeof v === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                } else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof tx === \"string\") {\n            return await this.provider.getTransaction(tx);\n        } else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */ getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof indexOrHash === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs){\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        (0, index_js_1.assertArgument)(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */ isMined() {\n        return !!this.hash;\n    }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */ isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */ orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\nexports.Block = Block;\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */ class Log {\n    /**\n     *  @_ignore:\n     */ constructor(log, provider){\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        (0, index_js_1.defineProperties)(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */ toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address,\n            blockHash,\n            blockNumber,\n            data,\n            index,\n            removed,\n            topics,\n            transactionHash,\n            transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        (0, index_js_1.assert)(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        (0, index_js_1.assert)(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */ async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        (0, index_js_1.assert)(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\nexports.Log = Log;\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/ /**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */ class TransactionReceipt {\n    #logs;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.#logs = Object.freeze(tx.logs.map((log)=>{\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        } else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        (0, index_js_1.defineProperties)(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            gasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */ get logs() {\n        return this.#logs;\n    }\n    /**\n     *  Returns a JSON-compatible representation.\n     */ toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash,\n            blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash,\n            index,\n            logs,\n            logsBloom,\n            root,\n            status,\n            to\n        };\n    }\n    /**\n     *  @_ignore:\n     */ get length() {\n        return this.logs.length;\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < this.length) {\n                    return {\n                        value: this.logs[index++],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */ get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */ async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */ async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */ async getResult() {\n        return await this.provider.getTransactionResult(this.hash);\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */ async confirmations() {\n        return await this.provider.getBlockNumber() - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */ removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */ reorderedEvent(other) {\n        (0, index_js_1.assert)(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"reorderedEvent(other)\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\nexports.TransactionReceipt = TransactionReceipt;\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */ class TransactionResponse {\n    #startBlock;\n    /**\n     *  @_ignore:\n     */ constructor(tx, provider){\n        this.provider = provider;\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = tx.accessList != null ? tx.accessList : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */ toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            accessList,\n            blockNumber,\n            blockHash,\n            chainId: toJson(this.chainId),\n            data,\n            from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            nonce,\n            signature,\n            to,\n            index,\n            type,\n            value: toJson(this.value)\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */ async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */ async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */ async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await (0, index_js_1.resolveProperties)({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */ async wait(_confirms, _timeout) {\n        const confirms = _confirms == null ? 1 : _confirms;\n        const timeout = _timeout == null ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = startBlock === -1 ? true : false;\n        const checkReplacement = async ()=>{\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await (0, index_js_1.resolveProperties)({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while(nextScan <= blockNumber){\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block){\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for(let i = 0; i < block.length; i++){\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        (0, index_js_1.assert)(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt)=>{\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            (0, index_js_1.assert)(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null,\n                reason: null,\n                invocation: null,\n                revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                },\n                receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if (await receipt.confirmations() >= confirms) {\n                return checkReceipt(receipt);\n            }\n        } else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject)=>{\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = ()=>{\n                cancellers.forEach((c)=>c());\n            };\n            // On cancel, stop scanning for replacements\n            cancellers.push(()=>{\n                stopScanning = true;\n            });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(()=>{\n                    cancel();\n                    reject((0, index_js_1.makeError)(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(()=>{\n                    clearTimeout(timer);\n                });\n            }\n            const txListener = async (receipt)=>{\n                // Done; return it!\n                if (await receipt.confirmations() >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    } catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(()=>{\n                this.provider.off(this.hash, txListener);\n            });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async ()=>{\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    } catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if ((0, index_js_1.isError)(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(()=>{\n                    this.provider.off(\"block\", replaceListener);\n                });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */ isMined() {\n        return this.blockHash != null;\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */ removedEvent() {\n        (0, index_js_1.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */ reorderedEvent(other) {\n        (0, index_js_1.assert)(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        (0, index_js_1.assert)(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"removeEvent()\"\n        });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */ replaceableTransaction(startBlock) {\n        (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nexports.TransactionResponse = TransactionResponse;\nfunction createOrphanedBlockFilter(block) {\n    return {\n        orphan: \"drop-block\",\n        hash: block.hash,\n        number: block.number\n    };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return {\n        orphan: \"reorder-transaction\",\n        tx,\n        other\n    };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return {\n        orphan: \"drop-transaction\",\n        tx\n    };\n}\nfunction createRemovedLogFilter(log) {\n    return {\n        orphan: \"drop-log\",\n        log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        }\n    };\n} //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwwQkFBMEIsR0FBR0EsV0FBVyxHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUN0SSwwREFBMEQ7QUFDMUQsTUFBTVEsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDhGQUF5QjtBQUNwRCxNQUFNRSxPQUFPQyxPQUFPO0FBQ3BCLDBCQUEwQjtBQUMxQixTQUFTQyxTQUFTWixLQUFLO0lBQ25CLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTYSxPQUFPYixLQUFLO0lBQ2pCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLE9BQU9BLE1BQU1jLFFBQVE7QUFDekI7QUFDQSwwREFBMEQ7QUFDMUQ7OztDQUdDLEdBQ0QsTUFBTVI7SUE0QkY7OztLQUdDLEdBQ0RTLFlBQVlDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsQ0FBRTtRQUNyRCxJQUFHWCxXQUFXWSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFDbkNILFVBQVVKLFNBQVNJO1lBQ25CQyxjQUFjTCxTQUFTSztZQUN2QkMsc0JBQXNCTixTQUFTTTtRQUNuQztJQUNKO0lBQ0E7O0tBRUMsR0FDREUsU0FBUztRQUNMLE1BQU0sRUFBRUosUUFBUSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixFQUFFLEdBQUcsSUFBSTtRQUM3RCxPQUFPO1lBQ0hHLE9BQU87WUFDUEwsVUFBVUgsT0FBT0c7WUFDakJDLGNBQWNKLE9BQU9JO1lBQ3JCQyxzQkFBc0JMLE9BQU9LO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBbkIs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QXVCcEg7UUFBSWtFO0lBQU07QUFDdEQ7QUFDQSxTQUFTRiwrQkFBK0JoRSxFQUFFO0lBQ3RDLE9BQU87UUFBRW9ILFFBQVE7UUFBb0JwSDtJQUFHO0FBQzVDO0FBQ0EsU0FBU2tELHVCQUF1QmIsR0FBRztJQUMvQixPQUFPO1FBQUUrRSxRQUFRO1FBQVkvRSxLQUFLO1lBQzFCRyxpQkFBaUJILElBQUlHLGVBQWU7WUFDcENDLFdBQVdKLElBQUlJLFNBQVM7WUFDeEJDLGFBQWFMLElBQUlLLFdBQVc7WUFDNUJFLFNBQVNQLElBQUlPLE9BQU87WUFDcEI3RCxNQUFNc0QsSUFBSXRELElBQUk7WUFDZHVELFFBQVFwRixPQUFPcUYsTUFBTSxDQUFDRixJQUFJQyxNQUFNLENBQUN4QixLQUFLO1lBQ3RDTSxPQUFPaUIsSUFBSWpCLEtBQUs7UUFDcEI7SUFBRTtBQUNWLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3Byb3ZpZGVyLmpzPzFiNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVjZWlwdCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5CbG9jayA9IGV4cG9ydHMuY29weVJlcXVlc3QgPSBleHBvcnRzLkZlZURhdGEgPSB2b2lkIDA7XG4vL2ltcG9ydCB7IHJlc29sdmVBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uL2luZGV4LmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0pzb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG59XG4vLyBAVE9ETz8gPFQgZXh0ZW5kcyBGZWVEYXRhID0geyB9PiBpbXBsZW1lbnRzIFJlcXVpcmVkPFQ+XG4vKipcbiAqICBBICoqRmVlRGF0YSoqIHdyYXBzIGFsbCB0aGUgZmVlLXJlbGF0ZWQgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aFxuICogIHRoZSBuZXR3b3JrLlxuICovXG5jbGFzcyBGZWVEYXRhIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBmb3IgbGVnYWN5IG5ldHdvcmtzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgdG8gcGF5IHBlciBnYXMuXG4gICAgICpcbiAgICAgKiAgVGhlIGJhc2UgZmVlIHBlciBnYXMgaXMgZGVmaW5lZCBieSB0aGUgbmV0d29yayBhbmQgYmFzZWQgb25cbiAgICAgKiAgY29uZ2VzdGlvbiwgaW5jcmVhc2luZyB0aGUgY29zdCBkdXJpbmcgdGltZXMgb2YgaGVhdnkgbG9hZFxuICAgICAqICBhbmQgbG93ZXJpbmcgd2hlbiBsZXNzIGJ1c3kuXG4gICAgICpcbiAgICAgKiAgVGhlIGFjdHVhbCBmZWUgcGVyIGdhcyB3aWxsIGJlIHRoZSBiYXNlIGZlZSBmb3IgdGhlIGJsb2NrXG4gICAgICogIGFuZCB0aGUgcHJpb3JpdHkgZmVlLCB1cCB0byB0aGUgbWF4IGZlZSBwZXIgZ2FzLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCBiZSBgYG51bGxgYCBvbiBsZWdhY3kgbmV0d29ya3MgKGkuZS4gW3ByZS1FSVAtMTU1OV0obGluay1laXAtMTU1OSkpXG4gICAgICovXG4gICAgbWF4RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgYWRkaXRpb25hbCBhbW91dCB0byBwYXkgcGVyIGdhcyB0byBlbmNvdXJhZ2UgYSB2YWxpZGF0b3JcbiAgICAgKiAgdG8gaW5jbHVkZSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhlIHB1cnBvc2Ugb2YgdGhpcyBpcyB0byBjb21wZW5zYXRlIHRoZSB2YWxpZGF0b3IgZm9yIHRoZVxuICAgICAqICBhZGp1c3RlZCByaXNrIGZvciBpbmNsdWRpbmcgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgYmUgYGBudWxsYGAgb24gbGVnYWN5IG5ldHdvcmtzIChpLmUuIFtwcmUtRUlQLTE1NTldKGxpbmstZWlwLTE1NTkpKVxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEZlZURhdGEgZm9yICUlZ2FzUHJpY2UlJSwgJSVtYXhGZWVQZXJHYXMlJSBhbmRcbiAgICAgKiAgJSVtYXhQcmlvcml0eUZlZVBlckdhcyUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIGdhc1ByaWNlOiBnZXRWYWx1ZShnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IGdldFZhbHVlKG1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogZ2V0VmFsdWUobWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tZnJpZW5kbHkgdmFsdWUuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX3R5cGU6IFwiRmVlRGF0YVwiLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbihnYXNQcmljZSksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbihtYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRvSnNvbihtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5GZWVEYXRhID0gRmVlRGF0YTtcbjtcbi8qKlxuICogIFJldHVybnMgYSBjb3B5IG9mICUlcmVxJSUgd2l0aCBhbGwgcHJvcGVydGllcyBjb2VyY2VkIHRvIHRoZWlyIHN0cmljdFxuICogIHR5cGVzLlxuICovXG5mdW5jdGlvbiBjb3B5UmVxdWVzdChyZXEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvLyBUaGVzZSBjb3VsZCBiZSBhZGRyZXNzZXMsIEVOUyBuYW1lcyBvciBBZGRyZXNzYWJsZXNcbiAgICBpZiAocmVxLnRvKSB7XG4gICAgICAgIHJlc3VsdC50byA9IHJlcS50bztcbiAgICB9XG4gICAgaWYgKHJlcS5mcm9tKSB7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gcmVxLmZyb207XG4gICAgfVxuICAgIGlmIChyZXEuZGF0YSkge1xuICAgICAgICByZXN1bHQuZGF0YSA9ICgwLCBpbmRleF9qc18xLmhleGxpZnkpKHJlcS5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgYmlnSW50S2V5cyA9IFwiY2hhaW5JZCxnYXNMaW1pdCxnYXNQcmljZSxtYXhGZWVQZXJHYXMsbWF4UHJpb3JpdHlGZWVQZXJHYXMsdmFsdWVcIi5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJpZ0ludEtleXMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHJlcSkgfHwgcmVxW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSAoMCwgaW5kZXhfanNfMS5nZXRCaWdJbnQpKHJlcVtrZXldLCBgcmVxdWVzdC4ke2tleX1gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyS2V5cyA9IFwidHlwZSxub25jZVwiLnNwbGl0KC8sLyk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbnVtYmVyS2V5cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gcmVxKSB8fCByZXFba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9ICgwLCBpbmRleF9qc18xLmdldE51bWJlcikocmVxW2tleV0sIGByZXF1ZXN0LiR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAocmVxLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSAoMCwgaW5kZXhfanNfMi5hY2Nlc3NMaXN0aWZ5KShyZXEuYWNjZXNzTGlzdCk7XG4gICAgfVxuICAgIGlmIChcImJsb2NrVGFnXCIgaW4gcmVxKSB7XG4gICAgICAgIHJlc3VsdC5ibG9ja1RhZyA9IHJlcS5ibG9ja1RhZztcbiAgICB9XG4gICAgaWYgKFwiZW5hYmxlQ2NpcFJlYWRcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmVuYWJsZUNjaXBSZWFkID0gISFyZXEuZW5hYmxlQ2NpcFJlYWQ7XG4gICAgfVxuICAgIGlmIChcImN1c3RvbURhdGFcIiBpbiByZXEpIHtcbiAgICAgICAgcmVzdWx0LmN1c3RvbURhdGEgPSByZXEuY3VzdG9tRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29weVJlcXVlc3QgPSBjb3B5UmVxdWVzdDtcbi8qKlxuICogIEEgKipCbG9jayoqIHJlcHJlc2VudHMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZnVsbCBibG9jayBvblxuICogIEV0aGVyZXVtLlxuICovXG5jbGFzcyBCbG9jayB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrIHVzZWQgdG8gZmV0Y2ggYWRkaXRpb25hbCBkZXRhaWxzXG4gICAgICogIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciwgc29tZXRpbWVzIGNhbGxlZCB0aGUgYmxvY2sgaGVpZ2h0LiBUaGlzIGlzIGFcbiAgICAgKiAgc2VxdWVudGlhbCBudW1iZXIgdGhhdCBpcyBvbmUgaGlnaGVyIHRoYW4gdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBudW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBoYXNoLlxuICAgICAqXG4gICAgICogIFRoaXMgaGFzaCBpbmNsdWRlcyBhbGwgcHJvcGVydGllcywgc28gY2FuIGJlIHNhZmVseSB1c2VkIHRvIGlkZW50aWZ5XG4gICAgICogIGFuIGV4YWN0IHNldCBvZiBibG9jayBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSB0aW1lc3RhbXAgZm9yIHRoaXMgYmxvY2ssIHdoaWNoIGlzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZVxuICAgICAqICBlcG9jaCB0aGF0IHRoaXMgYmxvY2sgd2FzIGluY2x1ZGVkLlxuICAgICAqL1xuICAgIHRpbWVzdGFtcDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIGhhc2ggb2YgdGhlIHBhcmVudCBibG9jay5cbiAgICAgKi9cbiAgICBwYXJlbnRIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzLCB0aGlzIGlzIHRoZSByYW5kb20gbnVtYmVyIGluc2VydGVkIHdoaWNoXG4gICAgICogIHBlcm1pdHRlZCB0aGUgZGlmZmljdWx0eSB0YXJnZXQgdG8gYmUgcmVhY2hlZC5cbiAgICAgKi9cbiAgICBub25jZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRpZmZpY3VsdHkgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIE9uIGxlZ2FjeSBuZXR3b3JrcywgdGhpcyBpcyB0aGUgcHJvb2Ytb2Ytd29yayB0YXJnZXQgcmVxdWlyZWRcbiAgICAgKiAgZm9yIGEgYmxvY2sgdG8gbWVldCB0aGUgcHJvdG9jb2wgcnVsZXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiAgT24gbW9kZXJuIG5ldHdvcmtzLCB0aGlzIGlzIGEgcmFuZG9tIG51bWJlciBhcnJpdmVkIGF0IHVzaW5nXG4gICAgICogIHJhbmRhby4gIEBUT0RPOiBGaW5kIGxpbmtzP1xuICAgICAqL1xuICAgIGRpZmZpY3VsdHk7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgbGltaXQgZm9yIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2FzTGltaXQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB0b3RhbCBnYXMgdXNlZCBpbiB0aGlzIGJsb2NrLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBtaW5lciBjb2luYmFzZSBhZGRyZXNzLCB3aWhjaCByZWNlaXZlcyBhbnkgc3Vic2lkaWVzIGZvclxuICAgICAqICBpbmNsdWRpbmcgdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBtaW5lcjtcbiAgICAvKipcbiAgICAgKiAgQW55IGV4dHJhIGRhdGEgdGhlIHZhbGlkYXRvciB3aXNoZWQgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBleHRyYURhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBiYXNlIGZlZSBwZXIgZ2FzIHRoYXQgYWxsIHRyYW5zYWN0aW9ucyBpbiB0aGlzIGJsb2NrIHdlcmVcbiAgICAgKiAgY2hhcmdlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGFkanVzdHMgYWZ0ZXIgZWFjaCBibG9jaywgZGVwZW5kaW5nIG9uIGhvdyBjb25nZXN0ZWQgdGhlIG5ldHdvcmtcbiAgICAgKiAgaXMuXG4gICAgICovXG4gICAgYmFzZUZlZVBlckdhcztcbiAgICAjdHJhbnNhY3Rpb25zO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipCbG9jayoqIG9iamVjdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIG5lY2Vzc2FyeSBhcyB0aGUgdW5sZXNzIGltcGxlbWVudGluZyBhXG4gICAgICogIGxvdy1sZXZlbCBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiN0cmFuc2FjdGlvbnMgPSBibG9jay50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvblJlc3BvbnNlKHR4LCBwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIGhhc2g6IGdldFZhbHVlKGJsb2NrLmhhc2gpLFxuICAgICAgICAgICAgbnVtYmVyOiBibG9jay5udW1iZXIsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGJsb2NrLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGJsb2NrLnBhcmVudEhhc2gsXG4gICAgICAgICAgICBub25jZTogYmxvY2subm9uY2UsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBibG9jay5kaWZmaWN1bHR5LFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJsb2NrLmdhc0xpbWl0LFxuICAgICAgICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCxcbiAgICAgICAgICAgIG1pbmVyOiBibG9jay5taW5lcixcbiAgICAgICAgICAgIGV4dHJhRGF0YTogYmxvY2suZXh0cmFEYXRhLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogZ2V0VmFsdWUoYmxvY2suYmFzZUZlZVBlckdhcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGhhc2hlcywgaW4gdGhlIG9yZGVyXG4gICAgICogIHRoZXkgd2VyZSBleGVjdXRlZCB3aXRoaW4gdGhlIGJsb2NrLlxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN0cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodHgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4Lmhhc2g7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgY29tcGxldGUgdHJhbnNhY3Rpb25zLCBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAqICB3ZXJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgYmxvY2suXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgYmxvY2tzIHdoaWNoIHByZWZldGNoZWRcbiAgICAgKiAgdHJhbnNhY3Rpb25zLCBieSBwYXNzaW5nIGBgdHJ1ZWBgIHRvICUlcHJlZmV0Y2hUeHMlJVxuICAgICAqICBpbnRvIFtbUHJvdmlkZXItZ2V0QmxvY2tdXS5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmV0Y2hlZFRyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy4jdHJhbnNhY3Rpb25zLnNsaWNlKCk7XG4gICAgICAgIC8vIERvZXNuJ3QgbWF0dGVyLi4uXG4gICAgICAgIGlmICh0eHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHByZWZldGNoZWQgdGhlIHRyYW5zYWN0aW9uc1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHR5cGVvZiAodHhzWzBdKSA9PT0gXCJvYmplY3RcIiwgXCJ0cmFuc2FjdGlvbnMgd2VyZSBub3QgcHJlZmV0Y2hlZCB3aXRoIGJsb2NrIHJlcXVlc3RcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRyYW5zYWN0aW9uUmVzcG9uc2VzKClcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR4cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWZyaWVuZGx5IHZhbHVlLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBiYXNlRmVlUGVyR2FzLCBkaWZmaWN1bHR5LCBleHRyYURhdGEsIGdhc0xpbWl0LCBnYXNVc2VkLCBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJCbG9ja1wiLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogdG9Kc29uKGJhc2VGZWVQZXJHYXMpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdG9Kc29uKGRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgZXh0cmFEYXRhLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHRvSnNvbihnYXNMaW1pdCksXG4gICAgICAgICAgICBnYXNVc2VkOiB0b0pzb24oZ2FzVXNlZCksXG4gICAgICAgICAgICBoYXNoLCBtaW5lciwgbm9uY2UsIG51bWJlciwgcGFyZW50SGFzaCwgdGltZXN0YW1wLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdHhzID0gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eHNbaW5kZXgrK10sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgYmxvY2suXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuI3RyYW5zYWN0aW9ucy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1qcy1kYXRlXV0gdGhpcyBibG9jayB3YXMgaW5jbHVkZWQgYXQuXG4gICAgICovXG4gICAgZ2V0IGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgdHJhbnNhY3Rpb24gYXQgJSVpbmRleGUlJSB3aXRoaW4gdGhpcyBibG9jay5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbihpbmRleE9ySGFzaCkge1xuICAgICAgICAvLyBGaW5kIHRoZSBpbnRlcm5hbCB2YWx1ZSBieSBpdHMgaW5kZXggb3IgaGFzaFxuICAgICAgICBsZXQgdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGluZGV4T3JIYXNoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdHggPSB0aGlzLiN0cmFuc2FjdGlvbnNbaW5kZXhPckhhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy4jdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4ID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eCA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3VjaCB0eFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh0eCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiBhICoqQmxvY2sqKiB3YXMgZmV0Y2hlZCB3aXRoIGEgcmVxdWVzdCB0byBpbmNsdWRlIHRoZSB0cmFuc2FjdGlvbnNcbiAgICAgKiAgdGhpcyB3aWxsIGFsbG93IHN5bmNocm9ub3VzIGFjY2VzcyB0byB0aG9zZSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlIHRyYW5zYWN0aW9ucyB3ZXJlIG5vdCBwcmVmZXRjaGVkLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICovXG4gICAgZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uKGluZGV4T3JIYXNoKSB7XG4gICAgICAgIGNvbnN0IHR4cyA9IHRoaXMucHJlZmV0Y2hlZFRyYW5zYWN0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXhPckhhc2gpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHhzW2luZGV4T3JIYXNoXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleE9ySGFzaCA9IGluZGV4T3JIYXNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdHggb2YgdHhzKSB7XG4gICAgICAgICAgICBpZiAodHguaGFzaCA9PT0gaW5kZXhPckhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcIm5vIG1hdGNoaW5nIHRyYW5zYWN0aW9uXCIsIFwiaW5kZXhPckhhc2hcIiwgaW5kZXhPckhhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgYmxvY2sgYmVlbiBtaW5lZC4gVGhpcyBwcm92aWRlcyBhIHR5cGUgZ3VhcmRcbiAgICAgKiAgZm9yIGFsbCBwcm9wZXJ0aWVzIG9uIGEgW1tNaW5lZEJsb2NrXV0uXG4gICAgICovXG4gICAgaXNNaW5lZCgpIHsgcmV0dXJuICEhdGhpcy5oYXNoOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIGFuIFtbbGluay1laXAtMjkzMF1dIGJsb2NrLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmJhc2VGZWVQZXJHYXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBvcnBoYW5lZEV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNaW5lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5CbG9jayA9IEJsb2NrO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9nXG4vKipcbiAqICBBICoqTG9nKiogaW4gRXRoZXJldW0gcmVwcmVzZW50cyBhbiBldmVudCB0aGF0IGhhcyBiZWVuIGluY2x1ZGVkIGluIGFcbiAqICB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYGBMT0cqYGAgb3Bjb2Rlcywgd2hpY2ggYXJlIG1vc3QgY29tbW9ubHkgdXNlZCBieVxuICogIFNvbGlkaXR5J3MgZW1pdCBmb3IgYW5ub3VuY2luZyBldmVudHMuXG4gKi9cbmNsYXNzIExvZyB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGlzIGxvZyBvY2N1cnJlZCBpbi4gVXNlIHRoZVxuICAgICAqICBbW0xvZy1nZXRUcmFuc2FjdGlvbl1dIHRvIGdldCB0aGUgW1tUcmFuc2FjdGlvblJlc3BvbnNlXV0uXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25IYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgaW4uIFVzZSB0aGVcbiAgICAgKiAgW1tMb2ctZ2V0QmxvY2tdXSB0byBnZXQgdGhlIFtbQmxvY2tdXS5cbiAgICAgKi9cbiAgICBibG9ja0hhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoaXMgbG9nIG9jY3VycmVkIGluLiBJdCBpcyBwcmVmZXJyZWRcbiAgICAgKiAgdG8gdXNlIHRoZSBbW0Jsb2NrLWhhc2hdXSB3aGVuIGZldGNoaW5nIHRoZSByZWxhdGVkIFtbQmxvY2tdXSxcbiAgICAgKiAgc2luY2UgaW4gdGhlIGNhc2Ugb2YgYW4gb3JwaGFuZWQgYmxvY2ssIHRoZSBibG9jayBhdCB0aGF0IGhlaWdodCBtYXlcbiAgICAgKiAgaGF2ZSBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBJZiB0aGUgKipMb2cqKiByZXByZXNlbnRzIGEgYmxvY2sgdGhhdCB3YXMgcmVtb3ZlZCBkdWUgdG8gYW4gb3JwaGFuZWRcbiAgICAgKiAgYmxvY2ssIHRoaXMgd2lsbCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHdpdGhpbiBhbiBvcnBoYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAgICovXG4gICAgcmVtb3ZlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoYXQgZW1pdHRlZCB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICBhZGRyZXNzO1xuICAgIC8qKlxuICAgICAqICBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleGVkIHRvcGljcyBpbmNsdWRlZCBpbiB0aGlzIGxvZyB3aGVuIGl0IHdhcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogIEFsbCB0b3BpY3MgYXJlIGluY2x1ZGVkIGluIHRoZSBibG9vbSBmaWx0ZXJzLCBzbyB0aGV5IGNhbiBiZVxuICAgICAqICBlZmZpY2llbnRseSBmaWx0ZXJlZCB1c2luZyB0aGUgW1tQcm92aWRlci1nZXRMb2dzXV0gbWV0aG9kLlxuICAgICAqL1xuICAgIHRvcGljcztcbiAgICAvKipcbiAgICAgKiAgVGhlIGluZGV4IHdpdGhpbiB0aGUgYmxvY2sgdGhpcyBsb2cgb2NjdXJyZWQgYXQuIFRoaXMgaXMgZ2VuZXJhbGx5XG4gICAgICogIG5vdCB1c2VmdWwgdG8gZGV2ZWxvcGVycywgYnV0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHZhcmlvdXMgcm9vdHNcbiAgICAgKiAgdG8gcHJvb2YgaW5jbHVzaW9uIHdpdGhpbiBhIGJsb2NrLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvZiB0aGlzIGxvZy5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvbkluZGV4O1xuICAgIC8qKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2csIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgY29uc3QgdG9waWNzID0gT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogbG9nLnJlbW92ZWQsXG4gICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgdG9waWNzLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBKU09OLWNvbXBhdGlibGUgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBkYXRhLCBpbmRleCwgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgIGFkZHJlc3MsIGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGRhdGEsIGluZGV4LFxuICAgICAgICAgICAgcmVtb3ZlZCwgdG9waWNzLCB0cmFuc2FjdGlvbkhhc2gsIHRyYW5zYWN0aW9uSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGJsb2NrIHRoYXQgdGhpcyBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmxvY2soKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayh0aGlzLmJsb2NrSGFzaCk7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoISFibG9jaywgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvblwiLCBcIlVOS05PV05fRVJST1JcIiwge30pO1xuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB0aGF0IHRoaXMgbG9nIG9jY3VycmVkIGluLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCEhdHgsIFwiZmFpbGVkIHRvIGZpbmQgdHJhbnNhY3Rpb25cIiwgXCJVTktOT1dOX0VSUk9SXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3QgdGhlIHRyYW5zYWN0aW9uIHRoYXQgdGhpc1xuICAgICAqICBsb2cgb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KCkge1xuICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodGhpcy50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCEhcmVjZWlwdCwgXCJmYWlsZWQgdG8gZmluZCB0cmFuc2FjdGlvbiByZWNlaXB0XCIsIFwiVU5LTk9XTl9FUlJPUlwiLCB7fSk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgcmVtb3ZlZEV2ZW50KCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcih0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkxvZyA9IExvZztcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRyYW5zYWN0aW9uIFJlY2VpcHRcbi8qXG5leHBvcnQgaW50ZXJmYWNlIExlZ2FjeVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiBmYWxzZTtcbiAgICBzdGF0dXM6IG51bGw7XG4gICAgcm9vdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ5emFudGl1bVRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgYnl6YW50aXVtOiB0cnVlO1xuICAgIHN0YXR1czogbnVtYmVyO1xuICAgIHJvb3Q6IG51bGw7XG59XG4qL1xuLyoqXG4gKiAgQSAqKlRyYW5zYWN0aW9uUmVjZWlwdCoqIGluY2x1ZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgYVxuICogIHRyYW5zYWN0aW9uIHRoYXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgaXQgaGFzIGJlZW4gbWluZWQuXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uUmVjZWlwdCB7XG4gICAgLyoqXG4gICAgICogIFRoZSBwcm92aWRlciBjb25uZWN0ZWQgdG8gdGhlIGxvZyB1c2VkIHRvIGZldGNoIGFkZGl0aW9uYWwgZGV0YWlsc1xuICAgICAqICBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBhZGRyZXNzIHRoZSB0cmFuc2FjdGlvbiB3YXMgc2VuZCB0by5cbiAgICAgKi9cbiAgICB0bztcbiAgICAvKipcbiAgICAgKiAgVGhlIHNlbmRlciBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZnJvbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgZGlyZWN0bHlcbiAgICAgKiAgcmVzcG9uc2libGUgZm9yIGRlcGxveWluZyBvbmUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub24tbnVsbCAqKm9ubHkqKiBpZiB0aGUgYGB0b2BgIGlzIGVtcHR5IGFuZCB0aGUgYGBkYXRhYGBcbiAgICAgKiAgd2FzIHN1Y2Nlc3NmdWxseSBleGVjdXRlZCBhcyBpbml0Y29kZS5cbiAgICAgKi9cbiAgICBjb250cmFjdEFkZHJlc3M7XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGhhc2g7XG4gICAgLyoqXG4gICAgICogIFRoZSBpbmRleCBvZiB0aGlzIHRyYW5zYWN0aW9uIHdpdGhpbiB0aGUgYmxvY2sgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluZGV4O1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvY2sgaGFzaCBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrSGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgW1tCbG9ja11dIHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqL1xuICAgIGJsb2NrTnVtYmVyO1xuICAgIC8qKlxuICAgICAqICBUaGUgYmxvb20gZmlsdGVyIGJ5dGVzIHRoYXQgcmVwcmVzZW50IGFsbCBsb2dzIHRoYXQgb2NjdXJyZWQgd2l0aGluXG4gICAgICogIHRoaXMgdHJhbnNhY3Rpb24uIFRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgZm9yIG1vc3QgZGV2ZWxvcGVycyxcbiAgICAgKiAgYnV0IGNhbiBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBpbmNsdWRlZCBsb2dzLlxuICAgICAqL1xuICAgIGxvZ3NCbG9vbTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBXaGVuIGNyZWF0aW5nIGEgdHJhbnNhY3Rpb24sIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd2lsbCBiZSB1c2VkIGNhblxuICAgICAqICBvbmx5IGJlIGFwcHJveGltYXRlZCwgYnV0IHRoZSBzZW5kZXIgbXVzdCBwYXkgdGhlIGdhcyBmZWUgZm9yIHRoZVxuICAgICAqICBlbnRpcmUgZ2FzIGxpbWl0LiBBZnRlciB0aGUgdHJhbnNhY3Rpb24sIHRoZSBkaWZmZXJlbmNlIGlzIHJlZnVuZGVkLlxuICAgICAqL1xuICAgIGdhc1VzZWQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZ2FzIHVzZWQgYnkgYWxsIHRyYW5zYWN0aW9ucyB3aXRoaW4gdGhlIGJsb2NrIGZvciB0aGlzXG4gICAgICogIGFuZCBhbGwgdHJhbnNhY3Rpb25zIHdpdGggYSBsb3dlciBgYGluZGV4YGAuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCBmb3IgZGV2ZWxvcGVycyBidXQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgdmFsaWRhdGUgY2VydGFpbiBhc3BlY3RzIG9mIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBjdW11bGF0aXZlR2FzVXNlZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGFjdHVhbCBnYXMgcHJpY2UgdXNlZCBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogIER1ZSB0byB0aGUgY29tcGxleGl0eSBvZiBbW2xpbmstZWlwLTE1NTldXSB0aGlzIHZhbHVlIGNhbiBvbmx5XG4gICAgICogIGJlIGNhbHVjbGF0ZWQgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkLCBzbmNlIHRoZSBiYXNlXG4gICAgICogIGZlZSBpcyBwcm90b2NvbC1lbmZvcmNlZC5cbiAgICAgKi9cbiAgICBnYXNQcmljZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvL3JlYWRvbmx5IGJ5emFudGl1bSE6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogIFRoZSBzdGF0dXMgb2YgdGhpcyB0cmFuc2FjdGlvbiwgaW5kaWNhdGluZyBzdWNjZXNzIChpLmUuIGBgMWBgKSBvclxuICAgICAqICBhIHJldmVydCAoaS5lLiBgYDBgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBhdmFpbGFibGUgaW4gcG9zdC1ieXphbnRpdW0gYmxvY2tzLCBidXQgc29tZSBiYWNrZW5kcyBtYXlcbiAgICAgKiAgYmFja2ZpbGwgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0dXM7XG4gICAgLyoqXG4gICAgICogIFRoZSByb290IGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIG5vIHByZXNlbnQgYW5kIHdhcyBvbmx5IGluY2x1ZGVkIGluIHByZS1ieXphbnRpdW0gYmxvY2tzLCBidXRcbiAgICAgKiAgY291bGQgYmUgdXNlZCB0byB2YWxpZGF0ZSBjZXJ0YWluIHBhcnRzIG9mIHRoZSByZWNlaXB0LlxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgI2xvZ3M7XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR4LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNsb2dzID0gT2JqZWN0LmZyZWV6ZSh0eC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZyhsb2csIHByb3ZpZGVyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgZ2FzUHJpY2UgPSBCTl8wO1xuICAgICAgICBpZiAodHguZWZmZWN0aXZlR2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2FzUHJpY2UgPSB0eC5lZmZlY3RpdmVHYXNQcmljZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18xLmRlZmluZVByb3BlcnRpZXMpKHRoaXMsIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHguY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgaGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgIGluZGV4OiB0eC5pbmRleCxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogdHguYmxvY2tIYXNoLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHR4LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiB0eC5sb2dzQmxvb20sXG4gICAgICAgICAgICBnYXNVc2VkOiB0eC5nYXNVc2VkLFxuICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IHR4LmN1bXVsYXRpdmVHYXNVc2VkLFxuICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICB0eXBlOiB0eC50eXBlLFxuICAgICAgICAgICAgLy9ieXphbnRpdW06IHR4LmJ5emFudGl1bSxcbiAgICAgICAgICAgIHN0YXR1czogdHguc3RhdHVzLFxuICAgICAgICAgICAgcm9vdDogdHgucm9vdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBsb2dzIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBsb2dzKCkgeyByZXR1cm4gdGhpcy4jbG9nczsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgSlNPTi1jb21wYXRpYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyB0bywgZnJvbSwgY29udHJhY3RBZGRyZXNzLCBoYXNoLCBpbmRleCwgYmxvY2tIYXNoLCBibG9ja051bWJlciwgbG9nc0Jsb29tLCBsb2dzLCAvL2J5emFudGl1bSwgXG4gICAgICAgIHN0YXR1cywgcm9vdCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIlRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgYmxvY2tIYXNoLCBibG9ja051bWJlcixcbiAgICAgICAgICAgIC8vYnl6YW50aXVtLCBcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0b0pzb24odGhpcy5jdW11bGF0aXZlR2FzVXNlZCksXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHRvSnNvbih0aGlzLmdhc1VzZWQpLFxuICAgICAgICAgICAgaGFzaCwgaW5kZXgsIGxvZ3MsIGxvZ3NCbG9vbSwgcm9vdCwgc3RhdHVzLCB0b1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMubG9ncy5sZW5ndGg7IH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy5sb2dzW2luZGV4KytdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgdG90YWwgZmVlIGZvciB0aGlzIHRyYW5zYWN0aW9uLCBpbiB3ZWkuXG4gICAgICovXG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2FzVXNlZCAqIHRoaXMuZ2FzUHJpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgYmxvY2sgdGhpcyB0cmFuc2FjdGlvbiBvY2N1cnJlZCBpbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKHRoaXMuYmxvY2tIYXNoKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhlIHRyYW5zYWN0aW9uIHRoaXMgdHJhbnNhY3Rpb24gb2NjdXJyZWQgaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbih0aGlzLmhhc2gpO1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRpb24gb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBTdXBwb3J0IGZvciB0aGlzIGZlYXR1cmUgaXMgbGltaXRlZCwgYXMgaXQgcmVxdWlyZXMgYW4gYXJjaGl2ZSBub2RlXG4gICAgICogIHdpdGggdGhlIGBgZGVidWdfYGAgb3IgYGB0cmFjZV9gYCBBUEkgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXN1bHQoKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlc3VsdCh0aGlzLmhhc2gpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSkgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIHJlb3JkZXJlZEV2ZW50KG90aGVyKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoIW90aGVyIHx8IG90aGVyLmlzTWluZWQoKSwgXCJ1bm1pbmVkICdvdGhlcicgdHJhbnNjdGlvbiBjYW5ub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVvcmRlcmVkRXZlbnQob3RoZXIpXCIgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzLCBvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlY2VpcHQgPSBUcmFuc2FjdGlvblJlY2VpcHQ7XG4vKipcbiAqICBBICoqVHJhbnNhY3Rpb25SZXNwb25zZSoqIGluY2x1ZGVzIGFsbCBwcm9wZXJ0aWVzIGFib3V0IGEgdHJhbnNhY3Rpb25cbiAqICB0aGF0IHdhcyBzZW50IHRvIHRoZSBuZXR3b3JrLCB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSBpbmNsdWRlZCBpbiBhXG4gKiAgYmxvY2suXG4gKlxuICogIFRoZSBbW1RyYW5zYWN0aW9uUmVzcG9uc2UtaXNNaW5lZF1dIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZVxuICogIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGFzIHdlbGwgYXMgdHlwZSBndWFyZCB0aGF0IHRoZSBvdGhlcndpc2VcbiAqICBwb3NzaWJseSBgYG51bGxgYCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvblJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIHByb3ZpZGVyIHRoaXMgaXMgY29ubmVjdGVkIHRvLCB3aGljaCB3aWxsIGluZmx1ZW5jZSBob3cgaXRzXG4gICAgICogIG1ldGhvZHMgd2lsbCByZXNvbHZlIGl0cyBhc3luYyBpbnNwZWN0aW9uIG1ldGhvZHMuXG4gICAgICovXG4gICAgcHJvdmlkZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9jayBudW1iZXIgb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIFRoZSBibG9ja0hhc2ggb2YgdGhlIGJsb2NrIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3YXMgaW5jbHVkZWQgaW4uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBgYG51bGxgYCBmb3IgcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgYmxvY2tIYXNoO1xuICAgIC8qKlxuICAgICAqICBUaGUgaW5kZXggd2l0aGluIHRoZSBibG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gcmVzaWRlcyBhdC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgaGFzaDtcbiAgICAvKipcbiAgICAgKiAgVGhlIFtbbGluay1laXAtMjcxOF1dIHRyYW5zYWN0aW9uIGVudmVsb3BlIHR5cGUuIFRoaXMgaXNcbiAgICAgKiAgYGAwYGAgZm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgdHlwZXMuXG4gICAgICovXG4gICAgdHlwZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHJlY2VpdmVyIG9mIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiAgSWYgYGBudWxsYGAsIHRoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFuIGluaXRjb2RlIHRyYW5zYWN0aW9uLlxuICAgICAqICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSBbW2RhdGFdXSB3aWxsIGJlIGRlcGxveWVkXG4gICAgICogIGFzIGEgbmV3IGNvbnRyYWN0IG9uIGNoYWluIChhc3N1bWluZyBpdCBkb2VzIG5vdCByZXZlcnQpIGFuZCB0aGVcbiAgICAgKiAgYWRkcmVzcyBtYXkgYmUgY29tcHV0ZWQgdXNpbmcgW1tnZXRDcmVhdGVBZGRyZXNzXV0uXG4gICAgICovXG4gICAgdG87XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kZXIgb2YgdGhpcyB0cmFuc2FjdGlvbi4gSXQgaXMgaW1wbGljaXRseSBjb21wdXRlZFxuICAgICAqICBmcm9tIHRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UgaGFzaCAoYXMgdGhlIGRpZ2VzdCkgYW5kIHRoZVxuICAgICAqICBbW3NpZ25hdHVyZV1dIHVzaW5nIGVjcmVjb3Zlci5cbiAgICAgKi9cbiAgICBmcm9tO1xuICAgIC8qKlxuICAgICAqICBUaGUgbm9uY2UsIHdoaWNoIGlzIHVzZWQgdG8gcHJldmVudCByZXBsYXkgYXR0YWNrcyBhbmQgb2ZmZXJcbiAgICAgKiAgYSBtZXRob2QgdG8gZW5zdXJlIHRyYW5zYWN0aW9ucyBmcm9tIGEgZ2l2ZW4gc2VuZGVyIGFyZSBleHBsaWNpdGx5XG4gICAgICogIG9yZGVyZWQuXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZW5kaW5nIGEgdHJhbnNhY3Rpb24sIHRoaXMgbXVzdCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICogIHRyYW5zYWN0aW9ucyBldmVyIHNlbnQgYnkgW1tmcm9tXV0uXG4gICAgICovXG4gICAgbm9uY2U7XG4gICAgLyoqXG4gICAgICogIFRoZSBtYXhpbXVtIHVuaXRzIG9mIGdhcyB0aGlzIHRyYW5zYWN0aW9uIGNhbiBjb25zdW1lLiBJZiBleGVjdXRpb25cbiAgICAgKiAgZXhjZWVkcyB0aGlzLCB0aGUgZW50cmllcyB0cmFuc2FjdGlvbiBpcyByZXZlcnRlZCBhbmQgdGhlIHNlbmRlclxuICAgICAqICBpcyBjaGFyZ2VkIGZvciB0aGUgZnVsbCBhbW91bnQsIGRlc3BpdGUgbm90IHN0YXRlIGNoYW5nZXMgYmVpbmcgbWFkZS5cbiAgICAgKi9cbiAgICBnYXNMaW1pdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBwcmljZSBjYW4gaGF2ZSB2YXJpb3VzIHZhbHVlcywgZGVwZW5kaW5nIG9uIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogIEluIG1vZGVybiBuZXR3b3JrcywgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBpbmNsdWRlZCB0aGlzIGlzXG4gICAgICogIHRoZSAvL2VmZmVjdGl2ZSBnYXMgcHJpY2UvLyAodGhlIGZlZSBwZXIgZ2FzIHRoYXQgd2FzIGFjdHVhbGx5XG4gICAgICogIGNoYXJnZWQpLCB3aGlsZSBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgaGF2ZSBub3QgYmVlbiBpbmNsdWRlZCB5ZXRcbiAgICAgKiAgaXMgdGhlIFtbbWF4RmVlUGVyR2FzXV0uXG4gICAgICpcbiAgICAgKiAgRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMsIG9yIHRyYW5zYWN0aW9ucyBvbiBsZWdhY3kgbmV0d29ya3MsIHRoaXNcbiAgICAgKiAgaXMgdGhlIGZlZSB0aGF0IHdpbGwgYmUgY2hhcmdlZCBwZXIgdW5pdCBvZiBnYXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogIGNvbnN1bWVzLlxuICAgICAqL1xuICAgIGdhc1ByaWNlO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgYVxuICAgICAqICB2YWxpZGF0b3IgdG8gY2hhcmdlIHRoZSBzZW5kZXIuIFRoaXMgaXMgaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqICBbW21heEZlZUZlZVBlckdhc11dLlxuICAgICAqL1xuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBmZWUgKHBlciB1bml0IG9mIGdhcykgdG8gYWxsb3cgdGhpcyB0cmFuc2FjdGlvblxuICAgICAqICB0byBjaGFyZ2UgdGhlIHNlbmRlci5cbiAgICAgKi9cbiAgICBtYXhGZWVQZXJHYXM7XG4gICAgLyoqXG4gICAgICogIFRoZSBkYXRhLlxuICAgICAqL1xuICAgIGRhdGE7XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSwgaW4gd2VpLiBVc2UgW1tmb3JtYXRFdGhlcl1dIHRvIGZvcm1hdCB0aGlzIHZhbHVlXG4gICAgICogIGFzIGV0aGVyLlxuICAgICAqL1xuICAgIHZhbHVlO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQuXG4gICAgICovXG4gICAgY2hhaW5JZDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBzaWduYXR1cmU7XG4gICAgLyoqXG4gICAgICogIFRoZSBbW2xpbmstZWlwLTI5MzBdXSBhY2Nlc3MgbGlzdCBmb3IgdHJhbnNhY3Rpb24gdHlwZXMgdGhhdFxuICAgICAqICBzdXBwb3J0IGl0LCBvdGhlcndpc2UgYGBudWxsYGAuXG4gICAgICovXG4gICAgYWNjZXNzTGlzdDtcbiAgICAjc3RhcnRCbG9jaztcbiAgICAvKipcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5ibG9ja051bWJlciA9ICh0eC5ibG9ja051bWJlciAhPSBudWxsKSA/IHR4LmJsb2NrTnVtYmVyIDogbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSAodHguYmxvY2tIYXNoICE9IG51bGwpID8gdHguYmxvY2tIYXNoIDogbnVsbDtcbiAgICAgICAgdGhpcy5oYXNoID0gdHguaGFzaDtcbiAgICAgICAgdGhpcy5pbmRleCA9IHR4LmluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSB0eC5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gdHgudG8gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5nYXNMaW1pdCA9IHR4Lmdhc0xpbWl0O1xuICAgICAgICB0aGlzLm5vbmNlID0gdHgubm9uY2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0eC52YWx1ZTtcbiAgICAgICAgdGhpcy5nYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpID8gdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLm1heEZlZVBlckdhcyA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkgPyB0eC5tYXhGZWVQZXJHYXMgOiBudWxsO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NMaXN0ID0gKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkgPyB0eC5hY2Nlc3NMaXN0IDogbnVsbDtcbiAgICAgICAgdGhpcy4jc3RhcnRCbG9jayA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIEpTT04tY29tcGF0aWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tIYXNoLCBpbmRleCwgaGFzaCwgdHlwZSwgdG8sIGZyb20sIG5vbmNlLCBkYXRhLCBzaWduYXR1cmUsIGFjY2Vzc0xpc3QgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogXCJUcmFuc2FjdGlvblJlY2VpcHRcIixcbiAgICAgICAgICAgIGFjY2Vzc0xpc3QsIGJsb2NrTnVtYmVyLCBibG9ja0hhc2gsXG4gICAgICAgICAgICBjaGFpbklkOiB0b0pzb24odGhpcy5jaGFpbklkKSxcbiAgICAgICAgICAgIGRhdGEsIGZyb20sXG4gICAgICAgICAgICBnYXNMaW1pdDogdG9Kc29uKHRoaXMuZ2FzTGltaXQpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRvSnNvbih0aGlzLmdhc1ByaWNlKSxcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHRvSnNvbih0aGlzLm1heEZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogdG9Kc29uKHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgbm9uY2UsIHNpZ25hdHVyZSwgdG8sIGluZGV4LCB0eXBlLFxuICAgICAgICAgICAgdmFsdWU6IHRvSnNvbih0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIHRoZSBCbG9jayB0aGF0IHRoaXMgdHJhbnNhY3Rpb24gd2FzIGluY2x1ZGVkIGluLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIHlldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCbG9jaygpIHtcbiAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gdGhpcy5ibG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHR4KSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0eC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmVzb2x2ZXMgdG8gdGhpcyB0cmFuc2FjdGlvbiBiZWluZyByZS1yZXF1ZXN0ZWQgZnJvbSB0aGVcbiAgICAgKiAgcHJvdmlkZXIuIFRoaXMgY2FuIGJlIHVzZWQgaWYgeW91IGhhdmUgYW4gdW5taW5lZCB0cmFuc2FjdGlvblxuICAgICAqICBhbmQgd2lzaCB0byBnZXQgYW4gdXAtdG8tZGF0ZSBwb3B1bGF0ZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRoaXMuaGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlIHRvIHRoZSBudW1iZXIgb2YgY29uZmlybWF0aW9ucyB0aGlzIHRyYW5zYWN0aW9uIGhhcy5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtYXRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHR4LCBibG9ja051bWJlciB9ID0gYXdhaXQgKDAsIGluZGV4X2pzXzEucmVzb2x2ZVByb3BlcnRpZXMpKHtcbiAgICAgICAgICAgICAgICB0eDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm90IG1pbmVkIHlldC4uLlxuICAgICAgICAgICAgaWYgKHR4ID09IG51bGwgfHwgdHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xuICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgLSB0aGlzLmJsb2NrTnVtYmVyICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIG9uY2UgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtaW5lZCBhbmQgaGFzXG4gICAgICogICUlY29uZmlybXMlJSBibG9ja3MgaW5jbHVkaW5nIGl0IChkZWZhdWx0OiBgYDFgYCkgd2l0aCBhblxuICAgICAqICBvcHRpb25hbCAlJXRpbWVvdXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNhbiByZXNvbHZlIHRvIGBgbnVsbGBgIG9ubHkgaWYgJSVjb25maXJtcyUlIGlzIGBgMGBgXG4gICAgICogIGFuZCB0aGUgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIG1pbmVkLCBvdGhlcndpc2UgdGhpcyB3aWxsXG4gICAgICogIHdhaXQgdW50aWwgZW5vdWdoIGNvbmZpcm1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdChfY29uZmlybXMsIF90aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1zID0gKF9jb25maXJtcyA9PSBudWxsKSA/IDEgOiBfY29uZmlybXM7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX3RpbWVvdXQgPT0gbnVsbCkgPyAwIDogX3RpbWVvdXQ7XG4gICAgICAgIGxldCBzdGFydEJsb2NrID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgbGV0IG5leHRTY2FuID0gLTE7XG4gICAgICAgIGxldCBzdG9wU2Nhbm5pbmcgPSAoc3RhcnRCbG9jayA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGVja1JlcGxhY2VtZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGlzIHNlbmRlclxuICAgICAgICAgICAgaWYgKHN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBibG9ja051bWJlciwgbm9uY2UgfSA9IGF3YWl0ICgwLCBpbmRleF9qc18xLnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBub25jZTogdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZnJvbSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm8gdHJhbnNhY3Rpb24gb3Igb3VyIG5vbmNlIGhhcyBub3QgYmVlbiBtaW5lZCB5ZXQ7IGJ1dCB3ZVxuICAgICAgICAgICAgLy8gY2FuIHN0YXJ0IHNjYW5uaW5nIGxhdGVyIHdoZW4gd2UgZG8gc3RhcnRcbiAgICAgICAgICAgIGlmIChub25jZSA8IHRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydEJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2Ugd2VyZSBtaW5lZDsgbm8gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbmVkID0gYXdhaXQgdGhpcy5nZXRUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG1pbmVkICYmIG1pbmVkLmJsb2NrTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB3ZXJlIHJlcGxhY2VkOyBzdGFydCBzY2FubmluZyBmb3IgdGhhdCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gU3RhcnRpbmcgdG8gc2NhbjsgbG9vayBiYWNrIGEgZmV3IGV4dHJhIGJsb2NrcyBmb3Igc2FmZXR5XG4gICAgICAgICAgICBpZiAobmV4dFNjYW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4gPSBzdGFydEJsb2NrIC0gMztcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNjYW4gPCB0aGlzLiNzdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTY2FuID0gdGhpcy4jc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAobmV4dFNjYW4gPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgYmxvY2sgdG8gc2NhblxuICAgICAgICAgICAgICAgIGlmIChzdG9wU2Nhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRCbG9jayhuZXh0U2NhbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjsgYnV0IHdlJ2xsIHRyeSBhZ2FpbiBzaG9ydGx5XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIG1pbmVkOyBubyByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaCA9PT0gdGhpcy5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgdHJhbnNhY3Rpb24gdGhhdCByZXBsYWNlZCB1c1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBibG9jay5nZXRUcmFuc2FjdGlvbihpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20gPT09IHRoaXMuZnJvbSAmJiB0eC5ub25jZSA9PT0gdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZWNlaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcFNjYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHguaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOyBidXQgd2UnbGwgdHJ5IGFnYWluIHNob3J0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIHJldHJ5IHRoaXMgb24gdGhlIG5leHQgYmxvY2sgKHRoaXMgY2FzZSBjb3VsZCBiZSBvcHRpbWl6ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDEpIDwgY29uZmlybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWFzb24gPSBcInJlcGxhY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gdGhpcy5kYXRhICYmIHR4LnRvID09PSB0aGlzLnRvICYmIHR4LnZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0eC5yZXBsYWNlYWJsZVRyYW5zYWN0aW9uKHN0YXJ0QmxvY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dFNjYW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2tSZWNlaXB0ID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgfHwgcmVjZWlwdC5zdGF0dXMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18xLmFzc2VydCkoZmFsc2UsIFwidHJhbnNhY3Rpb24gZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiQ0FMTF9FWENFUFRJT05cIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLCByZWFzb246IG51bGwsIGludm9jYXRpb246IG51bGwsIHJldmVydDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0bzogcmVjZWlwdC50byxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcmVjZWlwdC5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBcIlwiIC8vIEBUT0RPOiBpbiB2Nywgc3BsaXQgb3V0IHNlbmRUcmFuc2FjdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgfSwgcmVjZWlwdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0aGlzLmhhc2gpO1xuICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1JlY2VpcHQocmVjZWlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVjZWlwdChyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aHJvd3MgaWYgYSByZXBsYWNlbWVudCB3YXMgZm91bmRcbiAgICAgICAgICAgIGF3YWl0IGNoZWNrUmVwbGFjZW1lbnQoKTtcbiAgICAgICAgICAgIC8vIEFsbG93IG51bGwgb25seSB3aGVuIHRoZSBjb25maXJtcyBpcyAwXG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0IG9mIHRoaW5ncyB0byBjYW5jZWwgd2hlbiB3ZSBoYXZlIGEgcmVzdWx0IChvbmUgd2F5IG9yIHRoZSBvdGhlcilcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHsgY2FuY2VsbGVycy5mb3JFYWNoKChjKSA9PiBjKCkpOyB9O1xuICAgICAgICAgICAgLy8gT24gY2FuY2VsLCBzdG9wIHNjYW5uaW5nIGZvciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IHN0b3BTY2FubmluZyA9IHRydWU7IH0pO1xuICAgICAgICAgICAgLy8gU2V0IHVwIGFueSB0aW1lb3V0IHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgoMCwgaW5kZXhfanNfMS5tYWtlRXJyb3IpKFwid2FpdCBmb3IgdHJhbnNhY3Rpb24gdGltZW91dFwiLCBcIlRJTUVPVVRcIikpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlcnMucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhMaXN0ZW5lciA9IGFzeW5jIChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uZTsgcmV0dXJuIGl0IVxuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgcmVjZWlwdC5jb25maXJtYXRpb25zKCkpID49IGNvbmZpcm1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjaGVja1JlY2VpcHQocmVjZWlwdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW5jZWxsZXJzLnB1c2goKCkgPT4geyB0aGlzLnByb3ZpZGVyLm9mZih0aGlzLmhhc2gsIHR4TGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24odGhpcy5oYXNoLCB0eExpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcmVwbGFjZW1lbnQgZGV0ZWN0aW9uOyBzdGFydCBjaGVja2luZ1xuICAgICAgICAgICAgaWYgKHN0YXJ0QmxvY2sgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VMaXN0ZW5lciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHJlcGxhY2VtZW50OyB0aGlzIHRocm93cyBvbmx5IGlmIG9uZSBpcyBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hlY2tSZXBsYWNlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSByZXBsYWNlZCAod2l0aCBlbm91Z2ggY29uZmlybXMpOyByZS10aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2NoZXVkbGUgYSBjaGVjayBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3BTY2FubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FuY2VsbGVycy5wdXNoKCgpID0+IHsgdGhpcy5wcm92aWRlci5vZmYoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHdhaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYGB0cnVlYGAgaWYgdGhpcyB0cmFuc2FjdGlvbiBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGVmZmVjdGl2ZSBvbmx5IGFzIG9mIHRoZSB0aW1lIHRoZSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgICogIHdhcyBpbnN0YW50aWF0ZWQuIFRvIGdldCB1cC10by1kYXRlIGluZm9ybWF0aW9uLCB1c2VcbiAgICAgKiAgW1tnZXRUcmFuc2FjdGlvbl1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgbm9uLW51bGwgcHJvcGVydHkgdmFsdWVzIGZvciBwcm9wZXJ0aWVzIHRoYXQgYXJlIG51bGwgZm9yXG4gICAgICogIHVubWluZWQgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGlzTWluZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ibG9ja0hhc2ggIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGEgbGVnYWN5IChpLmUuIGBgdHlwZSA9PSAwYGApXG4gICAgICogIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xlZ2FjeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIEJlcmxpbiAoaS5lLiBgYHR5cGUgPT0gMWBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMjA3MF1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhIExvbmRvbiAoaS5lLiBgYHR5cGUgPT0gMmBgKVxuICAgICAqICB0cmFuc2FjdGlvbi4gU2VlIFtbbGluay1laXAtMTU1OV1dLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlIGBgbnVsbGBgLW5lc3MgZm9yIGhhcmRmb3JrLXNwZWNpZmljIHByb3BlcnRpZXMgc2V0IGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICBpc0xvbmRvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZpbHRlciB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIG9ycGhhbiBldmVudHNcbiAgICAgKiAgdGhhdCBldmljdCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHJlbW92ZWRFdmVudCgpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0KSh0aGlzLmlzTWluZWQoKSwgXCJ1bm1pbmVkIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlcih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBmaWx0ZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBvcnBoYW4gZXZlbnRzXG4gICAgICogIHRoYXQgcmUtb3JkZXIgdGhpcyBldmVudCBhZ2FpbnN0ICUlb3RoZXIlJS5cbiAgICAgKi9cbiAgICByZW9yZGVyZWRFdmVudChvdGhlcikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKHRoaXMuaXNNaW5lZCgpLCBcInVubWluZWQgdHJhbnNhY3Rpb24gY2Fub3QgYmUgb3JwaGFuZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwicmVtb3ZlRXZlbnQoKVwiIH0pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKCFvdGhlciB8fCBvdGhlci5pc01pbmVkKCksIFwidW5taW5lZCAnb3RoZXInIHRyYW5zYWN0aW9uIGNhbm90IGJlIG9ycGhhbmVkXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcInJlbW92ZUV2ZW50KClcIiB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlb3JkZXJlZFRyYW5zYWN0aW9uRmlsdGVyKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSBpbnN0YW5jZSB3aGljaCBoYXMgdGhlIGFiaWxpdHkgdG9cbiAgICAgKiAgZGV0ZWN0IChhbmQgdGhyb3cgYW4gZXJyb3IpIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyByZXBsYWNlZCwgd2hpY2hcbiAgICAgKiAgd2lsbCBiZWdpbiBzY2FubmluZyBhdCAlJXN0YXJ0QmxvY2slJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIHVzZWQgYnkgZGV2ZWxvcGVycyBhbmQgaXMgaW50ZW5kZWRcbiAgICAgKiAgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIFNldHRpbmcgYW4gaW5jb3JyZWN0ICUlc3RhcnRCbG9jayUlIGNhblxuICAgICAqICBoYXZlIGRldmFzdGF0aW5nIHBlcmZvcm1hbmNlIGNvbnNlcXVlbmNlcyBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAqL1xuICAgIHJlcGxhY2VhYmxlVHJhbnNhY3Rpb24oc3RhcnRCbG9jaykge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcihzdGFydEJsb2NrKSAmJiBzdGFydEJsb2NrID49IDAsIFwiaW52YWxpZCBzdGFydEJsb2NrXCIsIFwic3RhcnRCbG9ja1wiLCBzdGFydEJsb2NrKTtcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb25SZXNwb25zZSh0aGlzLCB0aGlzLnByb3ZpZGVyKTtcbiAgICAgICAgdHguI3N0YXJ0QmxvY2sgPSBzdGFydEJsb2NrO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3BvbnNlID0gVHJhbnNhY3Rpb25SZXNwb25zZTtcbmZ1bmN0aW9uIGNyZWF0ZU9ycGhhbmVkQmxvY2tGaWx0ZXIoYmxvY2spIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1ibG9ja1wiLCBoYXNoOiBibG9jay5oYXNoLCBudW1iZXI6IGJsb2NrLm51bWJlciB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVvcmRlcmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgsIG90aGVyKSB7XG4gICAgcmV0dXJuIHsgb3JwaGFuOiBcInJlb3JkZXItdHJhbnNhY3Rpb25cIiwgdHgsIG90aGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZW1vdmVkVHJhbnNhY3Rpb25GaWx0ZXIodHgpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC10cmFuc2FjdGlvblwiLCB0eCB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlcihsb2cpIHtcbiAgICByZXR1cm4geyBvcnBoYW46IFwiZHJvcC1sb2dcIiwgbG9nOiB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGxvZy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGxvZy5ibG9ja0hhc2gsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbG9nLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgIHRvcGljczogT2JqZWN0LmZyZWV6ZShsb2cudG9waWNzLnNsaWNlKCkpLFxuICAgICAgICAgICAgaW5kZXg6IGxvZy5pbmRleFxuICAgICAgICB9IH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUcmFuc2FjdGlvblJlc3BvbnNlIiwiVHJhbnNhY3Rpb25SZWNlaXB0IiwiTG9nIiwiQmxvY2siLCJjb3B5UmVxdWVzdCIsIkZlZURhdGEiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJCTl8wIiwiQmlnSW50IiwiZ2V0VmFsdWUiLCJ0b0pzb24iLCJ0b1N0cmluZyIsImNvbnN0cnVjdG9yIiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0b0pTT04iLCJfdHlwZSIsInJlcSIsInJlc3VsdCIsInRvIiwiZnJvbSIsImRhdGEiLCJoZXhsaWZ5IiwiYmlnSW50S2V5cyIsInNwbGl0Iiwia2V5IiwiZ2V0QmlnSW50IiwibnVtYmVyS2V5cyIsImdldE51bWJlciIsImFjY2Vzc0xpc3QiLCJhY2Nlc3NMaXN0aWZ5IiwiYmxvY2tUYWciLCJlbmFibGVDY2lwUmVhZCIsImN1c3RvbURhdGEiLCJ0cmFuc2FjdGlvbnMiLCJibG9jayIsInByb3ZpZGVyIiwibWFwIiwidHgiLCJoYXNoIiwibnVtYmVyIiwidGltZXN0YW1wIiwicGFyZW50SGFzaCIsIm5vbmNlIiwiZGlmZmljdWx0eSIsImdhc0xpbWl0IiwiZ2FzVXNlZCIsIm1pbmVyIiwiZXh0cmFEYXRhIiwiYmFzZUZlZVBlckdhcyIsInByZWZldGNoZWRUcmFuc2FjdGlvbnMiLCJ0eHMiLCJzbGljZSIsImxlbmd0aCIsImFzc2VydCIsIm9wZXJhdGlvbiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaW5kZXgiLCJuZXh0IiwiZG9uZSIsInVuZGVmaW5lZCIsImRhdGUiLCJEYXRlIiwiZ2V0VHJhbnNhY3Rpb24iLCJpbmRleE9ySGFzaCIsInRvTG93ZXJDYXNlIiwidiIsIkVycm9yIiwiZ2V0UHJlZmV0Y2hlZFRyYW5zYWN0aW9uIiwiYXNzZXJ0QXJndW1lbnQiLCJpc01pbmVkIiwiaXNMb25kb24iLCJvcnBoYW5lZEV2ZW50IiwiY3JlYXRlT3JwaGFuZWRCbG9ja0ZpbHRlciIsImxvZyIsInRvcGljcyIsImZyZWV6ZSIsInRyYW5zYWN0aW9uSGFzaCIsImJsb2NrSGFzaCIsImJsb2NrTnVtYmVyIiwicmVtb3ZlZCIsImFkZHJlc3MiLCJ0cmFuc2FjdGlvbkluZGV4IiwiZ2V0QmxvY2siLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJyZWNlaXB0IiwicmVtb3ZlZEV2ZW50IiwiY3JlYXRlUmVtb3ZlZExvZ0ZpbHRlciIsImxvZ3MiLCJlZmZlY3RpdmVHYXNQcmljZSIsImNvbnRyYWN0QWRkcmVzcyIsImxvZ3NCbG9vbSIsImN1bXVsYXRpdmVHYXNVc2VkIiwidHlwZSIsInN0YXR1cyIsInJvb3QiLCJmZWUiLCJnZXRSZXN1bHQiLCJnZXRUcmFuc2FjdGlvblJlc3VsdCIsImNvbmZpcm1hdGlvbnMiLCJnZXRCbG9ja051bWJlciIsImNyZWF0ZVJlbW92ZWRUcmFuc2FjdGlvbkZpbHRlciIsInJlb3JkZXJlZEV2ZW50Iiwib3RoZXIiLCJjcmVhdGVSZW9yZGVyZWRUcmFuc2FjdGlvbkZpbHRlciIsInN0YXJ0QmxvY2siLCJjaGFpbklkIiwic2lnbmF0dXJlIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJ3YWl0IiwiX2NvbmZpcm1zIiwiX3RpbWVvdXQiLCJjb25maXJtcyIsInRpbWVvdXQiLCJuZXh0U2NhbiIsInN0b3BTY2FubmluZyIsImNoZWNrUmVwbGFjZW1lbnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwibWluZWQiLCJpIiwicmVhc29uIiwiY2FuY2VsbGVkIiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlYWJsZVRyYW5zYWN0aW9uIiwiY2hlY2tSZWNlaXB0IiwiYWN0aW9uIiwiaW52b2NhdGlvbiIsInJldmVydCIsInRyYW5zYWN0aW9uIiwid2FpdGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYW5jZWxsZXJzIiwiY2FuY2VsIiwiZm9yRWFjaCIsImMiLCJwdXNoIiwidGltZXIiLCJzZXRUaW1lb3V0IiwibWFrZUVycm9yIiwiY2xlYXJUaW1lb3V0IiwidHhMaXN0ZW5lciIsImVycm9yIiwib2ZmIiwib24iLCJyZXBsYWNlTGlzdGVuZXIiLCJpc0Vycm9yIiwib25jZSIsImlzTGVnYWN5IiwiaXNCZXJsaW4iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJvcnBoYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NonceManager = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst abstract_signer_js_1 = __webpack_require__(/*! ./abstract-signer.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/abstract-signer.js\");\n/**\n *  A **NonceManager** wraps another [[Signer]] and automatically manages\n *  the nonce, ensuring serialized and sequential nonces are used during\n *  transaction.\n */ class NonceManager extends abstract_signer_js_1.AbstractSigner {\n    #noncePromise;\n    #delta;\n    /**\n     *  Creates a new **NonceManager** to manage %%signer%%.\n     */ constructor(signer){\n        super(signer.provider);\n        (0, index_js_1.defineProperties)(this, {\n            signer\n        });\n        this.#noncePromise = null;\n        this.#delta = 0;\n    }\n    async getAddress() {\n        return this.signer.getAddress();\n    }\n    connect(provider) {\n        return new NonceManager(this.signer.connect(provider));\n    }\n    async getNonce(blockTag) {\n        if (blockTag === \"pending\") {\n            if (this.#noncePromise == null) {\n                this.#noncePromise = super.getNonce(\"pending\");\n            }\n            const delta = this.#delta;\n            return await this.#noncePromise + delta;\n        }\n        return super.getNonce(blockTag);\n    }\n    /**\n     *  Manually increment the nonce. This may be useful when managng\n     *  offline transactions.\n     */ increment() {\n        this.#delta++;\n    }\n    /**\n     *  Resets the nonce, causing the **NonceManager** to reload the current\n     *  nonce from the blockchain on the next transaction.\n     */ reset() {\n        this.#delta = 0;\n        this.#noncePromise = null;\n    }\n    async sendTransaction(tx) {\n        const noncePromise = this.getNonce(\"pending\");\n        this.increment();\n        tx = await this.signer.populateTransaction(tx);\n        tx.nonce = await noncePromise;\n        // @TODO: Maybe handle interesting/recoverable errors?\n        // Like don't increment if the tx was certainly not sent\n        return await this.signer.sendTransaction(tx);\n    }\n    signTransaction(tx) {\n        return this.signer.signTransaction(tx);\n    }\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n    signTypedData(domain, types, value) {\n        return this.signer.signTypedData(domain, types, value);\n    }\n}\nexports.NonceManager = NonceManager; //# sourceMappingURL=signer-noncemanager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc2lnbmVyLW5vbmNlbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQyxtR0FBc0I7QUFDM0Q7Ozs7Q0FJQyxHQUNELE1BQU1GLHFCQUFxQkcscUJBQXFCQyxjQUFjO0lBSzFELENBQUNDLFlBQVksQ0FBQztJQUNkLENBQUNDLEtBQUssQ0FBQztJQUNQOztLQUVDLEdBQ0RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNoQixLQUFLLENBQUNBLE9BQU9DLFFBQVE7UUFDcEIsSUFBR1IsV0FBV1MsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQUVGO1FBQU87UUFDaEQsSUFBSSxDQUFDLENBQUNILFlBQVksR0FBRztRQUNyQixJQUFJLENBQUMsQ0FBQ0MsS0FBSyxHQUFHO0lBQ2xCO0lBQ0EsTUFBTUssYUFBYTtRQUNmLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNHLFVBQVU7SUFDakM7SUFDQUMsUUFBUUgsUUFBUSxFQUFFO1FBQ2QsT0FBTyxJQUFJVCxhQUFhLElBQUksQ0FBQ1EsTUFBTSxDQUFDSSxPQUFPLENBQUNIO0lBQ2hEO0lBQ0EsTUFBTUksU0FBU0MsUUFBUSxFQUFFO1FBQ3JCLElBQUlBLGFBQWEsV0FBVztZQUN4QixJQUFJLElBQUksQ0FBQyxDQUFDVCxZQUFZLElBQUksTUFBTTtnQkFDNUIsSUFBSSxDQUFDLENBQUNBLFlBQVksR0FBRyxLQUFLLENBQUNRLFNBQVM7WUFDeEM7WUFDQSxNQUFNUCxRQUFRLElBQUksQ0FBQyxDQUFDQSxLQUFLO1lBQ3pCLE9BQU8sTUFBTyxJQUFJLENBQUMsQ0FBQ0QsWUFBWSxHQUFJQztRQUN4QztRQUNBLE9BQU8sS0FBSyxDQUFDTyxTQUFTQztJQUMxQjtJQUNBOzs7S0FHQyxHQUNEQyxZQUFZO1FBQ1IsSUFBSSxDQUFDLENBQUNULEtBQUs7SUFDZjtJQUNBOzs7S0FHQyxHQUNEVSxRQUFRO1FBQ0osSUFBSSxDQUFDLENBQUNWLEtBQUssR0FBRztRQUNkLElBQUksQ0FBQyxDQUFDRCxZQUFZLEdBQUc7SUFDekI7SUFDQSxNQUFNWSxnQkFBZ0JDLEVBQUUsRUFBRTtRQUN0QixNQUFNYixlQUFlLElBQUksQ0FBQ1EsUUFBUSxDQUFDO1FBQ25DLElBQUksQ0FBQ0UsU0FBUztRQUNkRyxLQUFLLE1BQU0sSUFBSSxDQUFDVixNQUFNLENBQUNXLG1CQUFtQixDQUFDRDtRQUMzQ0EsR0FBR0UsS0FBSyxHQUFHLE1BQU1mO1FBQ2pCLHNEQUFzRDtRQUN0RCx3REFBd0Q7UUFDeEQsT0FBTyxNQUFNLElBQUksQ0FBQ0csTUFBTSxDQUFDUyxlQUFlLENBQUNDO0lBQzdDO0lBQ0FHLGdCQUFnQkgsRUFBRSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDVixNQUFNLENBQUNhLGVBQWUsQ0FBQ0g7SUFDdkM7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDZixNQUFNLENBQUNjLFdBQVcsQ0FBQ0M7SUFDbkM7SUFDQUMsY0FBY0MsTUFBTSxFQUFFQyxLQUFLLEVBQUUzQixLQUFLLEVBQUU7UUFDaEMsT0FBTyxJQUFJLENBQUNTLE1BQU0sQ0FBQ2dCLGFBQWEsQ0FBQ0MsUUFBUUMsT0FBTzNCO0lBQ3BEO0FBQ0o7QUFDQUQsb0JBQW9CLEdBQUdFLGNBQ3ZCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zaWduZXItbm9uY2VtYW5hZ2VyLmpzPzMzYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vbmNlTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBhYnN0cmFjdF9zaWduZXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0LXNpZ25lci5qc1wiKTtcbi8qKlxuICogIEEgKipOb25jZU1hbmFnZXIqKiB3cmFwcyBhbm90aGVyIFtbU2lnbmVyXV0gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlc1xuICogIHRoZSBub25jZSwgZW5zdXJpbmcgc2VyaWFsaXplZCBhbmQgc2VxdWVudGlhbCBub25jZXMgYXJlIHVzZWQgZHVyaW5nXG4gKiAgdHJhbnNhY3Rpb24uXG4gKi9cbmNsYXNzIE5vbmNlTWFuYWdlciBleHRlbmRzIGFic3RyYWN0X3NpZ25lcl9qc18xLkFic3RyYWN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIFNpZ25lciBiZWluZyBtYW5hZ2VkLlxuICAgICAqL1xuICAgIHNpZ25lcjtcbiAgICAjbm9uY2VQcm9taXNlO1xuICAgICNkZWx0YTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKk5vbmNlTWFuYWdlcioqIHRvIG1hbmFnZSAlJXNpZ25lciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpZ25lcikge1xuICAgICAgICBzdXBlcihzaWduZXIucHJvdmlkZXIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHNpZ25lciB9KTtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGVsdGEgPSAwO1xuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9uY2VNYW5hZ2VyKHRoaXMuc2lnbmVyLmNvbm5lY3QocHJvdmlkZXIpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI25vbmNlUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gc3VwZXIuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLiNkZWx0YTtcbiAgICAgICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy4jbm9uY2VQcm9taXNlKSArIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXROb25jZShibG9ja1RhZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBNYW51YWxseSBpbmNyZW1lbnQgdGhlIG5vbmNlLiBUaGlzIG1heSBiZSB1c2VmdWwgd2hlbiBtYW5hZ25nXG4gICAgICogIG9mZmxpbmUgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGluY3JlbWVudCgpIHtcbiAgICAgICAgdGhpcy4jZGVsdGErKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc2V0cyB0aGUgbm9uY2UsIGNhdXNpbmcgdGhlICoqTm9uY2VNYW5hZ2VyKiogdG8gcmVsb2FkIHRoZSBjdXJyZW50XG4gICAgICogIG5vbmNlIGZyb20gdGhlIGJsb2NrY2hhaW4gb24gdGhlIG5leHQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuI2RlbHRhID0gMDtcbiAgICAgICAgdGhpcy4jbm9uY2VQcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGNvbnN0IG5vbmNlUHJvbWlzZSA9IHRoaXMuZ2V0Tm9uY2UoXCJwZW5kaW5nXCIpO1xuICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICB0eCA9IGF3YWl0IHRoaXMuc2lnbmVyLnBvcHVsYXRlVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB0eC5ub25jZSA9IGF3YWl0IG5vbmNlUHJvbWlzZTtcbiAgICAgICAgLy8gQFRPRE86IE1heWJlIGhhbmRsZSBpbnRlcmVzdGluZy9yZWNvdmVyYWJsZSBlcnJvcnM/XG4gICAgICAgIC8vIExpa2UgZG9uJ3QgaW5jcmVtZW50IGlmIHRoZSB0eCB3YXMgY2VydGFpbmx5IG5vdCBzZW50XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgIH1cbiAgICBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbih0eCk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vbmNlTWFuYWdlciA9IE5vbmNlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25lci1ub25jZW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTm9uY2VNYW5hZ2VyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJhYnN0cmFjdF9zaWduZXJfanNfMSIsIkFic3RyYWN0U2lnbmVyIiwibm9uY2VQcm9taXNlIiwiZGVsdGEiLCJjb25zdHJ1Y3RvciIsInNpZ25lciIsInByb3ZpZGVyIiwiZGVmaW5lUHJvcGVydGllcyIsImdldEFkZHJlc3MiLCJjb25uZWN0IiwiZ2V0Tm9uY2UiLCJibG9ja1RhZyIsImluY3JlbWVudCIsInJlc2V0Iiwic2VuZFRyYW5zYWN0aW9uIiwidHgiLCJwb3B1bGF0ZVRyYW5zYWN0aW9uIiwibm9uY2UiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduTWVzc2FnZSIsIm1lc3NhZ2UiLCJzaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst subscriber_polling_js_1 = __webpack_require__(/*! ./subscriber-polling.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\");\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdSubscriber {\n    #provider;\n    #filterIdPromise;\n    #poller;\n    #running;\n    #network;\n    #hault;\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#network = null;\n        this.#hault = false;\n    }\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */ _subscribe(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */ _emitResults(provider, result) {\n        throw new Error(\"subclasses must override this\");\n    }\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */ _recover(provider) {\n        throw new Error(\"subclasses must override this\");\n    }\n    async #poll(blockNumber) {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n            // Get the Filter ID\n            let filterId = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!(0, index_js_1.isError)(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) {\n                this.#network = network;\n            }\n            if (this.#network.chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n            if (this.#hault) {\n                return;\n            }\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\n                filterId\n            ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) {\n            console.log(\"@TODO\", error);\n        }\n        this.#provider.once(\"block\", this.#poller);\n    }\n    #teardown() {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId)=>{\n                this.#provider.send(\"eth_uninstallFilter\", [\n                    filterId\n                ]);\n            });\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        if (dropWhilePaused) {\n            this.#teardown();\n        }\n        this.#provider.off(\"block\", this.#poller);\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.FilterIdSubscriber = FilterIdSubscriber;\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event;\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */ constructor(provider, filter){\n        super(provider);\n        this.#event = copy(filter);\n    }\n    _recover(provider) {\n        return new subscriber_polling_js_1.PollingEventSubscriber(provider, this.#event);\n    }\n    async _subscribe(provider) {\n        const filterId = await provider.send(\"eth_newFilter\", [\n            this.#event\n        ]);\n        return filterId;\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\nexports.FilterIdEventSubscriber = FilterIdEventSubscriber;\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider) {\n        return await provider.send(\"eth_newPendingTransactionFilter\", []);\n    }\n    async _emitResults(provider, results) {\n        for (const result of results){\n            provider.emit(\"pending\", result);\n        }\n    }\n}\nexports.FilterIdPendingSubscriber = FilterIdPendingSubscriber; //# sourceMappingURL=subscriber-filterid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc3Vic2NyaWJlci1maWx0ZXJpZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUNBQWlDLEdBQUdBLCtCQUErQixHQUFHQSwwQkFBMEIsR0FBRyxLQUFLO0FBQ3hHLE1BQU1LLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQywwQkFBMEJELG1CQUFPQSxDQUFDLHlHQUF5QjtBQUNqRSxTQUFTRSxLQUFLQyxHQUFHO0lBQ2IsT0FBT0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNIO0FBQ3JDO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUw7SUFDRixDQUFDUyxRQUFRLENBQUM7SUFDVixDQUFDQyxlQUFlLENBQUM7SUFDakIsQ0FBQ0MsTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsS0FBSyxDQUFDO0lBQ1A7Ozs7S0FJQyxHQUNEQyxZQUFZTixRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNDLGVBQWUsR0FBRztRQUN4QixJQUFJLENBQUMsQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDSyxJQUFJLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ25DLElBQUksQ0FBQyxDQUFDTCxPQUFPLEdBQUc7UUFDaEIsSUFBSSxDQUFDLENBQUNDLE9BQU8sR0FBRztRQUNoQixJQUFJLENBQUMsQ0FBQ0MsS0FBSyxHQUFHO0lBQ2xCO0lBQ0E7O0tBRUMsR0FDREksV0FBV1QsUUFBUSxFQUFFO1FBQ2pCLE1BQU0sSUFBSVUsTUFBTTtJQUNwQjtJQUNBOztLQUVDLEdBQ0RDLGFBQWFYLFFBQVEsRUFBRVksTUFBTSxFQUFFO1FBQzNCLE1BQU0s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TUFBTVgsYUFBYVgsUUFBUSxFQUFFcUMsT0FBTyxFQUFFO1FBQ2xDLEtBQUssTUFBTXpCLFVBQVV5QixRQUFTO1lBQzFCckMsU0FBU3NDLElBQUksQ0FBQyxXQUFXMUI7UUFDN0I7SUFDSjtBQUNKO0FBQ0F6QixpQ0FBaUMsR0FBR0UsMkJBQ3BDLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3Byb3ZpZGVycy9zdWJzY3JpYmVyLWZpbHRlcmlkLmpzP2UxYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIgPSBleHBvcnRzLkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5GaWx0ZXJJZFN1YnNjcmliZXIgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpYmVyLXBvbGxpbmcuanNcIik7XG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLyoqXG4gKiAgU29tZSBiYWNrZW5kcyBzdXBwb3J0IHN1YnNjcmliaW5nIHRvIGV2ZW50cyB1c2luZyBhIEZpbHRlciBJRC5cbiAqXG4gKiAgV2hlbiBzdWJzY3JpYmluZyB3aXRoIHRoaXMgdGVjaG5pcXVlLCB0aGUgbm9kZSBpc3N1ZXMgYSB1bmlxdWVcbiAqICAvL0ZpbHRlciBJRC8vLiBBdCB0aGlzIHBvaW50IHRoZSBub2RlIGRlZGljYXRlcyByZXNvdXJjZXMgdG9cbiAqICB0aGUgZmlsdGVyLCBzbyB0aGF0IHBlcmlvZGljIGNhbGxzIHRvIGZvbGxvdyB1cCBvbiB0aGUgLy9GaWx0ZXIgSUQvL1xuICogIHdpbGwgcmVjZWl2ZSBhbnkgZXZlbnRzIHNpbmNlIHRoZSBsYXN0IGNhbGwuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNmaWx0ZXJJZFByb21pc2U7XG4gICAgI3BvbGxlcjtcbiAgICAjcnVubmluZztcbiAgICAjbmV0d29yaztcbiAgICAjaGF1bHQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiB3aGljaCB3aWxsIHVzZWQgW1tfc3Vic2NyaWJlXV1cbiAgICAgKiAgYW5kIFtbX2VtaXRSZXN1bHRzXV0gdG8gc2V0dXAgdGhlIHN1YnNjcmlwdGlvbiBhbmQgcHJvdmlkZSB0aGUgZXZlbnRcbiAgICAgKiAgdG8gdGhlICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jbmV0d29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuI2hhdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIHRvIGJlZ2luIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzICoqbXVzdCoqIG92ZXJyaWRlIHRoaXMgaGFuZGxlIHRoZSBldmVudHMuXG4gICAgICovXG4gICAgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdWItY2xhc3NlcyAqKm11c3QqKiBvdmVycmlkZSB0aGlzIGhhbmRsZSByZWNvdmVyeSBvbiBlcnJvcnMuXG4gICAgICovXG4gICAgX3JlY292ZXIocHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIHRoaXNcIik7XG4gICAgfVxuICAgIGFzeW5jICNwb2xsKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAodGhpcy4jZmlsdGVySWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNmaWx0ZXJJZFByb21pc2UgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy4jcHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBGaWx0ZXIgSURcbiAgICAgICAgICAgIGxldCBmaWx0ZXJJZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZpbHRlcklkID0gYXdhaXQgdGhpcy4jZmlsdGVySWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgaW5kZXhfanNfMS5pc0Vycm9yKShlcnJvciwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIikgfHwgZXJyb3Iub3BlcmF0aW9uICE9PSBcImV0aF9uZXdGaWx0ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IEZpbHRlciBJRDsgZG93bmdyYWRlIHRvXG4gICAgICAgICAgICAvLyBwb2xsaW5nXG4gICAgICAgICAgICBpZiAoZmlsdGVySWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuX3JlY292ZXJTdWJzY3JpYmVyKHRoaXMsIHRoaXMuX3JlY292ZXIodGhpcy4jcHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jbmV0d29yay5jaGFpbklkICE9PSBuZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFpZCBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2hhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jcHJvdmlkZXIuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fZW1pdFJlc3VsdHModGhpcy4jcHJvdmlkZXIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBUT0RPXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbmNlKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgI3RlYXJkb3duKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJJZFByb21pc2UgPSB0aGlzLiNmaWx0ZXJJZFByb21pc2U7XG4gICAgICAgIGlmIChmaWx0ZXJJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpbHRlcklkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBmaWx0ZXJJZFByb21pc2UudGhlbigoZmlsdGVySWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm92aWRlci5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLiNwb2xsKC0yKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNoYXVsdCA9IHRydWU7XG4gICAgICAgIHRoaXMuI3RlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiN0ZWFyZG93bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHJlc3VtZSgpIHsgdGhpcy5zdGFydCgpOyB9XG59XG5leHBvcnRzLkZpbHRlcklkU3Vic2NyaWJlciA9IEZpbHRlcklkU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIGNvbnRyYWN0IGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRFdmVudFN1YnNjcmliZXIgZXh0ZW5kcyBGaWx0ZXJJZFN1YnNjcmliZXIge1xuICAgICNldmVudDtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyAqKkZpbHRlcklkRXZlbnRTdWJzY3JpYmVyKiogYXR0YWNoZWQgdG8gJSVwcm92aWRlciUlXG4gICAgICogIGxpc3RlbmluZyBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgZmlsdGVyKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy4jZXZlbnQgPSBjb3B5KGZpbHRlcik7XG4gICAgfVxuICAgIF9yZWNvdmVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgc3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEuUG9sbGluZ0V2ZW50U3Vic2NyaWJlcihwcm92aWRlciwgdGhpcy4jZXZlbnQpO1xuICAgIH1cbiAgICBhc3luYyBfc3Vic2NyaWJlKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcklkID0gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdGaWx0ZXJcIiwgW3RoaXMuI2V2ZW50XSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRSZXN1bHRzKHByb3ZpZGVyLCByZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jZXZlbnQsIHByb3ZpZGVyLl93cmFwTG9nKHJlc3VsdCwgcHJvdmlkZXIuX25ldHdvcmspKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRFdmVudFN1YnNjcmliZXIgPSBGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipGaWx0ZXJJZFN1YnNjcmliZXIqKiBmb3IgcmVjZWl2aW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciBleHRlbmRzIEZpbHRlcklkU3Vic2NyaWJlciB7XG4gICAgYXN5bmMgX3N1YnNjcmliZShwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvdmlkZXIuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgIH1cbiAgICBhc3luYyBfZW1pdFJlc3VsdHMocHJvdmlkZXIsIHJlc3VsdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcInBlbmRpbmdcIiwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVySWRQZW5kaW5nU3Vic2NyaWJlciA9IEZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLWZpbHRlcmlkLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpbHRlcklkUGVuZGluZ1N1YnNjcmliZXIiLCJGaWx0ZXJJZEV2ZW50U3Vic2NyaWJlciIsIkZpbHRlcklkU3Vic2NyaWJlciIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwic3Vic2NyaWJlcl9wb2xsaW5nX2pzXzEiLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHJvdmlkZXIiLCJmaWx0ZXJJZFByb21pc2UiLCJwb2xsZXIiLCJydW5uaW5nIiwibmV0d29yayIsImhhdWx0IiwiY29uc3RydWN0b3IiLCJwb2xsIiwiYmluZCIsIl9zdWJzY3JpYmUiLCJFcnJvciIsIl9lbWl0UmVzdWx0cyIsInJlc3VsdCIsIl9yZWNvdmVyIiwiYmxvY2tOdW1iZXIiLCJmaWx0ZXJJZCIsImVycm9yIiwiaXNFcnJvciIsIm9wZXJhdGlvbiIsIl9yZWNvdmVyU3Vic2NyaWJlciIsImdldE5ldHdvcmsiLCJjaGFpbklkIiwic2VuZCIsImNvbnNvbGUiLCJsb2ciLCJvbmNlIiwidGVhcmRvd24iLCJ0aGVuIiwic3RhcnQiLCJzdG9wIiwib2ZmIiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJldmVudCIsImZpbHRlciIsIlBvbGxpbmdFdmVudFN1YnNjcmliZXIiLCJyZXN1bHRzIiwiZW1pdCIsIl93cmFwTG9nIiwiX25ldHdvcmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction copy(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */ function getPollingSubscriber(provider, event) {\n    if (event === \"block\") {\n        return new PollingBlockSubscriber(provider);\n    }\n    if ((0, index_js_1.isHexString)(event, 32)) {\n        return new PollingTransactionSubscriber(provider, event);\n    }\n    (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\",\n        info: {\n            event\n        }\n    });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingBlockSubscriber {\n    #provider;\n    #poller;\n    #interval;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n        this.#blockNumber = -2;\n    }\n    /**\n     *  The polling interval.\n     */ get pollingInterval() {\n        return this.#interval;\n    }\n    set pollingInterval(value) {\n        this.#interval = value;\n    }\n    async #poll() {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n            // @TODO: Put a cap on the maximum number of events per loop?\n            if (blockNumber !== this.#blockNumber) {\n                for(let b = this.#blockNumber + 1; b <= blockNumber; b++){\n                    // We have been stopped\n                    if (this.#poller == null) {\n                        return;\n                    }\n                    await this.#provider.emit(\"block\", b);\n                }\n                this.#blockNumber = blockNumber;\n            }\n        } catch (error) {\n        // @TODO: Minor bump, add an \"error\" event to let subscribers\n        //        know things went awry.\n        //console.log(error);\n        }\n        // We have been stopped\n        if (this.#poller == null) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n    start() {\n        if (this.#poller) {\n            return;\n        }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n    stop() {\n        if (!this.#poller) {\n            return;\n        }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class OnBlockSubscriber {\n    #provider;\n    #poll;\n    #running;\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */ constructor(provider){\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber)=>{\n            this._poll(blockNumber, this.#provider);\n        };\n    }\n    /**\n     *  Called on every new block.\n     */ async _poll(blockNumber, provider) {\n        throw new Error(\"sub-classes must override this\");\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poll);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter;\n    constructor(provider, filter){\n        super(provider);\n        this.#filter = copy(filter);\n    }\n    async _poll(blockNumber, provider) {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */ constructor(provider, hash){\n        super(provider);\n        this.#hash = hash;\n    }\n    async _poll(blockNumber, provider) {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) {\n            provider.emit(this.#hash, tx);\n        }\n    }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */ class PollingEventSubscriber {\n    #provider;\n    #filter;\n    #poller;\n    #running;\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber;\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */ constructor(provider, filter){\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n    async #poll(blockNumber) {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) {\n            return;\n        }\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n        for (const log of logs){\n            this.#provider.emit(this.#filter, log);\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n    start() {\n        if (this.#running) {\n            return;\n        }\n        this.#running = true;\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber)=>{\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n    stop() {\n        if (!this.#running) {\n            return;\n        }\n        this.#running = false;\n        this.#provider.off(\"block\", this.#poller);\n    }\n    pause(dropWhilePaused) {\n        this.stop();\n        if (dropWhilePaused) {\n            this.#blockNumber = -2;\n        }\n    }\n    resume() {\n        this.start();\n    }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber; //# sourceMappingURL=subscriber-polling.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvc3Vic2NyaWJlci1wb2xsaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw4QkFBOEIsR0FBR0Esb0NBQW9DLEdBQUdBLCtCQUErQixHQUFHQSx5QkFBeUIsR0FBR0EsOEJBQThCLEdBQUdBLDRCQUE0QixHQUFHLEtBQUs7QUFDM00sTUFBTVEsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLFNBQVNDLEtBQUtDLEdBQUc7SUFDYixPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ0g7QUFDckM7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0oscUJBQXFCUSxRQUFRLEVBQUVDLEtBQUs7SUFDekMsSUFBSUEsVUFBVSxTQUFTO1FBQ25CLE9BQU8sSUFBSVYsdUJBQXVCUztJQUN0QztJQUNBLElBQUksQ0FBQyxHQUFHUCxXQUFXUyxXQUFXLEVBQUVELE9BQU8sS0FBSztRQUN4QyxPQUFPLElBQUliLDZCQUE2QlksVUFBVUM7SUFDdEQ7SUFDQyxJQUFHUixXQUFXVSxNQUFNLEVBQUUsT0FBTyw2QkFBNkIseUJBQXlCO1FBQ2hGQyxXQUFXO1FBQXdCQyxNQUFNO1lBQUVKO1FBQU07SUFDckQ7QUFDSjtBQUNBaEIsNEJBQTRCLEdBQUdPO0FBQy9CLHVCQUF1QjtBQUN2Qjs7Ozs7Q0FLQyxHQUNELE1BQU1EO0lBQ0YsQ0FBQ1MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ00sTUFBTSxDQUFDO0lBQ1IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRCxDQUFDQyxXQUFXLENBQUM7SUFDYjs7S0FFQyxHQUNEQyxZQUFZVCxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUNBLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNNLE1BQU0sR0FBRztRQUNm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O1lBQ2hCO1FBQ0o7UUFDQSxJQUFJLENBQUMsQ0FBQ0EsT0FBTyxHQUFHO1FBQ2hCLElBQUksQ0FBQyxDQUFDeEIsUUFBUSxDQUFDNEIsR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUN0QixNQUFNO0lBQzVDO0lBQ0FlLE1BQU1DLGVBQWUsRUFBRTtRQUNuQixJQUFJLENBQUNILElBQUk7UUFDVCxJQUFJRyxpQkFBaUI7WUFDakIsSUFBSSxDQUFDLENBQUNkLFdBQVcsR0FBRyxDQUFDO1FBQ3pCO0lBQ0o7SUFDQWUsU0FBUztRQUNMLElBQUksQ0FBQ0wsS0FBSztJQUNkO0FBQ0o7QUFDQWpDLDhCQUE4QixHQUFHRSx3QkFDakMsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3N1YnNjcmliZXItcG9sbGluZy5qcz9jMGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nRXZlbnRTdWJzY3JpYmVyID0gZXhwb3J0cy5Qb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyID0gZXhwb3J0cy5Qb2xsaW5nT3JwaGFuU3Vic2NyaWJlciA9IGV4cG9ydHMuT25CbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLlBvbGxpbmdCbG9ja1N1YnNjcmliZXIgPSBleHBvcnRzLmdldFBvbGxpbmdTdWJzY3JpYmVyID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vKipcbiAqICBSZXR1cm4gdGhlIHBvbGxpbmcgc3Vic2NyaWJlciBmb3IgY29tbW9uIGV2ZW50cy5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9sbGluZ1N1YnNjcmliZXIocHJvdmlkZXIsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKCgwLCBpbmRleF9qc18xLmlzSGV4U3RyaW5nKShldmVudCwgMzIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcihwcm92aWRlciwgZXZlbnQpO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIHBvbGxpbmcgZXZlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICBvcGVyYXRpb246IFwiZ2V0UG9sbGluZ1N1YnNjcmliZXJcIiwgaW5mbzogeyBldmVudCB9XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFBvbGxpbmdTdWJzY3JpYmVyID0gZ2V0UG9sbGluZ1N1YnNjcmliZXI7XG4vLyBAVE9ETzogcmVmYWN0b3IgdGhpc1xuLyoqXG4gKiAgQSAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBwb2xscyBhdCBhIHJlZ3VsYXIgaW50ZXJ2YWwgZm9yIGEgY2hhbmdlXG4gKiAgaW4gdGhlIGJsb2NrIG51bWJlci5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS9wcm92aWRlcnMvYWJzdHJhY3QtcHJvdmlkZXJcbiAqL1xuY2xhc3MgUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsZXI7XG4gICAgI2ludGVydmFsO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBibG9jayB3ZSBoYXZlIHNjYW5uZWQgZm9yIGV2ZW50cy4gVGhlIHZhbHVlIC0yXG4gICAgLy8gaW5kaWNhdGVzIHdlIHN0aWxsIG5lZWQgdG8gZmV0Y2ggYW4gaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAjYmxvY2tOdW1iZXI7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdCbG9ja1N1YnNjcmliZXIqKiBhdHRhY2hlZCB0byAlJXByb3ZpZGVyJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jcG9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuI2ludGVydmFsOyB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkgeyB0aGlzLiNpbnRlcnZhbCA9IHZhbHVlOyB9XG4gICAgYXN5bmMgI3BvbGwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBCb290c3RyYXAgcG9sbCB0byBzZXR1cCBvdXIgaW5pdGlhbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGlmICh0aGlzLiNibG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEBUT0RPOiBQdXQgYSBjYXAgb24gdGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyBwZXIgbG9vcD9cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciAhPT0gdGhpcy4jYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gdGhpcy4jYmxvY2tOdW1iZXIgKyAxOyBiIDw9IGJsb2NrTnVtYmVyOyBiKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jcHJvdmlkZXIuZW1pdChcImJsb2NrXCIsIGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQFRPRE86IE1pbm9yIGJ1bXAsIGFkZCBhbiBcImVycm9yXCIgZXZlbnQgdG8gbGV0IHN1YnNjcmliZXJzXG4gICAgICAgICAgICAvLyAgICAgICAga25vdyB0aGluZ3Mgd2VudCBhd3J5LlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIHN0b3BwZWRcbiAgICAgICAgaWYgKHRoaXMuI3BvbGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcG9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcG9sbGVyID0gdGhpcy4jcHJvdmlkZXIuX3NldFRpbWVvdXQodGhpcy4jcG9sbC5iaW5kKHRoaXMpLCB0aGlzLiNpbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuI3BvbGwoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiNwb2xsZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5fY2xlYXJUaW1lb3V0KHRoaXMuI3BvbGxlcik7XG4gICAgICAgIHRoaXMuI3BvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHBhdXNlKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKGRyb3BXaGlsZVBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmdCbG9ja1N1YnNjcmliZXIgPSBQb2xsaW5nQmxvY2tTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQW4gKipPbkJsb2NrU3Vic2NyaWJlcioqIGNhbiBiZSBzdWItY2xhc3NlZCwgd2l0aCBhIFtbX3BvbGxdXVxuICogIGltcGxtZW50YXRpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb24gZXZlcnkgbmV3IGJsb2NrLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3Byb3ZpZGVycy9hYnN0cmFjdC1wcm92aWRlclxuICovXG5jbGFzcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI3Byb3ZpZGVyO1xuICAgICNwb2xsO1xuICAgICNydW5uaW5nO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipPbkJsb2NrU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLiNwcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3BvbGwgPSAoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGwoYmxvY2tOdW1iZXIsIHRoaXMuI3Byb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbGxlZCBvbiBldmVyeSBuZXcgYmxvY2suXG4gICAgICovXG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1Yi1jbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpc1wiKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BvbGwoLTIpO1xuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Byb3ZpZGVyLm9mZihcImJsb2NrXCIsIHRoaXMuI3BvbGwpO1xuICAgIH1cbiAgICBwYXVzZShkcm9wV2hpbGVQYXVzZWQpIHsgdGhpcy5zdG9wKCk7IH1cbiAgICByZXN1bWUoKSB7IHRoaXMuc3RhcnQoKTsgfVxufVxuZXhwb3J0cy5PbkJsb2NrU3Vic2NyaWJlciA9IE9uQmxvY2tTdWJzY3JpYmVyO1xuLyoqXG4gKiAgQF9pZ25vcmU6XG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIFBvbGxpbmdPcnBoYW5TdWJzY3JpYmVyIGV4dGVuZHMgT25CbG9ja1N1YnNjcmliZXIge1xuICAgICNmaWx0ZXI7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGZpbHRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuI2ZpbHRlciA9IGNvcHkoZmlsdGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBUT0RPXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiNmaWx0ZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ09ycGhhblN1YnNjcmliZXIgPSBQb2xsaW5nT3JwaGFuU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipQb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uXG4gKiAgaGFzaCBmb3IgaXRzIHJlY2VpcHQuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIFBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIgZXh0ZW5kcyBPbkJsb2NrU3Vic2NyaWJlciB7XG4gICAgI2hhc2g7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyAqKlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIqKiBhdHRhY2hlZCB0b1xuICAgICAqICAlJXByb3ZpZGVyJSUsIGxpc3RlbmluZyBmb3IgJSVoYXNoJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGhhc2gpIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLiNoYXNoID0gaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX3BvbGwoYmxvY2tOdW1iZXIsIHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgcHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRoaXMuI2hhc2gpO1xuICAgICAgICBpZiAodHgpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQodGhpcy4jaGFzaCwgdHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nVHJhbnNhY3Rpb25TdWJzY3JpYmVyID0gUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcjtcbi8qKlxuICogIEEgKipQb2xsaW5nRXZlbnRTdWJzY3JpYmVyKiogd2lsbCBwb2xsIGZvciBhIGdpdmVuIGZpbHRlciBmb3IgaXRzIGxvZ3MuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvcHJvdmlkZXJzL2Fic3RyYWN0LXByb3ZpZGVyXG4gKi9cbmNsYXNzIFBvbGxpbmdFdmVudFN1YnNjcmliZXIge1xuICAgICNwcm92aWRlcjtcbiAgICAjZmlsdGVyO1xuICAgICNwb2xsZXI7XG4gICAgI3J1bm5pbmc7XG4gICAgLy8gVGhlIG1vc3QgcmVjZW50IGJsb2NrIHdlIGhhdmUgc2Nhbm5lZCBmb3IgZXZlbnRzLiBUaGUgdmFsdWUgLTJcbiAgICAvLyBpbmRpY2F0ZXMgd2Ugc3RpbGwgbmVlZCB0byBmZXRjaCBhbiBpbml0aWFsIGJsb2NrIG51bWJlclxuICAgICNibG9ja051bWJlcjtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3ICoqUG9sbGluZ1RyYW5zYWN0aW9uU3Vic2NyaWJlcioqIGF0dGFjaGVkIHRvXG4gICAgICogICUlcHJvdmlkZXIlJSwgbGlzdGVuaW5nIGZvciAlJWZpbHRlciUlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy4jZmlsdGVyID0gY29weShmaWx0ZXIpO1xuICAgICAgICB0aGlzLiNwb2xsZXIgPSB0aGlzLiNwb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSAtMjtcbiAgICB9XG4gICAgYXN5bmMgI3BvbGwoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgLy8gVGhlIGluaXRpYWwgYmxvY2sgaGFzbid0IGJlZW4gZGV0ZXJtaW5lZCB5ZXRcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNvcHkodGhpcy4jZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IHRoaXMuI2Jsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgY29uc3QgbG9ncyA9IGF3YWl0IHRoaXMuI3Byb3ZpZGVyLmdldExvZ3MoZmlsdGVyKTtcbiAgICAgICAgLy8gTm8gbG9ncyBjb3VsZCBqdXN0IG1lYW4gdGhlIG5vZGUgaGFzIG5vdCBpbmRleGVkIHRoZW0geWV0LFxuICAgICAgICAvLyBzbyB3ZSBrZWVwIGEgc2xpZGluZyB3aW5kb3cgb2YgNjAgYmxvY2tzIHRvIGtlZXAgc2Nhbm5pbmdcbiAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYmxvY2tOdW1iZXIgPCBibG9ja051bWJlciAtIDYwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuI3Byb3ZpZGVyLmVtaXQodGhpcy4jZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgLy8gT25seSBhZHZhbmNlIHRoZSBibG9jayBudW1iZXIgd2hlbiBsb2dzIHdlcmUgZm91bmQgdG9cbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIG5ldHdvcmtzIChsaWtlIEJOQiBhbmQgUG9seWdvbikgd2hpY2ggbWF5XG4gICAgICAgICAgICAvLyBzYWNyaWZpY2UgZXZlbnQgY29uc2lzdGVuY3kgZm9yIGJsb2NrIGV2ZW50IHNwZWVkXG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI2Jsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgdGhpcy4jcHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Jsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm92aWRlci5vbihcImJsb2NrXCIsIHRoaXMuI3BvbGxlcik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy4jcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jcHJvdmlkZXIub2ZmKFwiYmxvY2tcIiwgdGhpcy4jcG9sbGVyKTtcbiAgICB9XG4gICAgcGF1c2UoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAoZHJvcFdoaWxlUGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLiNibG9ja051bWJlciA9IC0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZ0V2ZW50U3Vic2NyaWJlciA9IFBvbGxpbmdFdmVudFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVyLXBvbGxpbmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9sbGluZ0V2ZW50U3Vic2NyaWJlciIsIlBvbGxpbmdUcmFuc2FjdGlvblN1YnNjcmliZXIiLCJQb2xsaW5nT3JwaGFuU3Vic2NyaWJlciIsIk9uQmxvY2tTdWJzY3JpYmVyIiwiUG9sbGluZ0Jsb2NrU3Vic2NyaWJlciIsImdldFBvbGxpbmdTdWJzY3JpYmVyIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJjb3B5Iiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicHJvdmlkZXIiLCJldmVudCIsImlzSGV4U3RyaW5nIiwiYXNzZXJ0Iiwib3BlcmF0aW9uIiwiaW5mbyIsInBvbGxlciIsImludGVydmFsIiwiYmxvY2tOdW1iZXIiLCJjb25zdHJ1Y3RvciIsInBvbGxpbmdJbnRlcnZhbCIsInBvbGwiLCJnZXRCbG9ja051bWJlciIsImIiLCJlbWl0IiwiZXJyb3IiLCJfc2V0VGltZW91dCIsImJpbmQiLCJzdGFydCIsInN0b3AiLCJfY2xlYXJUaW1lb3V0IiwicGF1c2UiLCJkcm9wV2hpbGVQYXVzZWQiLCJyZXN1bWUiLCJydW5uaW5nIiwiX3BvbGwiLCJFcnJvciIsIm9uIiwib2ZmIiwiZmlsdGVyIiwiY29uc29sZSIsImxvZyIsImhhc2giLCJ0eCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImZyb21CbG9jayIsInRvQmxvY2siLCJsb2dzIiwiZ2V0TG9ncyIsImxlbmd0aCIsInRoZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/subscriber-polling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/providers/ws.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/providers/ws.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WebSocket = void 0;\nvar ws_1 = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ethers/node_modules/ws/index.js\");\nObject.defineProperty(exports, \"WebSocket\", ({\n    enumerable: true,\n    get: function() {\n        return ws_1.WebSocket;\n    }\n})); //# sourceMappingURL=ws.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy9wcm92aWRlcnMvd3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsSUFBSUcsT0FBT0MsbUJBQU9BLENBQUMsZ0VBQUk7QUFDdkJOLDZDQUE0QztJQUFFTyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxLQUFLRCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDOUcsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvcHJvdmlkZXJzL3dzLmpzPzY0ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbnZhciB3c18xID0gcmVxdWlyZShcIndzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3c18xLldlYlNvY2tldDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldlYlNvY2tldCIsIndzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/providers/ws.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/accesslist.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.accessListify = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0, index_js_1.getAddress)(addr),\n        storageKeys: storageKeys.map((storageKey, index)=>{\n            (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */ function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                (0, index_js_2.assertArgument)(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            (0, index_js_2.assertArgument)(set != null && typeof set === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    (0, index_js_2.assertArgument)(value != null && typeof value === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n}\nexports.accessListify = accessListify; //# sourceMappingURL=accesslist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9hY2Nlc3NsaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLHNGQUFxQjtBQUNoRCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsU0FBU0UsYUFBYUMsSUFBSSxFQUFFQyxXQUFXO0lBQ25DLE9BQU87UUFDSEMsU0FBUyxDQUFDLEdBQUdOLFdBQVdPLFVBQVUsRUFBRUg7UUFDcENDLGFBQWFBLFlBQVlHLEdBQUcsQ0FBQyxDQUFDQyxZQUFZQztZQUNyQyxJQUFHUixXQUFXUyxjQUFjLEVBQUUsQ0FBQyxHQUFHVCxXQUFXVSxXQUFXLEVBQUVILFlBQVksS0FBSyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUVDLE1BQU0sQ0FBQyxDQUFDLEVBQUVEO1lBQ3JILE9BQU9BLFdBQVdJLFdBQVc7UUFDakM7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTZCxjQUFjRCxLQUFLO0lBQ3hCLElBQUlnQixNQUFNQyxPQUFPLENBQUNqQixRQUFRO1FBQ3RCLE9BQU9BLE1BQU1VLEdBQUcsQ0FBQyxDQUFDUSxLQUFLTjtZQUNuQixJQUFJSSxNQUFNQyxPQUFPLENBQUNDLE1BQU07Z0JBQ25CLElBQUdkLFdBQVdTLGNBQWMsRUFBRUssSUFBSUMsTUFBTSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFUCxNQUFNLENBQUMsQ0FBQyxFQUFFTTtnQkFDeEYsT0FBT2IsYUFBYWEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDdEM7WUFDQyxJQUFHZCxXQUFXUyxjQUFjLEVBQUVLLE9BQU8sUUFBUSxPQUFRQSxRQUFTLFVBQVUsNEJBQTRCLFNBQVNsQjtZQUM5RyxPQUFPSyxhQUFhYSxJQUFJVixPQUFPLEVBQUVVLElBQUlYLFdBQVc7UUFDcEQ7SUFDSjtJQUNDLElBQUdILFdBQVdTLGNBQWMsRUFBRWIsU0FBUyxRQUFRLE9BQVFBLFVBQVcsVUFBVSx1QkFBdUIsU0FBU0E7SUFDN0csTUFBTW9CLFNBQVN2QixPQUFPd0IsSUFBSSxDQUFDckIsT0FBT1UsR0FBRyxDQUFDLENBQUNKO1FBQ25DLE1BQU1DLGNBQWNQLEtBQUssQ0FBQ00sS0FBSyxDQUFDZ0IsTUFBTSxDQUFDLENBQUNDLE9BQU9aO1lBQzNDWSxLQUFLLENBQUNaLFdBQVcsR0FBRztZQUNwQixPQUFPWTtRQUNYLEdBQUcsQ0FBQztRQUNKLE9BQU9sQixhQUFhQyxNQUFNVCxPQUFPd0IsSUFBSSxDQUFDZCxhQUFhaUIsSUFBSTtJQUMzRDtJQUNBSixPQUFPSSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBT0QsRUFBRWpCLE9BQU8sQ0FBQ21CLGFBQWEsQ0FBQ0QsRUFBRWxCLE9BQU87SUFDeEQsT0FBT1k7QUFDWDtBQUNBckIscUJBQXFCLEdBQUdFLGVBQ3hCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3RyYW5zYWN0aW9uL2FjY2Vzc2xpc3QuanM/YTU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjZXNzTGlzdGlmeSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKShhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMi5pc0hleFN0cmluZykoc3RvcmFnZUtleSwgMzIpLCBcImludmFsaWQgc2xvdFwiLCBgc3RvcmFnZUtleXNbJHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tBY2Nlc3NMaXN0XV0gZnJvbSBhbnkgZXRoZXJzLXN1cHBvcnRlZCBhY2Nlc3MtbGlzdCBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShzZXQubGVuZ3RoID09PSAyLCBcImludmFsaWQgc2xvdCBzZXRcIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoc2V0ICE9IG51bGwgJiYgdHlwZW9mIChzZXQpID09PSBcIm9iamVjdFwiLCBcImludmFsaWQgYWRkcmVzcy1zbG90IHNldFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIiwgXCJpbnZhbGlkIGFjY2VzcyBsaXN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hY2Nlc3NMaXN0aWZ5ID0gYWNjZXNzTGlzdGlmeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzc2xpc3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWNjZXNzTGlzdGlmeSIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJnZXRBZGRyZXNzIiwibWFwIiwic3RvcmFnZUtleSIsImluZGV4IiwiYXNzZXJ0QXJndW1lbnQiLCJpc0hleFN0cmluZyIsInRvTG93ZXJDYXNlIiwiQXJyYXkiLCJpc0FycmF5Iiwic2V0IiwibGVuZ3RoIiwicmVzdWx0Iiwia2V5cyIsInJlZHVjZSIsImFjY3VtIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/transaction/address.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/address.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.recoverAddress = exports.computeAddress = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\n/**\n *  Returns the address for the %%key%%.\n *\n *  The key may be any standard form of public key or a private key.\n */ function computeAddress(key) {\n    let pubkey;\n    if (typeof key === \"string\") {\n        pubkey = index_js_2.SigningKey.computePublicKey(key, false);\n    } else {\n        pubkey = key.publicKey;\n    }\n    return (0, index_js_1.getAddress)((0, index_js_2.keccak256)(\"0x\" + pubkey.substring(4)).substring(26));\n}\nexports.computeAddress = computeAddress;\n/**\n *  Returns the recovered address for the private key that was\n *  used to sign %%digest%% that resulted in %%signature%%.\n */ function recoverAddress(digest, signature) {\n    return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));\n}\nexports.recoverAddress = recoverAddress; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUN2RCxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQW9CO0FBQy9DOzs7O0NBSUMsR0FDRCxTQUFTRixlQUFlSSxHQUFHO0lBQ3ZCLElBQUlDO0lBQ0osSUFBSSxPQUFRRCxRQUFTLFVBQVU7UUFDM0JDLFNBQVNGLFdBQVdHLFVBQVUsQ0FBQ0MsZ0JBQWdCLENBQUNILEtBQUs7SUFDekQsT0FDSztRQUNEQyxTQUFTRCxJQUFJSSxTQUFTO0lBQzFCO0lBQ0EsT0FBTyxDQUFDLEdBQUdQLFdBQVdRLFVBQVUsRUFBRSxDQUFDLEdBQUdOLFdBQVdPLFNBQVMsRUFBRSxPQUFPTCxPQUFPTSxTQUFTLENBQUMsSUFBSUEsU0FBUyxDQUFDO0FBQ3RHO0FBQ0FkLHNCQUFzQixHQUFHRztBQUN6Qjs7O0NBR0MsR0FDRCxTQUFTRCxlQUFlYSxNQUFNLEVBQUVDLFNBQVM7SUFDckMsT0FBT2IsZUFBZUcsV0FBV0csVUFBVSxDQUFDUSxnQkFBZ0IsQ0FBQ0YsUUFBUUM7QUFDekU7QUFDQWhCLHNCQUFzQixHQUFHRSxnQkFDekIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdHJhbnNhY3Rpb24vYWRkcmVzcy5qcz82MjRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSAlJWtleSUlLlxuICpcbiAqICBUaGUga2V5IG1heSBiZSBhbnkgc3RhbmRhcmQgZm9ybSBvZiBwdWJsaWMga2V5IG9yIGEgcHJpdmF0ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGxldCBwdWJrZXk7XG4gICAgaWYgKHR5cGVvZiAoa2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwdWJrZXkgPSBpbmRleF9qc18yLlNpZ25pbmdLZXkuY29tcHV0ZVB1YmxpY0tleShrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1YmtleSA9IGtleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKFwiMHhcIiArIHB1YmtleS5zdWJzdHJpbmcoNCkpLnN1YnN0cmluZygyNikpO1xufVxuZXhwb3J0cy5jb21wdXRlQWRkcmVzcyA9IGNvbXB1dGVBZGRyZXNzO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgcmVjb3ZlcmVkIGFkZHJlc3MgZm9yIHRoZSBwcml2YXRlIGtleSB0aGF0IHdhc1xuICogIHVzZWQgdG8gc2lnbiAlJWRpZ2VzdCUlIHRoYXQgcmVzdWx0ZWQgaW4gJSVzaWduYXR1cmUlJS5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MoaW5kZXhfanNfMi5TaWduaW5nS2V5LnJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpKTtcbn1cbmV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSByZWNvdmVyQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVjb3ZlckFkZHJlc3MiLCJjb21wdXRlQWRkcmVzcyIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImtleSIsInB1YmtleSIsIlNpZ25pbmdLZXkiLCJjb21wdXRlUHVibGljS2V5IiwicHVibGljS2V5IiwiZ2V0QWRkcmVzcyIsImtlY2NhazI1NiIsInN1YnN0cmluZyIsImRpZ2VzdCIsInNpZ25hdHVyZSIsInJlY292ZXJQdWJsaWNLZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/transaction/address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  Each state-changing operation on Ethereum requires a transaction.\n *\n *  @_section api/transaction:Transactions  [about-transactions]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;\nnull;\nvar accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\");\nObject.defineProperty(exports, \"accessListify\", ({\n    enumerable: true,\n    get: function() {\n        return accesslist_js_1.accessListify;\n    }\n}));\nvar address_js_1 = __webpack_require__(/*! ./address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/address.js\");\nObject.defineProperty(exports, \"computeAddress\", ({\n    enumerable: true,\n    get: function() {\n        return address_js_1.computeAddress;\n    }\n}));\nObject.defineProperty(exports, \"recoverAddress\", ({\n    enumerable: true,\n    get: function() {\n        return address_js_1.recoverAddress;\n    }\n}));\nvar transaction_js_1 = __webpack_require__(/*! ./transaction.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/transaction.js\");\nObject.defineProperty(exports, \"Transaction\", ({\n    enumerable: true,\n    get: function() {\n        return transaction_js_1.Transaction;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7O0NBSUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDckc7QUFDQSxJQUFJTSxrQkFBa0JDLG1CQUFPQSxDQUFDLDJGQUFpQjtBQUMvQ1QsaURBQWdEO0lBQUVVLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGdCQUFnQkQsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pJLElBQUlLLGVBQWVILG1CQUFPQSxDQUFDLHFGQUFjO0FBQ3pDVCxrREFBaUQ7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsYUFBYU4sY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hJTixrREFBaUQ7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsYUFBYVAsY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hJLElBQUlRLG1CQUFtQkosbUJBQU9BLENBQUMsNkZBQWtCO0FBQ2pEVCwrQ0FBOEM7SUFBRVUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsaUJBQWlCVCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDOUgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdHJhbnNhY3Rpb24vaW5kZXguanM/MDRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEVhY2ggc3RhdGUtY2hhbmdpbmcgb3BlcmF0aW9uIG9uIEV0aGVyZXVtIHJlcXVpcmVzIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdHJhbnNhY3Rpb246VHJhbnNhY3Rpb25zICBbYWJvdXQtdHJhbnNhY3Rpb25zXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBleHBvcnRzLmFjY2Vzc0xpc3RpZnkgPSB2b2lkIDA7XG5udWxsO1xudmFyIGFjY2Vzc2xpc3RfanNfMSA9IHJlcXVpcmUoXCIuL2FjY2Vzc2xpc3QuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhY2Nlc3NMaXN0aWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2Nlc3NsaXN0X2pzXzEuYWNjZXNzTGlzdGlmeTsgfSB9KTtcbnZhciBhZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfanNfMS5jb21wdXRlQWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlY292ZXJBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzX2pzXzEucmVjb3ZlckFkZHJlc3M7IH0gfSk7XG52YXIgdHJhbnNhY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNhY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zYWN0aW9uX2pzXzEuVHJhbnNhY3Rpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUcmFuc2FjdGlvbiIsInJlY292ZXJBZGRyZXNzIiwiY29tcHV0ZUFkZHJlc3MiLCJhY2Nlc3NMaXN0aWZ5IiwiYWNjZXNzbGlzdF9qc18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJhZGRyZXNzX2pzXzEiLCJ0cmFuc2FjdGlvbl9qc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/transaction/transaction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/transaction/transaction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Transaction = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst accesslist_js_1 = __webpack_require__(/*! ./accesslist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/accesslist.js\");\nconst address_js_1 = __webpack_require__(/*! ./address.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/address.js\");\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27);\nconst BN_28 = BigInt(28);\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0, index_js_1.getAddress)(value);\n}\nfunction handleAccessList(value, param) {\n    try {\n        return (0, accesslist_js_1.accessListify)(value);\n    } catch (error) {\n        (0, index_js_3.assertArgument)(false, error.message, param, value);\n    }\n}\nfunction handleNumber(_value, param) {\n    if (_value === \"0x\") {\n        return 0;\n    }\n    return (0, index_js_3.getNumber)(_value, param);\n}\nfunction handleUint(_value, param) {\n    if (_value === \"0x\") {\n        return BN_0;\n    }\n    const value = (0, index_js_3.getBigInt)(_value, param);\n    (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\nfunction formatNumber(_value, name) {\n    const value = (0, index_js_3.getBigInt)(_value, \"value\");\n    const result = (0, index_js_3.toBeArray)(value);\n    (0, index_js_3.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);\n    return result;\n}\nfunction formatAccessList(value) {\n    return (0, accesslist_js_1.accessListify)(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction _parseLegacy(data) {\n    const fields = (0, index_js_3.decodeRlp)(data);\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n    const tx = {\n        type: 0,\n        nonce: handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to: handleAddress(fields[3]),\n        value: handleUint(fields[4], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[5]),\n        chainId: BN_0\n    };\n    // Legacy unsigned transaction\n    if (fields.length === 6) {\n        return tx;\n    }\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n    } else {\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) {\n            chainId = BN_0;\n        }\n        tx.chainId = chainId;\n        // Signed Legacy Transaction\n        (0, index_js_3.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n        tx.signature = index_js_2.Signature.from({\n            r: (0, index_js_3.zeroPadValue)(fields[7], 32),\n            s: (0, index_js_3.zeroPadValue)(fields[8], 32),\n            v\n        });\n        tx.hash = (0, index_js_2.keccak256)(data);\n    }\n    return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n    const fields = [\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0, index_js_1.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\"\n    ];\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = (0, index_js_3.getBigInt)(tx.chainId, \"tx.chainId\");\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) {\n            chainId = legacy;\n        }\n    }\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push((0, index_js_3.toBeArray)(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n        return (0, index_js_3.encodeRlp)(fields);\n    }\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = index_js_2.Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        (0, index_js_3.assertArgument)(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n    // Add the signature\n    fields.push((0, index_js_3.toBeArray)(v));\n    fields.push((0, index_js_3.toBeArray)(sig.r));\n    fields.push((0, index_js_3.toBeArray)(sig.s));\n    return (0, index_js_3.encodeRlp)(fields);\n}\nfunction _parseEipSignature(tx, fields) {\n    let yParity;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) {\n            throw new Error(\"bad yParity\");\n        }\n    } catch (error) {\n        (0, index_js_3.assertArgument)(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n    const r = (0, index_js_3.zeroPadValue)(fields[1], 32);\n    const s = (0, index_js_3.zeroPadValue)(fields[2], 32);\n    const signature = index_js_2.Signature.from({\n        r,\n        s,\n        yParity\n    });\n    tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", (0, index_js_3.hexlify)(data));\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n    const tx = {\n        type: 2,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\n        to: handleAddress(fields[5]),\n        value: handleUint(fields[6], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[7]),\n        accessList: handleAccessList(fields[8], \"accessList\")\n    };\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) {\n        return tx;\n    }\n    tx.hash = (0, index_js_2.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(9));\n    return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0, index_js_1.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push((0, index_js_3.toBeArray)(sig.r));\n        fields.push((0, index_js_3.toBeArray)(sig.s));\n    }\n    return (0, index_js_3.concat)([\n        \"0x02\",\n        (0, index_js_3.encodeRlp)(fields)\n    ]);\n}\nfunction _parseEip2930(data) {\n    const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));\n    (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", (0, index_js_3.hexlify)(data));\n    const tx = {\n        type: 1,\n        chainId: handleUint(fields[0], \"chainId\"),\n        nonce: handleNumber(fields[1], \"nonce\"),\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\n        to: handleAddress(fields[4]),\n        value: handleUint(fields[5], \"value\"),\n        data: (0, index_js_3.hexlify)(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) {\n        return tx;\n    }\n    tx.hash = (0, index_js_2.keccak256)(data);\n    _parseEipSignature(tx, fields.slice(8));\n    return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n    const fields = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        tx.to != null ? (0, index_js_1.getAddress)(tx.to) : \"0x\",\n        formatNumber(tx.value || 0, \"value\"),\n        tx.data || \"0x\",\n        formatAccessList(tx.accessList || [])\n    ];\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push((0, index_js_3.toBeArray)(sig.r));\n        fields.push((0, index_js_3.toBeArray)(sig.s));\n    }\n    return (0, index_js_3.concat)([\n        \"0x01\",\n        (0, index_js_3.encodeRlp)(fields)\n    ]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */ class Transaction {\n    #type;\n    #to;\n    #data;\n    #nonce;\n    #gasLimit;\n    #gasPrice;\n    #maxPriorityFeePerGas;\n    #maxFeePerGas;\n    #value;\n    #chainId;\n    #sig;\n    #accessList;\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */ get type() {\n        return this.#type;\n    }\n    set type(value) {\n        switch(value){\n            case null:\n                this.#type = null;\n                break;\n            case 0:\n            case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1:\n            case \"berlin\":\n            case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2:\n            case \"london\":\n            case \"eip-1559\":\n                this.#type = 2;\n                break;\n            default:\n                (0, index_js_3.assertArgument)(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n    /**\n     *  The name of the transaction type.\n     */ get typeName() {\n        switch(this.type){\n            case 0:\n                return \"legacy\";\n            case 1:\n                return \"eip-2930\";\n            case 2:\n                return \"eip-1559\";\n        }\n        return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */ get to() {\n        return this.#to;\n    }\n    set to(value) {\n        this.#to = value == null ? null : (0, index_js_1.getAddress)(value);\n    }\n    /**\n     *  The transaction nonce.\n     */ get nonce() {\n        return this.#nonce;\n    }\n    set nonce(value) {\n        this.#nonce = (0, index_js_3.getNumber)(value, \"value\");\n    }\n    /**\n     *  The gas limit.\n     */ get gasLimit() {\n        return this.#gasLimit;\n    }\n    set gasLimit(value) {\n        this.#gasLimit = (0, index_js_3.getBigInt)(value);\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */ get gasPrice() {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) {\n            return BN_0;\n        }\n        return value;\n    }\n    set gasPrice(value) {\n        this.#gasPrice = value == null ? null : (0, index_js_3.getBigInt)(value, \"gasPrice\");\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxPriorityFeePerGas() {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value) {\n        this.#maxPriorityFeePerGas = value == null ? null : (0, index_js_3.getBigInt)(value, \"maxPriorityFeePerGas\");\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */ get maxFeePerGas() {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2) {\n                return BN_0;\n            }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value) {\n        this.#maxFeePerGas = value == null ? null : (0, index_js_3.getBigInt)(value, \"maxFeePerGas\");\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */ get data() {\n        return this.#data;\n    }\n    set data(value) {\n        this.#data = (0, index_js_3.hexlify)(value);\n    }\n    /**\n     *  The amount of ether (in wei) to send in this transactions.\n     */ get value() {\n        return this.#value;\n    }\n    set value(value) {\n        this.#value = (0, index_js_3.getBigInt)(value, \"value\");\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */ get chainId() {\n        return this.#chainId;\n    }\n    set chainId(value) {\n        this.#chainId = (0, index_js_3.getBigInt)(value);\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */ get signature() {\n        return this.#sig || null;\n    }\n    set signature(value) {\n        this.#sig = value == null ? null : index_js_2.Signature.from(value);\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */ get accessList() {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2) {\n                return [];\n            }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value) {\n        this.#accessList = value == null ? null : (0, accesslist_js_1.accessListify)(value);\n    }\n    /**\n     *  Creates a new Transaction with default values.\n     */ constructor(){\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BigInt(0);\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BigInt(0);\n        this.#chainId = BigInt(0);\n        this.#sig = null;\n        this.#accessList = null;\n    }\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */ get hash() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0, index_js_2.keccak256)(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */ get unsignedHash() {\n        return (0, index_js_2.keccak256)(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */ get from() {\n        if (this.signature == null) {\n            return null;\n        }\n        return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */ get fromPublicKey() {\n        if (this.signature == null) {\n            return null;\n        }\n        return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */ isSigned() {\n        //isSigned(): this is SignedTransaction {\n        return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */ get serialized() {\n        (0, index_js_3.assert)(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n        }\n        (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".serialized\"\n        });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */ get unsignedSerialized() {\n        switch(this.inferType()){\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n        }\n        (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n            operation: \".unsignedSerialized\"\n        });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */ inferType() {\n        return this.inferTypes().pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */ inferTypes() {\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n        const hasAccessList = this.accessList != null;\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n                value: this\n            });\n        }\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n        (0, index_js_3.assert)(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n            value: this\n        });\n        (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n            value: this\n        });\n        const types = [];\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n        } else {\n            if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) {\n                    types.push(0);\n                }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n            }\n        }\n        types.sort();\n        return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLegacy() {\n        return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isBerlin() {\n        return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */ isLondon() {\n        return this.type === 2;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */ clone() {\n        return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */ toJSON() {\n        const s = (v)=>{\n            if (v == null) {\n                return null;\n            }\n            return v.toString();\n        };\n        return {\n            type: this.type,\n            to: this.to,\n            //            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON() : null,\n            accessList: this.accessList\n        };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */ static from(tx) {\n        if (tx == null) {\n            return new Transaction();\n        }\n        if (typeof tx === \"string\") {\n            const payload = (0, index_js_3.getBytes)(tx);\n            if (payload[0] >= 0x7f) {\n                return Transaction.from(_parseLegacy(payload));\n            }\n            switch(payload[0]){\n                case 1:\n                    return Transaction.from(_parseEip2930(payload));\n                case 2:\n                    return Transaction.from(_parseEip1559(payload));\n            }\n            (0, index_js_3.assert)(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"from\"\n            });\n        }\n        const result = new Transaction();\n        if (tx.type != null) {\n            result.type = tx.type;\n        }\n        if (tx.to != null) {\n            result.to = tx.to;\n        }\n        if (tx.nonce != null) {\n            result.nonce = tx.nonce;\n        }\n        if (tx.gasLimit != null) {\n            result.gasLimit = tx.gasLimit;\n        }\n        if (tx.gasPrice != null) {\n            result.gasPrice = tx.gasPrice;\n        }\n        if (tx.maxPriorityFeePerGas != null) {\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        }\n        if (tx.maxFeePerGas != null) {\n            result.maxFeePerGas = tx.maxFeePerGas;\n        }\n        if (tx.data != null) {\n            result.data = tx.data;\n        }\n        if (tx.value != null) {\n            result.value = tx.value;\n        }\n        if (tx.chainId != null) {\n            result.chainId = tx.chainId;\n        }\n        if (tx.signature != null) {\n            result.signature = index_js_2.Signature.from(tx.signature);\n        }\n        if (tx.accessList != null) {\n            result.accessList = tx.accessList;\n        }\n        if (tx.hash != null) {\n            (0, index_js_3.assertArgument)(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            (0, index_js_3.assertArgument)(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n        if (tx.from != null) {\n            (0, index_js_3.assertArgument)(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n        return result;\n    }\n}\nexports.Transaction = Transaction; //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxzRkFBcUI7QUFDaEQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsb0ZBQW9CO0FBQy9DLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRyxrQkFBa0JILG1CQUFPQSxDQUFDLDJGQUFpQjtBQUNqRCxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxxRkFBYztBQUMzQyxNQUFNSyxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsTUFBTUUsUUFBUUYsT0FBTztBQUNyQixNQUFNRyxRQUFRSCxPQUFPO0FBQ3JCLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssY0FBY0wsT0FBTztBQUMzQixTQUFTTSxjQUFjZixLQUFLO0lBQ3hCLElBQUlBLFVBQVUsTUFBTTtRQUNoQixPQUFPO0lBQ1g7SUFDQSxPQUFPLENBQUMsR0FBR0UsV0FBV2MsVUFBVSxFQUFFaEI7QUFDdEM7QUFDQSxTQUFTaUIsaUJBQWlCakIsS0FBSyxFQUFFa0IsS0FBSztJQUNsQyxJQUFJO1FBQ0EsT0FBTyxDQUFDLEdBQUdaLGdCQUFnQmEsYUFBYSxFQUFFbkI7SUFDOUMsRUFDQSxPQUFPb0IsT0FBTztRQUNULElBQUdmLFdBQVdnQixjQUFjLEVBQUUsT0FBT0QsTUFBTUUsT0FBTyxFQUFFSixPQUFPbEI7SUFDaEU7QUFDSjtBQUNBLFNBQVN1QixhQUFhQyxNQUFNLEVBQUVOLEtBQUs7SUFDL0IsSUFBSU0sV0FBVyxNQUFNO1FBQ2pCLE9BQU87SUFDWDtJQUNBLE9BQU8sQ0FBQyxHQUFHbkIsV0FBV29CLFNBQVMsRUFBRUQsUUFBUU47QUFDN0M7QUFDQSxTQUFTUSxXQUFXRixNQUFNLEVBQUVOLEtBQUs7SUFDN0IsSUFBSU0sV0FBVyxNQUFNO1FBQ2pCLE9BQU9oQjtJQUNYO0lBQ0EsTUFBTVIsUUFBUSxDQUFDLEdBQUdLLFdBQVdzQixTQUFTLEVBQUVILFFBQVFOO0lBQy9DLElBQUdiLFdBQVdnQixjQUFjLEVBQUVyQixTQUFTYyxhQUFhLDJCQUEyQkksT0FBT2xCO0lBQ3ZGLE9BQU9BO0FBQ1g7QUFDQSxTQUFTNEIsYUFBYUosTUFBTSxFQUFFSyxJQUFJO0lBQzlCLE1BQU03QixRQUFRLENBQUMsR0FBR0ssV0FBV3NCLFNBQVMsRUFBRUgsUUFBUTtJQUNoRCxNQUFNTSxTQUFTLENBQUMsR0FBR3pCLFdBQVcwQixTQUFTLEVBQUUvQjtJQUN4QyxJQUFHSyxXQUFXZ0IsY0FBYyxFQUFFUyxPQUFPRSxNQUFNLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFSCxLQUFLLENBQUMsRUFBRTdCO0lBQ3JGLE9BQU84QjtBQUNYO0FBQ0EsU0FBU0csaUJBQWlCakMsS0FBSztJQUMzQixPQUFPLENBQUMsR0FBR00sZ0JBQWdCYSxhQUFhLEVBQUVuQixPQUFPa0MsR0FBRyxDQUFDLENBQUNDLE1BQVE7WUFBQ0EsSUFBSUMsT0FBTztZQUFFRCxJQUFJRSxXQUFXO1NBQUM7QUFDaEc7QUFDQSxTQUFTQyxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFNBQVMsQ0FBQyxHQUFHbkMsV0FBV29DLFNBQVMsRUFBRUY7SUFDeEMsSUFBR2xDLFdBQVdnQixjQUFjLEVBQUVxQixNQUFNQyxPQUFPLENBQUNILFdBQVlBLENBQUFBLE9BQU9SLE1BQU0sS0FBSyxLQUFLUSxPQUFPUixNQUFNLEtBQUssSUFBSSw4Q0FBOEMsUUFBUU87SUFDNUosTUFBTUssS0FBSztRQUNQQyxNQUFNO1FBQ05DLE9BQU92QixhQUFhaUIsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUMvQk8sVUFBVXJCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7UUFDaENRLFVBQVV0QixXQUFXYyxNQUFNLENBQUMsRUFBRSxFQUFFO1FBQ2hDUyxJQUFJbEMsY0FBY3lCLE1BQU0sQ0FBQyxFQUFFO1FBQzNCeEMsT0FBTzBCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7UUFDN0JELE1BQU0sQ0FBQyxHQUFHbEMsV0FBVzZDLE9BQU8sRUFBRVYsTUFBTSxDQUFDLEVBQUU7UUFDdkNXLFNBQVMzQztJQUNiO0lBQ0EsOEJBQThCO0lBQzlCLElBQUlnQyxPQUFPUixNQUFNLEtBQUssR0FBRztRQUNyQixPQUFPWTtJQUNYO0lBQ0EsTUFBTVEsSUFBSTFCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDaEMsTUFBTWEsSUFBSTNCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDaEMsTUFBTWMsSUFBSTVCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDaEMsSUFBSWEsTUFBTTdDLFFBQVE4QyxNQUFNOUMsTUFBTTtRQUMxQiwrQkFBK0I7UUFDL0JvQyxHQUFHTyxPQUFPLEdBQUdDO0lBQ2pCLE9BQ0s7UUFDRCxpREFBaUQ7UUFDakQsSUFBSUQsVUFBVSxDQUFDQyxJQUFJdkMsS0FBSSxJQUFLSDtRQUM1QixJQUFJeUMsVUFBVTNDLE1BQU07WUFDaEIyQyxVQUFVM0M7UUFDZDtRQUNBb0MsR0FBR08sT0FBTyxHQUFHQTtRQUNiLDRCQUE0QjtRQUMzQixJQUFHOUMsV0FBV2dCLGNBQWMsRUFBRThCLFlBQVkzQyxRQUFTNEMsTUFBTXpDLFNBQVN5QyxNQUFNeEMsT0FBUSwwQkFBMEIsS0FBSzRCLE1BQU0sQ0FBQyxFQUFFO1FBQ3pISSxHQUFHVyxTQUFTLEdBQUduRCxXQUFXb0QsU0FBUyxDQUFDQyxJQUFJLENBQUM7WUFDckNKLEdBQUcsQ0FBQyxHQUFHaEQsV0FBV3FELFlBQVksRUFBRWxCLE1BQU0sQ0FBQyxFQUFFLEVBQUU7WUFDM0NjLEdBQUcsQ0FBQyxHQUFHakQsV0FBV3FELFlBQVksRUFBRWxCLE1BQU0sQ0FBQyxFQUFFLEVBQUU7WUFDM0NZO1FBQ0o7UUFDQVIsR0FBR2UsSUFBSSxHQUFHLENBQUMsR0FBR3ZELFdBQVd3RCxTQUFTLEVBQUVyQjtJQUN4QztJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTaUIsaUJBQWlCakIsRUFBRSxFQUFFa0IsR0FBRztJQUM3QixNQUFNdEIsU0FBUztRQUNYWixhQUFhZ0IsR0FBR0UsS0FBSyxJQUFJLEdBQUc7UUFDNUJsQixhQUFhZ0IsR0FBR0csUUFBUSxJQUFJLEdBQUc7UUFDL0JuQixhQUFhZ0IsR0FBR0ksUUFBUSxJQUFJLEdBQUc7UUFDN0JKLEdBQUdLLEVBQUUsSUFBSSxPQUFRLENBQUMsR0FBRy9DLFdBQVdjLFVBQVUsRUFBRTRCLEdBQUdLLEVBQUUsSUFBSTtRQUN2RHJCLGFBQWFnQixHQUFHNUMsS0FBSyxJQUFJLEdBQUc7UUFDM0I0QyxHQUFHTCxJQUFJLElBQUk7S0FDZjtJQUNELElBQUlZLFVBQVUzQztJQUNkLElBQUlvQyxHQUFHTyxPQUFPLElBQUkzQyxNQUFNO1FBQ3BCLHdEQUF3RDtRQUN4RDJDLFVBQVUsQ0FBQyxHQUFHOUMsV0FBV3NCLFNBQVMsRUFBRWlCLEdBQUdPLE9BQU8sRUFBRTtRQUNoRCxpRUFBaUU7UUFDakUsdUNBQXVDO1FBQ3RDLElBQUc5QyxXQUFXZ0IsY0FBYyxFQUFFLENBQUN5QyxPQUFPQSxJQUFJQyxRQUFRLElBQUksUUFBUUQsSUFBSUUsYUFBYSxLQUFLYixTQUFTLDZCQUE2QixPQUFPVztJQUN0SSxPQUNLLElBQUlsQixHQUFHVyxTQUFTLEVBQUU7UUFDbkIsbUVBQW1FO1FBQ25FLE1BQU1VLFNBQVNyQixHQUFHVyxTQUFTLENBQUNTLGFBQWE7UUFDekMsSUFBSUMsVUFBVSxNQUFNO1lBQ2hCZCxVQUFVYztRQUNkO0lBQ0o7SUFDQSxxQ0FBcUM7SUFDckMsSUFBSSxDQUFDSCxLQUFLO1FBQ04sc0VBQXNFO1FBQ3RFLElBQUlYLFlBQVkzQyxNQUFNO1lBQ2xCZ0MsT0FBTzBCLElBQUksQ0FBQyxDQUFDLEdBQUc3RCxXQUFXMEIsU0FBUyxFQUFFb0I7WUFDdENYLE9BQU8wQixJQUFJLENBQUM7WUFDWjFCLE9BQU8wQixJQUFJLENBQUM7UUFDaEI7UUFDQSxPQUFPLENBQUMsR0FBRzdELFdBQVc4RCxTQUFTLEVBQUUzQjtJQUNyQztJQUNBLHNFQUFzRTtJQUN0RSxxRUFBcUU7SUFDckUsdUNBQXVDO0lBQ3ZDLHdCQUF3QjtJQUN4QixJQUFJWSxJQUFJM0MsT0FBTyxLQUFLcUQsSUFBSU0sT0FBTztJQUMvQixJQUFJakIsWUFBWTNDLE1BQU07UUFDbEI0QyxJQUFJaEQsV0FBV29ELFNBQVMsQ0FBQ2EsV0FBVyxDQUFDbEIsU0FBU1csSUFBSVYsQ0FBQztJQUN2RCxPQUNLLElBQUkzQyxPQUFPcUQsSUFBSVYsQ0FBQyxNQUFNQSxHQUFHO1FBQ3pCLElBQUcvQyxXQUFXZ0IsY0FBYyxFQUFFLE9BQU8sNkJBQTZCLE9BQU95QztJQUM5RTtJQUNBLG9CQUFvQjtJQUNwQnRCLE9BQU8wQixJQUFJLENBQUMsQ0FBQyxHQUFHN0QsV0FBVzBCLFNBQVMsRUFBRXFCO0lBQ3RDWixPQUFPMEIsSUFBSSxDQUFDLENBQUMsR0FBRzdELFdBQVcwQixTQUFTLEVBQUUrQixJQUFJVCxDQUFDO0lBQzNDYixPQUFPMEIsSUFBSSxDQUFDLENBQUMsR0FBRzdELFdBQVcwQixTQUFTLEVBQUUrQixJQUFJUixDQUFDO0lBQzNDLE9BQU8sQ0FBQyxHQUFHakQsV0FBVzhELFNBQVMsRUFBRTNCO0FBQ3JDO0FBQ0EsU0FBUzhCLG1CQUFtQjFCLEVBQUUsRUFBRUosTUFBTTtJQUNsQyxJQUFJNEI7SUFDSixJQUFJO1FBQ0FBLFVBQVU3QyxhQUFhaUIsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUNsQyxJQUFJNEIsWUFBWSxLQUFLQSxZQUFZLEdBQUc7WUFDaEMsTUFBTSxJQUFJRyxNQUFNO1FBQ3BCO0lBQ0osRUFDQSxPQUFPbkQsT0FBTztRQUNULElBQUdmLFdBQVdnQixjQUFjLEVBQUUsT0FBTyxtQkFBbUIsV0FBV21CLE1BQU0sQ0FBQyxFQUFFO0lBQ2pGO0lBQ0EsTUFBTWEsSUFBSSxDQUFDLEdBQUdoRCxXQUFXcUQsWUFBWSxFQUFFbEIsTUFBTSxDQUFDLEVBQUUsRUFBRTtJQUNsRCxNQUFNYyxJQUFJLENBQUMsR0FBR2pELFdBQVdxRCxZQUFZLEVBQUVsQixNQUFNLENBQUMsRUFBRSxFQUFFO0lBQ2xELE1BQU1lLFlBQVluRCxXQUFXb0QsU0FBUyxDQUFDQyxJQUFJLENBQUM7UUFBRUo7UUFBR0M7UUFBR2M7SUFBUTtJQUM1RHhCLEdBQUdXLFNBQVMsR0FBR0E7QUFDbkI7QUFDQSxTQUFTaUIsY0FBY2pDLElBQUk7SUFDdkIsTUFBTUMsU0FBUyxDQUFDLEdBQUduQyxXQUFXb0MsU0FBUyxFQUFFLENBQUMsR0FBR3BDLFdBQVdvRSxRQUFRLEVBQUVsQyxNQUFNbUMsS0FBSyxDQUFDO0lBQzdFLElBQUdyRSxXQUFXZ0IsY0FBYyxFQUFFcUIsTUFBTUMsT0FBTyxDQUFDSCxXQUFZQSxDQUFBQSxPQUFPUixNQUFNLEtBQUssS0FBS1EsT0FBT1IsTUFBTSxLQUFLLEVBQUMsR0FBSSwrQ0FBK0MsUUFBUSxDQUFDLEdBQUczQixXQUFXNkMsT0FBTyxFQUFFWDtJQUN0TCxNQUFNb0MsdUJBQXVCakQsV0FBV2MsTUFBTSxDQUFDLEVBQUUsRUFBRTtJQUNuRCxNQUFNb0MsZUFBZWxELFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDM0MsTUFBTUksS0FBSztRQUNQQyxNQUFNO1FBQ05NLFNBQVN6QixXQUFXYyxNQUFNLENBQUMsRUFBRSxFQUFFO1FBQy9CTSxPQUFPdkIsYUFBYWlCLE1BQU0sQ0FBQyxFQUFFLEVBQUU7UUFDL0JtQyxzQkFBc0JBO1FBQ3RCQyxjQUFjQTtRQUNkN0IsVUFBVTtRQUNWQyxVQUFVdEIsV0FBV2MsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUNoQ1MsSUFBSWxDLGNBQWN5QixNQUFNLENBQUMsRUFBRTtRQUMzQnhDLE9BQU8wQixXQUFXYyxNQUFNLENBQUMsRUFBRSxFQUFFO1FBQzdCRCxNQUFNLENBQUMsR0FBR2xDLFdBQVc2QyxPQUFPLEVBQUVWLE1BQU0sQ0FBQyxFQUFFO1FBQ3ZDcUMsWUFBWTVELGlCQUFpQnVCLE1BQU0sQ0FBQyxFQUFFLEVBQUU7SUFDNUM7SUFDQSxnQ0FBZ0M7SUFDaEMsSUFBSUEsT0FBT1IsTUFBTSxLQUFLLEdBQUc7UUFDckIsT0FBT1k7SUFDWDtJQUNBQSxHQUFHZSxJQUFJLEdBQUcsQ0FBQyxHQUFHdkQsV0FBV3dELFNBQVMsRUFBRXJCO0lBQ3BDK0IsbUJBQW1CMUIsSUFBSUosT0FBT2tDLEtBQUssQ0FBQztJQUNwQyxPQUFPOUI7QUFDWDtBQUNBLFNBQVNrQyxrQkFBa0JsQyxFQUFFLEVBQUVrQixHQUFHO0lBQzlCLE1BQU10QixTQUFTO1FBQ1haLGFBQWFnQixHQUFHTyxPQUFPLElBQUksR0FBRztRQUM5QnZCLGFBQWFnQixHQUFHRSxLQUFLLElBQUksR0FBRztRQUM1QmxCLGFBQWFnQixHQUFHK0Isb0JBQW9CLElBQUksR0FBRztRQUMzQy9DLGFBQWFnQixHQUFHZ0MsWUFBWSxJQUFJLEdBQUc7UUFDbkNoRCxhQUFhZ0IsR0FBR0ksUUFBUSxJQUFJLEdBQUc7UUFDN0JKLEdBQUdLLEVBQUUsSUFBSSxPQUFRLENBQUMsR0FBRy9DLFdBQVdjLFVBQVUsRUFBRTRCLEdBQUdLLEVBQUUsSUFBSTtRQUN2RHJCLGFBQWFnQixHQUFHNUMsS0FBSyxJQUFJLEdBQUc7UUFDM0I0QyxHQUFHTCxJQUFJLElBQUk7UUFDWE4saUJBQWlCVyxHQUFHaUMsVUFBVSxJQUFJLEVBQUU7S0FDeEM7SUFDRCxJQUFJZixLQUFLO1FBQ0x0QixPQUFPMEIsSUFBSSxDQUFDdEMsYUFBYWtDLElBQUlNLE9BQU8sRUFBRTtRQUN0QzVCLE9BQU8wQixJQUFJLENBQUMsQ0FBQyxHQUFHN0QsV0FBVzBCLFNBQVMsRUFBRStCLElBQUlULENBQUM7UUFDM0NiLE9BQU8wQixJQUFJLENBQUMsQ0FBQyxHQUFHN0QsV0FBVzBCLFNBQVMsRUFBRStCLElBQUlSLENBQUM7SUFDL0M7SUFDQSxPQUFPLENBQUMsR0FBR2pELFdBQVcwRSxNQUFNLEVBQUU7UUFBQztRQUFTLElBQUcxRSxXQUFXOEQsU0FBUyxFQUFFM0I7S0FBUTtBQUM3RTtBQUNBLFNBQVN3QyxjQUFjekMsSUFBSTtJQUN2QixNQUFNQyxTQUFTLENBQUMsR0FBR25DLFdBQVdvQyxTQUFTLEVBQUUsQ0FBQyxHQUFHcEMsV0FBV29FLFFBQVEsRUFBRWxDLE1BQU1tQyxLQUFLLENBQUM7SUFDN0UsSUFBR3JFLFdBQVdnQixjQUFjLEVBQUVxQixNQUFNQyxPQUFPLENBQUNILFdBQVlBLENBQUFBLE9BQU9SLE1BQU0sS0FBSyxLQUFLUSxPQUFPUixNQUFNLEtBQUssRUFBQyxHQUFJLCtDQUErQyxRQUFRLENBQUMsR0FBRzNCLFdBQVc2QyxPQUFPLEVBQUVYO0lBQ3RMLE1BQU1LLEtBQUs7UUFDUEMsTUFBTTtRQUNOTSxTQUFTekIsV0FBV2MsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUMvQk0sT0FBT3ZCLGFBQWFpQixNQUFNLENBQUMsRUFBRSxFQUFFO1FBQy9CTyxVQUFVckIsV0FBV2MsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUNoQ1EsVUFBVXRCLFdBQVdjLE1BQU0sQ0FBQyxFQUFFLEVBQUU7UUFDaENTLElBQUlsQyxjQUFjeUIsTUFBTSxDQUFDLEVBQUU7UUFDM0J4QyxPQUFPMEIsV0FBV2MsTUFBTSxDQUFDLEVBQUUsRUFBRTtRQUM3QkQsTUFBTSxDQUFDLEdBQUdsQyxXQUFXNkMsT0FBTyxFQUFFVixNQUFNLENBQUMsRUFBRTtRQUN2Q3FDLFlBQVk1RCxpQkFBaUJ1QixNQUFNLENBQUMsRUFBRSxFQUFFO0lBQzVDO0lBQ0EsZ0NBQWdDO0lBQ2hDLElBQUlBLE9BQU9SLE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE9BQU9ZO0lBQ1g7SUFDQUEsR0FBR2UsSUFBSSxHQUFHLENBQUMsR0FBR3ZELFdBQVd3RCxTQUFTLEVBQUVyQjtJQUNwQytCLG1CQUFtQjFCLElBQUlKLE9BQU9rQyxLQUFLLENBQUM7SUFDcEMsT0FBTzlCO0FBQ1g7QUFDQSxTQUFTcUMsa0JBQWtCckMsRUFBRSxFQUFFa0IsR0FBRztJQUM5QixNQUFNdEIsU0FBUztRQUNYWixhQUFhZ0IsR0FBR08sT0FBTyxJQUFJLEdBQUc7UUFDOUJ2QixhQUFhZ0IsR0FBR0UsS0FBSyxJQUFJLEdBQUc7UUFDNUJsQixhQUFhZ0IsR0FBR0csUUFBUSxJQUFJLEdBQUc7UUFDL0JuQixhQUFhZ0IsR0FBR0ksUUFBUSxJQUFJLEdBQUc7UUFDN0JKLEdBQUdLLEVBQUUsSUFBSSxPQUFRLENBQUMsR0FBRy9DLFdBQVdjLFVBQVUsRUFBRTRCLEdBQUdLLEVBQUUsSUFBSTtRQUN2RHJCLGFBQWFnQixHQUFHNUMsS0FBSyxJQUFJLEdBQUc7UUFDM0I0QyxHQUFHTCxJQUFJLElBQUk7UUFDWE4saUJBQWlCVyxHQUFHaUMsVUFBVSxJQUFJLEVBQUU7S0FDeEM7SUFDRCxJQUFJZixLQUFLO1FBQ0x0QixPQUFPMEIsSUFBSSxDQUFDdEMsYUFBYWtDLElBQUlNLE9BQU8sRUFBRTtRQUN0QzVCLE9BQU8wQixJQUFJLENBQUMsQ0FBQyxHQUFHN0QsV0FBVzBCLFNBQVMsRUFBRStCLElBQUlULENBQUM7UUFDM0NiLE9BQU8wQixJQUFJLENBQUMsQ0FBQyxHQUFHN0QsV0FBVzBCLFNBQVMsRUFBRStCLElBQUlSLENBQUM7SUFDL0M7SUFDQSxPQUFPLENBQUMsR0FBR2pELFdBQVcwRSxNQUFNLEVBQUU7UUFBQztRQUFTLElBQUcxRSxXQUFXOEQsU0FBUyxFQUFFM0I7S0FBUTtBQUM3RTtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELE1BQU12QztJQUNGLENBQUM0QyxJQUFJLENBQUM7SUFDTixDQUFDSSxFQUFFLENBQUM7SUFDSixDQUFDVixJQUFJLENBQUM7SUFDTixDQUFDTyxLQUFLLENBQUM7SUFDUCxDQUFDRSxRQUFRLENBQUM7SUFDVixDQUFDRCxRQUFRLENBQUM7SUFDVixDQUFDNEIsb0JBQW9CLENBQUM7SUFDdEIsQ0FBQ0MsWUFBWSxDQUFDO0lBQ2QsQ0FBQzVFLEtBQUssQ0FBQztJQUNQLENBQUNtRCxPQUFPLENBQUM7SUFDVCxDQUFDVyxHQUFHLENBQUM7SUFDTCxDQUFDZSxVQUFVLENBQUM7SUFDWjs7Ozs7S0FLQyxHQUNELElBQUloQyxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUFFO0lBQ2hDLElBQUlBLEtBQUs3QyxLQUFLLEVBQUU7UUFDWixPQUFRQTtZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDLENBQUM2QyxJQUFJLEdBQUc7Z0JBQ2I7WUFDSixLQUFLO1lBQ0wsS0FBSztnQkFDRCxJQUFJLENBQUMsQ0FBQ0EsSUFBSSxHQUFHO2dCQUNiO1lBQ0osS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNELElBQUksQ0FBQyxDQUFDQSxJQUFJLEdBQUc7Z0JBQ2I7WUFDSixLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDLENBQUNBLElBQUksR0FBRztnQkFDYjtZQUNKO2dCQUNLLElBQUd4QyxXQUFXZ0IsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLFFBQVFyQjtRQUN0RjtJQUNKO0lBQ0E7O0tBRUMsR0FDRCxJQUFJa0YsV0FBVztRQUNYLE9BQVEsSUFBSSxDQUFDckMsSUFBSTtZQUNiLEtBQUs7Z0JBQUcsT0FBTztZQUNmLEtBQUs7Z0JBQUcsT0FBTztZQUNmLEtBQUs7Z0JBQUcsT0FBTztRQUNuQjtRQUNBLE9BQU87SUFDWDtJQUNBOzs7S0FHQyxHQUNELElBQUlJLEtBQUs7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxFQUFFO0lBQUU7SUFDNUIsSUFBSUEsR0FBR2pELEtBQUssRUFBRTtRQUNWLElBQUksQ0FBQyxDQUFDaUQsRUFBRSxHQUFHLFNBQVUsT0FBUSxPQUFPLENBQUMsR0FBRy9DLFdBQVdjLFVBQVUsRUFBRWhCO0lBQ25FO0lBQ0E7O0tBRUMsR0FDRCxJQUFJOEMsUUFBUTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLEtBQUs7SUFBRTtJQUNsQyxJQUFJQSxNQUFNOUMsS0FBSyxFQUFFO1FBQUUsSUFBSSxDQUFDLENBQUM4QyxLQUFLLEdBQUcsQ0FBQyxHQUFHekMsV0FBV29CLFNBQVMsRUFBRXpCLE9BQU87SUFBVTtJQUM1RTs7S0FFQyxHQUNELElBQUlnRCxXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsUUFBUTtJQUFFO0lBQ3hDLElBQUlBLFNBQVNoRCxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ2dELFFBQVEsR0FBRyxDQUFDLEdBQUczQyxXQUFXc0IsU0FBUyxFQUFFM0I7SUFBUTtJQUN6RTs7Ozs7S0FLQyxHQUNELElBQUkrQyxXQUFXO1FBQ1gsTUFBTS9DLFFBQVEsSUFBSSxDQUFDLENBQUMrQyxRQUFRO1FBQzVCLElBQUkvQyxTQUFTLFFBQVMsS0FBSSxDQUFDNkMsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDQSxJQUFJLEtBQUssSUFBSTtZQUN2RCxPQUFPckM7UUFDWDtRQUNBLE9BQU9SO0lBQ1g7SUFDQSxJQUFJK0MsU0FBUy9DLEtBQUssRUFBRTtRQUNoQixJQUFJLENBQUMsQ0FBQytDLFFBQVEsR0FBRyxTQUFVLE9BQVEsT0FBTyxDQUFDLEdBQUcxQyxXQUFXc0IsU0FBUyxFQUFFM0IsT0FBTztJQUMvRTtJQUNBOzs7S0FHQyxHQUNELElBQUkyRSx1QkFBdUI7UUFDdkIsTUFBTTNFLFFBQVEsSUFBSSxDQUFDLENBQUMyRSxvQkFBb0I7UUFDeEMsSUFBSTNFLFNBQVMsTUFBTTtZQUNmLElBQUksSUFBSSxDQUFDNkMsSUFBSSxLQUFLLEdBQUc7Z0JBQ2pCLE9BQU9yQztZQUNYO1lBQ0EsT0FBTztRQUNYO1FBQ0EsT0FBT1I7SUFDWDtJQUNBLElBQUkyRSxxQkFBcUIzRSxLQUFLLEVBQUU7UUFDNUIsSUFBSSxDQUFDLENBQUMyRSxvQkFBb0IsR0FBRyxTQUFVLE9BQVEsT0FBTyxDQUFDLEdBQUd0RSxXQUFXc0IsU0FBUyxFQUFFM0IsT0FBTztJQUMzRjtJQUNBOzs7S0FHQyxHQUNELElBQUk0RSxlQUFlO1FBQ2YsTUFBTTVFLFFBQVEsSUFBSSxDQUFDLENBQUM0RSxZQUFZO1FBQ2hDLElBQUk1RSxTQUFTLE1BQU07WUFDZixJQUFJLElBQUksQ0FBQzZDLElBQUksS0FBSyxHQUFHO2dCQUNqQixPQUFPckM7WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU9SO0lBQ1g7SUFDQSxJQUFJNEUsYUFBYTVFLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUMsQ0FBQzRFLFlBQVksR0FBRyxTQUFVLE9BQVEsT0FBTyxDQUFDLEdBQUd2RSxXQUFXc0IsU0FBUyxFQUFFM0IsT0FBTztJQUNuRjtJQUNBOzs7S0FHQyxHQUNELElBQUl1QyxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsSUFBSTtJQUFFO0lBQ2hDLElBQUlBLEtBQUt2QyxLQUFLLEVBQUU7UUFBRSxJQUFJLENBQUMsQ0FBQ3VDLElBQUksR0FBRyxDQUFDLEdBQUdsQyxXQUFXNkMsT0FBTyxFQUFFbEQ7SUFBUTtJQUMvRDs7S0FFQyxHQUNELElBQUlBLFFBQVE7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDQSxLQUFLO0lBQUU7SUFDbEMsSUFBSUEsTUFBTUEsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDLENBQUNBLEtBQUssR0FBRyxDQUFDLEdBQUdLLFdBQVdzQixTQUFTLEVBQUUzQixPQUFPO0lBQ25EO0lBQ0E7O0tBRUMsR0FDRCxJQUFJbUQsVUFBVTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLE9BQU87SUFBRTtJQUN0QyxJQUFJQSxRQUFRbkQsS0FBSyxFQUFFO1FBQUUsSUFBSSxDQUFDLENBQUNtRCxPQUFPLEdBQUcsQ0FBQyxHQUFHOUMsV0FBV3NCLFNBQVMsRUFBRTNCO0lBQVE7SUFDdkU7O0tBRUMsR0FDRCxJQUFJdUQsWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNPLEdBQUcsSUFBSTtJQUFNO0lBQzVDLElBQUlQLFVBQVV2RCxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDLENBQUM4RCxHQUFHLEdBQUcsU0FBVSxPQUFRLE9BQU8xRCxXQUFXb0QsU0FBUyxDQUFDQyxJQUFJLENBQUN6RDtJQUNuRTtJQUNBOzs7OztLQUtDLEdBQ0QsSUFBSTZFLGFBQWE7UUFDYixNQUFNN0UsUUFBUSxJQUFJLENBQUMsQ0FBQzZFLFVBQVUsSUFBSTtRQUNsQyxJQUFJN0UsU0FBUyxNQUFNO1lBQ2YsSUFBSSxJQUFJLENBQUM2QyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUNBLElBQUksS0FBSyxHQUFHO2dCQUNwQyxPQUFPLEVBQUU7WUFDYjtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU83QztJQUNYO0lBQ0EsSUFBSTZFLFdBQVc3RSxLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDLENBQUM2RSxVQUFVLEdBQUcsU0FBVSxPQUFRLE9BQU8sQ0FBQyxHQUFHdkUsZ0JBQWdCYSxhQUFhLEVBQUVuQjtJQUNuRjtJQUNBOztLQUVDLEdBQ0RtRixhQUFjO1FBQ1YsSUFBSSxDQUFDLENBQUN0QyxJQUFJLEdBQUc7UUFDYixJQUFJLENBQUMsQ0FBQ0ksRUFBRSxHQUFHO1FBQ1gsSUFBSSxDQUFDLENBQUNILEtBQUssR0FBRztRQUNkLElBQUksQ0FBQyxDQUFDRSxRQUFRLEdBQUd2QyxPQUFPO1FBQ3hCLElBQUksQ0FBQyxDQUFDc0MsUUFBUSxHQUFHO1FBQ2pCLElBQUksQ0FBQyxDQUFDNEIsb0JBQW9CLEdBQUc7UUFDN0IsSUFBSSxDQUFDLENBQUNDLFlBQVksR0FBRztRQUNyQixJQUFJLENBQUMsQ0FBQ3JDLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDdkMsS0FBSyxHQUFHUyxPQUFPO1FBQ3JCLElBQUksQ0FBQyxDQUFDMEMsT0FBTyxHQUFHMUMsT0FBTztRQUN2QixJQUFJLENBQUMsQ0FBQ3FELEdBQUcsR0FBRztRQUNaLElBQUksQ0FBQyxDQUFDZSxVQUFVLEdBQUc7SUFDdkI7SUFDQTs7S0FFQyxHQUNELElBQUlsQixPQUFPO1FBQ1AsSUFBSSxJQUFJLENBQUNKLFNBQVMsSUFBSSxNQUFNO1lBQ3hCLE9BQU87UUFDWDtRQUNBLE9BQU8sQ0FBQyxHQUFHbkQsV0FBV3dELFNBQVMsRUFBRSxJQUFJLENBQUN3QixVQUFVO0lBQ3BEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJQyxlQUFlO1FBQ2YsT0FBTyxDQUFDLEdBQUdqRixXQUFXd0QsU0FBUyxFQUFFLElBQUksQ0FBQzBCLGtCQUFrQjtJQUM1RDtJQUNBOztLQUVDLEdBQ0QsSUFBSTdCLE9BQU87UUFDUCxJQUFJLElBQUksQ0FBQ0YsU0FBUyxJQUFJLE1BQU07WUFDeEIsT0FBTztRQUNYO1FBQ0EsT0FBTyxDQUFDLEdBQUdoRCxhQUFhZ0YsY0FBYyxFQUFFLElBQUksQ0FBQ0YsWUFBWSxFQUFFLElBQUksQ0FBQzlCLFNBQVM7SUFDN0U7SUFDQTs7S0FFQyxHQUNELElBQUlpQyxnQkFBZ0I7UUFDaEIsSUFBSSxJQUFJLENBQUNqQyxTQUFTLElBQUksTUFBTTtZQUN4QixPQUFPO1FBQ1g7UUFDQSxPQUFPbkQsV0FBV3FGLFVBQVUsQ0FBQ0MsZ0JBQWdCLENBQUMsSUFBSSxDQUFDTCxZQUFZLEVBQUUsSUFBSSxDQUFDOUIsU0FBUztJQUNuRjtJQUNBOzs7OztLQUtDLEdBQ0RvQyxXQUFXO1FBQ1AseUNBQXlDO1FBQ3pDLE9BQU8sSUFBSSxDQUFDcEMsU0FBUyxJQUFJO0lBQzdCO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJNkIsYUFBYTtRQUNaLElBQUcvRSxXQUFXdUYsTUFBTSxFQUFFLElBQUksQ0FBQ3JDLFNBQVMsSUFBSSxNQUFNLDhFQUE4RSx5QkFBeUI7WUFBRXNDLFdBQVc7UUFBYztRQUNqTCxPQUFRLElBQUksQ0FBQ0MsU0FBUztZQUNsQixLQUFLO2dCQUNELE9BQU9qQyxpQkFBaUIsSUFBSSxFQUFFLElBQUksQ0FBQ04sU0FBUztZQUNoRCxLQUFLO2dCQUNELE9BQU8wQixrQkFBa0IsSUFBSSxFQUFFLElBQUksQ0FBQzFCLFNBQVM7WUFDakQsS0FBSztnQkFDRCxPQUFPdUIsa0JBQWtCLElBQUksRUFBRSxJQUFJLENBQUN2QixTQUFTO1FBQ3JEO1FBQ0MsSUFBR2xELFdBQVd1RixNQUFNLEVBQUUsT0FBTyxnQ0FBZ0MseUJBQXlCO1lBQUVDLFdBQVc7UUFBYztJQUN0SDtJQUNBOzs7OztLQUtDLEdBQ0QsSUFBSVAscUJBQXFCO1FBQ3JCLE9BQVEsSUFBSSxDQUFDUSxTQUFTO1lBQ2xCLEtBQUs7Z0JBQ0QsT0FBT2pDLGlCQUFpQixJQUFJO1lBQ2hDLEtBQUs7Z0JBQ0QsT0FBT29CLGtCQUFrQixJQUFJO1lBQ2pDLEtBQUs7Z0JBQ0QsT0FBT0gsa0JBQWtCLElBQUk7UUFDckM7UUFDQyxJQUFHekUsV0FBV3VGLE1BQU0sRUFBRSxPQUFPLGdDQUFnQyx5QkFBeUI7WUFBRUMsV0FBVztRQUFzQjtJQUM5SDtJQUNBOzs7S0FHQyxHQUNEQyxZQUFZO1FBQ1IsT0FBUSxJQUFJLENBQUNDLFVBQVUsR0FBR0MsR0FBRztJQUNqQztJQUNBOzs7S0FHQyxHQUNERCxhQUFhO1FBQ1Qsc0RBQXNEO1FBQ3RELE1BQU1FLGNBQWMsSUFBSSxDQUFDbEQsUUFBUSxJQUFJO1FBQ3JDLE1BQU1tRCxTQUFVLElBQUksQ0FBQ3RCLFlBQVksSUFBSSxRQUFRLElBQUksQ0FBQ0Qsb0JBQW9CLElBQUk7UUFDMUUsTUFBTXdCLGdCQUFpQixJQUFJLENBQUN0QixVQUFVLElBQUk7UUFDMUMsOEJBQThCO1FBQzlCLDJFQUEyRTtRQUMzRSxHQUFHO1FBQ0gsSUFBSSxJQUFJLENBQUNELFlBQVksSUFBSSxRQUFRLElBQUksQ0FBQ0Qsb0JBQW9CLElBQUksTUFBTTtZQUMvRCxJQUFHdEUsV0FBV3VGLE1BQU0sRUFBRSxJQUFJLENBQUNoQixZQUFZLElBQUksSUFBSSxDQUFDRCxvQkFBb0IsRUFBRSwwQ0FBMEMsWUFBWTtnQkFBRTNFLE9BQU8sSUFBSTtZQUFDO1FBQy9JO1FBQ0EsdUNBQXVDO1FBQ3ZDLG1FQUFtRTtRQUNuRSxHQUFHO1FBQ0YsSUFBR0ssV0FBV3VGLE1BQU0sRUFBRSxDQUFDTSxVQUFXLElBQUksQ0FBQ3JELElBQUksS0FBSyxLQUFLLElBQUksQ0FBQ0EsSUFBSSxLQUFLLEdBQUkscUVBQXFFLFlBQVk7WUFBRTdDLE9BQU8sSUFBSTtRQUFDO1FBQ3RLLElBQUdLLFdBQVd1RixNQUFNLEVBQUUsSUFBSSxDQUFDL0MsSUFBSSxLQUFLLEtBQUssQ0FBQ3NELGVBQWUsNkNBQTZDLFlBQVk7WUFBRW5HLE9BQU8sSUFBSTtRQUFDO1FBQ2pJLE1BQU1vRyxRQUFRLEVBQUU7UUFDaEIsZ0JBQWdCO1FBQ2hCLElBQUksSUFBSSxDQUFDdkQsSUFBSSxJQUFJLE1BQU07WUFDbkJ1RCxNQUFNbEMsSUFBSSxDQUFDLElBQUksQ0FBQ3JCLElBQUk7UUFDeEIsT0FDSztZQUNELElBQUlxRCxRQUFRO2dCQUNSRSxNQUFNbEMsSUFBSSxDQUFDO1lBQ2YsT0FDSyxJQUFJK0IsYUFBYTtnQkFDbEJHLE1BQU1sQyxJQUFJLENBQUM7Z0JBQ1gsSUFBSSxDQUFDaUMsZUFBZTtvQkFDaEJDLE1BQU1sQyxJQUFJLENBQUM7Z0JBQ2Y7WUFDSixPQUNLLElBQUlpQyxlQUFlO2dCQUNwQkMsTUFBTWxDLElBQUksQ0FBQztnQkFDWGtDLE1BQU1sQyxJQUFJLENBQUM7WUFDZixPQUNLO2dCQUNEa0MsTUFBTWxDLElBQUksQ0FBQztnQkFDWGtDLE1BQU1sQyxJQUFJLENBQUM7Z0JBQ1hrQyxNQUFNbEMsSUFBSSxDQUFDO1lBQ2Y7UUFDSjtRQUNBa0MsTUFBTUMsSUFBSTtRQUNWLE9BQU9EO0lBQ1g7SUFDQTs7Ozs7O0tBTUMsR0FDREUsV0FBVztRQUNQLE9BQVEsSUFBSSxDQUFDekQsSUFBSSxLQUFLO0lBQzFCO0lBQ0E7Ozs7OztLQU1DLEdBQ0QwRCxXQUFXO1FBQ1AsT0FBUSxJQUFJLENBQUMxRCxJQUFJLEtBQUs7SUFDMUI7SUFDQTs7Ozs7O0tBTUMsR0FDRDJELFdBQVc7UUFDUCxPQUFRLElBQUksQ0FBQzNELElBQUksS0FBSztJQUMxQjtJQUNBOztLQUVDLEdBQ0Q0RCxRQUFRO1FBQ0osT0FBT3hHLFlBQVl3RCxJQUFJLENBQUMsSUFBSTtJQUNoQztJQUNBOztLQUVDLEdBQ0RpRCxTQUFTO1FBQ0wsTUFBTXBELElBQUksQ0FBQ0Y7WUFDUCxJQUFJQSxLQUFLLE1BQU07Z0JBQ1gsT0FBTztZQUNYO1lBQ0EsT0FBT0EsRUFBRXVELFFBQVE7UUFDckI7UUFDQSxPQUFPO1lBQ0g5RCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmSSxJQUFJLElBQUksQ0FBQ0EsRUFBRTtZQUNYLDhCQUE4QjtZQUM5QlYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZk8sT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJFLFVBQVVNLEVBQUUsSUFBSSxDQUFDTixRQUFRO1lBQ3pCRCxVQUFVTyxFQUFFLElBQUksQ0FBQ1AsUUFBUTtZQUN6QjRCLHNCQUFzQnJCLEVBQUUsSUFBSSxDQUFDcUIsb0JBQW9CO1lBQ2pEQyxjQUFjdEIsRUFBRSxJQUFJLENBQUNzQixZQUFZO1lBQ2pDNUUsT0FBT3NELEVBQUUsSUFBSSxDQUFDdEQsS0FBSztZQUNuQm1ELFNBQVNHLEVBQUUsSUFBSSxDQUFDSCxPQUFPO1lBQ3ZCVyxLQUFLLElBQUksQ0FBQ1AsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDbUQsTUFBTSxLQUFLO1lBQ2hEN0IsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDL0I7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE9BQU9wQixLQUFLYixFQUFFLEVBQUU7UUFDWixJQUFJQSxNQUFNLE1BQU07WUFDWixPQUFPLElBQUkzQztRQUNmO1FBQ0EsSUFBSSxPQUFRMkMsT0FBUSxVQUFVO1lBQzFCLE1BQU1nRSxVQUFVLENBQUMsR0FBR3ZHLFdBQVdvRSxRQUFRLEVBQUU3QjtZQUN6QyxJQUFJZ0UsT0FBTyxDQUFDLEVBQUUsSUFBSSxNQUFNO2dCQUNwQixPQUFPM0csWUFBWXdELElBQUksQ0FBQ25CLGFBQWFzRTtZQUN6QztZQUNBLE9BQVFBLE9BQU8sQ0FBQyxFQUFFO2dCQUNkLEtBQUs7b0JBQUcsT0FBTzNHLFlBQVl3RCxJQUFJLENBQUN1QixjQUFjNEI7Z0JBQzlDLEtBQUs7b0JBQUcsT0FBTzNHLFlBQVl3RCxJQUFJLENBQUNlLGNBQWNvQztZQUNsRDtZQUNDLElBQUd2RyxXQUFXdUYsTUFBTSxFQUFFLE9BQU8sZ0NBQWdDLHlCQUF5QjtnQkFBRUMsV0FBVztZQUFPO1FBQy9HO1FBQ0EsTUFBTS9ELFNBQVMsSUFBSTdCO1FBQ25CLElBQUkyQyxHQUFHQyxJQUFJLElBQUksTUFBTTtZQUNqQmYsT0FBT2UsSUFBSSxHQUFHRCxHQUFHQyxJQUFJO1FBQ3pCO1FBQ0EsSUFBSUQsR0FBR0ssRUFBRSxJQUFJLE1BQU07WUFDZm5CLE9BQU9tQixFQUFFLEdBQUdMLEdBQUdLLEVBQUU7UUFDckI7UUFDQSxJQUFJTCxHQUFHRSxLQUFLLElBQUksTUFBTTtZQUNsQmhCLE9BQU9nQixLQUFLLEdBQUdGLEdBQUdFLEtBQUs7UUFDM0I7UUFDQSxJQUFJRixHQUFHSSxRQUFRLElBQUksTUFBTTtZQUNyQmxCLE9BQU9rQixRQUFRLEdBQUdKLEdBQUdJLFFBQVE7UUFDakM7UUFDQSxJQUFJSixHQUFHRyxRQUFRLElBQUksTUFBTTtZQUNyQmpCLE9BQU9pQixRQUFRLEdBQUdILEdBQUdHLFFBQVE7UUFDakM7UUFDQSxJQUFJSCxHQUFHK0Isb0JBQW9CLElBQUksTUFBTTtZQUNqQzdDLE9BQU82QyxvQkFBb0IsR0FBRy9CLEdBQUcrQixvQkFBb0I7UUFDekQ7UUFDQSxJQUFJL0IsR0FBR2dDLFlBQVksSUFBSSxNQUFNO1lBQ3pCOUMsT0FBTzhDLFlBQVksR0FBR2hDLEdBQUdnQyxZQUFZO1FBQ3pDO1FBQ0EsSUFBSWhDLEdBQUdMLElBQUksSUFBSSxNQUFNO1lBQ2pCVCxPQUFPUyxJQUFJLEdBQUdLLEdBQUdMLElBQUk7UUFDekI7UUFDQSxJQUFJSyxHQUFHNUMsS0FBSyxJQUFJLE1BQU07WUFDbEI4QixPQUFPOUIsS0FBSyxHQUFHNEMsR0FBRzVDLEtBQUs7UUFDM0I7UUFDQSxJQUFJNEMsR0FBR08sT0FBTyxJQUFJLE1BQU07WUFDcEJyQixPQUFPcUIsT0FBTyxHQUFHUCxHQUFHTyxPQUFPO1FBQy9CO1FBQ0EsSUFBSVAsR0FBR1csU0FBUyxJQUFJLE1BQU07WUFDdEJ6QixPQUFPeUIsU0FBUyxHQUFHbkQsV0FBV29ELFNBQVMsQ0FBQ0MsSUFBSSxDQUFDYixHQUFHVyxTQUFTO1FBQzdEO1FBQ0EsSUFBSVgsR0FBR2lDLFVBQVUsSUFBSSxNQUFNO1lBQ3ZCL0MsT0FBTytDLFVBQVUsR0FBR2pDLEdBQUdpQyxVQUFVO1FBQ3JDO1FBQ0EsSUFBSWpDLEdBQUdlLElBQUksSUFBSSxNQUFNO1lBQ2hCLElBQUd0RCxXQUFXZ0IsY0FBYyxFQUFFUyxPQUFPNkQsUUFBUSxJQUFJLDJDQUEyQyxNQUFNL0M7WUFDbEcsSUFBR3ZDLFdBQVdnQixjQUFjLEVBQUVTLE9BQU82QixJQUFJLEtBQUtmLEdBQUdlLElBQUksRUFBRSxpQkFBaUIsTUFBTWY7UUFDbkY7UUFDQSxJQUFJQSxHQUFHYSxJQUFJLElBQUksTUFBTTtZQUNoQixJQUFHcEQsV0FBV2dCLGNBQWMsRUFBRVMsT0FBTzZELFFBQVEsSUFBSSwyQ0FBMkMsTUFBTS9DO1lBQ2xHLElBQUd2QyxXQUFXZ0IsY0FBYyxFQUFFUyxPQUFPMkIsSUFBSSxDQUFDb0QsV0FBVyxPQUFPLENBQUNqRSxHQUFHYSxJQUFJLElBQUksRUFBQyxFQUFHb0QsV0FBVyxJQUFJLGlCQUFpQixNQUFNakU7UUFDdkg7UUFDQSxPQUFPZDtJQUNYO0FBQ0o7QUFDQS9CLG1CQUFtQixHQUFHRSxhQUN0Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi5qcz9lZDFjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGFjY2Vzc2xpc3RfanNfMSA9IHJlcXVpcmUoXCIuL2FjY2Vzc2xpc3QuanNcIik7XG5jb25zdCBhZGRyZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLmpzXCIpO1xuY29uc3QgQk5fMCA9IEJpZ0ludCgwKTtcbmNvbnN0IEJOXzIgPSBCaWdJbnQoMik7XG5jb25zdCBCTl8yNyA9IEJpZ0ludCgyNyk7XG5jb25zdCBCTl8yOCA9IEJpZ0ludCgyOCk7XG5jb25zdCBCTl8zNSA9IEJpZ0ludCgzNSk7XG5jb25zdCBCTl9NQVhfVUlOVCA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFjY2Vzc0xpc3QodmFsdWUsIHBhcmFtKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBhY2Nlc3NsaXN0X2pzXzEuYWNjZXNzTGlzdGlmeSkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBlcnJvci5tZXNzYWdlLCBwYXJhbSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcihfdmFsdWUsIHBhcmFtKSB7XG4gICAgaWYgKF92YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZ2V0TnVtYmVyKShfdmFsdWUsIHBhcmFtKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVVpbnQoX3ZhbHVlLCBwYXJhbSkge1xuICAgIGlmIChfdmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gQk5fMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKF92YWx1ZSwgcGFyYW0pO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA8PSBCTl9NQVhfVUlOVCwgXCJ2YWx1ZSBleGNlZWRzIHVpbnQgc2l6ZVwiLCBwYXJhbSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihfdmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkodmFsdWUpO1xuICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShyZXN1bHQubGVuZ3RoIDw9IDMyLCBgdmFsdWUgdG9vIGxhcmdlYCwgYHR4LiR7bmFtZX1gLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGFjY2Vzc2xpc3RfanNfMS5hY2Nlc3NMaXN0aWZ5KSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfcGFyc2VMZWdhY3koZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoZGF0YSk7XG4gICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiAoZmllbGRzLmxlbmd0aCA9PT0gOSB8fCBmaWVsZHMubGVuZ3RoID09PSA2KSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciBsZWdhY3kgdHJhbnNhY3Rpb25cIiwgXCJkYXRhXCIsIGRhdGEpO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKGZpZWxkc1swXSwgXCJub25jZVwiKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZVVpbnQoZmllbGRzWzFdLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzTGltaXRcIiksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKGZpZWxkc1szXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVVaW50KGZpZWxkc1s0XSwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgZGF0YTogKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkoZmllbGRzWzVdKSxcbiAgICAgICAgY2hhaW5JZDogQk5fMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICBjb25zdCB2ID0gaGFuZGxlVWludChmaWVsZHNbNl0sIFwidlwiKTtcbiAgICBjb25zdCByID0gaGFuZGxlVWludChmaWVsZHNbN10sIFwiclwiKTtcbiAgICBjb25zdCBzID0gaGFuZGxlVWludChmaWVsZHNbOF0sIFwic1wiKTtcbiAgICBpZiAociA9PT0gQk5fMCAmJiBzID09PSBCTl8wKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHY7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBFSVAtMTU1IGNoYWluIElEIChvciAwIGZvciBsZWdhY3kpXG4gICAgICAgIGxldCBjaGFpbklkID0gKHYgLSBCTl8zNSkgLyBCTl8yO1xuICAgICAgICBpZiAoY2hhaW5JZCA8IEJOXzApIHtcbiAgICAgICAgICAgIGNoYWluSWQgPSBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHR4LmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAvLyBTaWduZWQgTGVnYWN5IFRyYW5zYWN0aW9uXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShjaGFpbklkICE9PSBCTl8wIHx8ICh2ID09PSBCTl8yNyB8fCB2ID09PSBCTl8yOCksIFwibm9uLWNhbm9uaWNhbCBsZWdhY3kgdlwiLCBcInZcIiwgZmllbGRzWzZdKTtcbiAgICAgICAgdHguc2lnbmF0dXJlID0gaW5kZXhfanNfMi5TaWduYXR1cmUuZnJvbSh7XG4gICAgICAgICAgICByOiAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1s3XSwgMzIpLFxuICAgICAgICAgICAgczogKDAsIGluZGV4X2pzXzMuemVyb1BhZFZhbHVlKShmaWVsZHNbOF0sIDMyKSxcbiAgICAgICAgICAgIHZcbiAgICAgICAgfSk7XG4gICAgICAgIHR4Lmhhc2ggPSAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdHg7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplTGVnYWN5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHgudG8gIT0gbnVsbCkgPyAoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSh0eC50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgudmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHR4LmRhdGEgfHwgXCIweFwiKSxcbiAgICBdO1xuICAgIGxldCBjaGFpbklkID0gQk5fMDtcbiAgICBpZiAodHguY2hhaW5JZCAhPSBCTl8wKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHR4LmNoYWluSWQsIFwidHguY2hhaW5JZFwiKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNoYWluSWQgaW4gdGhlIHR4IGFuZCBhbiBFSVAtMTU1IHYgaW4gdGhlIHNpZ25hdHVyZSxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYWdyZWUgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KSghc2lnIHx8IHNpZy5uZXR3b3JrViA9PSBudWxsIHx8IHNpZy5sZWdhY3lDaGFpbklkID09PSBjaGFpbklkLCBcInR4LmNoYWluSWQvc2lnLnYgbWlzbWF0Y2hcIiwgXCJzaWdcIiwgc2lnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHguc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIE5vIGV4cGxpY2l0IGNoYWluSWQsIGJ1dCBFSVAtMTU1IGhhdmUgYSBkZXJpdmVkIGltcGxpY2l0IGNoYWluSWRcbiAgICAgICAgY29uc3QgbGVnYWN5ID0gdHguc2lnbmF0dXJlLmxlZ2FjeUNoYWluSWQ7XG4gICAgICAgIGlmIChsZWdhY3kgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhaW5JZCA9IGxlZ2FjeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgICAgICBpZiAoY2hhaW5JZCAhPT0gQk5fMCkge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goKDAsIGluZGV4X2pzXzMudG9CZUFycmF5KShjaGFpbklkKSk7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCIweFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGluZGV4X2pzXzMuZW5jb2RlUmxwKShmaWVsZHMpO1xuICAgIH1cbiAgICAvLyBAVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoYXQgdHguc2lnbmF0dXJlLCBjaGFpbklkLCBhbmQgc2lnXG4gICAgLy8gICAgICAgIG1hdGNoIGJ1dCB0aGF0IGxvZ2ljIGNvdWxkIGJyZWFrIGV4aXN0aW5nIGNvZGUsIHNvIHNjaGVkdWxlXG4gICAgLy8gICAgICAgIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIGJ1bXAuXG4gICAgLy8gQ29tcHV0ZSB0aGUgRUlQLTE1NSB2XG4gICAgbGV0IHYgPSBCaWdJbnQoMjcgKyBzaWcueVBhcml0eSk7XG4gICAgaWYgKGNoYWluSWQgIT09IEJOXzApIHtcbiAgICAgICAgdiA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmdldENoYWluSWRWKGNoYWluSWQsIHNpZy52KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQmlnSW50KHNpZy52KSAhPT0gdikge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidHguY2hhaW5JZC9zaWcudiBtaXNtYXRjaFwiLCBcInNpZ1wiLCBzaWcpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIHNpZ25hdHVyZVxuICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkodikpO1xuICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnIpKTtcbiAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5zKSk7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmVuY29kZVJscCkoZmllbGRzKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzKSB7XG4gICAgbGV0IHlQYXJpdHk7XG4gICAgdHJ5IHtcbiAgICAgICAgeVBhcml0eSA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0sIFwieVBhcml0eVwiKTtcbiAgICAgICAgaWYgKHlQYXJpdHkgIT09IDAgJiYgeVBhcml0eSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHlQYXJpdHlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIHlQYXJpdHlcIiwgXCJ5UGFyaXR5XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1sxXSwgMzIpO1xuICAgIGNvbnN0IHMgPSAoMCwgaW5kZXhfanNfMy56ZXJvUGFkVmFsdWUpKGZpZWxkc1syXSwgMzIpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20oeyByLCBzLCB5UGFyaXR5IH0pO1xuICAgIHR4LnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDE1NTkoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKGRhdGEpLnNsaWNlKDEpKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA5IHx8IGZpZWxkcy5sZW5ndGggPT09IDEyKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAyXCIsIFwiZGF0YVwiLCAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhKSk7XG4gICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1syXSwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKTtcbiAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJtYXhGZWVQZXJHYXNcIik7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDIsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZVVpbnQoZmllbGRzWzRdLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyhmaWVsZHNbNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlVWludChmaWVsZHNbNl0sIFwidmFsdWVcIiksXG4gICAgICAgIGRhdGE6ICgwLCBpbmRleF9qc18zLmhleGxpZnkpKGZpZWxkc1s3XSksXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGhhbmRsZUFjY2Vzc0xpc3QoZmllbGRzWzhdLCBcImFjY2Vzc0xpc3RcIiksXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMTU1OSBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9ICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOSkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHgubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/ICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInlQYXJpdHlcIikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW1wiMHgwMlwiLCAoMCwgaW5kZXhfanNfMy5lbmNvZGVSbHApKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAoZGF0YSkge1xuICAgIGNvbnN0IGZpZWxkcyA9ICgwLCBpbmRleF9qc18zLmRlY29kZVJscCkoKDAsIGluZGV4X2pzXzMuZ2V0Qnl0ZXMpKGRhdGEpLnNsaWNlKDEpKTtcbiAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIChmaWVsZHMubGVuZ3RoID09PSA4IHx8IGZpZWxkcy5sZW5ndGggPT09IDExKSwgXCJpbnZhbGlkIGZpZWxkIGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwiZGF0YVwiLCAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShkYXRhKSk7XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZVVpbnQoZmllbGRzWzBdLCBcImNoYWluSWRcIiksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIoZmllbGRzWzFdLCBcIm5vbmNlXCIpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlVWludChmaWVsZHNbMl0sIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVVaW50KGZpZWxkc1szXSwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3MoZmllbGRzWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZVVpbnQoZmllbGRzWzVdLCBcInZhbHVlXCIpLFxuICAgICAgICBkYXRhOiAoMCwgaW5kZXhfanNfMy5oZXhsaWZ5KShmaWVsZHNbNl0pLFxuICAgICAgICBhY2Nlc3NMaXN0OiBoYW5kbGVBY2Nlc3NMaXN0KGZpZWxkc1s3XSwgXCJhY2Nlc3NMaXN0XCIpXG4gICAgfTtcbiAgICAvLyBVbnNpZ25lZCBFSVAtMjkzMCBUcmFuc2FjdGlvblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9ICgwLCBpbmRleF9qc18yLmtlY2NhazI1NikoZGF0YSk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMuc2xpY2UoOCkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHR4LCBzaWcpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHR4Lm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHguZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0eC50byAhPSBudWxsKSA/ICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHR4LnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0eC52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHguZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0eC5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWcpIHtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy55UGFyaXR5LCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaCgoMCwgaW5kZXhfanNfMy50b0JlQXJyYXkpKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKCgwLCBpbmRleF9qc18zLnRvQmVBcnJheSkoc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18zLmNvbmNhdCkoW1wiMHgwMVwiLCAoMCwgaW5kZXhfanNfMy5lbmNvZGVSbHApKGZpZWxkcyldKTtcbn1cbi8qKlxuICogIEEgKipUcmFuc2FjdGlvbioqIGRlc2NyaWJlcyBhbiBvcGVyYXRpb24gdG8gYmUgZXhlY3V0ZWQgb25cbiAqICBFdGhlcmV1bSBieSBhbiBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuIEl0IGluY2x1ZGVzXG4gKiAgd2hvICh0aGUgW1t0b11dIGFkZHJlc3MpLCB3aGF0ICh0aGUgW1tkYXRhXV0pIGFuZCBob3cgbXVjaCAodGhlXG4gKiAgW1t2YWx1ZV1dIGluIGV0aGVyKSB0aGUgb3BlcmF0aW9uIHNob3VsZCBlbnRhaWwuXG4gKlxuICogIEBleGFtcGxlOlxuICogICAgdHggPSBuZXcgVHJhbnNhY3Rpb24oKVxuICogICAgLy9fcmVzdWx0OlxuICpcbiAqICAgIHR4LmRhdGEgPSBcIjB4MTIzNFwiO1xuICogICAgLy9fcmVzdWx0OlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgI3R5cGU7XG4gICAgI3RvO1xuICAgICNkYXRhO1xuICAgICNub25jZTtcbiAgICAjZ2FzTGltaXQ7XG4gICAgI2dhc1ByaWNlO1xuICAgICNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAjbWF4RmVlUGVyR2FzO1xuICAgICN2YWx1ZTtcbiAgICAjY2hhaW5JZDtcbiAgICAjc2lnO1xuICAgICNhY2Nlc3NMaXN0O1xuICAgIC8qKlxuICAgICAqICBUaGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKlxuICAgICAqICBJZiBudWxsLCB0aGUgdHlwZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5mZXJyZWQgYmFzZWQgb25cbiAgICAgKiAgZXhwbGljaXQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuI3R5cGU7IH1cbiAgICBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIFwibGVnYWN5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy4jdHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiYmVybGluXCI6XG4gICAgICAgICAgICBjYXNlIFwiZWlwLTI5MzBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLiN0eXBlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJsb25kb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJlaXAtMTU1OVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuI3R5cGUgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcInR5cGVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbmFtZSBvZiB0aGUgdHJhbnNhY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBnZXQgdHlwZU5hbWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBcImxlZ2FjeVwiO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gXCJlaXAtMjkzMFwiO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gXCJlaXAtMTU1OVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGBgdG9gYCBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb24gb3IgYGBudWxsYGAgaWYgdGhlXG4gICAgICogIHRyYW5zYWN0aW9uIGlzIGFuIGBgaW5pdGBgIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuI3RvOyB9XG4gICAgc2V0IHRvKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI3RvID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBpbmRleF9qc18xLmdldEFkZHJlc3MpKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBub25jZS5cbiAgICAgKi9cbiAgICBnZXQgbm9uY2UoKSB7IHJldHVybiB0aGlzLiNub25jZTsgfVxuICAgIHNldCBub25jZSh2YWx1ZSkgeyB0aGlzLiNub25jZSA9ICgwLCBpbmRleF9qc18zLmdldE51bWJlcikodmFsdWUsIFwidmFsdWVcIik7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGdhcyBsaW1pdC5cbiAgICAgKi9cbiAgICBnZXQgZ2FzTGltaXQoKSB7IHJldHVybiB0aGlzLiNnYXNMaW1pdDsgfVxuICAgIHNldCBnYXNMaW1pdCh2YWx1ZSkgeyB0aGlzLiNnYXNMaW1pdCA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBnYXMgcHJpY2UuXG4gICAgICpcbiAgICAgKiAgT24gbGVnYWN5IG5ldHdvcmtzIHRoaXMgZGVmaW5lcyB0aGUgZmVlIHRoYXQgd2lsbCBiZSBwYWlkLiBPblxuICAgICAqICBFSVAtMTU1OSBuZXR3b3JrcywgdGhpcyBzaG91bGQgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgZ2V0IGdhc1ByaWNlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2dhc1ByaWNlO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAodGhpcy50eXBlID09PSAwIHx8IHRoaXMudHlwZSA9PT0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGdhc1ByaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2dhc1ByaWNlID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUsIFwiZ2FzUHJpY2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSBwcmlvcml0eSBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhQcmlvcml0eUZlZVBlckdhcygpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNtYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQk5fMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heFByaW9yaXR5RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbWF4aW11bSB0b3RhbCBmZWUgcGVyIHVuaXQgb2YgZ2FzIHRvIHBheS4gT24gbGVnYWN5XG4gICAgICogIG5ldHdvcmtzIHRoaXMgc2hvdWxkIGJlIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBtYXhGZWVQZXJHYXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jbWF4RmVlUGVyR2FzO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBCTl8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbWF4RmVlUGVyR2FzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI21heEZlZVBlckdhcyA9ICh2YWx1ZSA9PSBudWxsKSA/IG51bGwgOiAoMCwgaW5kZXhfanNfMy5nZXRCaWdJbnQpKHZhbHVlLCBcIm1heEZlZVBlckdhc1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYGBpbml0YGAgdHJhbnNhY3Rpb25zIHRoaXMgaXMgdGhlXG4gICAgICogIGRlcGxveW1lbnQgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuI2RhdGE7IH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkgeyB0aGlzLiNkYXRhID0gKDAsIGluZGV4X2pzXzMuaGV4bGlmeSkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBhbW91bnQgb2YgZXRoZXIgKGluIHdlaSkgdG8gc2VuZCBpbiB0aGlzIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLiN2YWx1ZTsgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLiN2YWx1ZSA9ICgwLCBpbmRleF9qc18zLmdldEJpZ0ludCkodmFsdWUsIFwidmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgY2hhaW4gSUQgdGhpcyB0cmFuc2FjdGlvbiBpcyB2YWxpZCBvbi5cbiAgICAgKi9cbiAgICBnZXQgY2hhaW5JZCgpIHsgcmV0dXJuIHRoaXMuI2NoYWluSWQ7IH1cbiAgICBzZXQgY2hhaW5JZCh2YWx1ZSkgeyB0aGlzLiNjaGFpbklkID0gKDAsIGluZGV4X2pzXzMuZ2V0QmlnSW50KSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiAgSWYgc2lnbmVkLCB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBzaWduYXR1cmUoKSB7IHJldHVybiB0aGlzLiNzaWcgfHwgbnVsbDsgfVxuICAgIHNldCBzaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2lnID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6IGluZGV4X2pzXzIuU2lnbmF0dXJlLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGFjY2VzcyBsaXN0LlxuICAgICAqXG4gICAgICogIEFuIGFjY2VzcyBsaXN0IHBlcm1pdHMgZGlzY291bnRlZCAoYnV0IHByZS1wYWlkKSBhY2Nlc3MgdG9cbiAgICAgKiAgYnl0ZWNvZGUgYW5kIHN0YXRlIHZhcmlhYmxlIGFjY2VzcyB3aXRoaW4gY29udHJhY3QgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBhY2Nlc3NMaXN0KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2FjY2Vzc0xpc3QgfHwgbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IDEgfHwgdGhpcy50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNhY2Nlc3NMaXN0ID0gKHZhbHVlID09IG51bGwpID8gbnVsbCA6ICgwLCBhY2Nlc3NsaXN0X2pzXzEuYWNjZXNzTGlzdGlmeSkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBUcmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiN0eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jdG8gPSBudWxsO1xuICAgICAgICB0aGlzLiNub25jZSA9IDA7XG4gICAgICAgIHRoaXMuI2dhc0xpbWl0ID0gQmlnSW50KDApO1xuICAgICAgICB0aGlzLiNnYXNQcmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuI21heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jbWF4RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGF0YSA9IFwiMHhcIjtcbiAgICAgICAgdGhpcy4jdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI2NoYWluSWQgPSBCaWdJbnQoMCk7XG4gICAgICAgIHRoaXMuI3NpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjY2Vzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRyYW5zYWN0aW9uIGhhc2gsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHRoaXMuc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJlLWltYWdlIGhhc2ggb2YgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqICBUaGlzIGlzIHRoZSBkaWdlc3QgdGhhdCBhIFtbU2lnbmVyXV0gbXVzdCBzaWduIHRvIGF1dGhvcml6ZVxuICAgICAqICB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldCB1bnNpZ25lZEhhc2goKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKHRoaXMudW5zaWduZWRTZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZW5kaW5nIGFkZHJlc3MsIGlmIHNpZ25lZC4gT3RoZXJ3aXNlLCBgYG51bGxgYC5cbiAgICAgKi9cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgYWRkcmVzc19qc18xLnJlY292ZXJBZGRyZXNzKSh0aGlzLnVuc2lnbmVkSGFzaCwgdGhpcy5zaWduYXR1cmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlciwgaWYgc2lnbmVkLiBPdGhlcndpc2UsIGBgbnVsbGBgLlxuICAgICAqL1xuICAgIGdldCBmcm9tUHVibGljS2V5KCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4X2pzXzIuU2lnbmluZ0tleS5yZWNvdmVyUHVibGljS2V5KHRoaXMudW5zaWduZWRIYXNoLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgc2lnbmVkLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgcHJvcGVydGllcyByZXF1aXJpbmcgYSBzaWduZWRcbiAgICAgKiAgdHJhbnNhY3Rpb24gYXJlIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICAvL2lzU2lnbmVkKCk6IHRoaXMgaXMgU2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmUgIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogIFRoaXMgdGhyb3dzIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyB1bnNpZ25lZC4gRm9yIHRoZSBwcmUtaW1hZ2UsXG4gICAgICogIHVzZSBbW3Vuc2lnbmVkU2VyaWFsaXplZF1dLlxuICAgICAqL1xuICAgIGdldCBzZXJpYWxpemVkKCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKHRoaXMuc2lnbmF0dXJlICE9IG51bGwsIFwiY2Fubm90IHNlcmlhbGl6ZSB1bnNpZ25lZCB0cmFuc2FjdGlvbjsgbWF5YmUgeW91IG1lYW50IC51bnNpZ25lZFNlcmlhbGl6ZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmluZmVyVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVMZWdhY3kodGhpcywgdGhpcy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0aGlzLCB0aGlzLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMsIHRoaXMuc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKGZhbHNlLCBcInVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGVcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiLnNlcmlhbGl6ZWRcIiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSB0cmFuc2FjdGlvbiBwcmUtaW1hZ2UuXG4gICAgICpcbiAgICAgKiAgVGhlIGhhc2ggb2YgdGhpcyBpcyB0aGUgZGlnZXN0IHdoaWNoIG5lZWRzIHRvIGJlIHNpZ25lZCB0b1xuICAgICAqICBhdXRob3JpemUgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgdW5zaWduZWRTZXJpYWxpemVkKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuaW5mZXJUeXBlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUxlZ2FjeSh0aGlzKTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodGhpcyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCIudW5zaWduZWRTZXJpYWxpemVkXCIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIG1vc3QgXCJsaWtlbHlcIiB0eXBlOyBjdXJyZW50bHkgdGhlIGhpZ2hlc3RcbiAgICAgKiAgc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUuXG4gICAgICovXG4gICAgaW5mZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5mZXJUeXBlcygpLnBvcCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlcyB0aGUgZXhwbGljaXQgcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgY29tcGF0aWJsZVxuICAgICAqICB0cmFuc2FjdGlvbiB0eXBlcy5cbiAgICAgKi9cbiAgICBpbmZlclR5cGVzKCkge1xuICAgICAgICAvLyBDaGVja3MgdGhhdCB0aGVyZSBhcmUgbm8gY29uZmxpY3RpbmcgcHJvcGVydGllcyBzZXRcbiAgICAgICAgY29uc3QgaGFzR2FzUHJpY2UgPSB0aGlzLmdhc1ByaWNlICE9IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0ZlZSA9ICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGhhc0FjY2Vzc0xpc3QgPSAodGhpcy5hY2Nlc3NMaXN0ICE9IG51bGwpO1xuICAgICAgICAvL2lmIChoYXNHYXNQcmljZSAmJiBoYXNGZWUpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2UgYW5kIG1heEZlZVBlckdhc1wiKTtcbiAgICAgICAgLy99XG4gICAgICAgIGlmICh0aGlzLm1heEZlZVBlckdhcyAhPSBudWxsICYmIHRoaXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSh0aGlzLm1heEZlZVBlckdhcyA+PSB0aGlzLm1heFByaW9yaXR5RmVlUGVyR2FzLCBcInByaW9yaXR5RmVlIGNhbm5vdCBiZSBtb3JlIHRoYW4gbWF4RmVlXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvL2lmICh0aGlzLnR5cGUgPT09IDIgJiYgaGFzR2FzUHJpY2UpIHtcbiAgICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gY2Fubm90IGhhdmUgZ2FzUHJpY2VcIik7XG4gICAgICAgIC8vfVxuICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnQpKCFoYXNGZWUgfHwgKHRoaXMudHlwZSAhPT0gMCAmJiB0aGlzLnR5cGUgIT09IDEpLCBcInRyYW5zYWN0aW9uIHR5cGUgY2Fubm90IGhhdmUgbWF4RmVlUGVyR2FzIG9yIG1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwiQkFEX0RBVEFcIiwgeyB2YWx1ZTogdGhpcyB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0KSh0aGlzLnR5cGUgIT09IDAgfHwgIWhhc0FjY2Vzc0xpc3QsIFwibGVnYWN5IHRyYW5zYWN0aW9uIGNhbm5vdCBoYXZlIGFjY2Vzc0xpc3RcIiwgXCJCQURfREFUQVwiLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgICAgICAvLyBFeHBsaWNpdCB0eXBlXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0ZlZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNHYXNQcmljZSkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMSk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB0eXBlcy5wdXNoKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR5cGVzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBsZWdhY3kgdHJhbnNhY3Rpb24gKGkuZS5cbiAgICAgKiAgYGB0eXBlID09PSAwYGApLlxuICAgICAqXG4gICAgICogIFRoaXMgcHJvdmlkZXMgYSBUeXBlIEd1YXJkIHRoYXQgdGhlIHJlbGF0ZWQgcHJvcGVydGllcyBhcmVcbiAgICAgKiAgbm9uLW51bGwuXG4gICAgICovXG4gICAgaXNMZWdhY3koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50eXBlID09PSAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHRyYW5zYWN0aW9uIGlzIGJlcmxpbiBoYXJkZm9ybSB0cmFuc2FjdGlvbiAoaS5lLlxuICAgICAqICBgYHR5cGUgPT09IDFgYCkuXG4gICAgICpcbiAgICAgKiAgVGhpcyBwcm92aWRlcyBhIFR5cGUgR3VhcmQgdGhhdCB0aGUgcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqICBub24tbnVsbC5cbiAgICAgKi9cbiAgICBpc0JlcmxpbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR5cGUgPT09IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgbG9uZG9uIGhhcmRmb3JtIHRyYW5zYWN0aW9uIChpLmUuXG4gICAgICogIGBgdHlwZSA9PT0gMmBgKS5cbiAgICAgKlxuICAgICAqICBUaGlzIHByb3ZpZGVzIGEgVHlwZSBHdWFyZCB0aGF0IHRoZSByZWxhdGVkIHByb3BlcnRpZXMgYXJlXG4gICAgICogIG5vbi1udWxsLlxuICAgICAqL1xuICAgIGlzTG9uZG9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudHlwZSA9PT0gMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgdHJhbnNhY2l0b24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIGEgSlNPTi1mcmllbmRseSBvYmplY3QuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzID0gKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICBnYXNMaW1pdDogcyh0aGlzLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBzKHRoaXMuZ2FzUHJpY2UpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHModGhpcy5tYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IHModGhpcy5tYXhGZWVQZXJHYXMpLFxuICAgICAgICAgICAgdmFsdWU6IHModGhpcy52YWx1ZSksXG4gICAgICAgICAgICBjaGFpbklkOiBzKHRoaXMuY2hhaW5JZCksXG4gICAgICAgICAgICBzaWc6IHRoaXMuc2lnbmF0dXJlID8gdGhpcy5zaWduYXR1cmUudG9KU09OKCkgOiBudWxsLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogdGhpcy5hY2Nlc3NMaXN0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSAqKlRyYW5zYWN0aW9uKiogZnJvbSBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb3IgYVxuICAgICAqICBUcmFuc2FjdGlvbi1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh0eCkge1xuICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHR4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9ICgwLCBpbmRleF9qc18zLmdldEJ5dGVzKSh0eCk7XG4gICAgICAgICAgICBpZiAocGF5bG9hZFswXSA+PSAweDdmKSB7IC8vIEBUT0RPOiA+IHZzID49ID8/XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlTGVnYWN5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFRyYW5zYWN0aW9uLmZyb20oX3BhcnNlRWlwMjkzMChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShfcGFyc2VFaXAxNTU5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmcm9tXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIGlmICh0eC50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdHgudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRvID0gdHgudG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ub25jZSA9IHR4Lm5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZ2FzTGltaXQgPSB0eC5nYXNMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lmdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHR4LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHR4LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gdHguY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaWduYXR1cmUgPSBpbmRleF9qc18yLlNpZ25hdHVyZS5mcm9tKHR4LnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4LmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmFjY2Vzc0xpc3QgPSB0eC5hY2Nlc3NMaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5oYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc18zLmFzc2VydEFyZ3VtZW50KShyZXN1bHQuaXNTaWduZWQoKSwgXCJ1bnNpZ25lZCB0cmFuc2FjdGlvbiBjYW5ub3QgZGVmaW5lIGhhc2hcIiwgXCJ0eFwiLCB0eCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkocmVzdWx0Lmhhc2ggPT09IHR4Lmhhc2gsIFwiaGFzaCBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMy5hc3NlcnRBcmd1bWVudCkocmVzdWx0LmlzU2lnbmVkKCksIFwidW5zaWduZWQgdHJhbnNhY3Rpb24gY2Fubm90IGRlZmluZSBmcm9tXCIsIFwidHhcIiwgdHgpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzMuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdC5mcm9tLnRvTG93ZXJDYXNlKCkgPT09ICh0eC5mcm9tIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCksIFwiZnJvbSBtaXNtYXRjaFwiLCBcInR4XCIsIHR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRyYW5zYWN0aW9uIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18yIiwiaW5kZXhfanNfMyIsImFjY2Vzc2xpc3RfanNfMSIsImFkZHJlc3NfanNfMSIsIkJOXzAiLCJCaWdJbnQiLCJCTl8yIiwiQk5fMjciLCJCTl8yOCIsIkJOXzM1IiwiQk5fTUFYX1VJTlQiLCJoYW5kbGVBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImhhbmRsZUFjY2Vzc0xpc3QiLCJwYXJhbSIsImFjY2Vzc0xpc3RpZnkiLCJlcnJvciIsImFzc2VydEFyZ3VtZW50IiwibWVzc2FnZSIsImhhbmRsZU51bWJlciIsIl92YWx1ZSIsImdldE51bWJlciIsImhhbmRsZVVpbnQiLCJnZXRCaWdJbnQiLCJmb3JtYXROdW1iZXIiLCJuYW1lIiwicmVzdWx0IiwidG9CZUFycmF5IiwibGVuZ3RoIiwiZm9ybWF0QWNjZXNzTGlzdCIsIm1hcCIsInNldCIsImFkZHJlc3MiLCJzdG9yYWdlS2V5cyIsIl9wYXJzZUxlZ2FjeSIsImRhdGEiLCJmaWVsZHMiLCJkZWNvZGVSbHAiLCJBcnJheSIsImlzQXJyYXkiLCJ0eCIsInR5cGUiLCJub25jZSIsImdhc1ByaWNlIiwiZ2FzTGltaXQiLCJ0byIsImhleGxpZnkiLCJjaGFpbklkIiwidiIsInIiLCJzIiwic2lnbmF0dXJlIiwiU2lnbmF0dXJlIiwiZnJvbSIsInplcm9QYWRWYWx1ZSIsImhhc2giLCJrZWNjYWsyNTYiLCJfc2VyaWFsaXplTGVnYWN5Iiwic2lnIiwibmV0d29ya1YiLCJsZWdhY3lDaGFpbklkIiwibGVnYWN5IiwicHVzaCIsImVuY29kZVJscCIsInlQYXJpdHkiLCJnZXRDaGFpbklkViIsIl9wYXJzZUVpcFNpZ25hdHVyZSIsIkVycm9yIiwiX3BhcnNlRWlwMTU1OSIsImdldEJ5dGVzIiwic2xpY2UiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsImFjY2Vzc0xpc3QiLCJfc2VyaWFsaXplRWlwMTU1OSIsImNvbmNhdCIsIl9wYXJzZUVpcDI5MzAiLCJfc2VyaWFsaXplRWlwMjkzMCIsInR5cGVOYW1lIiwiY29uc3RydWN0b3IiLCJzZXJpYWxpemVkIiwidW5zaWduZWRIYXNoIiwidW5zaWduZWRTZXJpYWxpemVkIiwicmVjb3ZlckFkZHJlc3MiLCJmcm9tUHVibGljS2V5IiwiU2lnbmluZ0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJpc1NpZ25lZCIsImFzc2VydCIsIm9wZXJhdGlvbiIsImluZmVyVHlwZSIsImluZmVyVHlwZXMiLCJwb3AiLCJoYXNHYXNQcmljZSIsImhhc0ZlZSIsImhhc0FjY2Vzc0xpc3QiLCJ0eXBlcyIsInNvcnQiLCJpc0xlZ2FjeSIsImlzQmVybGluIiwiaXNMb25kb24iLCJjbG9uZSIsInRvSlNPTiIsInRvU3RyaW5nIiwicGF5bG9hZCIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/transaction/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/base58.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/base58.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\n *  to be encoded as a compact string using a radix of 58 using only\n *  alpha-numeric characters. Confusingly similar characters are omitted\n *  (i.e. ``\"l0O\"``).\n *\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\n *  since any zero-bytes on the left would get removed. To mitigate this\n *  issue most schemes that use Base58 choose specific high-order values\n *  to ensure non-zero prefixes.\n *\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeBase58 = exports.encodeBase58 = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\nfunction getAlpha(letter) {\n    if (Lookup == null) {\n        Lookup = {};\n        for(let i = 0; i < Alphabet.length; i++){\n            Lookup[Alphabet[i]] = BigInt(i);\n        }\n    }\n    const result = Lookup[letter];\n    (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, \"letter\", letter);\n    return result;\n}\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\n *  Encode %%value%% as a Base58-encoded string.\n */ function encodeBase58(_value) {\n    let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value));\n    let result = \"\";\n    while(value){\n        result = Alphabet[Number(value % BN_58)] + result;\n        value /= BN_58;\n    }\n    return result;\n}\nexports.encodeBase58 = encodeBase58;\n/**\n *  Decode the Base58-encoded %%value%%.\n */ function decodeBase58(value) {\n    let result = BN_0;\n    for(let i = 0; i < value.length; i++){\n        result *= BN_58;\n        result += getAlpha(value[i]);\n    }\n    return result;\n}\nexports.decodeBase58 = decodeBase58; //# sourceMappingURL=base58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNTguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQ25ELE1BQU1JLFlBQVlDLG1CQUFPQSxDQUFDLHlFQUFXO0FBQ3JDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDZFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDJFQUFZO0FBQ3ZDLE1BQU1HLFdBQVc7QUFDakIsSUFBSUMsU0FBUztBQUNiLFNBQVNDLFNBQVNDLE1BQU07SUFDcEIsSUFBSUYsVUFBVSxNQUFNO1FBQ2hCQSxTQUFTLENBQUM7UUFDVixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUosU0FBU0ssTUFBTSxFQUFFRCxJQUFLO1lBQ3RDSCxNQUFNLENBQUNELFFBQVEsQ0FBQ0ksRUFBRSxDQUFDLEdBQUdFLE9BQU9GO1FBQ2pDO0lBQ0o7SUFDQSxNQUFNRyxTQUFTTixNQUFNLENBQUNFLE9BQU87SUFDNUIsSUFBR0wsWUFBWVUsY0FBYyxFQUFFRCxVQUFVLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLFVBQVVKO0lBQ2xGLE9BQU9JO0FBQ1g7QUFDQSxNQUFNRSxPQUFPSCxPQUFPO0FBQ3BCLE1BQU1JLFFBQVFKLE9BQU87QUFDckI7O0NBRUMsR0FDRCxTQUFTWCxhQUFhZ0IsTUFBTTtJQUN4QixJQUFJbEIsUUFBUSxDQUFDLEdBQUdNLFdBQVdhLFFBQVEsRUFBRSxDQUFDLEdBQUdoQixVQUFVaUIsUUFBUSxFQUFFRjtJQUM3RCxJQUFJSixTQUFTO0lBQ2IsTUFBT2QsTUFBTztRQUNWYyxTQUFTUCxRQUFRLENBQUNjLE9BQU9yQixRQUFRaUIsT0FBTyxHQUFHSDtRQUMzQ2QsU0FBU2lCO0lBQ2I7SUFDQSxPQUFPSDtBQUNYO0FBQ0FmLG9CQUFvQixHQUFHRztBQUN2Qjs7Q0FFQyxHQUNELFNBQVNELGFBQWFELEtBQUs7SUFDdkIsSUFBSWMsU0FBU0U7SUFDYixJQUFLLElBQUlMLElBQUksR0FBR0EsSUFBSVgsTUFBTVksTUFBTSxFQUFFRCxJQUFLO1FBQ25DRyxVQUFVRztRQUNWSCxVQUFVTCxTQUFTVCxLQUFLLENBQUNXLEVBQUU7SUFDL0I7SUFDQSxPQUFPRztBQUNYO0FBQ0FmLG9CQUFvQixHQUFHRSxjQUN2QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNTguanM/YjdmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBbQmFzZTU4IEVuY29kaW5nXShsaW5rLWJhc2U1OCkgc2NoZW1lIGFsbG93cyBhICoqbnVtZXJpYyoqIHZhbHVlXG4gKiAgdG8gYmUgZW5jb2RlZCBhcyBhIGNvbXBhY3Qgc3RyaW5nIHVzaW5nIGEgcmFkaXggb2YgNTggdXNpbmcgb25seVxuICogIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy4gQ29uZnVzaW5nbHkgc2ltaWxhciBjaGFyYWN0ZXJzIGFyZSBvbWl0dGVkXG4gKiAgKGkuZS4gYGBcImwwT1wiYGApLlxuICpcbiAqICBOb3RlIHRoYXQgQmFzZTU4IGVuY29kZXMgYSAqKm51bWVyaWMqKiB2YWx1ZSwgbm90IGFyYml0cmFyeSBieXRlcyxcbiAqICBzaW5jZSBhbnkgemVyby1ieXRlcyBvbiB0aGUgbGVmdCB3b3VsZCBnZXQgcmVtb3ZlZC4gVG8gbWl0aWdhdGUgdGhpc1xuICogIGlzc3VlIG1vc3Qgc2NoZW1lcyB0aGF0IHVzZSBCYXNlNTggY2hvb3NlIHNwZWNpZmljIGhpZ2gtb3JkZXIgdmFsdWVzXG4gKiAgdG8gZW5zdXJlIG5vbi16ZXJvIHByZWZpeGVzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS91dGlsczpCYXNlNTggRW5jb2RpbmcgW2Fib3V0LWJhc2U1OF1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVCYXNlNTggPSBleHBvcnRzLmVuY29kZUJhc2U1OCA9IHZvaWQgMDtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IG1hdGhzX2pzXzEgPSByZXF1aXJlKFwiLi9tYXRocy5qc1wiKTtcbmNvbnN0IEFscGhhYmV0ID0gXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7XG5sZXQgTG9va3VwID0gbnVsbDtcbmZ1bmN0aW9uIGdldEFscGhhKGxldHRlcikge1xuICAgIGlmIChMb29rdXAgPT0gbnVsbCkge1xuICAgICAgICBMb29rdXAgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgTG9va3VwW0FscGhhYmV0W2ldXSA9IEJpZ0ludChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBMb29rdXBbbGV0dGVyXTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHJlc3VsdCAhPSBudWxsLCBgaW52YWxpZCBiYXNlNTggdmFsdWVgLCBcImxldHRlclwiLCBsZXR0ZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fNTggPSBCaWdJbnQoNTgpO1xuLyoqXG4gKiAgRW5jb2RlICUldmFsdWUlJSBhcyBhIEJhc2U1OC1lbmNvZGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTU4KF92YWx1ZSkge1xuICAgIGxldCB2YWx1ZSA9ICgwLCBtYXRoc19qc18xLnRvQmlnSW50KSgoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShfdmFsdWUpKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gQWxwaGFiZXRbTnVtYmVyKHZhbHVlICUgQk5fNTgpXSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgLz0gQk5fNTg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmVuY29kZUJhc2U1OCA9IGVuY29kZUJhc2U1ODtcbi8qKlxuICogIERlY29kZSB0aGUgQmFzZTU4LWVuY29kZWQgJSV2YWx1ZSUlLlxuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNTgodmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gQk5fMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCAqPSBCTl81ODtcbiAgICAgICAgcmVzdWx0ICs9IGdldEFscGhhKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjb2RlQmFzZTU4ID0gZGVjb2RlQmFzZTU4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTU4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlY29kZUJhc2U1OCIsImVuY29kZUJhc2U1OCIsImRhdGFfanNfMSIsInJlcXVpcmUiLCJlcnJvcnNfanNfMSIsIm1hdGhzX2pzXzEiLCJBbHBoYWJldCIsIkxvb2t1cCIsImdldEFscGhhIiwibGV0dGVyIiwiaSIsImxlbmd0aCIsIkJpZ0ludCIsInJlc3VsdCIsImFzc2VydEFyZ3VtZW50IiwiQk5fMCIsIkJOXzU4IiwiX3ZhbHVlIiwidG9CaWdJbnQiLCJnZXRCeXRlcyIsIk51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/base58.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/base64.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/base64.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeBase64 = exports.decodeBase64 = void 0;\n/**\n *  [Base64 encoding](link-wiki-base64) using 6-bit words to encode\n *  arbitrary bytes into a string using 65 printable symbols, the\n *  upper-case and lower-case alphabet, the digits ``0`` through ``9``,\n *  ``\"+\"`` and ``\"/\"`` with the ``\"=\"`` used for padding.\n *\n *  @_subsection: api/utils:Base64 Encoding  [about-base64]\n */ const data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  Decodes the base-64 encoded %%value%%.\n *\n *  @example:\n *    // The decoded value is always binary data...\n *    result = decodeBase64(\"SGVsbG8gV29ybGQhIQ==\")\n *    //_result:\n *\n *    // ...use toUtf8String to convert it to a string.\n *    toUtf8String(result)\n *    //_result:\n *\n *    // Decoding binary data\n *    decodeBase64(\"EjQ=\")\n *    //_result:\n */ function decodeBase64(value) {\n    return (0, data_js_1.getBytesCopy)(Buffer.from(value, \"base64\"));\n}\nexports.decodeBase64 = decodeBase64;\n;\n/**\n *  Encodes %%data%% as a base-64 encoded string.\n *\n *  @example:\n *    // Encoding binary data as a hexstring\n *    encodeBase64(\"0x1234\")\n *    //_result:\n *\n *    // Encoding binary data as a Uint8Array\n *    encodeBase64(new Uint8Array([ 0x12, 0x34 ]))\n *    //_result:\n *\n *    // The input MUST be data...\n *    encodeBase64(\"Hello World!!\")\n *    //_error:\n *\n *    // ...use toUtf8Bytes for this.\n *    encodeBase64(toUtf8Bytes(\"Hello World!!\"))\n *    //_result:\n */ function encodeBase64(data) {\n    return Buffer.from((0, data_js_1.getBytes)(data)).toString(\"base64\");\n}\nexports.encodeBase64 = encodeBase64; //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQ25EOzs7Ozs7O0NBT0MsR0FDRCxNQUFNSSxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxTQUFTRixhQUFhRixLQUFLO0lBQ3ZCLE9BQU8sQ0FBQyxHQUFHRyxVQUFVRSxZQUFZLEVBQUVDLE9BQU9DLElBQUksQ0FBQ1AsT0FBTztBQUMxRDtBQUNBRCxvQkFBb0IsR0FBR0c7O0FBRXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0QsYUFBYU8sSUFBSTtJQUN0QixPQUFPRixPQUFPQyxJQUFJLENBQUMsQ0FBQyxHQUFHSixVQUFVTSxRQUFRLEVBQUVELE9BQU9FLFFBQVEsQ0FBQztBQUMvRDtBQUNBWCxvQkFBb0IsR0FBR0UsY0FDdkIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvYmFzZTY0LmpzPzZmMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZUJhc2U2NCA9IGV4cG9ydHMuZGVjb2RlQmFzZTY0ID0gdm9pZCAwO1xuLyoqXG4gKiAgW0Jhc2U2NCBlbmNvZGluZ10obGluay13aWtpLWJhc2U2NCkgdXNpbmcgNi1iaXQgd29yZHMgdG8gZW5jb2RlXG4gKiAgYXJiaXRyYXJ5IGJ5dGVzIGludG8gYSBzdHJpbmcgdXNpbmcgNjUgcHJpbnRhYmxlIHN5bWJvbHMsIHRoZVxuICogIHVwcGVyLWNhc2UgYW5kIGxvd2VyLWNhc2UgYWxwaGFiZXQsIHRoZSBkaWdpdHMgYGAwYGAgdGhyb3VnaCBgYDlgYCxcbiAqICBgYFwiK1wiYGAgYW5kIGBgXCIvXCJgYCB3aXRoIHRoZSBgYFwiPVwiYGAgdXNlZCBmb3IgcGFkZGluZy5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6QmFzZTY0IEVuY29kaW5nICBbYWJvdXQtYmFzZTY0XVxuICovXG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuLyoqXG4gKiAgRGVjb2RlcyB0aGUgYmFzZS02NCBlbmNvZGVkICUldmFsdWUlJS5cbiAqXG4gKiAgQGV4YW1wbGU6XG4gKiAgICAvLyBUaGUgZGVjb2RlZCB2YWx1ZSBpcyBhbHdheXMgYmluYXJ5IGRhdGEuLi5cbiAqICAgIHJlc3VsdCA9IGRlY29kZUJhc2U2NChcIlNHVnNiRzhnVjI5eWJHUWhJUT09XCIpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gLi4udXNlIHRvVXRmOFN0cmluZyB0byBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLlxuICogICAgdG9VdGY4U3RyaW5nKHJlc3VsdClcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBEZWNvZGluZyBiaW5hcnkgZGF0YVxuICogICAgZGVjb2RlQmFzZTY0KFwiRWpRPVwiKVxuICogICAgLy9fcmVzdWx0OlxuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGRhdGFfanNfMS5nZXRCeXRlc0NvcHkpKEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKSk7XG59XG5leHBvcnRzLmRlY29kZUJhc2U2NCA9IGRlY29kZUJhc2U2NDtcbjtcbi8qKlxuICogIEVuY29kZXMgJSVkYXRhJSUgYXMgYSBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIC8vIEVuY29kaW5nIGJpbmFyeSBkYXRhIGFzIGEgaGV4c3RyaW5nXG4gKiAgICBlbmNvZGVCYXNlNjQoXCIweDEyMzRcIilcbiAqICAgIC8vX3Jlc3VsdDpcbiAqXG4gKiAgICAvLyBFbmNvZGluZyBiaW5hcnkgZGF0YSBhcyBhIFVpbnQ4QXJyYXlcbiAqICAgIGVuY29kZUJhc2U2NChuZXcgVWludDhBcnJheShbIDB4MTIsIDB4MzQgXSkpXG4gKiAgICAvL19yZXN1bHQ6XG4gKlxuICogICAgLy8gVGhlIGlucHV0IE1VU1QgYmUgZGF0YS4uLlxuICogICAgZW5jb2RlQmFzZTY0KFwiSGVsbG8gV29ybGQhIVwiKVxuICogICAgLy9fZXJyb3I6XG4gKlxuICogICAgLy8gLi4udXNlIHRvVXRmOEJ5dGVzIGZvciB0aGlzLlxuICogICAgZW5jb2RlQmFzZTY0KHRvVXRmOEJ5dGVzKFwiSGVsbG8gV29ybGQhIVwiKSlcbiAqICAgIC8vX3Jlc3VsdDpcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0KGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoZGF0YSkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuZXhwb3J0cy5lbmNvZGVCYXNlNjQgPSBlbmNvZGVCYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW5jb2RlQmFzZTY0IiwiZGVjb2RlQmFzZTY0IiwiZGF0YV9qc18xIiwicmVxdWlyZSIsImdldEJ5dGVzQ29weSIsIkJ1ZmZlciIsImZyb20iLCJkYXRhIiwiZ2V0Qnl0ZXMiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/base64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/data.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;\n/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */ const errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for(let i = 0; i < result.length; i++){\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */ function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\nexports.getBytes = getBytes;\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */ function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\nexports.getBytesCopy = getBytesCopy;\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && value.length % 2 !== 0) {\n        return false;\n    }\n    return true;\n}\nexports.isHexString = isHexString;\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */ function isBytesLike(value) {\n    return isHexString(value, true) || value instanceof Uint8Array;\n}\nexports.isBytesLike = isBytesLike;\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */ function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for(let i = 0; i < bytes.length; i++){\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\nexports.hexlify = hexlify;\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */ function concat(datas) {\n    return \"0x\" + datas.map((d)=>hexlify(d).substring(2)).join(\"\");\n}\nexports.concat = concat;\n/**\n *  Returns the length of %%data%%, in bytes.\n */ function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\nexports.dataLength = dataLength;\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */ function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        (0, errors_js_1.assert)(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes,\n            length: bytes.length,\n            offset: end\n        });\n    }\n    return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\nexports.dataSlice = dataSlice;\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */ function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while(bytes.startsWith(\"00\")){\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nexports.stripZerosLeft = stripZerosLeft;\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    (0, errors_js_1.assert)(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    } else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */ function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\nexports.zeroPadValue = zeroPadValue;\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */ function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\nexports.zeroPadBytes = zeroPadBytes; //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9kYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQzlPOzs7OztDQUtDLEdBQ0QsTUFBTWEsY0FBY0MsbUJBQU9BLENBQUMsNkVBQWE7QUFDekMsU0FBU0MsVUFBVWQsS0FBSyxFQUFFZSxJQUFJLEVBQUVDLElBQUk7SUFDaEMsSUFBSWhCLGlCQUFpQmlCLFlBQVk7UUFDN0IsSUFBSUQsTUFBTTtZQUNOLE9BQU8sSUFBSUMsV0FBV2pCO1FBQzFCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBLElBQUksT0FBUUEsVUFBVyxZQUFZQSxNQUFNa0IsS0FBSyxDQUFDLDZCQUE2QjtRQUN4RSxNQUFNQyxTQUFTLElBQUlGLFdBQVcsQ0FBQ2pCLE1BQU1vQixNQUFNLEdBQUcsS0FBSztRQUNuRCxJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE9BQU9DLE1BQU0sRUFBRUUsSUFBSztZQUNwQ0gsTUFBTSxDQUFDRyxFQUFFLEdBQUdDLFNBQVN2QixNQUFNd0IsU0FBUyxDQUFDSCxRQUFRQSxTQUFTLElBQUk7WUFDMURBLFVBQVU7UUFDZDtRQUNBLE9BQU9GO0lBQ1g7SUFDQyxJQUFHUCxZQUFZYSxjQUFjLEVBQUUsT0FBTywyQkFBMkJWLFFBQVEsU0FBU2Y7QUFDdkY7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTVyxTQUFTWCxLQUFLLEVBQUVlLElBQUk7SUFDekIsT0FBT0QsVUFBVWQsT0FBT2UsTUFBTTtBQUNsQztBQUNBaEIsZ0JB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O1FBQzdGaUIsUUFBUSxJQUFJcEIsV0FBV1c7UUFDdkJSLFFBQVFBO1FBQ1JDLFFBQVFELFNBQVM7SUFDckI7SUFDQSxNQUFNRCxTQUFTLElBQUlGLFdBQVdHO0lBQzlCRCxPQUFPdUIsSUFBSSxDQUFDO0lBQ1osSUFBSUQsTUFBTTtRQUNOdEIsT0FBT3dCLEdBQUcsQ0FBQ2YsT0FBT1IsU0FBU1EsTUFBTVIsTUFBTTtJQUMzQyxPQUNLO1FBQ0RELE9BQU93QixHQUFHLENBQUNmLE9BQU87SUFDdEI7SUFDQSxPQUFPckIsUUFBUVk7QUFDbkI7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTakIsYUFBYXlCLElBQUksRUFBRVAsTUFBTTtJQUM5QixPQUFPb0IsUUFBUWIsTUFBTVAsUUFBUTtBQUNqQztBQUNBckIsb0JBQW9CLEdBQUdHO0FBQ3ZCOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNELGFBQWEwQixJQUFJLEVBQUVQLE1BQU07SUFDOUIsT0FBT29CLFFBQVFiLE1BQU1QLFFBQVE7QUFDakM7QUFDQXJCLG9CQUFvQixHQUFHRSxjQUN2QixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9kYXRhLmpzPzg2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnplcm9QYWRCeXRlcyA9IGV4cG9ydHMuemVyb1BhZFZhbHVlID0gZXhwb3J0cy5zdHJpcFplcm9zTGVmdCA9IGV4cG9ydHMuZGF0YVNsaWNlID0gZXhwb3J0cy5kYXRhTGVuZ3RoID0gZXhwb3J0cy5jb25jYXQgPSBleHBvcnRzLmhleGxpZnkgPSBleHBvcnRzLmlzQnl0ZXNMaWtlID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0Qnl0ZXNDb3B5ID0gZXhwb3J0cy5nZXRCeXRlcyA9IHZvaWQgMDtcbi8qKlxuICogIFNvbWUgZGF0YSBoZWxwZXJzLlxuICpcbiAqXG4gKiAgQF9zdWJzZWN0aW9uIGFwaS91dGlsczpEYXRhIEhlbHBlcnMgIFthYm91dC1kYXRhXVxuICovXG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmZ1bmN0aW9uIF9nZXRCeXRlcyh2YWx1ZSwgbmFtZSwgY29weSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWF0Y2goL14weChbMC05YS1mXVswLTlhLWZdKSokL2kpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIDIpLCAxNik7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgQnl0ZXNMaWtlIHZhbHVlXCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKipcbiAqICBHZXQgYSB0eXBlZCBVaW50OEFycmF5IGZvciAlJXZhbHVlJSUuIElmIGFscmVhZHkgYSBVaW50OEFycmF5XG4gKiAgdGhlIG9yaWdpbmFsICUldmFsdWUlJSBpcyByZXR1cm5lZDsgaWYgYSBjb3B5IGlzIHJlcXVpcmVkIHVzZVxuICogIFtbZ2V0Qnl0ZXNDb3B5XV0uXG4gKlxuICogIEBzZWU6IGdldEJ5dGVzQ29weVxuICovXG5mdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbmFtZSkge1xuICAgIHJldHVybiBfZ2V0Qnl0ZXModmFsdWUsIG5hbWUsIGZhbHNlKTtcbn1cbmV4cG9ydHMuZ2V0Qnl0ZXMgPSBnZXRCeXRlcztcbi8qKlxuICogIEdldCBhIHR5cGVkIFVpbnQ4QXJyYXkgZm9yICUldmFsdWUlJSwgY3JlYXRpbmcgYSBjb3B5IGlmIG5lY2Vzc2FyeVxuICogIHRvIHByZXZlbnQgYW55IG1vZGlmaWNhdGlvbnMgb2YgdGhlIHJldHVybmVkIHZhbHVlIGZyb20gYmVpbmdcbiAqICByZWZsZWN0ZWQgZWxzZXdoZXJlLlxuICpcbiAqICBAc2VlOiBnZXRCeXRlc1xuICovXG5mdW5jdGlvbiBnZXRCeXRlc0NvcHkodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gX2dldEJ5dGVzKHZhbHVlLCBuYW1lLCB0cnVlKTtcbn1cbmV4cG9ydHMuZ2V0Qnl0ZXNDb3B5ID0gZ2V0Qnl0ZXNDb3B5O1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUldmFsdWUlJSBpcyBhIHZhbGlkIFtbSGV4U3RyaW5nXV0uXG4gKlxuICogIElmICUlbGVuZ3RoJSUgaXMgYGB0cnVlYGAgb3IgYSAvL251bWJlci8vLCBpdCBhbHNvIGNoZWNrcyB0aGF0XG4gKiAgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVsZW5ndGglJSAoaWYgYSAvL251bWJlci8vKVxuICogIGJ5dGVzIG9mIGRhdGEgKGUuZy4gYGAweDEyMzRgYCBpcyAyIGJ5dGVzKS5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGxlbmd0aCkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggPT09IHRydWUgJiYgKHZhbHVlLmxlbmd0aCAlIDIpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSV2YWx1ZSUlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYXJiaXRyYXJ5XG4gKiAgZGF0YSAoaS5lLiBhIHZhbGlkIFtbRGF0YUhleFN0cmluZ11dIG9yIGEgVWludDhBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0hleFN0cmluZyh2YWx1ZSwgdHJ1ZSkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpO1xufVxuZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGlzQnl0ZXNMaWtlO1xuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIHJlcHJlc2VudGF0aW9uIG9mICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBoZXhsaWZ5KGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldEJ5dGVzKGRhdGEpO1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gYnl0ZXNbaV07XG4gICAgICAgIHJlc3VsdCArPSBIZXhDaGFyYWN0ZXJzWyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhDaGFyYWN0ZXJzW3YgJiAweDBmXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuaGV4bGlmeSA9IGhleGxpZnk7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tEYXRhSGV4U3RyaW5nXV0gYnkgY29uY2F0ZW5hdGluZyBhbGwgdmFsdWVzXG4gKiAgd2l0aGluICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBjb25jYXQoZGF0YXMpIHtcbiAgICByZXR1cm4gXCIweFwiICsgZGF0YXMubWFwKChkKSA9PiBoZXhsaWZ5KGQpLnN1YnN0cmluZygyKSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLCBpbiBieXRlcy5cbiAqL1xuZnVuY3Rpb24gZGF0YUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBnZXRCeXRlcyhkYXRhKS5sZW5ndGg7XG59XG5leHBvcnRzLmRhdGFMZW5ndGggPSBkYXRhTGVuZ3RoO1xuLyoqXG4gKiAgUmV0dXJucyBhIFtbRGF0YUhleFN0cmluZ11dIGJ5IHNsaWNpbmcgJSVkYXRhJSUgZnJvbSB0aGUgJSVzdGFydCUlXG4gKiAgb2Zmc2V0IHRvIHRoZSAlJWVuZCUlIG9mZnNldC5cbiAqXG4gKiAgQnkgZGVmYXVsdCAlJXN0YXJ0JSUgaXMgMCBhbmQgJSVlbmQlJSBpcyB0aGUgbGVuZ3RoIG9mICUlZGF0YSUlLlxuICovXG5mdW5jdGlvbiBkYXRhU2xpY2UoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGVuZCAhPSBudWxsICYmIGVuZCA+IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShmYWxzZSwgXCJjYW5ub3Qgc2xpY2UgYmV5b25kIGRhdGEgYm91bmRzXCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBieXRlcywgbGVuZ3RoOiBieXRlcy5sZW5ndGgsIG9mZnNldDogZW5kXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcy5zbGljZSgoc3RhcnQgPT0gbnVsbCkgPyAwIDogc3RhcnQsIChlbmQgPT0gbnVsbCkgPyBieXRlcy5sZW5ndGggOiBlbmQpKTtcbn1cbmV4cG9ydHMuZGF0YVNsaWNlID0gZGF0YVNsaWNlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSByZXN1bHQgYnkgc3RyaXBwaW5nIGFsbCAqKmxlYWRpbmcqKlxuICoqIHplcm8gYnl0ZXMgZnJvbSAlJWRhdGElJS5cbiAqL1xuZnVuY3Rpb24gc3RyaXBaZXJvc0xlZnQoZGF0YSkge1xuICAgIGxldCBieXRlcyA9IGhleGxpZnkoZGF0YSkuc3Vic3RyaW5nKDIpO1xuICAgIHdoaWxlIChieXRlcy5zdGFydHNXaXRoKFwiMDBcIikpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBieXRlcztcbn1cbmV4cG9ydHMuc3RyaXBaZXJvc0xlZnQgPSBzdHJpcFplcm9zTGVmdDtcbmZ1bmN0aW9uIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCBsZWZ0KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShsZW5ndGggPj0gYnl0ZXMubGVuZ3RoLCBcInBhZGRpbmcgZXhjZWVkcyBkYXRhIGxlbmd0aFwiLCBcIkJVRkZFUl9PVkVSUlVOXCIsIHtcbiAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShieXRlcyksXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IGxlbmd0aCArIDFcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5maWxsKDApO1xuICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIGxlbmd0aCAtIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuc2V0KGJ5dGVzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbi8qKlxuICogIFJldHVybiB0aGUgW1tEYXRhSGV4U3RyaW5nXV0gb2YgJSVkYXRhJSUgcGFkZGVkIG9uIHRoZSAqKmxlZnQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqdmFsdWVzKiogYXJlIGluIFNvbGlkaXR5XG4gKiAgKGUuZy4gYGB1aW50MTI4YGApLlxuICovXG5mdW5jdGlvbiB6ZXJvUGFkVmFsdWUoZGF0YSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHplcm9QYWQoZGF0YSwgbGVuZ3RoLCB0cnVlKTtcbn1cbmV4cG9ydHMuemVyb1BhZFZhbHVlID0gemVyb1BhZFZhbHVlO1xuLyoqXG4gKiAgUmV0dXJuIHRoZSBbW0RhdGFIZXhTdHJpbmddXSBvZiAlJWRhdGElJSBwYWRkZWQgb24gdGhlICoqcmlnaHQqKlxuICogIHRvICUlbGVuZ3RoJSUgYnl0ZXMuXG4gKlxuICogIElmICUlZGF0YSUlIGFscmVhZHkgZXhjZWVkcyAlJWxlbmd0aCUlLCBhIFtbQnVmZmVyT3ZlcnJ1bkVycm9yXV0gaXNcbiAqICB0aHJvd24uXG4gKlxuICogIFRoaXMgcGFkcyBkYXRhIHRoZSBzYW1lIGFzICoqYnl0ZXMqKiBhcmUgaW4gU29saWRpdHlcbiAqICAoZS5nLiBgYGJ5dGVzMTZgYCkuXG4gKi9cbmZ1bmN0aW9uIHplcm9QYWRCeXRlcyhkYXRhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gemVyb1BhZChkYXRhLCBsZW5ndGgsIGZhbHNlKTtcbn1cbmV4cG9ydHMuemVyb1BhZEJ5dGVzID0gemVyb1BhZEJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ6ZXJvUGFkQnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJzdHJpcFplcm9zTGVmdCIsImRhdGFTbGljZSIsImRhdGFMZW5ndGgiLCJjb25jYXQiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJpc0hleFN0cmluZyIsImdldEJ5dGVzQ29weSIsImdldEJ5dGVzIiwiZXJyb3JzX2pzXzEiLCJyZXF1aXJlIiwiX2dldEJ5dGVzIiwibmFtZSIsImNvcHkiLCJVaW50OEFycmF5IiwibWF0Y2giLCJyZXN1bHQiLCJsZW5ndGgiLCJvZmZzZXQiLCJpIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJhc3NlcnRBcmd1bWVudCIsIkhleENoYXJhY3RlcnMiLCJkYXRhIiwiYnl0ZXMiLCJ2IiwiZGF0YXMiLCJtYXAiLCJkIiwiam9pbiIsInN0YXJ0IiwiZW5kIiwiYXNzZXJ0IiwiYnVmZmVyIiwic2xpY2UiLCJzdGFydHNXaXRoIiwiemVyb1BhZCIsImxlZnQiLCJmaWxsIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;\nconst _version_js_1 = __webpack_require__(/*! ../_version.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/_version.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + value.map(stringify).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch(typeof value){\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return value.toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\":\n            {\n                const keys = Object.keys(value);\n                keys.sort();\n                return \"{ \" + keys.map((k)=>`${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n            }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript envornoments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */ function isError(error, code) {\n    return error && error.code === code;\n}\nexports.isError = isError;\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */ function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\nexports.isCallException = isCallException;\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additioanl properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depneding on %%code%%, additional\n *  required properties. The error message will also include the %%meeage%%,\n *  ethers version, %%code%% and all aditional properties, serialized.\n */ function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for(const key in info){\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = info[key];\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n            //                } catch (error: any) {\n            //                console.log(\"MMM\", error.message);\n            //                    details.push(key + \"=[could not serialize object]\");\n            //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${_version_js_1.version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch(code){\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    (0, properties_js_1.defineProperties)(error, {\n        code\n    });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        (0, properties_js_1.defineProperties)(error, {\n            shortMessage\n        });\n    }\n    return error;\n}\nexports.makeError = makeError;\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */ function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\nexports.assert = assert;\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */ function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", {\n        argument: name,\n        value: value\n    });\n}\nexports.assertArgument = assertArgument;\nfunction assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguemnts\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nexports.assertArgumentCount = assertArgumentCount;\nconst _normalizeForms = [\n    \"NFD\",\n    \"NFC\",\n    \"NFKD\",\n    \"NFKC\"\n].reduce((accum, form)=>{\n    try {\n        // General test for normalize\n        /* c8 ignore start */ if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */ if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */ if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n        /* c8 ignore stop */ }\n        accum.push(form);\n    } catch (error) {}\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */ function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\",\n        info: {\n            form\n        }\n    });\n}\nexports.assertNormalize = assertNormalize;\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */ function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\nexports.assertPrivate = assertPrivate; //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Q0FRQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLHVCQUF1QixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLGNBQWMsR0FBR0EsaUJBQWlCLEdBQUdBLHVCQUF1QixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUMvTCxNQUFNVSxnQkFBZ0JDLG1CQUFPQSxDQUFDLDRFQUFnQjtBQUM5QyxNQUFNQyxrQkFBa0JELG1CQUFPQSxDQUFDLHFGQUFpQjtBQUNqRCxTQUFTRSxVQUFVWixLQUFLO0lBQ3BCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUlhLE1BQU1DLE9BQU8sQ0FBQ2QsUUFBUTtRQUN0QixPQUFPLE9BQU8sTUFBT2UsR0FBRyxDQUFDSCxXQUFZSSxJQUFJLENBQUMsUUFBUTtJQUN0RDtJQUNBLElBQUloQixpQkFBaUJpQixZQUFZO1FBQzdCLE1BQU1DLE1BQU07UUFDWixJQUFJQyxTQUFTO1FBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlwQixNQUFNcUIsTUFBTSxFQUFFRCxJQUFLO1lBQ25DRCxVQUFVRCxHQUFHLENBQUNsQixLQUFLLENBQUNvQixFQUFFLElBQUksRUFBRTtZQUM1QkQsVUFBVUQsR0FBRyxDQUFDbEIsS0FBSyxDQUFDb0IsRUFBRSxHQUFHLElBQUk7UUFDakM7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsSUFBSSxPQUFRbkIsVUFBVyxZQUFZLE9BQVFBLE1BQU1zQixNQUFNLEtBQU0sWUFBWTtRQUNyRSxPQUFPVixVQUFVWixNQUFNc0IsTUFBTTtJQUNqQztJQUNBLE9BQVEsT0FBUXRCO1FBQ1osS0FBSztRQUNMLEtBQUs7WUFDRCxPQUFPQSxNQUFNdUIsUUFBUTtRQUN6QixLQUFLO1lB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Q3pCOUMsT0FBTzJDLGdCQUFnQlEsT0FBTyxDQUFDTCxTQUFTLEdBQUcsK0NBQStDLHlCQUF5QjtRQUMvR00sV0FBVztRQUE4QnpCLE1BQU07WUFBRW1CO1FBQUs7SUFDMUQ7QUFDSjtBQUNBcEQsdUJBQXVCLEdBQUdHO0FBQzFCOzs7OztDQUtDLEdBQ0QsU0FBU0QsY0FBY3lELFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxTQUFTO0lBQy9DLElBQUlBLGFBQWEsTUFBTTtRQUNuQkEsWUFBWTtJQUNoQjtJQUNBLElBQUlGLGVBQWVDLE9BQU87UUFDdEIsSUFBSUUsU0FBU0QsV0FBV0gsWUFBWTtRQUNwQyxJQUFJRyxXQUFXO1lBQ1hDLFVBQVU7WUFDVkosYUFBYSxNQUFNRztRQUN2QjtRQUNBdkQsT0FBTyxPQUFPLENBQUMseUJBQXlCLEVBQUV3RCxPQUFPLGFBQWEsQ0FBQyxFQUFFLHlCQUF5QjtZQUN0Rko7UUFDSjtJQUNKO0FBQ0o7QUFDQTFELHFCQUFxQixHQUFHRSxlQUN4QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9lcnJvcnMuanM/NzBmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEFsbCBlcnJvcnMgaW4gZXRoZXJzIGluY2x1ZGUgcHJvcGVydGllcyB0byBlbnN1cmUgdGhleSBhcmUgYm90aFxuICogIGh1bWFuLXJlYWRhYmxlIChpLmUuIGBgLm1lc3NhZ2VgYCkgYW5kIG1hY2hpbmUtcmVhZGFibGUgKGkuZS4gYGAuY29kZWBgKS5cbiAqXG4gKiAgVGhlIFtbaXNFcnJvcl1dIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHRoZSBlcnJvciBgYGNvZGVgYCBhbmRcbiAqICBwcm92aWRlIGEgdHlwZSBndWFyZCBmb3IgdGhlIHByb3BlcnRpZXMgcHJlc2VudCBvbiB0aGF0IGVycm9yIGludGVyZmFjZS5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZXJyb3JzOkVycm9ycyAgW2Fib3V0LWVycm9yc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gZXhwb3J0cy5hc3NlcnROb3JtYWxpemUgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50Q291bnQgPSBleHBvcnRzLmFzc2VydEFyZ3VtZW50ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLm1ha2VFcnJvciA9IGV4cG9ydHMuaXNDYWxsRXhjZXB0aW9uID0gZXhwb3J0cy5pc0Vycm9yID0gdm9pZCAwO1xuY29uc3QgX3ZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9fdmVyc2lvbi5qc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJbIFwiICsgKHZhbHVlLm1hcChzdHJpbmdpZnkpKS5qb2luKFwiLCBcIikgKyBcIiBdXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gSEVYW3ZhbHVlW2ldICYgMHhmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mICh2YWx1ZS50b0pTT04pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWx1ZS50b0pTT04oKSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIFwieyBcIiArIGtleXMubWFwKChrKSA9PiBgJHtzdHJpbmdpZnkoayl9OiAke3N0cmluZ2lmeSh2YWx1ZVtrXSl9YCkuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgWyBDT1VMRCBOT1QgU0VSSUFMSVpFIF1gO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmIHRoZSAlJWVycm9yJSUgbWF0Y2hlcyBhbiBlcnJvciB0aHJvd24gYnkgZXRoZXJzXG4gKiAgdGhhdCBtYXRjaGVzIHRoZSBlcnJvciAlJWNvZGUlJS5cbiAqXG4gKiAgSW4gVHlwZVNjcmlwdCBlbnZvcm5vbWVudHMsIHRoaXMgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhhdCAlJWVycm9yJSVcbiAqICBtYXRjaGVzIGFuIEV0aGVyc0Vycm9yIHR5cGUsIHdoaWNoIG1lYW5zIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAqICBiZSBzZXQuXG4gKlxuICogIEBTZWUgW0Vycm9yQ29kZXNdKGFwaTpFcnJvckNvZGUpXG4gKiAgQGV4YW1wbGVcbiAqICAgIHRyeSB7XG4gKiAgICAgIC8vIGNvZGUuLi4uXG4gKiAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgIGlmIChpc0Vycm9yKGUsIFwiQ0FMTF9FWENFUFRJT05cIikpIHtcbiAqICAgICAgICAgIC8vIFRoZSBUeXBlIEd1YXJkIGhhcyB2YWxpZGF0ZWQgdGhpcyBvYmplY3RcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gKiAgICAgIH1cbiAqICAgIH1cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvciwgY29kZSkge1xuICAgIHJldHVybiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gY29kZSk7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuLyoqXG4gKiAgUmV0dXJucyB0cnVlIGlmICUlZXJyb3IlJSBpcyBhIFtbQ2FsbEV4Y2VwdGlvbkVycm9yXS5cbiAqL1xuZnVuY3Rpb24gaXNDYWxsRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZXJyb3IsIFwiQ0FMTF9FWENFUFRJT05cIik7XG59XG5leHBvcnRzLmlzQ2FsbEV4Y2VwdGlvbiA9IGlzQ2FsbEV4Y2VwdGlvbjtcbi8qKlxuICogIFJldHVybnMgYSBuZXcgRXJyb3IgY29uZmlndXJlZCB0byB0aGUgZm9ybWF0IGV0aGVycyBlbWl0cyBlcnJvcnMsIHdpdGhcbiAqICB0aGUgJSVtZXNzYWdlJSUsIFtbYXBpOkVycm9yQ29kZV1dICUlY29kZSUlIGFuZCBhZGRpdGlvYW5sIHByb3BlcnRpZXNcbiAqICBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgRXRoZXJzRXJyb3IuXG4gKlxuICogIEVhY2ggZXJyb3IgaW4gZXRoZXJzIGluY2x1ZGVzIHRoZSB2ZXJzaW9uIG9mIGV0aGVycywgYVxuICogIG1hY2hpbmUtcmVhZGFibGUgW1tFcnJvckNvZGVdXSwgYW5kIGRlcG5lZGluZyBvbiAlJWNvZGUlJSwgYWRkaXRpb25hbFxuICogIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSBlcnJvciBtZXNzYWdlIHdpbGwgYWxzbyBpbmNsdWRlIHRoZSAlJW1lZWFnZSUlLFxuICogIGV0aGVycyB2ZXJzaW9uLCAlJWNvZGUlJSBhbmQgYWxsIGFkaXRpb25hbCBwcm9wZXJ0aWVzLCBzZXJpYWxpemVkLlxuICovXG5mdW5jdGlvbiBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbykge1xuICAgIGxldCBzaG9ydE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKFwibWVzc2FnZVwiIGluIGluZm8gfHwgXCJjb2RlXCIgaW4gaW5mbyB8fCBcIm5hbWVcIiBpbiBpbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBwb3B1bGF0ZWQgdmFsdWVzOiAke3N0cmluZ2lmeShpbmZvKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcInNob3J0TWVzc2FnZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmZvW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTU1NXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLnB1c2goa2V5ICsgXCI9W2NvdWxkIG5vdCBzZXJpYWxpemUgb2JqZWN0XVwiKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgZGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7X3ZlcnNpb25fanNfMS52ZXJzaW9ufWApO1xuICAgICAgICBpZiAoZGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgZGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZXJyb3I7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJTlZBTElEX0FSR1VNRU5UXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk5VTUVSSUNfRkFVTFRcIjpcbiAgICAgICAgY2FzZSBcIkJVRkZFUl9PVkVSUlVOXCI6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKShlcnJvciwgeyBjb2RlIH0pO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc2hvcnRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgKDAsIHByb3BlcnRpZXNfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKShlcnJvciwgeyBzaG9ydE1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydHMubWFrZUVycm9yID0gbWFrZUVycm9yO1xuLyoqXG4gKiAgVGhyb3dzIGFuIEV0aGVyc0Vycm9yIHdpdGggJSVtZXNzYWdlJSUsICUlY29kZSUlIGFuZCBhZGRpdGlvbmFsIGVycm9yXG4gKiAgJSVpbmZvJSUgd2hlbiAlJWNoZWNrJSUgaXMgZmFsc2lzaC4uXG4gKlxuICogIEBzZWUgW1thcGk6bWFrZUVycm9yXV1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBjb2RlLCBpbmZvKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgaW5mbyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqICBBIHNpbXBsZSBoZWxwZXIgdG8gc2ltcGx5IGVuc3VyaW5nIHByb3ZpZGVkIGFyZ3VtZW50cyBtYXRjaCBleHBlY3RlZFxuICogIGNvbnN0cmFpbnRzLCB0aHJvd2luZyBpZiBub3QuXG4gKlxuICogIEluIFR5cGVTY3JpcHQgZW52aXJvbm1lbnRzLCB0aGUgJSVjaGVjayUlIGhhcyBiZWVuIGFzc2VydGVkIHRydWUsIHNvXG4gKiAgYW55IGZ1cnRoZXIgY29kZSBkb2VzIG5vdCBuZWVkIGFkZGl0aW9uYWwgY29tcGlsZS10aW1lIGNoZWNrcy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnQoY2hlY2ssIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0KGNoZWNrLCBtZXNzYWdlLCBcIklOVkFMSURfQVJHVU1FTlRcIiwgeyBhcmd1bWVudDogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuZXhwb3J0cy5hc3NlcnRBcmd1bWVudCA9IGFzc2VydEFyZ3VtZW50O1xuZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3NlcnQoY291bnQgPj0gZXhwZWN0ZWRDb3VudCwgXCJtaXNzaW5nIGFyZ3VlbW50XCIgKyBtZXNzYWdlLCBcIk1JU1NJTkdfQVJHVU1FTlRcIiwge1xuICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICB9KTtcbiAgICBhc3NlcnQoY291bnQgPD0gZXhwZWN0ZWRDb3VudCwgXCJ0b28gbWFueSBhcmd1ZW1udHNcIiArIG1lc3NhZ2UsIFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiLCB7XG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgIH0pO1xufVxuZXhwb3J0cy5hc3NlcnRBcmd1bWVudENvdW50ID0gYXNzZXJ0QXJndW1lbnRDb3VudDtcbmNvbnN0IF9ub3JtYWxpemVGb3JtcyA9IFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLnJlZHVjZSgoYWNjdW0sIGZvcm0pID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZW5lcmFsIHRlc3QgZm9yIG5vcm1hbGl6ZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGlmIChmb3JtID09PSBcIk5GRFwiKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmIChjaGVjayAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtLnB1c2goZm9ybSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGFjY3VtO1xufSwgW10pO1xuLyoqXG4gKiAgVGhyb3dzIGlmIHRoZSBub3JtYWxpemF0aW9uICUlZm9ybSUlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vcm1hbGl6ZShmb3JtKSB7XG4gICAgYXNzZXJ0KF9ub3JtYWxpemVGb3Jtcy5pbmRleE9mKGZvcm0pID49IDAsIFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBpbmZvOiB7IGZvcm0gfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hc3NlcnROb3JtYWxpemUgPSBhc3NlcnROb3JtYWxpemU7XG4vKipcbiAqICBNYW55IGNsYXNzZXMgdXNlIGZpbGUtc2NvcGVkIHZhbHVlcyB0byBndWFyZCB0aGUgY29uc3RydWN0b3IsXG4gKiAgbWFraW5nIGl0IGVmZmVjdGl2ZWx5IHByaXZhdGUuIFRoaXMgZmFjaWxpdGF0ZXMgdGhhdCBwYXR0ZXJuXG4gKiAgYnkgZW5zdXJpbmcgdGhlICUlZ2l2ZW5HYXVyZCUlIG1hdGNoZXMgdGhlIGZpbGUtc2NvcGVkICUlZ3VhcmQlJSxcbiAqICB0aHJvd2luZyBpZiBub3QsIGluZGljYXRpbmcgdGhlICUlY2xhc3NOYW1lJSUgaWYgcHJvdmlkZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByaXZhdGUoZ2l2ZW5HdWFyZCwgZ3VhcmQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUgPT0gbnVsbCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAoZ2l2ZW5HdWFyZCAhPT0gZ3VhcmQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGNsYXNzTmFtZSwgb3BlcmF0aW9uID0gXCJuZXdcIjtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgbWV0aG9kICs9IFwiLlwiO1xuICAgICAgICAgICAgb3BlcmF0aW9uICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydChmYWxzZSwgYHByaXZhdGUgY29uc3RydWN0b3I7IHVzZSAke21ldGhvZH1mcm9tKiBtZXRob2RzYCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGFzc2VydFByaXZhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0UHJpdmF0ZSIsImFzc2VydE5vcm1hbGl6ZSIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydCIsIm1ha2VFcnJvciIsImlzQ2FsbEV4Y2VwdGlvbiIsImlzRXJyb3IiLCJfdmVyc2lvbl9qc18xIiwicmVxdWlyZSIsInByb3BlcnRpZXNfanNfMSIsInN0cmluZ2lmeSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImpvaW4iLCJVaW50OEFycmF5IiwiSEVYIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInRvSlNPTiIsInRvU3RyaW5nIiwiQmlnSW50IiwiSlNPTiIsImtleXMiLCJzb3J0IiwiayIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJpbmZvIiwic2hvcnRNZXNzYWdlIiwiZGV0YWlscyIsIkVycm9yIiwia2V5IiwicHVzaCIsInZlcnNpb24iLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2lnbiIsImNoZWNrIiwibmFtZSIsImFyZ3VtZW50IiwiY291bnQiLCJleHBlY3RlZENvdW50IiwiX25vcm1hbGl6ZUZvcm1zIiwicmVkdWNlIiwiYWNjdW0iLCJmb3JtIiwibm9ybWFsaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwZWN0ZWQiLCJpbmRleE9mIiwib3BlcmF0aW9uIiwiZ2l2ZW5HdWFyZCIsImd1YXJkIiwiY2xhc3NOYW1lIiwibWV0aG9kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EventPayload = void 0;\n/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */ const properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */ class EventPayload {\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */ constructor(emitter, listener, filter){\n        this.#listener = listener;\n        (0, properties_js_1.defineProperties)(this, {\n            emitter,\n            filter\n        });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */ async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\nexports.EventPayload = EventPayload; //# sourceMappingURL=events.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ldmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHLEtBQUs7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxxRkFBaUI7QUFDakQ7Ozs7Q0FJQyxHQUNELE1BQU1GO0lBU0YsQ0FBQ0csUUFBUSxDQUFDO0lBQ1Y7OztLQUdDLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUYsUUFBUSxFQUFFRyxNQUFNLENBQUU7UUFDbkMsSUFBSSxDQUFDLENBQUNILFFBQVEsR0FBR0E7UUFDaEIsSUFBR0YsZ0JBQWdCTSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRUY7WUFBU0M7UUFBTztJQUNsRTtJQUNBOztLQUVDLEdBQ0QsTUFBTUUsaUJBQWlCO1FBQ25CLElBQUksSUFBSSxDQUFDLENBQUNMLFFBQVEsSUFBSSxNQUFNO1lBQ3hCO1FBQ0o7UUFDQSxNQUFNLElBQUksQ0FBQ0UsT0FBTyxDQUFDSSxHQUFHLENBQUMsSUFBSSxDQUFDSCxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUNILFFBQVE7SUFDdEQ7QUFDSjtBQUNBTCxvQkFBb0IsR0FBR0UsY0FDdkIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvZXZlbnRzLmpzPzliMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50UGF5bG9hZCA9IHZvaWQgMDtcbi8qKlxuICogIEV2ZW50cyBhbGxvdyBmb3IgYXBwbGljYXRpb25zIHRvIHVzZSB0aGUgb2JzZXJ2ZXIgcGF0dGVybiwgd2hpY2hcbiAqICBhbGxvd3Mgc3Vic2NyaWJpbmcgYW5kIHB1Ymxpc2hpbmcgZXZlbnRzLCBvdXRzaWRlIHRoZSBub3JtYWxcbiAqICBleGVjdXRpb24gcGF0aHMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZXZlbnRzOkV2ZW50cyAgW2Fib3V0LWV2ZW50c11cbiAqL1xuY29uc3QgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbi8qKlxuICogIFdoZW4gYW4gW1tFdmVudEVtaXR0ZXJhYmxlXV0gdHJpZ2dlcnMgYSBbW0xpc3RlbmVyXV0sIHRoZVxuICogIGNhbGxiYWNrIGFsd2F5cyBhaGFzIG9uZSBhZGRpdGlvbmFsIGFyZ3VtZW50IHBhc3NlZCwgd2hpY2ggaXNcbiAqICBhbiAqKkV2ZW50UGF5bG9hZCoqLlxuICovXG5jbGFzcyBFdmVudFBheWxvYWQge1xuICAgIC8qKlxuICAgICAqICBUaGUgZXZlbnQgZmlsdGVyLlxuICAgICAqL1xuICAgIGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiAgVGhlICoqRXZlbnRFbWl0dGVyYWJsZSoqLlxuICAgICAqL1xuICAgIGVtaXR0ZXI7XG4gICAgI2xpc3RlbmVyO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipFdmVudFBheWxvYWQqKiBmb3IgJSVlbWl0dGVyJSUgd2l0aFxuICAgICAqICB0aGUgJSVsaXN0ZW5lciUlIGFuZCBmb3IgJSVmaWx0ZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyLCBsaXN0ZW5lciwgZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBlbWl0dGVyLCBmaWx0ZXIgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVbnJlZ2lzdGVyIHRoZSB0cmlnZ2VyZWQgbGlzdGVuZXIgZm9yIGZ1dHVyZSBldmVudHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmZpbHRlciwgdGhpcy4jbGlzdGVuZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRQYXlsb2FkID0gRXZlbnRQYXlsb2FkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkV2ZW50UGF5bG9hZCIsInByb3BlcnRpZXNfanNfMSIsInJlcXVpcmUiLCJsaXN0ZW5lciIsImNvbnN0cnVjdG9yIiwiZW1pdHRlciIsImZpbHRlciIsImRlZmluZVByb3BlcnRpZXMiLCJyZW1vdmVMaXN0ZW5lciIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;\n/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction the each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retreive the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentcation, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */ const base64_js_1 = __webpack_require__(/*! ./base64.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/base64.js\");\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst utf8_js_1 = __webpack_require__(/*! ./utf8.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nconst geturl_js_1 = __webpack_require__(/*! ./geturl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/geturl.js\");\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\");\n// If locked, new Gateways cannot be added\nlet locked = false;\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url, signal) {\n    try {\n        const match = url.match(reData);\n        if (!match) {\n            throw new Error(\"invalid data\");\n        }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": match[1] || \"text/plain\"\n        }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3]));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", {}, null, new FetchRequest(url));\n    }\n}\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */ function getIpfsGatewayFunc(baseUrl) {\n    async function gatewayIpfs(url, signal) {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) {\n                throw new Error(\"invalid link\");\n            }\n            return new FetchRequest(`${baseUrl}${match[2]}`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", {}, null, new FetchRequest(url));\n        }\n    }\n    return gatewayIpfs;\n}\nconst Gateways = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\")\n};\nconst fetchSignals = new WeakMap();\n/**\n *  @_ignore\n */ class FetchCancelSignal {\n    #listeners;\n    #cancelled;\n    constructor(request){\n        this.#listeners = [];\n        this.#cancelled = false;\n        fetchSignals.set(request, ()=>{\n            if (this.#cancelled) {\n                return;\n            }\n            this.#cancelled = true;\n            for (const listener of this.#listeners){\n                setTimeout(()=>{\n                    listener();\n                }, 0);\n            }\n            this.#listeners = [];\n        });\n    }\n    addListener(listener) {\n        (0, errors_js_1.assert)(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n    get cancelled() {\n        return this.#cancelled;\n    }\n    checkSignal() {\n        (0, errors_js_1.assert)(!this.cancelled, \"cancelled\", \"CANCELLED\", {});\n    }\n}\nexports.FetchCancelSignal = FetchCancelSignal;\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal) {\n    if (signal == null) {\n        throw new Error(\"missing signal; should not happen\");\n    }\n    signal.checkSignal();\n    return signal;\n}\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */ class FetchRequest {\n    #allowInsecure;\n    #gzip;\n    #headers;\n    #method;\n    #timeout;\n    #url;\n    #body;\n    #bodyType;\n    #creds;\n    // Hooks\n    #preflight;\n    #process;\n    #retry;\n    #signal;\n    #throttle;\n    #getUrlFunc;\n    /**\n     *  The fetch URI to requrest.\n     */ get url() {\n        return this.#url;\n    }\n    set url(url) {\n        this.#url = String(url);\n    }\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``) and the .\n     *\n     *  If %%body%% is a string, the intrincis ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrincis ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrincis ``Content-Type`` is\n     *  set to ``application/json``.\n     */ get body() {\n        if (this.#body == null) {\n            return null;\n        }\n        return new Uint8Array(this.#body);\n    }\n    set body(body) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof body === \"string\") {\n            this.#body = (0, utf8_js_1.toUtf8Bytes)(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof body === \"object\") {\n            this.#body = (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n    /**\n     *  Returns true if the request has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */ get method() {\n        if (this.#method) {\n            return this.#method;\n        }\n        if (this.hasBody()) {\n            return \"POST\";\n        }\n        return \"GET\";\n    }\n    set method(method) {\n        if (method == null) {\n            method = \"\";\n        }\n        this.#method = String(method).toUpperCase();\n    }\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any chnages will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */ get headers() {\n        const headers = Object.assign({}, this.#headers);\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${(0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(this.#creds))}`;\n        }\n        ;\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) {\n            headers[\"content-length\"] = String(this.body.length);\n        }\n        return headers;\n    }\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */ setHeader(key, value) {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */ clearHeaders() {\n        this.#headers = {};\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */ get credentials() {\n        return this.#creds || null;\n    }\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */ setCredentials(username, password) {\n        (0, errors_js_1.assertArgument)(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${username}:${password}`;\n    }\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */ get allowGzip() {\n        return this.#gzip;\n    }\n    set allowGzip(value) {\n        this.#gzip = !!value;\n    }\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */ get allowInsecureAuthentication() {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value) {\n        this.#allowInsecure = !!value;\n    }\n    /**\n     *  The timeout (in milliseconds) to wait for a complere response.\n     *  //(default: 5 minutes)//\n     */ get timeout() {\n        return this.#timeout;\n    }\n    set timeout(timeout) {\n        (0, errors_js_1.assertArgument)(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */ get preflightFunc() {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight) {\n        this.#preflight = preflight;\n    }\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */ get processFunc() {\n        return this.#process || null;\n    }\n    set processFunc(process) {\n        this.#process = process;\n    }\n    /**\n     *  This function is called on each retry attempt.\n     */ get retryFunc() {\n        return this.#retry || null;\n    }\n    set retryFunc(retry) {\n        this.#retry = retry;\n    }\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */ get getUrlFunc() {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value) {\n        this.#getUrlFunc = value;\n    }\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */ constructor(url){\n        this.#url = String(url);\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = {};\n        this.#method = \"\";\n        this.#timeout = 300000;\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n        this.#getUrlFunc = null;\n    }\n    toString() {\n        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */ setThrottleParams(params) {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n    async #send(attempt, expires, delay, _request, _response) {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n        (0, errors_js_1.assert)(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\",\n            reason: \"timeout\",\n            request: _request\n        });\n        if (delay > 0) {\n            await wait(delay);\n        }\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error) {\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof error.stall !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n                    // Ignore throttling\n                    }\n                }\n                return response;\n            }\n            req = result;\n        }\n        // We have a preflight function; update the request\n        if (this.preflightFunc) {\n            req = await this.preflightFunc(req);\n        }\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n        if (response.statusCode === 301 || response.statusCode === 302) {\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) {}\n            // Things won't get any better on another attempt; abort\n            return response;\n        } else if (response.statusCode === 429) {\n            // Throttle\n            if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error) {\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof error.stall !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                ;\n                if (error.stall >= 0) {\n                    delay = error.stall;\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n        return response;\n    }\n    /**\n     *  Resolves to the response by sending the request.\n     */ send() {\n        (0, errors_js_1.assert)(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.send\"\n        });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", {}, null, this));\n    }\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */ cancel() {\n        (0, errors_js_1.assert)(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchRequest.cancel\"\n        });\n        const signal = fetchSignals.get(this);\n        if (!signal) {\n            throw new Error(\"missing signal; should not happen\");\n        }\n        signal();\n    }\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */ redirect(location) {\n        // Redirection; for now we only support absolute locataions\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        (0, errors_js_1.assert)(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`\n        });\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({}, this.#headers);\n        if (this.#body) {\n            req.#body = new Uint8Array(this.#body);\n        }\n        req.#bodyType = this.#bodyType;\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n        return req;\n    }\n    /**\n     *  Create a new copy of this request.\n     */ clone() {\n        const clone = new FetchRequest(this.url);\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) {\n            clone.#body = this.#body;\n        }\n        clone.#bodyType = this.#bodyType;\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({}, this.#headers);\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n        if (this.allowGzip) {\n            clone.allowGzip = true;\n        }\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) {\n            clone.allowInsecureAuthentication = true;\n        }\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n        clone.#getUrlFunc = this.#getUrlFunc;\n        return clone;\n    }\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */ static lockConfig() {\n        locked = true;\n    }\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */ static getGateway(scheme) {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGateway(scheme, func) {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);\n        }\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        Gateways[scheme] = func;\n    }\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */ static registerGetUrl(getUrl) {\n        if (locked) {\n            throw new Error(\"gateways locked\");\n        }\n        defaultGetUrlFunc = getUrl;\n    }\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */ static createGetUrlFunc(options) {\n        return (0, geturl_js_1.createGetUrl)(options);\n    }\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */ static createDataGateway() {\n        return dataGatewayFunc;\n    }\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */ static createIpfsGatewayFunc(baseUrl) {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\nexports.FetchRequest = FetchRequest;\n;\n/**\n *  The response for a FetchREquest.\n */ class FetchResponse {\n    #statusCode;\n    #statusMessage;\n    #headers;\n    #body;\n    #request;\n    #error;\n    toString() {\n        return `<FetchResponse status=${this.statusCode} body=${this.#body ? (0, data_js_1.hexlify)(this.#body) : \"null\"}>`;\n    }\n    /**\n     *  The response status code.\n     */ get statusCode() {\n        return this.#statusCode;\n    }\n    /**\n     *  The response status message.\n     */ get statusMessage() {\n        return this.#statusMessage;\n    }\n    /**\n     *  The response headers. All keys are lower-case.\n     */ get headers() {\n        return Object.assign({}, this.#headers);\n    }\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */ get body() {\n        return this.#body == null ? null : new Uint8Array(this.#body);\n    }\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */ get bodyText() {\n        try {\n            return this.#body == null ? \"\" : (0, utf8_js_1.toUtf8String)(this.#body);\n        } catch (error) {\n            (0, errors_js_1.assert)(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */ get bodyJson() {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            (0, errors_js_1.assert)(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\",\n                info: {\n                    response: this\n                }\n            });\n        }\n    }\n    [Symbol.iterator]() {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: ()=>{\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [\n                            key,\n                            headers[key]\n                        ],\n                        done: false\n                    };\n                }\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    constructor(statusCode, statusMessage, headers, body, request){\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k)=>{\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, {});\n        this.#body = body == null ? null : new Uint8Array(body);\n        this.#request = request || null;\n        this.#error = {\n            message: \"\"\n        };\n    }\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */ makeServerError(message, error) {\n        let statusMessage;\n        if (!message) {\n            message = `${this.statusCode} ${this.statusMessage}`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);\n        response.#error = {\n            message,\n            error\n        };\n        return response;\n    }\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */ throwThrottleError(message, stall) {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n        const error = new Error(message || \"throttling requests\");\n        (0, properties_js_1.defineProperties)(error, {\n            stall,\n            throttle: true\n        });\n        throw error;\n    }\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */ getHeader(key) {\n        return this.headers[key.toLowerCase()];\n    }\n    /**\n     *  Returns true of the response has a body.\n     */ hasBody() {\n        return this.#body != null;\n    }\n    /**\n     *  The request made for this response.\n     */ get request() {\n        return this.#request;\n    }\n    /**\n     *  Returns true if this response was a success statusCode.\n     */ ok() {\n        return this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300;\n    }\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */ assertOk() {\n        if (this.ok()) {\n            return;\n        }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${this.statusCode} ${this.statusMessage}`;\n        }\n        (0, errors_js_1.assert)(false, message, \"SERVER_ERROR\", {\n            request: this.request || \"unknown request\",\n            response: this,\n            error\n        });\n    }\n}\nexports.FetchResponse = FetchResponse;\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction unpercent(value) {\n    return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\nfunction wait(delay) {\n    return new Promise((resolve)=>setTimeout(resolve, delay));\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLG9CQUFvQixHQUFHQSx5QkFBeUIsR0FBRyxLQUFLO0FBQ2hGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxNQUFNSyxjQUFjQyxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNRyxrQkFBa0JILG1CQUFPQSxDQUFDLHFGQUFpQjtBQUNqRCxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNTSxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qiw2Q0FBNkM7QUFDN0MsSUFBSUMsb0JBQW9CLENBQUMsR0FBR0gsWUFBWUksWUFBWTtBQUNwRCxNQUFNQyxTQUFTLElBQUlDLE9BQU8sbUNBQW1DO0FBQzdELE1BQU1DLFNBQVMsSUFBSUQsT0FBTyx5QkFBMEI7QUFDcEQsMENBQTBDO0FBQzFDLElBQUlFLFNBQVM7QUFDYiw2RUFBNkU7QUFDN0UsZUFBZUMsZ0JBQWdCQyxHQUFHLEVBQUVDLE1BQU07SUFDdEMsSUFBSTtRQUNBLE1BQU1DLFFBQVFGLElBQUlFLEtBQUssQ0FBQ1A7UUFDeEIsSUFBSSxDQUFDTyxPQUFPO1lBQ1IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJdEIsY0FBYyxLQUFLLE1BQU07WUFDaEMsZ0JBQWlCcUIsS0FBSyxDQUFDLEVBQUUsSUFBSTtRQUNqQyxHQUFJQSxLQUFLLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBR2xCLFlBQVlvQixZQUFZLEVBQUVGLEtBQUssQ0FB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QUNoQyxVQUFVLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsYUFBYSxDQUFDLENBQUM7UUFDeEU7UUFDQyxJQUFHN0csWUFBWWtDLE1BQU0sRUFBRSxPQUFPMEcsU0FBUyxnQkFBZ0I7WUFDcEQvRyxTQUFVLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1lBQW9CMkUsVUFBVSxJQUFJO1lBQUVyRjtRQUNsRTtJQUNKO0FBQ0o7QUFDQTNCLHFCQUFxQixHQUFHRTtBQUN4QixTQUFTc0c7SUFBWSxPQUFPLElBQUtrRCxPQUFRbEQsT0FBTztBQUFJO0FBQ3BELFNBQVM5RSxVQUFVekIsS0FBSztJQUNwQixPQUFPLENBQUMsR0FBR1MsVUFBVW9ELFdBQVcsRUFBRTdELE1BQU0wSixPQUFPLENBQUMseUJBQXlCLENBQUNDLEtBQUtDO1FBQzNFLE9BQU9sRyxPQUFPbUcsWUFBWSxDQUFDakMsU0FBU2dDLE1BQU07SUFDOUM7QUFDSjtBQUNBLFNBQVNuRCxLQUFLTixLQUFLO0lBQ2YsT0FBTyxJQUFJMkQsUUFBUSxDQUFDQyxVQUFZeEgsV0FBV3dILFNBQVM1RDtBQUN4RCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2ZldGNoLmpzPzA2MDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZldGNoUmVzcG9uc2UgPSBleHBvcnRzLkZldGNoUmVxdWVzdCA9IGV4cG9ydHMuRmV0Y2hDYW5jZWxTaWduYWwgPSB2b2lkIDA7XG4vKipcbiAqICBGZXRjaGluZyBjb250ZW50IGZyb20gdGhlIHdlYiBpcyBlbnZpcm9ubWVudC1zcGVjaWZpYywgc28gRXRoZXJzXG4gKiAgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gdGhlIGVhY2ggZW52aXJvbm1lbnQgY2FuIGltcGxlbWVudCB0byBwcm92aWRlXG4gKiAgdGhpcyBzZXJ2aWNlLlxuICpcbiAqICBPbiBbTm9kZS5qc10obGluay1ub2RlKSwgdGhlIGBgaHR0cGBgIGFuZCBgYGh0dHBzYGAgbGlicyBhcmUgdXNlZCB0b1xuICogIGNyZWF0ZSBhIHJlcXVlc3Qgb2JqZWN0LCByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgYW5kIHByb2Nlc3MgZGF0YVxuICogIGFuZCBwb3B1bGF0ZSB0aGUgW1tGZXRjaFJlc3BvbnNlXV0uXG4gKlxuICogIEluIGEgYnJvd3NlciwgdGhlIFtET00gZmV0Y2hdKGxpbmstanMtZmV0Y2gpIGlzIHVzZWQsIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiAgYGBQcm9taXNlYGAgaXMgd2FpdGVkIG9uIHRvIHJldHJlaXZlIHRoZSBwYXlsb2FkLlxuICpcbiAqICBUaGUgW1tGZXRjaFJlcXVlc3RdXSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgbWFueSBjb21tb24gc2l0dWF0aW9ucyxcbiAqICBzdWNoIGFzIHJlZGlyZWN0cywgc2VydmVyIHRocm90dGxpbmcsIGF1dGhlbnRjYXRpb24sIGV0Yy5cbiAqXG4gKiAgSXQgYWxzbyBoYW5kbGVzIGNvbW1vbiBnYXRld2F5cywgc3VjaCBhcyBJUEZTIGFuZCBkYXRhIFVSSXMuXG4gKlxuICogIEBfc2VjdGlvbiBhcGkvdXRpbHMvZmV0Y2hpbmc6RmV0Y2hpbmcgV2ViIENvbnRlbnQgIFthYm91dC1mZXRjaF1cbiAqL1xuY29uc3QgYmFzZTY0X2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlNjQuanNcIik7XG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBwcm9wZXJ0aWVzX2pzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzLmpzXCIpO1xuY29uc3QgdXRmOF9qc18xID0gcmVxdWlyZShcIi4vdXRmOC5qc1wiKTtcbmNvbnN0IGdldHVybF9qc18xID0gcmVxdWlyZShcIi4vZ2V0dXJsLmpzXCIpO1xuY29uc3QgTUFYX0FUVEVNUFRTID0gMTI7XG5jb25zdCBTTE9UX0lOVEVSVkFMID0gMjUwO1xuLy8gVGhlIGdsb2JhbCBGZXRjaEdldFVybEZ1bmMgaW1wbGVtZW50YXRpb24uXG5sZXQgZGVmYXVsdEdldFVybEZ1bmMgPSAoMCwgZ2V0dXJsX2pzXzEuY3JlYXRlR2V0VXJsKSgpO1xuY29uc3QgcmVEYXRhID0gbmV3IFJlZ0V4cChcIl5kYXRhOihbXjs6XSopPyg7YmFzZTY0KT8sKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgcmVJcGZzID0gbmV3IFJlZ0V4cChcIl5pcGZzOi9cXC8oaXBmcy8pPyguKikkXCIsIFwiaVwiKTtcbi8vIElmIGxvY2tlZCwgbmV3IEdhdGV3YXlzIGNhbm5vdCBiZSBhZGRlZFxubGV0IGxvY2tlZCA9IGZhbHNlO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSTHNcbmFzeW5jIGZ1bmN0aW9uIGRhdGFHYXRld2F5RnVuYyh1cmwsIHNpZ25hbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlRGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoMjAwLCBcIk9LXCIsIHtcbiAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IChtYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIiksXG4gICAgICAgIH0sIChtYXRjaFsyXSA/ICgwLCBiYXNlNjRfanNfMS5kZWNvZGVCYXNlNjQpKG1hdGNoWzNdKSA6IHVucGVyY2VudChtYXRjaFszXSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZSg1OTksIFwiQkFEIFJFUVVFU1QgKGludmFsaWQgZGF0YTogVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICB9XG59XG4vKipcbiAqICBSZXR1cm5zIGEgW1tGZXRjaEdhdGV3YXlGdW5jXV0gZm9yIGZldGNoaW5nIGNvbnRlbnQgZnJvbSBhIHN0YW5kYXJkXG4gKiAgSVBGUyBnYXRld2F5IGhvc3RlZCBhdCAlJWJhc2VVcmwlJS5cbiAqL1xuZnVuY3Rpb24gZ2V0SXBmc0dhdGV3YXlGdW5jKGJhc2VVcmwpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnYXRld2F5SXBmcyh1cmwsIHNpZ25hbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVJcGZzKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGxpbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVxdWVzdChgJHtiYXNlVXJsfSR7bWF0Y2hbMl19YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBcIkJBRCBSRVFVRVNUIChpbnZhbGlkIElQRlMgVVJJKVwiLCB7fSwgbnVsbCwgbmV3IEZldGNoUmVxdWVzdCh1cmwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2F0ZXdheUlwZnM7XG59XG5jb25zdCBHYXRld2F5cyA9IHtcbiAgICBcImRhdGFcIjogZGF0YUdhdGV3YXlGdW5jLFxuICAgIFwiaXBmc1wiOiBnZXRJcGZzR2F0ZXdheUZ1bmMoXCJodHRwczovXFwvZ2F0ZXdheS5pcGZzLmlvL2lwZnMvXCIpXG59O1xuY29uc3QgZmV0Y2hTaWduYWxzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmNsYXNzIEZldGNoQ2FuY2VsU2lnbmFsIHtcbiAgICAjbGlzdGVuZXJzO1xuICAgICNjYW5jZWxsZWQ7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICB0aGlzLiNsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy4jY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGZldGNoU2lnbmFscy5zZXQocmVxdWVzdCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2NhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBsaXN0ZW5lcigpOyB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2xpc3RlbmVycyA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoIXRoaXMuI2NhbmNlbGxlZCwgXCJzaW5nYWwgYWxyZWFkeSBjYW5jZWxsZWRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZldGNoQ2FuY2VsU2lnbmFsLmFkZENhbmNlbExpc3RlbmVyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHsgcmV0dXJuIHRoaXMuI2NhbmNlbGxlZDsgfVxuICAgIGNoZWNrU2lnbmFsKCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSghdGhpcy5jYW5jZWxsZWQsIFwiY2FuY2VsbGVkXCIsIFwiQ0FOQ0VMTEVEXCIsIHt9KTtcbiAgICB9XG59XG5leHBvcnRzLkZldGNoQ2FuY2VsU2lnbmFsID0gRmV0Y2hDYW5jZWxTaWduYWw7XG4vLyBDaGVjayB0aGUgc2lnbmFsLCB0aHJvd2luZyBpZiBpdCBpcyBjYW5jZWxsZWRcbmZ1bmN0aW9uIGNoZWNrU2lnbmFsKHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHNpZ25hbDsgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgfVxuICAgIHNpZ25hbC5jaGVja1NpZ25hbCgpO1xuICAgIHJldHVybiBzaWduYWw7XG59XG4vKipcbiAqICBSZXByZXNlbnRzIGEgcmVxdWVzdCBmb3IgYSByZXNvdXJjZSB1c2luZyBhIFVSSS5cbiAqXG4gKiAgQnkgZGVmYXVsdCwgdGhlIHN1cHBvcnRlZCBzY2hlbWVzIGFyZSBgYEhUVFBgYCwgYGBIVFRQU2BgLCBgYGRhdGE6YGAsXG4gKiAgYW5kIGBgSVBGUzpgYC5cbiAqXG4gKiAgQWRkaXRpb25hbCBzY2hlbWVzIGNhbiBiZSBhZGRlZCBnbG9iYWxseSB1c2luZyBbW3JlZ2lzdGVyR2F0ZXdheV1dLlxuICpcbiAqICBAZXhhbXBsZTpcbiAqICAgIHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QoXCJodHRwczovL3d3dy5yaWNtb28uY29tXCIpXG4gKiAgICByZXNwID0gYXdhaXQgcmVxLnNlbmQoKVxuICogICAgcmVzcC5ib2R5Lmxlbmd0aFxuICogICAgLy9fcmVzdWx0OlxuICovXG5jbGFzcyBGZXRjaFJlcXVlc3Qge1xuICAgICNhbGxvd0luc2VjdXJlO1xuICAgICNnemlwO1xuICAgICNoZWFkZXJzO1xuICAgICNtZXRob2Q7XG4gICAgI3RpbWVvdXQ7XG4gICAgI3VybDtcbiAgICAjYm9keTtcbiAgICAjYm9keVR5cGU7XG4gICAgI2NyZWRzO1xuICAgIC8vIEhvb2tzXG4gICAgI3ByZWZsaWdodDtcbiAgICAjcHJvY2VzcztcbiAgICAjcmV0cnk7XG4gICAgI3NpZ25hbDtcbiAgICAjdGhyb3R0bGU7XG4gICAgI2dldFVybEZ1bmM7XG4gICAgLyoqXG4gICAgICogIFRoZSBmZXRjaCBVUkkgdG8gcmVxdXJlc3QuXG4gICAgICovXG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuI3VybDsgfVxuICAgIHNldCB1cmwodXJsKSB7XG4gICAgICAgIHRoaXMuI3VybCA9IFN0cmluZyh1cmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGZldGNoIGJvZHksIGlmIGFueSwgdG8gc2VuZCBhcyB0aGUgcmVxdWVzdCBib2R5LiAvLyhkZWZhdWx0OiBudWxsKS8vXG4gICAgICpcbiAgICAgKiAgV2hlbiBzZXR0aW5nIGEgYm9keSwgdGhlIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiAgc2V0IGFuZCB3aWxsIGJlIHVzZWQgaWYgKipub3Qgb3ZlcnJpZGRlbioqIGJ5IHNldHRpbmcgYSBjdXN0b21cbiAgICAgKiAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIElmICUlYm9keSUlIGlzIG51bGwsIHRoZSBib2R5IGlzIGNsZWFyZWQgKGFsb25nIHdpdGggdGhlXG4gICAgICogIGludHJpbnNpYyBgYENvbnRlbnQtVHlwZWBgKSBhbmQgdGhlIC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIHN0cmluZywgdGhlIGludHJpbmNpcyBgYENvbnRlbnQtVHlwZWBgIGlzIHNldCB0b1xuICAgICAqICBgYHRleHQvcGxhaW5gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhIFVpbnQ4QXJyYXksIHRoZSBpbnRyaW5jaXMgYGBDb250ZW50LVR5cGVgYCBpcyBzZXQgdG9cbiAgICAgKiAgYGBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1gYC5cbiAgICAgKlxuICAgICAqICBJZiAlJWJvZHklJSBpcyBhbnkgb3RoZXIgb2JqZWN0LCB0aGUgaW50cmluY2lzIGBgQ29udGVudC1UeXBlYGAgaXNcbiAgICAgKiAgc2V0IHRvIGBgYXBwbGljYXRpb24vanNvbmBgLlxuICAgICAqL1xuICAgIGdldCBib2R5KCkge1xuICAgICAgICBpZiAodGhpcy4jYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYm9keSk7XG4gICAgfVxuICAgIHNldCBib2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShib2R5KTtcbiAgICAgICAgICAgIHRoaXMuI2JvZHlUeXBlID0gXCJ0ZXh0L3BsYWluXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSBib2R5O1xuICAgICAgICAgICAgdGhpcy4jYm9keVR5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYm9keSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2JvZHkgPSAoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKShKU09OLnN0cmluZ2lmeShib2R5KSk7XG4gICAgICAgICAgICB0aGlzLiNib2R5VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBib2R5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGEgYm9keS5cbiAgICAgKi9cbiAgICBoYXNCb2R5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2JvZHkgIT0gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBJZiBubyBtZXRob2RcbiAgICAgKiAgaGFzIGJlZW4gZXhwbGljaXRseSBzZXQsIHRoZW4gYGBHRVRgYCBpcyB1c2VkIGlmIHRoZSBib2R5IGlzXG4gICAgICogIG51bGwgYW5kIGBgUE9TVGBgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICBpZiAodGhpcy4jbWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0JvZHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkdFVFwiO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBpZiAobWV0aG9kID09IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWV0aG9kID0gU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBoZWFkZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gcmVxdWVzdGluZyB0aGUgVVJJLiBBbGxcbiAgICAgKiAga2V5cyBhcmUgbG93ZXItY2FzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIG9iamVjdCBpcyBhIGNvcHksIHNvIGFueSBjaG5hZ2VzIHdpbGwgKipOT1QqKiBiZSByZWZsZWN0ZWRcbiAgICAgKiAgaW4gdGhlIGBgRmV0Y2hSZXF1ZXN0YGAuXG4gICAgICpcbiAgICAgKiAgVG8gc2V0IGEgaGVhZGVyIGVudHJ5LCB1c2UgdGhlIGBgc2V0SGVhZGVyYGAgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNjcmVkcykge1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmFzaWMgJHsoMCwgYmFzZTY0X2pzXzEuZW5jb2RlQmFzZTY0KSgoMCwgdXRmOF9qc18xLnRvVXRmOEJ5dGVzKSh0aGlzLiNjcmVkcykpfWA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0d6aXApIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImd6aXBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9PSBudWxsICYmIHRoaXMuI2JvZHlUeXBlKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm9keSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0gU3RyaW5nKHRoaXMuYm9keS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgR2V0IHRoZSBoZWFkZXIgZm9yICUla2V5JSUsIGlnbm9yaW5nIGNhc2UuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldCB0aGUgaGVhZGVyIGZvciAlJWtleSUlIHRvICUldmFsdWUlJS4gQWxsIHZhbHVlcyBhcmUgY29lcmNlZFxuICAgICAqICB0byBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLiNoZWFkZXJzW1N0cmluZyhrZXkpLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENsZWFyIGFsbCBoZWFkZXJzLCByZXNldHRpbmcgYWxsIGludHJpbnNpYyBoZWFkZXJzLlxuICAgICAqL1xuICAgIGNsZWFySGVhZGVycygpIHtcbiAgICAgICAgdGhpcy4jaGVhZGVycyA9IHt9O1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2tleSwgaGVhZGVyc1trZXldXSwgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHZhbHVlIHRoYXQgd2lsbCBiZSBzZW50IGZvciB0aGUgYGBBdXRob3JpemF0aW9uYGAgaGVhZGVyLlxuICAgICAqXG4gICAgICogIFRvIHNldCB0aGUgY3JlZGVudGlhbHMsIHVzZSB0aGUgYGBzZXRDcmVkZW50aWFsc2BgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjcmVkcyB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU2V0cyBhbiBgYEF1dGhvcml6YXRpb25gYCBmb3IgJSV1c2VybmFtZSUlIHdpdGggJSVwYXNzd29yZCUlLlxuICAgICAqL1xuICAgIHNldENyZWRlbnRpYWxzKHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKCF1c2VybmFtZS5tYXRjaCgvOi8pLCBcImludmFsaWQgYmFzaWMgYXV0aGVudGljYXRpb24gdXNlcm5hbWVcIiwgXCJ1c2VybmFtZVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIHRoaXMuI2NyZWRzID0gYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEVuYWJsZSBhbmQgcmVxdWVzdCBnemlwLWVuY29kZWQgcmVzcG9uc2VzLiBUaGUgcmVzcG9uc2Ugd2lsbFxuICAgICAqICBhdXRvbWF0aWNhbGx5IGJlIGRlY29tcHJlc3NlZC4gLy8oZGVmYXVsdDogdHJ1ZSkvL1xuICAgICAqL1xuICAgIGdldCBhbGxvd0d6aXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnemlwO1xuICAgIH1cbiAgICBzZXQgYWxsb3dHemlwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2d6aXAgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgYGBBdXRoZW50aWNhdGlvbmBgIGNyZWRlbnRpYWxzIHRvIGJlIHNlbnQgb3ZlciBpbnNlY3VyZVxuICAgICAqICBjaGFubmVscy4gLy8oZGVmYXVsdDogZmFsc2UpLy9cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLiNhbGxvd0luc2VjdXJlO1xuICAgIH1cbiAgICBzZXQgYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHRpbWVvdXQgKGluIG1pbGxpc2Vjb25kcykgdG8gd2FpdCBmb3IgYSBjb21wbGVyZSByZXNwb25zZS5cbiAgICAgKiAgLy8oZGVmYXVsdDogNSBtaW51dGVzKS8vXG4gICAgICovXG4gICAgZ2V0IHRpbWVvdXQoKSB7IHJldHVybiB0aGlzLiN0aW1lb3V0OyB9XG4gICAgc2V0IHRpbWVvdXQodGltZW91dCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHRpbWVvdXQgPj0gMCwgXCJ0aW1lb3V0IG11c3QgYmUgbm9uLXplcm9cIiwgXCJ0aW1lb3V0XCIsIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHByaW9yIHRvIGVhY2ggcmVxdWVzdCwgZm9yIGV4YW1wbGVcbiAgICAgKiAgZHVyaW5nIGEgcmVkaXJlY3Rpb24gb3IgcmV0cnkgaW4gY2FzZSBvZiBzZXJ2ZXIgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqICBUaGlzIG9mZmVycyBhbiBvcHBvcnR1bml0eSB0byBwb3B1bGF0ZSBoZWFkZXJzIG9yIHVwZGF0ZVxuICAgICAqICBjb250ZW50IGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXQgcHJlZmxpZ2h0RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3ByZWZsaWdodCB8fCBudWxsO1xuICAgIH1cbiAgICBzZXQgcHJlZmxpZ2h0RnVuYyhwcmVmbGlnaHQpIHtcbiAgICAgICAgdGhpcy4jcHJlZmxpZ2h0ID0gcHJlZmxpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXNwb25zZSwgb2ZmZXJpbmcgYW5cbiAgICAgKiAgb3Bwb3J0dW5pdHkgdG8gcHJvdmlkZSBjbGllbnQtbGV2ZWwgdGhyb3R0bGluZyBvciB1cGRhdGluZ1xuICAgICAqICByZXNwb25zZSBkYXRhLlxuICAgICAqXG4gICAgICogIEFueSBlcnJvciB0aHJvd24gaW4gdGhpcyBjYXVzZXMgdGhlIGBgc2VuZCgpYGAgdG8gdGhyb3cuXG4gICAgICpcbiAgICAgKiAgVG8gc2NoZWR1bGUgYSByZXRyeSBhdHRlbXB0IChhc3N1bWluZyB0aGUgbWF4aW11bSByZXRyeSBsaW1pdFxuICAgICAqICBoYXMgbm90IGJlZW4gcmVhY2hlZCksIHVzZSBbW3Jlc3BvbnNlLnRocm93VGhyb3R0bGVFcnJvcl1dLlxuICAgICAqL1xuICAgIGdldCBwcm9jZXNzRnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IHByb2Nlc3NGdW5jKHByb2Nlc3MpIHtcbiAgICAgICAgdGhpcy4jcHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBlYWNoIHJldHJ5IGF0dGVtcHQuXG4gICAgICovXG4gICAgZ2V0IHJldHJ5RnVuYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JldHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIHNldCByZXRyeUZ1bmMocmV0cnkpIHtcbiAgICAgICAgdGhpcy4jcmV0cnkgPSByZXRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGZldGNoIGNvbnRlbnQgZnJvbSBIVFRQIGFuZFxuICAgICAqICBIVFRQUyBVUkxzIGFuZCBpcyBwbGF0Zm9ybSBzcGVjaWZpYyAoZS5nLiBub2RlanMgdnNcbiAgICAgKiAgYnJvd3NlcnMpLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgYnkgZGVmYXVsdCB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgZ2xvYmFsIGdldFVybFxuICAgICAqICBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdXNpbmcgW1tyZWdpc3RlckdldFVybF1dLlxuICAgICAqICBJZiB0aGlzIGhhcyBiZWVuIHNldCwgc2V0dGluZyBpcyB0byBgYG51bGxgYCB3aWxsIGNhdXNlXG4gICAgICogIHRoaXMgRmV0Y2hSZXF1ZXN0IChhbmQgYW55IGZ1dHVyZSBjbG9uZXMpIHRvIHJldmVydCBiYWNrIHRvXG4gICAgICogIHVzaW5nIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBnbG9iYWwgZ2V0VXJsIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIFNldHRpbmcgdGhpcyBpcyBnZW5lcmFsbHkgbm90IG5lY2Vzc2FyeSwgYnV0IG1heSBiZSB1c2VmdWxcbiAgICAgKiAgZm9yIGRldmVsb3BlcnMgdGhhdCB3aXNoIHRvIGludGVyY2VwdCByZXF1ZXN0cyBvciB0b1xuICAgICAqICBjb25maWd1cmVnZSBhIHByb3h5IG9yIG90aGVyIGFnZW50LlxuICAgICAqL1xuICAgIGdldCBnZXRVcmxGdW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZ2V0VXJsRnVuYyB8fCBkZWZhdWx0R2V0VXJsRnVuYztcbiAgICB9XG4gICAgc2V0IGdldFVybEZ1bmModmFsdWUpIHtcbiAgICAgICAgdGhpcy4jZ2V0VXJsRnVuYyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGEgbmV3IEZldGNoUmVxdWVzdCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogIE9uY2UgY3JlYXRlZCwgZWFjaCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGJlZm9yZSBpc3N1aW5nIGFcbiAgICAgKiAgYGAuc2VuZCgpYGAgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gU3RyaW5nKHVybCk7XG4gICAgICAgIHRoaXMuI2FsbG93SW5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy4jZ3ppcCA9IHRydWU7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy4jbWV0aG9kID0gXCJcIjtcbiAgICAgICAgdGhpcy4jdGltZW91dCA9IDMwMDAwMDtcbiAgICAgICAgdGhpcy4jdGhyb3R0bGUgPSB7XG4gICAgICAgICAgICBzbG90SW50ZXJ2YWw6IFNMT1RfSU5URVJWQUwsXG4gICAgICAgICAgICBtYXhBdHRlbXB0czogTUFYX0FUVEVNUFRTXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2dldFVybEZ1bmMgPSBudWxsO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGA8RmV0Y2hSZXF1ZXN0IG1ldGhvZD0ke0pTT04uc3RyaW5naWZ5KHRoaXMubWV0aG9kKX0gdXJsPSR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSBoZWFkZXJzPSR7SlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKX0gYm9keT0ke3RoaXMuI2JvZHkgPyAoMCwgZGF0YV9qc18xLmhleGxpZnkpKHRoaXMuI2JvZHkpIDogXCJudWxsXCJ9PmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBVcGRhdGUgdGhlIHRocm90dGxlIHBhcmFtZXRlcnMgdXNlZCB0byBkZXRlcm1pbmUgbWF4aW11bVxuICAgICAqICBhdHRlbXB0cyBhbmQgZXhwb25lbnRpYWwtYmFja29mZiBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHNldFRocm90dGxlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnNsb3RJbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgPSBwYXJhbXMuc2xvdEludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWF4QXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMgPSBwYXJhbXMubWF4QXR0ZW1wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI3NlbmQoYXR0ZW1wdCwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPj0gdGhpcy4jdGhyb3R0bGUubWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXhjZWVkZWQgbWF4aW11bSByZXRyeSBsaW1pdFwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShnZXRUaW1lKCkgPD0gZXhwaXJlcywgXCJ0aW1lb3V0XCIsIFwiVElNRU9VVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdC5zZW5kXCIsIHJlYXNvbjogXCJ0aW1lb3V0XCIsIHJlcXVlc3Q6IF9yZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVxID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBjb25zdCBzY2hlbWUgPSAocmVxLnVybC5zcGxpdChcIjpcIilbMF0gfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbnkgR2F0ZXdheXNcbiAgICAgICAgaWYgKHNjaGVtZSBpbiBHYXRld2F5cykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgR2F0ZXdheXNbc2NoZW1lXShyZXEudXJsLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRmV0Y2hSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzRnVuYyhyZXEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBwcm9jZXNzaW5nOyB0aHJvdyBhIDV4eCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZSA9PSBudWxsIHx8IHR5cGVvZiAoZXJyb3Iuc3RhbGwpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBhIHByZWZsaWdodCBmdW5jdGlvbjsgdXBkYXRlIHRoZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodEZ1bmMpIHtcbiAgICAgICAgICAgIHJlcSA9IGF3YWl0IHRoaXMucHJlZmxpZ2h0RnVuYyhyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmdldFVybEZ1bmMocmVxLCBjaGVja1NpZ25hbChfcmVxdWVzdC4jc2lnbmFsKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3Auc3RhdHVzQ29kZSwgcmVzcC5zdGF0dXNNZXNzYWdlLCByZXNwLmhlYWRlcnMsIHJlc3AuYm9keSwgX3JlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgLy8gUmVkaXJlY3RcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZWRpcmVjdChsb2NhdGlvbikuI3NlbmQoYXR0ZW1wdCArIDEsIGV4cGlyZXMsIDAsIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgLy8gVGhpbmdzIHdvbid0IGdldCBhbnkgYmV0dGVyIG9uIGFub3RoZXIgYXR0ZW1wdDsgYWJvcnRcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIC8vIFRocm90dGxlXG4gICAgICAgICAgICBpZiAodGhpcy5yZXRyeUZ1bmMgPT0gbnVsbCB8fCAoYXdhaXQgdGhpcy5yZXRyeUZ1bmMocmVxLCByZXNwb25zZSwgYXR0ZW1wdCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLiN0aHJvdHRsZS5zbG90SW50ZXJ2YWwgKiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQocmV0cnlBZnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXEuY2xvbmUoKS4jc2VuZChhdHRlbXB0ICsgMSwgZXhwaXJlcywgZGVsYXksIF9yZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIGNoZWNrU2lnbmFsKF9yZXF1ZXN0LiNzaWduYWwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0Z1bmMocmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgcHJvY2Vzc2luZzsgdGhyb3cgYSA1eHggc2VydmVyIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnRocm90dGxlID09IG51bGwgfHwgdHlwZW9mIChlcnJvci5zdGFsbCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubWFrZVNlcnZlckVycm9yKFwiZXJyb3IgaW4gcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uXCIsIGVycm9yKS5hc3NlcnRPaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaHJvdHRsZVxuICAgICAgICAgICAgICAgIGxldCBkZWxheSA9IHRoaXMuI3Rocm90dGxlLnNsb3RJbnRlcnZhbCAqIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnN0YWxsID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBlcnJvci5zdGFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5jbG9uZSgpLiNzZW5kKGF0dGVtcHQgKyAxLCBleHBpcmVzLCBkZWxheSwgX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgYnkgc2VuZGluZyB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZW5kKCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSh0aGlzLiNzaWduYWwgPT0gbnVsbCwgXCJyZXF1ZXN0IGFscmVhZHkgc2VudFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7IG9wZXJhdGlvbjogXCJmZXRjaFJlcXVlc3Quc2VuZFwiIH0pO1xuICAgICAgICB0aGlzLiNzaWduYWwgPSBuZXcgRmV0Y2hDYW5jZWxTaWduYWwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNzZW5kKDAsIGdldFRpbWUoKSArIHRoaXMudGltZW91dCwgMCwgdGhpcywgbmV3IEZldGNoUmVzcG9uc2UoMCwgXCJcIiwge30sIG51bGwsIHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENhbmNlbHMgdGhlIGluZmxpZ2h0IHJlc3BvbnNlLCBjYXVzaW5nIGEgYGBDQU5DRUxMRURgYFxuICAgICAqICBlcnJvciB0byBiZSByZWplY3RlZCBmcm9tIHRoZSBbW3NlbmRdXS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHRoaXMuI3NpZ25hbCAhPSBudWxsLCBcInJlcXVlc3QgaGFzIG5vdCBiZWVuIHNlbnRcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwgeyBvcGVyYXRpb246IFwiZmV0Y2hSZXF1ZXN0LmNhbmNlbFwiIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBmZXRjaFNpZ25hbHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoIXNpZ25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBzaWduYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZldGNoUmVxdWVzdF1dIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVkaXJlY3Rpb25cbiAgICAgKiAgdG8gJSVsb2NhdGlvbiUlLlxuICAgICAqL1xuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGFpb25zXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnVybC5zcGxpdChcIjpcIilbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYXRpb24uc3BsaXQoXCI6XCIpWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIERvbid0IGFsbG93IHJlZGlyZWN0aW5nOlxuICAgICAgICAvLyAtIG5vbi1HRVQgcmVxdWVzdHNcbiAgICAgICAgLy8gLSBkb3duZ3JhZGluZyB0aGUgc2VjdXJpdHkgKGUuZy4gaHR0cHMgPT4gaHR0cClcbiAgICAgICAgLy8gLSB0byBub24tSFRUUCAob3Igbm9uLUhUVFBTKSBwcm90b2NvbHMgW3RoaXMgY291bGQgYmUgcmVsYXhlZD9dXG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHRoaXMubWV0aG9kID09PSBcIkdFVFwiICYmIChjdXJyZW50ICE9PSBcImh0dHBzXCIgfHwgdGFyZ2V0ICE9PSBcImh0dHBcIikgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwcz86LyksIGB1bnN1cHBvcnRlZCByZWRpcmVjdGAsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlZGlyZWN0KCR7dGhpcy5tZXRob2R9ICR7SlNPTi5zdHJpbmdpZnkodGhpcy51cmwpfSA9PiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0pYFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGlzIHJlcXVlc3QsIHdpdGggYSBuZXcgVVJMXG4gICAgICAgIGNvbnN0IHJlcSA9IG5ldyBGZXRjaFJlcXVlc3QobG9jYXRpb24pO1xuICAgICAgICByZXEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgcmVxLmFsbG93R3ppcCA9IHRoaXMuYWxsb3dHemlwO1xuICAgICAgICByZXEudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgcmVxLiNoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4jaGVhZGVycyk7XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICByZXEuI2JvZHkgPSBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXEuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIERvIG5vdCBmb3J3YXJkIGNyZWRlbnRpYWxzIHVubGVzcyBvbiB0aGUgc2FtZSBkb21haW47IG9ubHkgYWJzb2x1dGVcbiAgICAgICAgLy9yZXEuYWxsb3dJbnNlY3VyZSA9IGZhbHNlO1xuICAgICAgICAvLyBwYXRocyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDsgbWF5IHdhbnQgYSB3YXkgdG8gc3BlY2lmeSB0byBmb3J3YXJkP1xuICAgICAgICAvL3NldFN0b3JlKHJlcS4jcHJvcHMsIFwiY3JlZHNcIiwgZ2V0U3RvcmUodGhpcy4jcHJvcywgXCJjcmVkc1wiKSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGlzIHJlcXVlc3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLnVybCk7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBtZXRob2RcIiAoaS5lLiBudWxsKVxuICAgICAgICBjbG9uZS4jbWV0aG9kID0gdGhpcy4jbWV0aG9kO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBcImRlZmF1bHQgYm9keVwiIHdpdGggdHlwZSwgY29weWluZyB0aGUgVWludDhBcnJheSBpcyBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLiNib2R5KSB7XG4gICAgICAgICAgICBjbG9uZS4jYm9keSA9IHRoaXMuI2JvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuI2JvZHlUeXBlID0gdGhpcy4jYm9keVR5cGU7XG4gICAgICAgIC8vIFByZXNlcnZlIFwiZGVmYXVsdCBoZWFkZXJzXCJcbiAgICAgICAgY2xvbmUuI2hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTtcbiAgICAgICAgLy8gQ3JlZGVudGlhbHMgaXMgcmVhZG9ubHksIHNvIHdlIGNvcHkgaW50ZXJuYWxseVxuICAgICAgICBjbG9uZS4jY3JlZHMgPSB0aGlzLiNjcmVkcztcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dHemlwKSB7XG4gICAgICAgICAgICBjbG9uZS5hbGxvd0d6aXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICh0aGlzLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgY2xvbmUuYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZS4jcHJlZmxpZ2h0ID0gdGhpcy4jcHJlZmxpZ2h0O1xuICAgICAgICBjbG9uZS4jcHJvY2VzcyA9IHRoaXMuI3Byb2Nlc3M7XG4gICAgICAgIGNsb25lLiNyZXRyeSA9IHRoaXMuI3JldHJ5O1xuICAgICAgICBjbG9uZS4jZ2V0VXJsRnVuYyA9IHRoaXMuI2dldFVybEZ1bmM7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIExvY2tzIGFsbCBzdGF0aWMgY29uZmlndXJhdGlvbiBmb3IgZ2F0ZXdheXMgYW5kIEZldGNoR2V0VXJsRnVuY1xuICAgICAqICByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGxvY2tDb25maWcoKSB7XG4gICAgICAgIGxvY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBHZXQgdGhlIGN1cnJlbnQgR2F0ZXdheSBmdW5jdGlvbiBmb3IgJSVzY2hlbWUlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0R2F0ZXdheShzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIEdhdGV3YXlzW3NjaGVtZS50b0xvd2VyQ2FzZSgpXSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVXNlIHRoZSAlJWZ1bmMlJSB3aGVuIGZldGNoaW5nIFVSSXMgdXNpbmcgJSVzY2hlbWUlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCBhZmZlY3RzIGFsbCByZXF1ZXN0cyBnbG9iYWxseS5cbiAgICAgKlxuICAgICAqICBJZiBbW2xvY2tDb25maWddXSBoYXMgYmVlbiBjYWxsZWQsIG5vIGNoYW5nZSBpcyBtYWRlIGFuZCB0aGlzXG4gICAgICogIHRocm93cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVnaXN0ZXJHYXRld2F5KHNjaGVtZSwgZnVuYykge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJodHRwXCIgfHwgc2NoZW1lID09PSBcImh0dHBzXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGludGVyY2VwdCAke3NjaGVtZX07IHVzZSByZWdpc3RlckdldFVybGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdhdGV3YXlzIGxvY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBHYXRld2F5c1tzY2hlbWVdID0gZnVuYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVzZSAlJWdldFVybCUlIHdoZW4gZmV0Y2hpbmcgVVJJcyBvdmVyIEhUVFAgYW5kIEhUVFBTIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIGFmZmVjdHMgYWxsIHJlcXVlc3RzIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICogIElmIFtbbG9ja0NvbmZpZ11dIGhhcyBiZWVuIGNhbGxlZCwgbm8gY2hhbmdlIGlzIG1hZGUgYW5kIHRoaXNcbiAgICAgKiAgdGhyb3dzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZWdpc3RlckdldFVybChnZXRVcmwpIHtcbiAgICAgICAgaWYgKGxvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2F0ZXdheXMgbG9ja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRHZXRVcmxGdW5jID0gZ2V0VXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGdldFVybCBmdW5jdGlvbiB0aGF0IGZldGNoZXMgY29udGVudCBmcm9tIEhUVFAgYW5kXG4gICAgICogIEhUVFBTIFVSTHMuXG4gICAgICpcbiAgICAgKiAgVGhlIGF2YWlsYWJsZSAlJW9wdGlvbnMlJSBhcmUgZGVwZW5kZW50IG9uIHRoZSBwbGF0Zm9ybVxuICAgICAqICBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmYXVsdCBnZXRVcmwgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBub3QgZ2VuZXJhbGx5IHNvbWV0aGluZyB0aGF0IGlzIG5lZWRlZCwgYnV0IGlzIHVzZWZ1bFxuICAgICAqICB3aGVuIHRyeWluZyB0byBjdXN0b21pemUgc2ltcGxlIGJlaGF2aW91ciB3aGVuIGZldGNoaW5nIEhUVFBcbiAgICAgKiAgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR2V0VXJsRnVuYyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZ2V0dXJsX2pzXzEuY3JlYXRlR2V0VXJsKShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBcImZldGNoXCIgZGF0YSBVUklzLlxuICAgICAqXG4gICAgICogIE5vdGUgdGhhdCB0aGlzIGlzIGF1dG9tYXRpY2FsbHkgZG9uZSBpbnRlcm5hbGx5IHRvIHN1cHBvcnRcbiAgICAgKiAgZGF0YSBVUklzLCBzbyBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHJlZ2lzdGVyIGl0LlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgbm90IGdlbmVyYWxseSBzb21ldGhpbmcgdGhhdCBpcyBuZWVkZWQsIGJ1dCBtYXlcbiAgICAgKiAgYmUgdXNlZnVsIGluIGEgd3JhcHBlciB0byBwZXJmb20gY3VzdG9tIGRhdGEgVVJJIGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURhdGFHYXRld2F5KCkge1xuICAgICAgICByZXR1cm4gZGF0YUdhdGV3YXlGdW5jO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBmZXRjaCBJUEZTICh1bnZhbGlkYXRlZCkgZnJvbVxuICAgICAqICBhIGN1c3RvbSBnYXRld2F5IGJhc2VVcmwuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlZmF1bHQgSVBGUyBnYXRld2F5IHVzZWQgaW50ZXJuYWxseSBpc1xuICAgICAqICBgYFwiaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzL1wiYGAuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlwZnNHYXRld2F5RnVuYyhiYXNlVXJsKSB7XG4gICAgICAgIHJldHVybiBnZXRJcGZzR2F0ZXdheUZ1bmMoYmFzZVVybCk7XG4gICAgfVxufVxuZXhwb3J0cy5GZXRjaFJlcXVlc3QgPSBGZXRjaFJlcXVlc3Q7XG47XG4vKipcbiAqICBUaGUgcmVzcG9uc2UgZm9yIGEgRmV0Y2hSRXF1ZXN0LlxuICovXG5jbGFzcyBGZXRjaFJlc3BvbnNlIHtcbiAgICAjc3RhdHVzQ29kZTtcbiAgICAjc3RhdHVzTWVzc2FnZTtcbiAgICAjaGVhZGVycztcbiAgICAjYm9keTtcbiAgICAjcmVxdWVzdDtcbiAgICAjZXJyb3I7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgPEZldGNoUmVzcG9uc2Ugc3RhdHVzPSR7dGhpcy5zdGF0dXNDb2RlfSBib2R5PSR7dGhpcy4jYm9keSA/ICgwLCBkYXRhX2pzXzEuaGV4bGlmeSkodGhpcy4jYm9keSkgOiBcIm51bGxcIn0+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHsgcmV0dXJuIHRoaXMuI3N0YXR1c0NvZGU7IH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlc3BvbnNlIHN0YXR1cyBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXNNZXNzYWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhdHVzTWVzc2FnZTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgaGVhZGVycy4gQWxsIGtleXMgYXJlIGxvd2VyLWNhc2UuXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcnMoKSB7IHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiNoZWFkZXJzKTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgb3IgYGBudWxsYGAgaWYgdGhlcmUgd2FzIG5vIGJvZHkuXG4gICAgICovXG4gICAgZ2V0IGJvZHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jYm9keSA9PSBudWxsKSA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLiNib2R5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSByZXNwb25zZSBib2R5IGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcsIG9yIHRoZSBlbXB0eVxuICAgICAqICBzdHJpbmcgKGkuZS4gYGBcIlwiYGApIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIFVURi04IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGJvZHlUZXh0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ID09IG51bGwpID8gXCJcIiA6ICgwLCB1dGY4X2pzXzEudG9VdGY4U3RyaW5nKSh0aGlzLiNib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGZhbHNlLCBcInJlc3BvbnNlIGJvZHkgaXMgbm90IHZhbGlkIFVURi04IGRhdGFcIiwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJib2R5VGV4dFwiLCBpbmZvOiB7IHJlc3BvbnNlOiB0aGlzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcmVzcG9uc2UgYm9keSwgZGVjb2RlZCBhcyBKU09OLlxuICAgICAqXG4gICAgICogIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgYm9keSBpcyBpbnZhbGlkIEpTT04tZW5jb2RlZCBkYXRhXG4gICAgICogIG9yIGlmIHRoZXJlIHdhcyBubyBib2R5LlxuICAgICAqL1xuICAgIGdldCBib2R5SnNvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYm9keVRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoZmFsc2UsIFwicmVzcG9uc2UgYm9keSBpcyBub3QgdmFsaWQgSlNPTlwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImJvZHlKc29uXCIsIGluZm86IHsgcmVzcG9uc2U6IHRoaXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtrZXksIGhlYWRlcnNba2V5XV0sIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgc3RhdHVzTWVzc2FnZSwgaGVhZGVycywgYm9keSwgcmVxdWVzdCkge1xuICAgICAgICB0aGlzLiNzdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy4jc3RhdHVzTWVzc2FnZSA9IHN0YXR1c01lc3NhZ2U7XG4gICAgICAgIHRoaXMuI2hlYWRlcnMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5yZWR1Y2UoKGFjY3VtLCBrKSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtrLnRvTG93ZXJDYXNlKCldID0gU3RyaW5nKGhlYWRlcnNba10pO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuI2JvZHkgPSAoKGJvZHkgPT0gbnVsbCkgPyBudWxsIDogbmV3IFVpbnQ4QXJyYXkoYm9keSkpO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0ID0gKHJlcXVlc3QgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMuI2Vycm9yID0geyBtZXNzYWdlOiBcIlwiIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBSZXNwb25zZSB3aXRoIG1hdGNoaW5nIGhlYWRlcnMgYW5kIGJvZHksIGJ1dCB3aXRoXG4gICAgICogIGFuIGVycm9yIHN0YXR1cyBjb2RlIChpLmUuIDU5OSkgYW5kICUlbWVzc2FnZSUlIHdpdGggYW5cbiAgICAgKiAgb3B0aW9uYWwgJSVlcnJvciUlLlxuICAgICAqL1xuICAgIG1ha2VTZXJ2ZXJFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICBsZXQgc3RhdHVzTWVzc2FnZTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYCR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSA9IGBDTElFTlQgRVNDQUxBVEVEIFNFUlZFUiBFUlJPUiAoJHttZXNzYWdlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZSA9IGBDTElFTlQgRVNDQUxBVEVEIFNFUlZFUiBFUlJPUiAoJHt0aGlzLnN0YXR1c0NvZGV9ICR7dGhpcy5zdGF0dXNNZXNzYWdlfTsgJHttZXNzYWdlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IEZldGNoUmVzcG9uc2UoNTk5LCBzdGF0dXNNZXNzYWdlLCB0aGlzLmhlYWRlcnMsIHRoaXMuYm9keSwgdGhpcy4jcmVxdWVzdCB8fCB1bmRlZmluZWQpO1xuICAgICAgICByZXNwb25zZS4jZXJyb3IgPSB7IG1lc3NhZ2UsIGVycm9yIH07XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIElmIGNhbGxlZCB3aXRoaW4gYSBbcmVxdWVzdC5wcm9jZXNzRnVuY10oRmV0Y2hSZXF1ZXN0LXByb2Nlc3NGdW5jKVxuICAgICAqICBjYWxsLCBjYXVzZXMgdGhlIHJlcXVlc3QgdG8gcmV0cnkgYXMgaWYgdGhyb3R0bGVkIGZvciAlJXN0YWxsJSVcbiAgICAgKiAgbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIHRocm93VGhyb3R0bGVFcnJvcihtZXNzYWdlLCBzdGFsbCkge1xuICAgICAgICBpZiAoc3RhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhbGwgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcihzdGFsbCkgJiYgc3RhbGwgPj0gMCwgXCJpbnZhbGlkIHN0YWxsIHRpbWVvdXRcIiwgXCJzdGFsbFwiLCBzdGFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcInRocm90dGxpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykoZXJyb3IsIHsgc3RhbGwsIHRocm90dGxlOiB0cnVlIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdldCB0aGUgaGVhZGVyIHZhbHVlIGZvciAlJWtleSUlLCBpZ25vcmluZyBjYXNlLlxuICAgICAqL1xuICAgIGdldEhlYWRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgb2YgdGhlIHJlc3BvbnNlIGhhcyBhIGJvZHkuXG4gICAgICovXG4gICAgaGFzQm9keSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNib2R5ICE9IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIHJlcXVlc3QgbWFkZSBmb3IgdGhpcyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHsgcmV0dXJuIHRoaXMuI3JlcXVlc3Q7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVzcG9uc2Ugd2FzIGEgc3VjY2VzcyBzdGF0dXNDb2RlLlxuICAgICAqL1xuICAgIG9rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Vycm9yLm1lc3NhZ2UgPT09IFwiXCIgJiYgdGhpcy5zdGF0dXNDb2RlID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPCAzMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhyb3dzIGEgYGBTRVJWRVJfRVJST1JgYCBpZiB0aGlzIHJlc3BvbnNlIGlzIG5vdCBvay5cbiAgICAgKi9cbiAgICBhc3NlcnRPaygpIHtcbiAgICAgICAgaWYgKHRoaXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IG1lc3NhZ2UsIGVycm9yIH0gPSB0aGlzLiNlcnJvcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgc2VydmVyIHJlc3BvbnNlICR7dGhpcy5zdGF0dXNDb2RlfSAke3RoaXMuc3RhdHVzTWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGZhbHNlLCBtZXNzYWdlLCBcIlNFUlZFUl9FUlJPUlwiLCB7XG4gICAgICAgICAgICByZXF1ZXN0OiAodGhpcy5yZXF1ZXN0IHx8IFwidW5rbm93biByZXF1ZXN0XCIpLCByZXNwb25zZTogdGhpcywgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5GZXRjaFJlc3BvbnNlID0gRmV0Y2hSZXNwb25zZTtcbmZ1bmN0aW9uIGdldFRpbWUoKSB7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpOyB9XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHV0ZjhfanNfMS50b1V0ZjhCeXRlcykodmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHdhaXQoZGVsYXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZldGNoUmVzcG9uc2UiLCJGZXRjaFJlcXVlc3QiLCJGZXRjaENhbmNlbFNpZ25hbCIsImJhc2U2NF9qc18xIiwicmVxdWlyZSIsImRhdGFfanNfMSIsImVycm9yc19qc18xIiwicHJvcGVydGllc19qc18xIiwidXRmOF9qc18xIiwiZ2V0dXJsX2pzXzEiLCJNQVhfQVRURU1QVFMiLCJTTE9UX0lOVEVSVkFMIiwiZGVmYXVsdEdldFVybEZ1bmMiLCJjcmVhdGVHZXRVcmwiLCJyZURhdGEiLCJSZWdFeHAiLCJyZUlwZnMiLCJsb2NrZWQiLCJkYXRhR2F0ZXdheUZ1bmMiLCJ1cmwiLCJzaWduYWwiLCJtYXRjaCIsIkVycm9yIiwiZGVjb2RlQmFzZTY0IiwidW5wZXJjZW50IiwiZXJyb3IiLCJnZXRJcGZzR2F0ZXdheUZ1bmMiLCJiYXNlVXJsIiwiZ2F0ZXdheUlwZnMiLCJHYXRld2F5cyIsImZldGNoU2lnbmFscyIsIldlYWtNYXAiLCJsaXN0ZW5lcnMiLCJjYW5jZWxsZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVlc3QiLCJzZXQiLCJsaXN0ZW5lciIsInNldFRpbWVvdXQiLCJhZGRMaXN0ZW5lciIsImFzc2VydCIsIm9wZXJhdGlvbiIsInB1c2giLCJjaGVja1NpZ25hbCIsImFsbG93SW5zZWN1cmUiLCJnemlwIiwiaGVhZGVycyIsIm1ldGhvZCIsInRpbWVvdXQiLCJib2R5IiwiYm9keVR5cGUiLCJjcmVkcyIsInByZWZsaWdodCIsInByb2Nlc3MiLCJyZXRyeSIsInRocm90dGxlIiwiZ2V0VXJsRnVuYyIsIlN0cmluZyIsIlVpbnQ4QXJyYXkiLCJ1bmRlZmluZWQiLCJ0b1V0ZjhCeXRlcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXNCb2R5IiwidG9VcHBlckNhc2UiLCJhc3NpZ24iLCJlbmNvZGVCYXNlNjQiLCJhbGxvd0d6aXAiLCJsZW5ndGgiLCJnZXRIZWFkZXIiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInNldEhlYWRlciIsImNsZWFySGVhZGVycyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwia2V5cyIsImluZGV4IiwibmV4dCIsImRvbmUiLCJjcmVkZW50aWFscyIsInNldENyZWRlbnRpYWxzIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImFzc2VydEFyZ3VtZW50IiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwicHJlZmxpZ2h0RnVuYyIsInByb2Nlc3NGdW5jIiwicmV0cnlGdW5jIiwic2xvdEludGVydmFsIiwibWF4QXR0ZW1wdHMiLCJ0b1N0cmluZyIsImhleGxpZnkiLCJzZXRUaHJvdHRsZVBhcmFtcyIsInBhcmFtcyIsInNlbmQiLCJhdHRlbXB0IiwiZXhwaXJlcyIsImRlbGF5IiwiX3JlcXVlc3QiLCJfcmVzcG9uc2UiLCJtYWtlU2VydmVyRXJyb3IiLCJnZXRUaW1lIiwicmVhc29uIiwid2FpdCIsInJlcSIsImNsb25lIiwic2NoZW1lIiwic3BsaXQiLCJyZXN1bHQiLCJyZXNwb25zZSIsInN0YWxsIiwiYXNzZXJ0T2siLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJsb2NhdGlvbiIsInJlZGlyZWN0IiwicmV0cnlBZnRlciIsIk1hdGgiLCJ0cnVuYyIsInJhbmRvbSIsInBvdyIsInBhcnNlSW50IiwiY2FuY2VsIiwiZ2V0IiwiY3VycmVudCIsInRhcmdldCIsImxvY2tDb25maWciLCJnZXRHYXRld2F5IiwicmVnaXN0ZXJHYXRld2F5IiwiZnVuYyIsInJlZ2lzdGVyR2V0VXJsIiwiZ2V0VXJsIiwiY3JlYXRlR2V0VXJsRnVuYyIsIm9wdGlvbnMiLCJjcmVhdGVEYXRhR2F0ZXdheSIsImNyZWF0ZUlwZnNHYXRld2F5RnVuYyIsImJvZHlUZXh0IiwidG9VdGY4U3RyaW5nIiwiaW5mbyIsImJvZHlKc29uIiwicGFyc2UiLCJyZWR1Y2UiLCJhY2N1bSIsImsiLCJtZXNzYWdlIiwidGhyb3dUaHJvdHRsZUVycm9yIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZGVmaW5lUHJvcGVydGllcyIsIm9rIiwiRGF0ZSIsInJlcGxhY2UiLCJhbGwiLCJjb2RlIiwiZnJvbUNoYXJDb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/fixednumber.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FixedNumber = void 0;\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */ const data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile(Zeros.length < 80){\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while(result.length < decimals){\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = BN_1 << width - BN_1;\n        (0, errors_js_1.assert)(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        if (val > BN_0) {\n            val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);\n        } else {\n            val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);\n        }\n    } else {\n        const limit = BN_1 << width;\n        (0, errors_js_1.assert)(safeOp == null || val >= 0 && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp,\n            fault: \"overflow\",\n            value: val\n        });\n        val = (val % limit + limit) % limit & limit - BN_1;\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof value === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof value === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n        // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0, errors_js_1.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = match[1] !== \"u\";\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue)=>{\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0, errors_js_1.assertArgument)(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0, errors_js_1.assertArgument)(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0, errors_js_1.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return {\n        signed,\n        width,\n        decimals,\n        name\n    };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return negative + str;\n    }\n    // Pad out to the whole component (including a whole digit)\n    while(str.length <= decimals){\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while(str[0] === \"0\" && str[1] !== \".\"){\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while(str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\"){\n        str = str.substring(0, str.length - 1);\n    }\n    return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */ class FixedNumber {\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */ constructor(guard, value, format){\n        (0, errors_js_1.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0, properties_js_1.defineProperties)(this, {\n            format: format.name,\n            _value\n        });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */ get signed() {\n        return this.#format.signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */ get width() {\n        return this.#format.width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */ get decimals() {\n        return this.#format.decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */ get value() {\n        return this.#val;\n    }\n    #checkFormat(other) {\n        (0, errors_js_1.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */ val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */ addUnsafe(other) {\n        return this.#add(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ add(other) {\n        return this.#add(other, \"add\");\n    }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */ subUnsafe(other) {\n        return this.#sub(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ sub(other) {\n        return this.#sub(other, \"sub\");\n    }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */ mulUnsafe(other) {\n        return this.#mul(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */ mul(other) {\n        return this.#mul(other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */ mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0, errors_js_1.assert)(value % this.#tens === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0, errors_js_1.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ divUnsafe(other) {\n        return this.#div(other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */ div(other) {\n        return this.#div(other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */ divSignal(other) {\n        (0, errors_js_1.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\",\n            fault: \"divide-by-zero\",\n            value: this\n        });\n        this.#checkFormat(other);\n        const value = this.#val * this.#tens;\n        (0, errors_js_1.assert)(value % other.#val === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\",\n            fault: \"underflow\",\n            value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */ cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        } else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */ eq(other) {\n        return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */ lt(other) {\n        return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */ lte(other) {\n        return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */ gt(other) {\n        return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */ gte(other) {\n        return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */ ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = this.#val / this.#tens * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */ round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = value / tens * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */ isZero() {\n        return this.#val === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */ isNegative() {\n        return this.#val < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */ toString() {\n        return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */ toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */ toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */ static fromValue(_value, _decimals, _format) {\n        const decimals = _decimals == null ? 0 : (0, maths_js_1.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0, maths_js_1.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0, errors_js_1.assert)(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\",\n                fault: \"underflow\",\n                value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */ static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0, errors_js_1.assertArgument)(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = match[2] || \"0\", decimal = match[3] || \"\";\n        // Pad out the decimals\n        while(decimal.length < format.decimals){\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\",\n            fault: \"underflow\",\n            value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */ static fromBytes(_value, _format) {\n        let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0, maths_js_1.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\nexports.FixedNumber = FixedNumber; //const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n //const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n //console.log(f1.divSignal(f2));\n //const BUMP = FixedNumber.from(\"0.5\");\n //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQjs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRyxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywyRUFBWTtBQUN2QyxNQUFNRyxrQkFBa0JILG1CQUFPQSxDQUFDLHFGQUFpQjtBQUNqRCxNQUFNSSxRQUFRQyxPQUFPLENBQUM7QUFDdEIsTUFBTUMsT0FBT0QsT0FBTztBQUNwQixNQUFNRSxPQUFPRixPQUFPO0FBQ3BCLE1BQU1HLE9BQU9ILE9BQU87QUFDcEIsTUFBTUksU0FBUyxDQUFDO0FBQ2hCLDhDQUE4QztBQUM5QyxJQUFJQyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLEdBQUk7SUFDdEJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsUUFBUUMsUUFBUTtJQUNyQixJQUFJQyxTQUFTSjtJQUNiLE1BQU9JLE9BQU9ILE1BQU0sR0FBR0UsU0FBVTtRQUM3QkMsVUFBVUE7SUFDZDtJQUNBLE9BQU9ULE9BQU8sTUFBTVMsT0FBT0MsU0FBUyxDQUFDLEdBQUdGO0FBQzVDO0FBQ0EsU0FBU0csV0FBV0MsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE1BQU07SUFDbkMsTUFBTUMsUUFBUWYsT0FBT2EsT0FBT0UsS0FBSztJQUNqQyxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZixNQUFNQyxRQUFTZixRQUFTYSxRQUFRYjtRQUMvQixJQUFHTixZQUFZc0IsTUFBTSxFQUFFSixVQUFVLFFBQVNGLE9BQU8sQ0FBQ0ssU0FBU0wsTUFBTUssT0FBUSxZQUFZLGlCQUFpQjtZ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O1FBQ3hDdkUsV0FBV25CLE9BQU9xQixRQUFRO1FBQzFCLE9BQU8sSUFBSXBCLFlBQVlXLFFBQVFaLE9BQU9xQjtJQUMxQztJQUNBOzs7Ozs7S0FNQyxHQUNELE9BQU9zRSxVQUFVekMsTUFBTSxFQUFFb0MsT0FBTyxFQUFFO1FBQzlCLElBQUl0RixRQUFRLENBQUMsR0FBR0ssV0FBV3VGLFFBQVEsRUFBRSxDQUFDLEdBQUcxRixVQUFVMkYsUUFBUSxFQUFFM0MsUUFBUTtRQUNyRSxNQUFNN0IsU0FBU1UsVUFBVXVEO1FBQ3pCLElBQUlqRSxPQUFPRyxNQUFNLEVBQUU7WUFDZnhCLFFBQVEsQ0FBQyxHQUFHSyxXQUFXd0IsUUFBUSxFQUFFN0IsT0FBT3FCLE9BQU9FLEtBQUs7UUFDeEQ7UUFDQUosV0FBV25CLE9BQU9xQixRQUFRO1FBQzFCLE9BQU8sSUFBSXBCLFlBQVlXLFFBQVFaLE9BQU9xQjtJQUMxQztBQUNKO0FBQ0F0QixtQkFBbUIsR0FBR0UsYUFDdEIsMERBQTBEO0NBQzFELHdEQUF3RDtDQUN4RCxnQ0FBZ0M7Q0FDaEMsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2ZpeGVkbnVtYmVyLmpzPzg0ZTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpeGVkTnVtYmVyID0gdm9pZCAwO1xuLyoqXG4gKiAgVGhlICoqRml4ZWROdW1iZXIqKiBjbGFzcyBwZXJtaXRzIHVzaW5nIHZhbHVlcyB3aXRoIGRlY2ltYWwgcGxhY2VzLFxuICogIHVzaW5nIGZpeGVkLXBvbnQgbWF0aC5cbiAqXG4gKiAgRml4ZWQtcG9pbnQgbWF0aCBpcyBzdGlsbCBiYXNlZCBvbiBpbnRlZ2VycyB1bmRlci10aGUtaG9vZCwgYnV0IHVzZXMgYW5cbiAqICBpbnRlcm5hbCBvZmZzZXQgdG8gc3RvcmUgZnJhY3Rpb25hbCBjb21wb25lbnRzIGJlbG93LCBhbmQgZWFjaCBvcGVyYXRpb25cbiAqICBjb3JyZWN0cyBmb3IgdGhpcyBhZnRlciBlYWNoIG9wZXJhdGlvbi5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvdXRpbHMvZml4ZWQtcG9pbnQtbWF0aDpGaXhlZC1Qb2ludCBNYXRocyAgW2Fib3V0LWZpeGVkLXBvaW50LW1hdGhdXG4gKi9cbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IG1hdGhzX2pzXzEgPSByZXF1aXJlKFwiLi9tYXRocy5qc1wiKTtcbmNvbnN0IHByb3BlcnRpZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnRpZXMuanNcIik7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgPSAoMCwgbWF0aHNfanNfMS5mcm9tVHdvcykoKDAsIG1hdGhzX2pzXzEubWFzaykodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IC0oMCwgbWF0aHNfanNfMS5mcm9tVHdvcykoKDAsIG1hdGhzX2pzXzEubWFzaykoLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IHNhZmVPcCwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IHZhbFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsID0gKCgodmFsICUgbGltaXQpICsgbGltaXQpICUgbGltaXQpICYgKGxpbWl0IC0gQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBnZXRGb3JtYXQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFsdWUgPSBgZml4ZWQxMjh4JHt2YWx1ZX1gO1xuICAgIH1cbiAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcbiAgICBsZXQgd2lkdGggPSAxMjg7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0cy4uLlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInVmaXhlZFwiKSB7XG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkobWF0Y2gsIFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tIHRoZSBvYmplY3RcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSgod2lkdGggJSA4KSA9PT0gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShkZWNpbWFscyA8PSA4MCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIGRlY2ltYWxzICh0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICBjb25zdCBuYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgIHJldHVybiB7IHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzLCBuYW1lIH07XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWwsIGRlY2ltYWxzKSB7XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAodmFsIDwgQk5fMCkge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB2YWwgKj0gQk5fTjE7XG4gICAgfVxuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAvLyBObyBkZWNpbWFsIHBvaW50IGZvciB3aG9sZSB2YWx1ZXNcbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG4gICAgfVxuICAgIC8vIFBhZCBvdXQgdG8gdGhlIHdob2xlIGNvbXBvbmVudCAoaW5jbHVkaW5nIGEgd2hvbGUgZGlnaXQpXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgc3RyID0gWmVyb3MgKyBzdHI7XG4gICAgfVxuICAgIC8vIEluc2VydCB0aGUgZGVjaW1hbCBwb2ludFxuICAgIGNvbnN0IGluZGV4ID0gc3RyLmxlbmd0aCAtIGRlY2ltYWxzO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpICsgXCIuXCIgKyBzdHIuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAvLyBUcmltIHRoZSB3aG9sZSBjb21wb25lbnQgKGxlYXZpbmcgYXQgbGVhc3Qgb25lIDApXG4gICAgd2hpbGUgKHN0clswXSA9PT0gXCIwXCIgJiYgc3RyWzFdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyBUcmltIHRoZSBkZWNpbWFsIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gXCIwXCIgJiYgc3RyW3N0ci5sZW5ndGggLSAyXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAobmVnYXRpdmUgKyBzdHIpO1xufVxuLyoqXG4gKiAgQSBGaXhlZE51bWJlciByZXByZXNlbnRzIGEgdmFsdWUgb3ZlciBpdHMgW1tGaXhlZEZvcm1hdF1dXG4gKiAgYXJpdGhtZXRpYyBmaWVsZC5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIG1hdGgsIGxvc3NsZXNzbHksIG9uXG4gKiAgdmFsdWVzIHdoaWNoIGhhdmUgZGVjbWlhbCBwbGFjZXMuXG4gKlxuICogIEEgRml4ZWROdW1iZXIgaGFzIGEgZml4ZWQgYml0LXdpZHRoIHRvIHN0b3JlIHZhbHVlcyBpbiwgYW5kIHN0b3JlcyBhbGxcbiAqICB2YWx1ZXMgaW50ZXJuYWxseSBieSBtdWx0aXBseWluZyB0aGUgdmFsdWUgYnkgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZlxuICogICUlZGVjaW1hbHMlJS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBncm93IHRvbyBoaWdoIChjbG9zZSB0b1xuICogIHBvc2l0aXZlIGluZmluaXR5KSBvciB0b28gbG93IChjbG9zZSB0byBuZWdhdGl2ZSBpbmZpbml0eSksIHRoZSB2YWx1ZVxuICogIGlzIHNhaWQgdG8gLy9vdmVyZmxvdy8vLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgYW4gOC1iaXQgc2lnbmVkIHZhbHVlLCB3aXRoIDAgZGVjaW1hbHMgbWF5IG9ubHkgYmUgd2l0aGluXG4gKiAgdGhlIHJhbmdlIGBgLTEyOGBgIHRvIGBgMTI3YGA7IHNvIGBgLTEyOCAtIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWVcbiAqICBgYDEyN2BgLiBMaWtld2lzZSwgYGAxMjcgKyAxYGAgd2lsbCBvdmVyZmxvdyBhbmQgYmVjb21lIGBgLTEyN2BgLlxuICpcbiAqICBNYW55IG9wZXJhdGlvbiBoYXZlIGEgbm9ybWFsIGFuZCAvL3Vuc2FmZS8vIHZhcmlhbnQuIFRoZSBub3JtYWwgdmFyaWFudFxuICogIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gb24gYW55IG92ZXJmbG93LCB3aGlsZSB0aGUgLy91bnNhZmUvL1xuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBhbGxvdyBvdmVyZmxvdywgY29ycnVwdGluZyBpdHMgdmFsdWUgdmFsdWUuXG4gKlxuICogIElmIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0aGF0IGNhdXNlIGEgdmFsdWUgdG8gYmVjb21lIHRvbyBzbWFsbFxuICogIChjbG9zZSB0byB6ZXJvKSwgdGhlIHZhbHVlIGxvc2VzIHByZWNpc29uIGFuZCBpcyBzYWlkIHRvIC8vdW5kZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiB2YWx1ZSB3aXRoIDEgZGVjaW1hbCBwbGFjZSBtYXkgc3RvcmUgYSBudW1iZXIgYXMgc21hbGxcbiAqICBhcyBgYDAuMWBgLCBidXQgdGhlIHZhbHVlIG9mIGBgMC4xIC8gMmBgIGlzIGBgMC4wNWBgLCB3aGljaCBjYW5ub3QgZml0XG4gKiAgaW50byAxIGRlY2ltYWwgcGxhY2UsIHNvIHVuZGVyZmxvdyBvY2N1cnMgd2hpY2ggbWVhbnMgcHJlY2lzaW9uIGlzIGxvc3RcbiAqICBhbmQgdGhlIHZhbHVlIGJlY29tZXMgYGAwYGAuXG4gKlxuICogIFNvbWUgb3BlcmF0aW9ucyBoYXZlIGEgbm9ybWFsIGFuZCAvL3NpZ25hbGxpbmcvLyB2YXJpYW50LiBUaGUgbm9ybWFsXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGlnbm9yZSB1bmRlcmZsb3csIHdoaWxlIHRoZSAvL3NpZ25hbGxpbmcvLyB2YXJpYW50XG4gKiAgd2lsbCB0aG93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIG9uIHVuZGVyZmxvdy5cbiAqL1xuY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgc3BlY2lmaWMgZml4ZWQtcG9pbnQgYXJpdGhtZXRpYyBmaWVsZCBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBmb3JtYXQ7XG4gICAgI2Zvcm1hdDtcbiAgICAvLyBUaGUgYWN0dWFsIHZhbHVlIChhY2NvdW50aW5nIGZvciBkZWNpbWFscylcbiAgICAjdmFsO1xuICAgIC8vIEEgYmFzZS0xMCB2YWx1ZSB0byBtdWx0aXBsZSB2YWx1ZXMgYnkgdG8gbWFpbnRhaW4gdGhlIG1hZ25pdHVkZVxuICAgICN0ZW5zO1xuICAgIC8qKlxuICAgICAqICBUaGlzIGlzIGEgcHJvcGVydHkgc28gY29uc29sZS5sb2cgc2hvd3MgYSBodW1hbi1tZWFuaW5nZnVsIHZhbHVlLlxuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgX3ZhbHVlO1xuICAgIC8vIFVzZSB0aGlzIHdoZW4gY2hhbmdpbmcgdGhpcyBmaWxlIHRvIGdldCBzb21lIHR5cGluZyBpbmZvLFxuICAgIC8vIGJ1dCB0aGVuIHN3aXRjaCB0byBhbnkgdG8gbWFzayB0aGUgaW50ZXJuYWwgdHlwZVxuICAgIC8vY29uc3RydWN0b3IoZ3VhcmQ6IGFueSwgdmFsdWU6IGJpZ2ludCwgZm9ybWF0OiBfRml4ZWRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihndWFyZCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0UHJpdmF0ZSkoZ3VhcmQsIF9ndWFyZCwgXCJGaXhlZE51bWJlclwiKTtcbiAgICAgICAgdGhpcy4jdmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuI2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgY29uc3QgX3ZhbHVlID0gdG9TdHJpbmcodmFsdWUsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgICgwLCBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBmb3JtYXQ6IGZvcm1hdC5uYW1lLCBfdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI3RlbnMgPSBnZXRUZW5zKGZvcm1hdC5kZWNpbWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0cnVlLCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHBlcm1pdHRlZCwgb3RoZXJ3aXNlIG9ubHlcbiAgICAgKiAgcG9zaXRpdmUgdmFsdWVzIGFuZCB6ZXJvIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBzaWduZWQoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuc2lnbmVkOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgdG8gc3RvcmUgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC53aWR0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGluIHRoZSBmaXhlZC1wb2ludCBhcml0aG1lbnQgZmllbGQuXG4gICAgICovXG4gICAgZ2V0IGRlY2ltYWxzKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LmRlY2ltYWxzOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSBhcyBhbiBpbnRlZ2VyLCBiYXNlZCBvbiB0aGUgc21hbGxlc3QgdW5pdCB0aGVcbiAgICAgKiAgW1tkZWNpbWFsc11dIGFsbG93LlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbDsgfVxuICAgICNjaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHRoaXMuZm9ybWF0ID09PSBvdGhlci5mb3JtYXQsIFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuICAgIH1cbiAgICAjY2hlY2tWYWx1ZSh2YWwsIHNhZmVPcCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW1pdCA9IChCTl8xIDw8ICh3aWR0aCAtIEJOXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gLWxpbWl0ICAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogPHN0cmluZz5zYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza2VkID0gbWFzayh2YWwsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHNhZmVPcCA9PSBudWxsIHx8ICh2YWwgPj0gMCAmJiB2YWwgPT09IG1hc2tlZCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogPHN0cmluZz5zYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IG1hc2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHZhbCA9IGNoZWNrVmFsdWUodmFsLCB0aGlzLiNmb3JtYXQsIHNhZmVPcCk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWwsIHRoaXMuI2Zvcm1hdCk7XG4gICAgfVxuICAgICNhZGQobywgc2FmZU9wKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG8pO1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hlY2tWYWx1ZSh0aGlzLiN2YWwgKyBvLiN2YWwsIHNhZmVPcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgYWRkZWRcbiAgICAgKiAgdG8gJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBhZGRVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXG4gICAgICogIHRvICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBhZGQob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2FkZChvdGhlciwgXCJhZGRcIik7IH1cbiAgICAjc3ViKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsIC0gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXG4gICAgICogIGZyb20gJSV0aGlzJSUsIGlnbm9yaW5nIG92ZXJmbG93LlxuICAgICAqL1xuICAgIHN1YlVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jc3ViKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSVvdGhlciUlIHN1YnRyYWN0ZWRcbiAgICAgKiAgZnJvbSAlJXRoaXMlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBzdWIob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlciwgXCJzdWJcIik7IH1cbiAgICAjbXVsKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIG8uI3ZhbCkgLyB0aGlzLiN0ZW5zLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyBvdmVyZmxvdyBhbmQgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgbXVsVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3Vycy5cbiAgICAgKi9cbiAgICBtdWwob3RoZXIpIHsgcmV0dXJuIHRoaXMuI211bChvdGhlciwgXCJtdWxcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIG11bHRpcGxpZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgb3ZlcmZsb3dcbiAgICAgKiAgb2NjdXJzIG9yIGlmIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpIG9jY3Vycy5cbiAgICAgKi9cbiAgICBtdWxTaWduYWwob3RoZXIpIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3ZhbCAqIG90aGVyLiN2YWw7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKCh2YWx1ZSAlIHRoaXMuI3RlbnMpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIG11bFwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm11bFNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gdGhpcy4jdGVucywgXCJtdWxTaWduYWxcIik7XG4gICAgfVxuICAgICNkaXYobywgc2FmZU9wKSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKG8uI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpIC8gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXYob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlciwgXCJkaXZcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgdW5kZXJmbG93XG4gICAgICogIChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlNpZ25hbChvdGhlcikge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShvdGhlci4jdmFsICE9PSBCTl8wLCBcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkaXZcIiwgZmF1bHQ6IFwiZGl2aWRlLWJ5LXplcm9cIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSAodGhpcy4jdmFsICogdGhpcy4jdGVucyk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKCh2YWx1ZSAlIG90aGVyLiN2YWwpID09PSBCTl8wLCBcInByZWNpc2lvbiBsb3N0IGR1cmluZyBzaWduYWxsaW5nIGRpdlwiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRpdlNpZ25hbFwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbHVlIC8gb3RoZXIuI3ZhbCwgXCJkaXZTaWduYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiAlJXRoaXMlJSBhbmQgJSVvdGhlciUlLlxuICAgICAqXG4gICAgICogIFRoaXMgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzb3J0aW5nLCB3aGVyZSBgYC0xYGAgaW1wbGllcyAlJXRoaXMlJVxuICAgICAqICBpcyBzbWFsbGVyLCBgYDFgYCBpbXBsaWVzICUldGhpcyUlIGlzIGxhcmdlciBhbmQgYGAwYGAgaW1wbGllc1xuICAgICAqICBib3RoIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBjbXAob3RoZXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnZhbHVlLCBiID0gb3RoZXIudmFsdWU7XG4gICAgICAgIC8vIENvZXJjZSBhIGFuZCBiIHRvIHRoZSBzYW1lIG1hZ25pdHVkZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBvdGhlci5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgYiAqPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIGEgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbW5wYXJlXG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPT09IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHQob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUlb3RoZXIlJSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgbHRlKG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPD0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID4gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBndGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA+PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBsYXJnZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGZsb29yKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsIDwgQk5fMCkge1xuICAgICAgICAgICAgdmFsIC09IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJmbG9vclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdoaWNoIGlzIHRoZSBzbWFsbGVzdCAqKmludGVnZXIqKlxuICAgICAqICB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKlxuICAgICAqICBUaGUgZGVjaW1hbCBjb21wb25lbnQgb2YgdGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBgYDBgYC5cbiAgICAgKi9cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcy4jdmFsO1xuICAgICAgICBpZiAodGhpcy4jdmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsICs9IHRoaXMuI3RlbnMgLSBCTl8xO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICh0aGlzLiN2YWwgLyB0aGlzLiN0ZW5zKSAqIHRoaXMuI3RlbnM7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHZhbCwgXCJjZWlsaW5nXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgZGVjaW1hbCBjb21wb25lbnRcbiAgICAgKiAgcm91bmRlZCB1cCBvbiB0aWVzIGF0ICUlZGVjaW1hbHMlJSBwbGFjZXMuXG4gICAgICovXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZW5vdWdoIHByZWNpc2lvbiB0byBub3QgYWxyZWFkeSBiZSByb3VuZGVkXG4gICAgICAgIGlmIChkZWNpbWFscyA+PSB0aGlzLmRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuZGVjaW1hbHMgLSBkZWNpbWFscztcbiAgICAgICAgY29uc3QgYnVtcCA9IEJOXzUgKiBnZXRUZW5zKGRlbHRhIC0gMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWUgKyBidW1wO1xuICAgICAgICBjb25zdCB0ZW5zID0gZ2V0VGVucyhkZWx0YSk7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC8gdGVucykgKiB0ZW5zO1xuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCB0aGlzLiNmb3JtYXQsIFwicm91bmRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgdGhpcy4jZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBlcXVhbCB0byBgYDBgYC5cbiAgICAgKi9cbiAgICBpc1plcm8oKSB7IHJldHVybiAodGhpcy4jdmFsID09PSBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSV0aGlzJSUgaXMgbGVzcyB0aGFuIGBgMGBgLlxuICAgICAqL1xuICAgIGlzTmVnYXRpdmUoKSB7IHJldHVybiAodGhpcy4jdmFsIDwgQk5fMCk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mICUldGhpcyUlLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIGZsb2F0IGFwcHJveGltYXRpb24uXG4gICAgICpcbiAgICAgKiAgRHVlIHRvIElFRUUgNzU0IHByZWNpc3Npb24gKG9yIGxhY2sgdGhlcmVvZiksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiAgY2FuIG9ubHkgcmV0dXJuIGFuIGFwcHJveGltYXRpb24gYW5kIG1vc3QgdmFsdWVzIHdpbGwgY29udGFpblxuICAgICAqICByb3VuZGluZyBlcnJvcnMuXG4gICAgICovXG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHNhbWUgdmFsdWUgYnV0IGhhcyBoYWRcbiAgICAgKiAgaXRzIGZpZWxkIHNldCB0byAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgdmFsdWUgY2Fubm90IGZpdCBpbnRvICUlZm9ybWF0JSUuXG4gICAgICovXG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgZGl2aWRlZCBieVxuICAgICAqICAlJWRlY2ltYWwlJSBwbGFjZXMgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgKG9uY2UgYWRqdXN0ZWRcbiAgICAgKiAgZm9yICUlZGVjaW1hbHMlJSkgY2Fubm90IGZpdCBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93XG4gICAgICogIG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVmFsdWUoX3ZhbHVlLCBfZGVjaW1hbHMsIF9mb3JtYXQpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSAoX2RlY2ltYWxzID09IG51bGwpID8gMCA6ICgwLCBtYXRoc19qc18xLmdldE51bWJlcikoX2RlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgdmFsdWUgPSAoMCwgbWF0aHNfanNfMS5nZXRCaWdJbnQpKF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkZWNpbWFscyAtIGZvcm1hdC5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkoKHZhbHVlICUgdGVucykgPT09IEJOXzAsIFwidmFsdWUgbG9zZXMgcHJlY2lzaW9uIGZvciBmb3JtYXRcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVZhbHVlXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlIC89IHRlbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21WYWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSBjYW5ub3QgZml0XG4gICAgICogIGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3cgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoX3ZhbHVlLCBfZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3ZhbHVlLm1hdGNoKC9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8pO1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKG1hdGNoICYmIChtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGgpID4gMCwgXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHN0cmluZyB2YWx1ZVwiLCBcInZhbHVlXCIsIF92YWx1ZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHdob2xlID0gKG1hdGNoWzJdIHx8IFwiMFwiKSwgZGVjaW1hbCA9IChtYXRjaFszXSB8fCBcIlwiKTtcbiAgICAgICAgLy8gUGFkIG91dCB0aGUgZGVjaW1hbHNcbiAgICAgICAgd2hpbGUgKGRlY2ltYWwubGVuZ3RoIDwgZm9ybWF0LmRlY2ltYWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFplcm9zO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHByZWNpc2lvbiBpcyBzYWZlXG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGRlY2ltYWwuc3Vic3RyaW5nKGZvcm1hdC5kZWNpbWFscykubWF0Y2goL14wKiQvKSwgXCJ0b28gbWFueSBkZWNpbWFscyBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVN0cmluZ1wiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIHBhZGRpbmdcbiAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyaW5nKDAsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KG1hdGNoWzFdICsgd2hvbGUgKyBkZWNpbWFsKTtcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21TdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb25cbiAgICAgKiAgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSBkdWUgdG8gb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gKDAsIG1hdGhzX2pzXzEudG9CaWdJbnQpKCgwLCBkYXRhX2pzXzEuZ2V0Qnl0ZXMpKF92YWx1ZSwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIG1hdGhzX2pzXzEuZnJvbVR3b3MpKHZhbHVlLCBmb3JtYXQud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tQnl0ZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG59XG5leHBvcnRzLkZpeGVkTnVtYmVyID0gRml4ZWROdW1iZXI7XG4vL2NvbnN0IGYxID0gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhcIjEyLjU2XCIsIFwiZml4ZWQxNngyXCIpO1xuLy9jb25zdCBmMiA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIwLjNcIiwgXCJmaXhlZDE2eDJcIik7XG4vL2NvbnNvbGUubG9nKGYxLmRpdlNpZ25hbChmMikpO1xuLy9jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkZpeGVkTnVtYmVyIiwiZGF0YV9qc18xIiwicmVxdWlyZSIsImVycm9yc19qc18xIiwibWF0aHNfanNfMSIsInByb3BlcnRpZXNfanNfMSIsIkJOX04xIiwiQmlnSW50IiwiQk5fMCIsIkJOXzEiLCJCTl81IiwiX2d1YXJkIiwiWmVyb3MiLCJsZW5ndGgiLCJnZXRUZW5zIiwiZGVjaW1hbHMiLCJyZXN1bHQiLCJzdWJzdHJpbmciLCJjaGVja1ZhbHVlIiwidmFsIiwiZm9ybWF0Iiwic2FmZU9wIiwid2lkdGgiLCJzaWduZWQiLCJsaW1pdCIsImFzc2VydCIsIm9wZXJhdGlvbiIsImZhdWx0IiwiZnJvbVR3b3MiLCJtYXNrIiwiZ2V0Rm9ybWF0IiwibWF0Y2giLCJhc3NlcnRBcmd1bWVudCIsInBhcnNlSW50IiwidiIsImNoZWNrIiwia2V5IiwidHlwZSIsImRlZmF1bHRWYWx1ZSIsIm5hbWUiLCJTdHJpbmciLCJ0b1N0cmluZyIsIm5lZ2F0aXZlIiwic3RyIiwiaW5kZXgiLCJ0ZW5zIiwiY29uc3RydWN0b3IiLCJndWFyZCIsImFzc2VydFByaXZhdGUiLCJfdmFsdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY2hlY2tGb3JtYXQiLCJvdGhlciIsImFkZCIsIm8iLCJhZGRVbnNhZmUiLCJzdWIiLCJzdWJVbnNhZmUiLCJtdWwiLCJtdWxVbnNhZmUiLCJtdWxTaWduYWwiLCJkaXYiLCJkaXZVbnNhZmUiLCJkaXZTaWduYWwiLCJjbXAiLCJhIiwiYiIsImRlbHRhIiwiZXEiLCJsdCIsImx0ZSIsImd0IiwiZ3RlIiwiZmxvb3IiLCJjZWlsaW5nIiwicm91bmQiLCJidW1wIiwiaXNaZXJvIiwiaXNOZWdhdGl2ZSIsInRvVW5zYWZlRmxvYXQiLCJwYXJzZUZsb2F0IiwidG9Gb3JtYXQiLCJmcm9tU3RyaW5nIiwiZnJvbVZhbHVlIiwiX2RlY2ltYWxzIiwiX2Zvcm1hdCIsImdldE51bWJlciIsImdldEJpZ0ludCIsIndob2xlIiwiZGVjaW1hbCIsImZyb21CeXRlcyIsInRvQmlnSW50IiwiZ2V0Qnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/geturl.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/geturl.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getUrl = exports.createGetUrl = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/ethers/node_modules/tslib/tslib.es6.js\");\nconst http_1 = tslib_1.__importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = tslib_1.__importDefault(__webpack_require__(/*! https */ \"https\"));\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  @_ignore:\n */ function createGetUrl(options) {\n    async function getUrl(req, signal) {\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n        (0, errors_js_1.assert)(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n            info: {\n                protocol\n            },\n            operation: \"request\"\n        });\n        (0, errors_js_1.assert)(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n        const method = req.method;\n        const headers = Object.assign({}, req.headers);\n        const reqOptions = {\n            method,\n            headers\n        };\n        if (options) {\n            if (options.agent) {\n                reqOptions.agent = options.agent;\n            }\n        }\n        const request = (protocol === \"http\" ? http_1.default : https_1.default).request(req.url, reqOptions);\n        request.setTimeout(req.timeout);\n        const body = req.body;\n        if (body) {\n            request.write(Buffer.from(body));\n        }\n        request.end();\n        return new Promise((resolve, reject)=>{\n            // @TODO: Node 15 added AbortSignal; once we drop support for\n            // Node14, we can add that in here too\n            request.once(\"response\", (resp)=>{\n                const statusCode = resp.statusCode || 0;\n                const statusMessage = resp.statusMessage || \"\";\n                const headers = Object.keys(resp.headers || {}).reduce((accum, name)=>{\n                    let value = resp.headers[name] || \"\";\n                    if (Array.isArray(value)) {\n                        value = value.join(\", \");\n                    }\n                    accum[name] = value;\n                    return accum;\n                }, {});\n                let body = null;\n                //resp.setEncoding(\"utf8\");\n                resp.on(\"data\", (chunk)=>{\n                    if (signal) {\n                        try {\n                            signal.checkSignal();\n                        } catch (error) {\n                            return reject(error);\n                        }\n                    }\n                    if (body == null) {\n                        body = chunk;\n                    } else {\n                        const newBody = new Uint8Array(body.length + chunk.length);\n                        newBody.set(body, 0);\n                        newBody.set(chunk, body.length);\n                        body = newBody;\n                    }\n                });\n                resp.on(\"end\", ()=>{\n                    if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                        body = (0, data_js_1.getBytes)((0, zlib_1.gunzipSync)(body));\n                    }\n                    resolve({\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    });\n                });\n                resp.on(\"error\", (error)=>{\n                    //@TODO: Should this just return nornal response with a server error?\n                    error.response = {\n                        statusCode,\n                        statusMessage,\n                        headers,\n                        body\n                    };\n                    reject(error);\n                });\n            });\n            request.on(\"error\", (error)=>{\n                reject(error);\n            });\n        });\n    }\n    return getUrl;\n}\nexports.createGetUrl = createGetUrl;\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl = createGetUrl({});\n/**\n *  @_ignore:\n */ async function getUrl(req, signal) {\n    return defaultGetUrl(req, signal);\n}\nexports.getUrl = getUrl; //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9nZXR1cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUM3QyxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywwRUFBTztBQUMvQixNQUFNQyxTQUFTRixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLGtCQUFNO0FBQ3JELE1BQU1HLFVBQVVKLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsb0JBQU87QUFDdkQsTUFBTUksU0FBU0osbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUssY0FBY0wsbUJBQU9BLENBQUMsNkVBQWE7QUFDekMsTUFBTU0sWUFBWU4sbUJBQU9BLENBQUMseUVBQVc7QUFDckM7O0NBRUMsR0FDRCxTQUFTRixhQUFhUyxPQUFPO0lBQ3pCLGVBQWVWLE9BQU9XLEdBQUcsRUFBRUMsTUFBTTtRQUM3QixNQUFNQyxXQUFXRixJQUFJRyxHQUFHLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxXQUFXO1FBQ2pELElBQUdSLFlBQVlTLE1BQU0sRUFBRUosYUFBYSxVQUFVQSxhQUFhLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRUEsU0FBUyxDQUFDLEVBQUUseUJBQXlCO1lBQzlISyxNQUFNO2dCQUFFTDtZQUFTO1lBQ2pCTSxXQUFXO1FBQ2Y7UUFDQyxJQUFHWCxZQUFZUyxNQUFNLEVBQUVKLGFBQWEsV0FBVyxDQUFDRixJQUFJUyxXQUFXLElBQUlULElBQUlVLDJCQUEyQixFQUFFLCtDQUErQyx5QkFBeUI7WUFDektGLFdBQVc7UUFDZjtRQUNBLE1BQU1HLFNBQVNYLElBQUlXLE1BQU07UUFDekIsTUFBTUMsVUFBVTNCLE9BQU80QixNQUFNLENBQUMsQ0FBQyxHQUFHYixJQUFJWSxPQUFPO1FBQzdDLE1BQU1FLGFB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Ly4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvZ2V0dXJsLmpzPzJmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVybCA9IGV4cG9ydHMuY3JlYXRlR2V0VXJsID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IGh0dHBfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJodHRwXCIpKTtcbmNvbnN0IGh0dHBzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG4vKipcbiAqICBAX2lnbm9yZTpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2V0VXJsKG9wdGlvbnMpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBzaWduYWwpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSByZXEudXJsLnNwbGl0KFwiOlwiKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIiwgYHVuc3VwcG9ydGVkIHByb3RvY29sICR7cHJvdG9jb2x9YCwgXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIiwge1xuICAgICAgICAgICAgaW5mbzogeyBwcm90b2NvbCB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlcXVlc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCAhcmVxLmNyZWRlbnRpYWxzIHx8IHJlcS5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24sIFwiaW5zZWN1cmUgYXV0aG9yaXplZCBjb25uZWN0aW9ucyB1bnN1cHBvcnRlZFwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVxdWVzdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxLmhlYWRlcnMpO1xuICAgICAgICBjb25zdCByZXFPcHRpb25zID0geyBtZXRob2QsIGhlYWRlcnMgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgICAgICAgICAgICAgcmVxT3B0aW9ucy5hZ2VudCA9IG9wdGlvbnMuYWdlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9ICgocHJvdG9jb2wgPT09IFwiaHR0cFwiKSA/IGh0dHBfMS5kZWZhdWx0IDogaHR0cHNfMS5kZWZhdWx0KS5yZXF1ZXN0KHJlcS51cmwsIHJlcU9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQocmVxLnRpbWVvdXQpO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVxLmJvZHk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICByZXF1ZXN0LndyaXRlKEJ1ZmZlci5mcm9tKGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gQFRPRE86IE5vZGUgMTUgYWRkZWQgQWJvcnRTaWduYWw7IG9uY2Ugd2UgZHJvcCBzdXBwb3J0IGZvclxuICAgICAgICAgICAgLy8gTm9kZTE0LCB3ZSBjYW4gYWRkIHRoYXQgaW4gaGVyZSB0b29cbiAgICAgICAgICAgIHJlcXVlc3Qub25jZShcInJlc3BvbnNlXCIsIChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3Auc3RhdHVzQ29kZSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSByZXNwLnN0YXR1c01lc3NhZ2UgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMocmVzcC5oZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGFjY3VtLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3AuaGVhZGVyc1tuYW1lXSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vcmVzcC5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLmNoZWNrU2lnbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdCb2R5ID0gbmV3IFVpbnQ4QXJyYXkoYm9keS5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Qm9keS5zZXQoYm9keSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCb2R5LnNldChjaHVuaywgYm9keS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ld0JvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LWVuY29kaW5nXCJdID09PSBcImd6aXBcIiAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gKDAsIGRhdGFfanNfMS5nZXRCeXRlcykoKDAsIHpsaWJfMS5ndW56aXBTeW5jKShib2R5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzcC5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL0BUT0RPOiBTaG91bGQgdGhpcyBqdXN0IHJldHVybiBub3JuYWwgcmVzcG9uc2Ugd2l0aCBhIHNlcnZlciBlcnJvcj9cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMsIGJvZHkgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIChlcnJvcikgPT4geyByZWplY3QoZXJyb3IpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRVcmw7XG59XG5leHBvcnRzLmNyZWF0ZUdldFVybCA9IGNyZWF0ZUdldFVybDtcbi8vIEBUT0RPOiByZW1vdmUgaW4gdjc7IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0XG5jb25zdCBkZWZhdWx0R2V0VXJsID0gY3JlYXRlR2V0VXJsKHt9KTtcbi8qKlxuICogIEBfaWdub3JlOlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVcmwocmVxLCBzaWduYWwpIHtcbiAgICByZXR1cm4gZGVmYXVsdEdldFVybChyZXEsIHNpZ25hbCk7XG59XG5leHBvcnRzLmdldFVybCA9IGdldFVybDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRVcmwiLCJjcmVhdGVHZXRVcmwiLCJ0c2xpYl8xIiwicmVxdWlyZSIsImh0dHBfMSIsIl9faW1wb3J0RGVmYXVsdCIsImh0dHBzXzEiLCJ6bGliXzEiLCJlcnJvcnNfanNfMSIsImRhdGFfanNfMSIsIm9wdGlvbnMiLCJyZXEiLCJzaWduYWwiLCJwcm90b2NvbCIsInVybCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJhc3NlcnQiLCJpbmZvIiwib3BlcmF0aW9uIiwiY3JlZGVudGlhbHMiLCJhbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24iLCJtZXRob2QiLCJoZWFkZXJzIiwiYXNzaWduIiwicmVxT3B0aW9ucyIsImFnZW50IiwicmVxdWVzdCIsImRlZmF1bHQiLCJzZXRUaW1lb3V0IiwidGltZW91dCIsImJvZHkiLCJ3cml0ZSIsIkJ1ZmZlciIsImZyb20iLCJlbmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uY2UiLCJyZXNwIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJuYW1lIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsIm9uIiwiY2h1bmsiLCJjaGVja1NpZ25hbCIsImVycm9yIiwibmV3Qm9keSIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJzZXQiLCJnZXRCeXRlcyIsImd1bnppcFN5bmMiLCJyZXNwb25zZSIsImRlZmF1bHRHZXRVcmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/geturl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  There are many simple utilities required to interact with\n *  Ethereum and to simplify the library, without increasing\n *  the library dependencies for simple functions.\n *\n *  @_section api/utils:Utilities  [about-utils]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;\nexports.uuidV4 = exports.Utf8ErrorFuncs = void 0;\nvar base58_js_1 = __webpack_require__(/*! ./base58.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/base58.js\");\nObject.defineProperty(exports, \"decodeBase58\", ({\n    enumerable: true,\n    get: function() {\n        return base58_js_1.decodeBase58;\n    }\n}));\nObject.defineProperty(exports, \"encodeBase58\", ({\n    enumerable: true,\n    get: function() {\n        return base58_js_1.encodeBase58;\n    }\n}));\nvar base64_js_1 = __webpack_require__(/*! ./base64.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/base64.js\");\nObject.defineProperty(exports, \"decodeBase64\", ({\n    enumerable: true,\n    get: function() {\n        return base64_js_1.decodeBase64;\n    }\n}));\nObject.defineProperty(exports, \"encodeBase64\", ({\n    enumerable: true,\n    get: function() {\n        return base64_js_1.encodeBase64;\n    }\n}));\nvar data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nObject.defineProperty(exports, \"getBytes\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.getBytes;\n    }\n}));\nObject.defineProperty(exports, \"getBytesCopy\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.getBytesCopy;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"isBytesLike\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.isBytesLike;\n    }\n}));\nObject.defineProperty(exports, \"hexlify\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.hexlify;\n    }\n}));\nObject.defineProperty(exports, \"concat\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.concat;\n    }\n}));\nObject.defineProperty(exports, \"dataLength\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.dataLength;\n    }\n}));\nObject.defineProperty(exports, \"dataSlice\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.dataSlice;\n    }\n}));\nObject.defineProperty(exports, \"stripZerosLeft\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.stripZerosLeft;\n    }\n}));\nObject.defineProperty(exports, \"zeroPadValue\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.zeroPadValue;\n    }\n}));\nObject.defineProperty(exports, \"zeroPadBytes\", ({\n    enumerable: true,\n    get: function() {\n        return data_js_1.zeroPadBytes;\n    }\n}));\nvar errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nObject.defineProperty(exports, \"isCallException\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.isCallException;\n    }\n}));\nObject.defineProperty(exports, \"isError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.isError;\n    }\n}));\nObject.defineProperty(exports, \"assert\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.assert;\n    }\n}));\nObject.defineProperty(exports, \"assertArgument\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.assertArgument;\n    }\n}));\nObject.defineProperty(exports, \"assertArgumentCount\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.assertArgumentCount;\n    }\n}));\nObject.defineProperty(exports, \"assertPrivate\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.assertPrivate;\n    }\n}));\nObject.defineProperty(exports, \"assertNormalize\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.assertNormalize;\n    }\n}));\nObject.defineProperty(exports, \"makeError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.makeError;\n    }\n}));\nvar events_js_1 = __webpack_require__(/*! ./events.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/events.js\");\nObject.defineProperty(exports, \"EventPayload\", ({\n    enumerable: true,\n    get: function() {\n        return events_js_1.EventPayload;\n    }\n}));\nvar fetch_js_1 = __webpack_require__(/*! ./fetch.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/fetch.js\");\nObject.defineProperty(exports, \"FetchRequest\", ({\n    enumerable: true,\n    get: function() {\n        return fetch_js_1.FetchRequest;\n    }\n}));\nObject.defineProperty(exports, \"FetchResponse\", ({\n    enumerable: true,\n    get: function() {\n        return fetch_js_1.FetchResponse;\n    }\n}));\nObject.defineProperty(exports, \"FetchCancelSignal\", ({\n    enumerable: true,\n    get: function() {\n        return fetch_js_1.FetchCancelSignal;\n    }\n}));\nvar fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\");\nObject.defineProperty(exports, \"FixedNumber\", ({\n    enumerable: true,\n    get: function() {\n        return fixednumber_js_1.FixedNumber;\n    }\n}));\nvar maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nObject.defineProperty(exports, \"fromTwos\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.fromTwos;\n    }\n}));\nObject.defineProperty(exports, \"toTwos\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toTwos;\n    }\n}));\nObject.defineProperty(exports, \"mask\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.mask;\n    }\n}));\nObject.defineProperty(exports, \"getBigInt\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.getBigInt;\n    }\n}));\nObject.defineProperty(exports, \"getNumber\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.getNumber;\n    }\n}));\nObject.defineProperty(exports, \"getUint\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.getUint;\n    }\n}));\nObject.defineProperty(exports, \"toBigInt\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toBigInt;\n    }\n}));\nObject.defineProperty(exports, \"toNumber\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toNumber;\n    }\n}));\nObject.defineProperty(exports, \"toBeHex\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toBeHex;\n    }\n}));\nObject.defineProperty(exports, \"toBeArray\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toBeArray;\n    }\n}));\nObject.defineProperty(exports, \"toQuantity\", ({\n    enumerable: true,\n    get: function() {\n        return maths_js_1.toQuantity;\n    }\n}));\nvar properties_js_1 = __webpack_require__(/*! ./properties.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\");\nObject.defineProperty(exports, \"resolveProperties\", ({\n    enumerable: true,\n    get: function() {\n        return properties_js_1.resolveProperties;\n    }\n}));\nObject.defineProperty(exports, \"defineProperties\", ({\n    enumerable: true,\n    get: function() {\n        return properties_js_1.defineProperties;\n    }\n}));\nvar rlp_decode_js_1 = __webpack_require__(/*! ./rlp-decode.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js\");\nObject.defineProperty(exports, \"decodeRlp\", ({\n    enumerable: true,\n    get: function() {\n        return rlp_decode_js_1.decodeRlp;\n    }\n}));\nvar rlp_encode_js_1 = __webpack_require__(/*! ./rlp-encode.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js\");\nObject.defineProperty(exports, \"encodeRlp\", ({\n    enumerable: true,\n    get: function() {\n        return rlp_encode_js_1.encodeRlp;\n    }\n}));\nvar units_js_1 = __webpack_require__(/*! ./units.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/units.js\");\nObject.defineProperty(exports, \"formatEther\", ({\n    enumerable: true,\n    get: function() {\n        return units_js_1.formatEther;\n    }\n}));\nObject.defineProperty(exports, \"parseEther\", ({\n    enumerable: true,\n    get: function() {\n        return units_js_1.parseEther;\n    }\n}));\nObject.defineProperty(exports, \"formatUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units_js_1.formatUnits;\n    }\n}));\nObject.defineProperty(exports, \"parseUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units_js_1.parseUnits;\n    }\n}));\nvar utf8_js_1 = __webpack_require__(/*! ./utf8.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/utf8.js\");\nObject.defineProperty(exports, \"toUtf8Bytes\", ({\n    enumerable: true,\n    get: function() {\n        return utf8_js_1.toUtf8Bytes;\n    }\n}));\nObject.defineProperty(exports, \"toUtf8CodePoints\", ({\n    enumerable: true,\n    get: function() {\n        return utf8_js_1.toUtf8CodePoints;\n    }\n}));\nObject.defineProperty(exports, \"toUtf8String\", ({\n    enumerable: true,\n    get: function() {\n        return utf8_js_1.toUtf8String;\n    }\n}));\nObject.defineProperty(exports, \"Utf8ErrorFuncs\", ({\n    enumerable: true,\n    get: function() {\n        return utf8_js_1.Utf8ErrorFuncs;\n    }\n}));\nvar uuid_js_1 = __webpack_require__(/*! ./uuid.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/uuid.js\");\nObject.defineProperty(exports, \"uuidV4\", ({\n    enumerable: true,\n    get: function() {\n        return uuid_js_1.uuidV4;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Q0FNQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLHdCQUF3QixHQUFHQSxtQkFBbUIsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSxrQkFBa0IsR0FBR0EsaUJBQWlCLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxjQUFjLEdBQUdBLGdCQUFnQixHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHFCQUFxQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLGlCQUFpQixHQUFHQSx1QkFBdUIsR0FBR0EscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUdBLHVCQUF1QixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0Esa0JBQWtCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN2a0NBLGNBQWMsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUMvQyxJQUFJc0QsY0FBY0MsbUJBQU9BLENBQUMsNkVBQWE7QUFDdkN6RCxnREFBK0M7SUFBRTBELFlBQVk7SUFBTUMs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QVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ZLFVBQVVoQixjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0gsSUFBSWlCLFlBQVlmLG1CQUFPQSxDQUFDLHlFQUFXO0FBQ25DekQsMENBQXlDO0lBQUUwRCxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPYSxVQUFVbEIsTUFBTTtJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQzdHLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL2luZGV4LmpzPzhmZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBUaGVyZSBhcmUgbWFueSBzaW1wbGUgdXRpbGl0aWVzIHJlcXVpcmVkIHRvIGludGVyYWN0IHdpdGhcbiAqICBFdGhlcmV1bSBhbmQgdG8gc2ltcGxpZnkgdGhlIGxpYnJhcnksIHdpdGhvdXQgaW5jcmVhc2luZ1xuICogIHRoZSBsaWJyYXJ5IGRlcGVuZGVuY2llcyBmb3Igc2ltcGxlIGZ1bmN0aW9ucy5cbiAqXG4gKiAgQF9zZWN0aW9uIGFwaS91dGlsczpVdGlsaXRpZXMgIFthYm91dC11dGlsc11cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBleHBvcnRzLnRvVXRmOENvZGVQb2ludHMgPSBleHBvcnRzLnRvVXRmOEJ5dGVzID0gZXhwb3J0cy5wYXJzZVVuaXRzID0gZXhwb3J0cy5mb3JtYXRVbml0cyA9IGV4cG9ydHMucGFyc2VFdGhlciA9IGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBleHBvcnRzLmVuY29kZVJscCA9IGV4cG9ydHMuZGVjb2RlUmxwID0gZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IGV4cG9ydHMudG9RdWFudGl0eSA9IGV4cG9ydHMudG9CZUFycmF5ID0gZXhwb3J0cy50b0JlSGV4ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMudG9CaWdJbnQgPSBleHBvcnRzLmdldFVpbnQgPSBleHBvcnRzLmdldE51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gZXhwb3J0cy5GaXhlZE51bWJlciA9IGV4cG9ydHMuRmV0Y2hDYW5jZWxTaWduYWwgPSBleHBvcnRzLkZldGNoUmVzcG9uc2UgPSBleHBvcnRzLkZldGNoUmVxdWVzdCA9IGV4cG9ydHMuRXZlbnRQYXlsb2FkID0gZXhwb3J0cy5tYWtlRXJyb3IgPSBleHBvcnRzLmFzc2VydE5vcm1hbGl6ZSA9IGV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGV4cG9ydHMuYXNzZXJ0QXJndW1lbnRDb3VudCA9IGV4cG9ydHMuYXNzZXJ0QXJndW1lbnQgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuaXNFcnJvciA9IGV4cG9ydHMuaXNDYWxsRXhjZXB0aW9uID0gZXhwb3J0cy56ZXJvUGFkQnl0ZXMgPSBleHBvcnRzLnplcm9QYWRWYWx1ZSA9IGV4cG9ydHMuc3RyaXBaZXJvc0xlZnQgPSBleHBvcnRzLmRhdGFTbGljZSA9IGV4cG9ydHMuZGF0YUxlbmd0aCA9IGV4cG9ydHMuY29uY2F0ID0gZXhwb3J0cy5oZXhsaWZ5ID0gZXhwb3J0cy5pc0J5dGVzTGlrZSA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmdldEJ5dGVzQ29weSA9IGV4cG9ydHMuZ2V0Qnl0ZXMgPSBleHBvcnRzLmVuY29kZUJhc2U2NCA9IGV4cG9ydHMuZGVjb2RlQmFzZTY0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNTggPSBleHBvcnRzLmRlY29kZUJhc2U1OCA9IHZvaWQgMDtcbmV4cG9ydHMudXVpZFY0ID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IHZvaWQgMDtcbnZhciBiYXNlNThfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2U1OC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUJhc2U1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTU4X2pzXzEuZGVjb2RlQmFzZTU4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlQmFzZTU4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlNThfanNfMS5lbmNvZGVCYXNlNTg7IH0gfSk7XG52YXIgYmFzZTY0X2pzXzEgPSByZXF1aXJlKFwiLi9iYXNlNjQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVCYXNlNjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2U2NF9qc18xLmRlY29kZUJhc2U2NDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUJhc2U2NFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFzZTY0X2pzXzEuZW5jb2RlQmFzZTY0OyB9IH0pO1xudmFyIGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmdldEJ5dGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Qnl0ZXNDb3B5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuZ2V0Qnl0ZXNDb3B5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5pc0hleFN0cmluZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnl0ZXNMaWtlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuaXNCeXRlc0xpa2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhsaWZ5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuaGV4bGlmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLmNvbmNhdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRhdGFMZW5ndGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5kYXRhTGVuZ3RoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGF0YVNsaWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkYXRhX2pzXzEuZGF0YVNsaWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaXBaZXJvc0xlZnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfanNfMS5zdHJpcFplcm9zTGVmdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInplcm9QYWRWYWx1ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLnplcm9QYWRWYWx1ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInplcm9QYWRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YV9qc18xLnplcm9QYWRCeXRlczsgfSB9KTtcbnZhciBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ2FsbEV4Y2VwdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuaXNDYWxsRXhjZXB0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuaXNFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuYXNzZXJ0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0QXJndW1lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0QXJndW1lbnRDb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnRDb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFByaXZhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmFzc2VydFByaXZhdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnROb3JtYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLmFzc2VydE5vcm1hbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEubWFrZUVycm9yOyB9IH0pO1xudmFyIGV2ZW50c19qc18xID0gcmVxdWlyZShcIi4vZXZlbnRzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRQYXlsb2FkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfanNfMS5FdmVudFBheWxvYWQ7IH0gfSk7XG52YXIgZmV0Y2hfanNfMSA9IHJlcXVpcmUoXCIuL2ZldGNoLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmV0Y2hSZXF1ZXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmZXRjaF9qc18xLkZldGNoUmVxdWVzdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZldGNoUmVzcG9uc2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoX2pzXzEuRmV0Y2hSZXNwb25zZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZldGNoQ2FuY2VsU2lnbmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmZXRjaF9qc18xLkZldGNoQ2FuY2VsU2lnbmFsOyB9IH0pO1xudmFyIGZpeGVkbnVtYmVyX2pzXzEgPSByZXF1aXJlKFwiLi9maXhlZG51bWJlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaXhlZG51bWJlcl9qc18xLkZpeGVkTnVtYmVyOyB9IH0pO1xudmFyIG1hdGhzX2pzXzEgPSByZXF1aXJlKFwiLi9tYXRocy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21Ud29zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLmZyb21Ud29zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Ud29zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvVHdvczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1hc2tcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEubWFzazsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpZ0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS5nZXRCaWdJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXROdW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEuZ2V0TnVtYmVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VWludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS5nZXRVaW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CaWdJbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9CaWdJbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b051bWJlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b051bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmVIZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhzX2pzXzEudG9CZUhleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmVBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aHNfanNfMS50b0JlQXJyYXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1F1YW50aXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoc19qc18xLnRvUXVhbnRpdHk7IH0gfSk7XG52YXIgcHJvcGVydGllc19qc18xID0gcmVxdWlyZShcIi4vcHJvcGVydGllcy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wZXJ0aWVzX2pzXzEucmVzb2x2ZVByb3BlcnRpZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZpbmVQcm9wZXJ0aWVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9wZXJ0aWVzX2pzXzEuZGVmaW5lUHJvcGVydGllczsgfSB9KTtcbnZhciBybHBfZGVjb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9ybHAtZGVjb2RlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlUmxwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBybHBfZGVjb2RlX2pzXzEuZGVjb2RlUmxwOyB9IH0pO1xudmFyIHJscF9lbmNvZGVfanNfMSA9IHJlcXVpcmUoXCIuL3JscC1lbmNvZGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVSbHBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJscF9lbmNvZGVfanNfMS5lbmNvZGVSbHA7IH0gfSk7XG52YXIgdW5pdHNfanNfMSA9IHJlcXVpcmUoXCIuL3VuaXRzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0RXRoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzX2pzXzEuZm9ybWF0RXRoZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUV0aGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0c19qc18xLnBhcnNlRXRoZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JtYXRVbml0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHNfanNfMS5mb3JtYXRVbml0czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlVW5pdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaXRzX2pzXzEucGFyc2VVbml0czsgfSB9KTtcbnZhciB1dGY4X2pzXzEgPSByZXF1aXJlKFwiLi91dGY4LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfanNfMS50b1V0ZjhCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvVXRmOENvZGVQb2ludHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfanNfMS50b1V0ZjhDb2RlUG9pbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9VdGY4U3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGY4X2pzXzEudG9VdGY4U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOEVycm9yRnVuY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0ZjhfanNfMS5VdGY4RXJyb3JGdW5jczsgfSB9KTtcbnZhciB1dWlkX2pzXzEgPSByZXF1aXJlKFwiLi91dWlkLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXVpZFY0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dWlkX2pzXzEudXVpZFY0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidG9VdGY4U3RyaW5nIiwidG9VdGY4Q29kZVBvaW50cyIsInRvVXRmOEJ5dGVzIiwicGFyc2VVbml0cyIsImZvcm1hdFVuaXRzIiwicGFyc2VFdGhlciIsImZvcm1hdEV0aGVyIiwiZW5jb2RlUmxwIiwiZGVjb2RlUmxwIiwiZGVmaW5lUHJvcGVydGllcyIsInJlc29sdmVQcm9wZXJ0aWVzIiwidG9RdWFudGl0eSIsInRvQmVBcnJheSIsInRvQmVIZXgiLCJ0b051bWJlciIsInRvQmlnSW50IiwiZ2V0VWludCIsImdldE51bWJlciIsImdldEJpZ0ludCIsIm1hc2siLCJ0b1R3b3MiLCJmcm9tVHdvcyIsIkZpeGVkTnVtYmVyIiwiRmV0Y2hDYW5jZWxTaWduYWwiLCJGZXRjaFJlc3BvbnNlIiwiRmV0Y2hSZXF1ZXN0IiwiRXZlbnRQYXlsb2FkIiwibWFrZUVycm9yIiwiYXNzZXJ0Tm9ybWFsaXplIiwiYXNzZXJ0UHJpdmF0ZSIsImFzc2VydEFyZ3VtZW50Q291bnQiLCJhc3NlcnRBcmd1bWVudCIsImFzc2VydCIsImlzRXJyb3IiLCJpc0NhbGxFeGNlcHRpb24iLCJ6ZXJvUGFkQnl0ZXMiLCJ6ZXJvUGFkVmFsdWUiLCJzdHJpcFplcm9zTGVmdCIsImRhdGFTbGljZSIsImRhdGFMZW5ndGgiLCJjb25jYXQiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJpc0hleFN0cmluZyIsImdldEJ5dGVzQ29weSIsImdldEJ5dGVzIiwiZW5jb2RlQmFzZTY0IiwiZGVjb2RlQmFzZTY0IiwiZW5jb2RlQmFzZTU4IiwiZGVjb2RlQmFzZTU4IiwidXVpZFY0IiwiVXRmOEVycm9yRnVuY3MiLCJiYXNlNThfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYmFzZTY0X2pzXzEiLCJkYXRhX2pzXzEiLCJlcnJvcnNfanNfMSIsImV2ZW50c19qc18xIiwiZmV0Y2hfanNfMSIsImZpeGVkbnVtYmVyX2pzXzEiLCJtYXRoc19qc18xIiwicHJvcGVydGllc19qc18xIiwicmxwX2RlY29kZV9qc18xIiwicmxwX2VuY29kZV9qc18xIiwidW5pdHNfanNfMSIsInV0ZjhfanNfMSIsInV1aWRfanNfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/maths.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;\n/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */ const data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */ function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    (0, errors_js_1.assert)(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\",\n        fault: \"overflow\",\n        value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> width - BN_1) {\n        const mask = (BN_1 << width) - BN_1;\n        return -((~value & mask) + BN_1);\n    }\n    return value;\n}\nexports.fromTwos = fromTwos;\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */ function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = BN_1 << width - BN_1;\n    if (value < BN_0) {\n        value = -value;\n        (0, errors_js_1.assert)(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return (~value & mask) + BN_1;\n    } else {\n        (0, errors_js_1.assert)(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\",\n            fault: \"overflow\",\n            value: _value\n        });\n    }\n    return value;\n}\nexports.toTwos = toTwos;\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */ function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & (BN_1 << bits) - BN_1;\n}\nexports.mask = mask;\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */ function getBigInt(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            return value;\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            } catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexports.getBigInt = getBigInt;\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */ function getUint(value, name) {\n    const result = getBigInt(value, name);\n    (0, errors_js_1.assert)(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\",\n        operation: \"getUint\",\n        value\n    });\n    return result;\n}\nexports.getUint = getUint;\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */ function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value){\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\nexports.toBigInt = toBigInt;\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */ function getNumber(value, name) {\n    switch(typeof value){\n        case \"bigint\":\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            (0, errors_js_1.assertArgument)(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            } catch (e) {\n                (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    (0, errors_js_1.assertArgument)(false, \"invalid numeric value\", name || \"value\", value);\n}\nexports.getNumber = getNumber;\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */ function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\nexports.toNumber = toNumber;\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */ function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    } else {\n        const width = getNumber(_width, \"width\");\n        (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bits)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while(result.length < width * 2){\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\nexports.toBeHex = toBeHex;\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */ function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < result.length; i++){\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\nexports.toBeArray = toBeArray;\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */ function toQuantity(value) {\n    let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);\n    while(result.startsWith(\"0\")){\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\nexports.toQuantity = toQuantity; //# sourceMappingURL=maths.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9tYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLGlCQUFpQixHQUFHQSxlQUFlLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLFlBQVksR0FBR0EsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ25OOzs7O0NBSUMsR0FDRCxNQUFNYSxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNRSxPQUFPQyxPQUFPO0FBQ3BCLE1BQU1DLE9BQU9ELE9BQU87QUFDcEIsaURBQWlEO0FBQ2pELHVDQUF1QztBQUN2QyxNQUFNRSxXQUFXO0FBQ2pCOzs7OztDQUtDLEdBQ0QsU0FBU1AsU0FBU1EsTUFBTSxFQUFFQyxNQUFNO0lBQzVCLE1BQU1wQixRQUFRTyxRQUFRWSxRQUFRO0lBQzlCLE1BQU1FLFFBQVFMLE9BQU9YLFVBQVVlLFFBQVE7SUFDdEMsSUFBR04sWUFBWVEsTUFBTSxFQUFFLFNBQVVELFVBQVdOLE1BQU0sWUFBWSxpQkFBaUI7UUFDNUVRLFdBQVc7UUFBWUMsT0FBTztRQUFZeEIsT0FBT21CO0lBQ3JEO0lBQ0EseUNBQXlDO0lBQ3pDLElBQUluQixTQUFVcUIsUUFBUUosTUFBTztRQUN6QixNQUFNUixPQUFPLENBQUNRLFFBQVFJLEtBQUksSUFBS0o7UUFDL0IsT0FBTyxDQUFFLEVBQUMsQ0FBRWpCLFFBQVNTLElBQUcsSUFBS1EsSUFBRztJQUNwQztJQUNBLE9BQU9qQjtBQUNYO0FBQ0FELGdCQUFnQixHQUFHWTtBQUNuQjs7Ozs7Q0FLQyxHQUNELFNBQVNELE9BQU9TLE1BQU0sRUFBRUMsTUFBTTtJQUMxQixJQUFJ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LFFBQVFpQyxTQUFTLENBQUM7SUFDNUcsTUFBT0csT0FBT1ksVUFBVSxDQUFDLEtBQU07UUFDM0JaLFNBQVNBLE9BQU9ILFNBQVMsQ0FBQztJQUM5QjtJQUNBLElBQUlHLFdBQVcsSUFBSTtRQUNmQSxTQUFTO0lBQ2I7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCO0FBQ0FyQyxrQkFBa0IsR0FBR0UsWUFDckIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvbWF0aHMuanM/MDUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9RdWFudGl0eSA9IGV4cG9ydHMudG9CZUFycmF5ID0gZXhwb3J0cy50b0JlSGV4ID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMuZ2V0TnVtYmVyID0gZXhwb3J0cy50b0JpZ0ludCA9IGV4cG9ydHMuZ2V0VWludCA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5tYXNrID0gZXhwb3J0cy50b1R3b3MgPSBleHBvcnRzLmZyb21Ud29zID0gdm9pZCAwO1xuLyoqXG4gKiAgU29tZSBtYXRoZW1hdGljIG9wZXJhdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3V0aWxzOk1hdGggSGVscGVycyAgW2Fib3V0LW1hdGhzXVxuICovXG5jb25zdCBkYXRhX2pzXzEgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbi8vY29uc3QgQk5fTWF4MjU2ID0gKEJOXzEgPDwgQmlnSW50KDI1NikpIC0gQk5fMTtcbi8vIElFRUUgNzU0IHN1cHBvcnQgNTMtYml0cyBvZiBtYW50aXNzYVxuY29uc3QgbWF4VmFsdWUgPSAweDFmZmZmZmZmZmZmZmZmO1xuLyoqXG4gKiAgQ29udmVydCAlJXZhbHVlJSUgZnJvbSBhIHR3b3MtY29tcGxpbWVudCByZXByZXNlbnRhdGlvbiBvZiAlJXdpZHRoJSVcbiAqICBiaXRzIHRvIGl0cyB2YWx1ZS5cbiAqXG4gKiAgSWYgdGhlIGhpZ2hlc3QgYml0IGlzIGBgMWBgLCB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGZyb21Ud29zKF92YWx1ZSwgX3dpZHRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRVaW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICBjb25zdCB3aWR0aCA9IEJpZ0ludChnZXROdW1iZXIoX3dpZHRoLCBcIndpZHRoXCIpKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KSgodmFsdWUgPj4gd2lkdGgpID09PSBCTl8wLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJmcm9tVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgfSk7XG4gICAgLy8gVG9wIGJpdCBzZXQ7IHRyZWF0IGFzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWUgPj4gKHdpZHRoIC0gQk5fMSkpIHtcbiAgICAgICAgY29uc3QgbWFzayA9IChCTl8xIDw8IHdpZHRoKSAtIEJOXzE7XG4gICAgICAgIHJldHVybiAtKCgofnZhbHVlKSAmIG1hc2spICsgQk5fMSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMuZnJvbVR3b3MgPSBmcm9tVHdvcztcbi8qKlxuICogIENvbnZlcnQgJSV2YWx1ZSUlIHRvIGEgdHdvcy1jb21wbGltZW50IHJlcHJlc2VudGF0aW9uIG9mXG4gKiAgJSV3aWR0aCUlIGJpdHMuXG4gKlxuICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgcG9zaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIHRvVHdvcyhfdmFsdWUsIF93aWR0aCkge1xuICAgIGxldCB2YWx1ZSA9IGdldEJpZ0ludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgY29uc3Qgd2lkdGggPSBCaWdJbnQoZ2V0TnVtYmVyKF93aWR0aCwgXCJ3aWR0aFwiKSk7XG4gICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgaWYgKHZhbHVlIDwgQk5fMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkodmFsdWUgPD0gbGltaXQsIFwidG9vIGxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvVHdvc1wiLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXNrID0gKEJOXzEgPDwgd2lkdGgpIC0gQk5fMTtcbiAgICAgICAgcmV0dXJuICgofnZhbHVlKSAmIG1hc2spICsgQk5fMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHZhbHVlIDwgbGltaXQsIFwidG9vIGhpZ2hcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJ0b1R3b3NcIiwgZmF1bHQ6IFwib3ZlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy50b1R3b3MgPSB0b1R3b3M7XG4vKipcbiAqICBNYXNrICUldmFsdWUlJSB3aXRoIGEgYml0bWFzayBvZiAlJWJpdHMlJSBvbmVzLlxuICovXG5mdW5jdGlvbiBtYXNrKF92YWx1ZSwgX2JpdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFVpbnQoX3ZhbHVlLCBcInZhbHVlXCIpO1xuICAgIGNvbnN0IGJpdHMgPSBCaWdJbnQoZ2V0TnVtYmVyKF9iaXRzLCBcImJpdHNcIikpO1xuICAgIHJldHVybiB2YWx1ZSAmICgoQk5fMSA8PCBiaXRzKSAtIEJOXzEpO1xufVxuZXhwb3J0cy5tYXNrID0gbWFzaztcbi8qKlxuICogIEdldHMgYSBCaWdJbnQgZnJvbSAlJXZhbHVlJSUuIElmIGl0IGlzIGFuIGludmFsaWQgdmFsdWUgZm9yXG4gKiAgYSBCaWdJbnQsIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldEJpZ0ludCh2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOiByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksIFwidW5kZXJmbG93XCIsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHZhbHVlID49IC1tYXhWYWx1ZSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgXCJvdmVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIiAmJiB2YWx1ZVsxXSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1CaWdJbnQodmFsdWUuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGBpbnZhbGlkIEJpZ051bWJlcmlzaCBzdHJpbmc6ICR7ZS5tZXNzYWdlfWAsIG5hbWUgfHwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBCaWdOdW1iZXJpc2ggdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0QmlnSW50ID0gZ2V0QmlnSW50O1xuLyoqXG4gKiAgUmV0dXJucyAlJXZhbHVlJSUgYXMgYSBiaWdpbnQsIHZhbGlkYXRpbmcgaXQgaXMgdmFsaWQgYXMgYSBiaWdpbnRcbiAqICB2YWx1ZSBhbmQgdGhhdCBpdCBpcyBwb3NpdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VWludCh2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldEJpZ0ludCh2YWx1ZSwgbmFtZSk7XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydCkocmVzdWx0ID49IEJOXzAsIFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsIG9wZXJhdGlvbjogXCJnZXRVaW50XCIsIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0VWludCA9IGdldFVpbnQ7XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4vKlxuICogQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgQmlnSW50LiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogaXMgdHJlYXRlZCBhcyBCaWcgRW5kaWFuIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweDBcIjtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTmliYmxlc1t2ID4+IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE5pYmJsZXNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJpZ0ludCh2YWx1ZSk7XG59XG5leHBvcnRzLnRvQmlnSW50ID0gdG9CaWdJbnQ7XG4vKipcbiAqICBHZXRzIGEgLy9udW1iZXIvLyBmcm9tICUldmFsdWUlJS4gSWYgaXQgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3JcbiAqICBhIC8vbnVtYmVyLy8sIHRoZW4gYW4gQXJndW1lbnRFcnJvciB3aWxsIGJlIHRocm93biBmb3IgJSVuYW1lJSUuXG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIHN3aXRjaCAodHlwZW9mICh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKE51bWJlci5pc0ludGVnZXIodmFsdWUpLCBcInVuZGVyZmxvd1wiLCBuYW1lIHx8IFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KSh2YWx1ZSA+PSAtbWF4VmFsdWUgJiYgdmFsdWUgPD0gbWF4VmFsdWUsIFwib3ZlcmZsb3dcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVyKEJpZ0ludCh2YWx1ZSksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgaW52YWxpZCBudW1lcmljIHN0cmluZzogJHtlLm1lc3NhZ2V9YCwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGVycm9yc19qc18xLmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIG51bWVyaWMgdmFsdWVcIiwgbmFtZSB8fCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0TnVtYmVyID0gZ2V0TnVtYmVyO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIHRvIGEgbnVtYmVyLiBJZiAlJXZhbHVlJSUgaXMgYSBVaW50OEFycmF5LCBpdFxuICogIGlzIHRyZWF0ZWQgYXMgQmlnIEVuZGlhbiBkYXRhLiBUaHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCBzYWZlLlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBnZXROdW1iZXIodG9CaWdJbnQodmFsdWUpKTtcbn1cbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gaGV4c3RyaW5nLCBvcHRpb25hbGx5IHBhZGRlZCB0b1xuICogICUld2lkdGglJSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gdG9CZUhleChfdmFsdWUsIF93aWR0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoX3dpZHRoID09IG51bGwpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSB2YWx1ZSBpcyBvZiBldmVuIGxlbmd0aFxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3aWR0aCA9IGdldE51bWJlcihfd2lkdGgsIFwid2lkdGhcIik7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKHdpZHRoICogMiA+PSByZXN1bHQubGVuZ3RoLCBgdmFsdWUgZXhjZWVkcyB3aWR0aCAoJHt3aWR0aH0gYml0cylgLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInRvQmVIZXhcIixcbiAgICAgICAgICAgIGZhdWx0OiBcIm92ZXJmbG93XCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQYWQgdGhlIHZhbHVlIHRvIHRoZSByZXF1aXJlZCB3aWR0aFxuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8ICh3aWR0aCAqIDIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZXhwb3J0cy50b0JlSGV4ID0gdG9CZUhleDtcbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSB0byBhIEJpZyBFbmRpYW4gVWludDhBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9CZUFycmF5KF92YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0VWludChfdmFsdWUsIFwidmFsdWVcIik7XG4gICAgaWYgKHZhbHVlID09PSBCTl8wKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXSk7XG4gICAgfVxuICAgIGxldCBoZXggPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDI7XG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy50b0JlQXJyYXkgPSB0b0JlQXJyYXk7XG4vKipcbiAqICBSZXR1cm5zIGEgW1tIZXhTdHJpbmddXSBmb3IgJSV2YWx1ZSUlIHNhZmUgdG8gdXNlIGFzIGEgLy9RdWFudGl0eS8vLlxuICpcbiAqICBBIC8vUXVhbnRpdHkvLyBkb2VzIG5vdCBoYXZlIGFuZCBsZWFkaW5nIDAgdmFsdWVzIHVubGVzcyB0aGUgdmFsdWUgaXNcbiAqICB0aGUgbGl0ZXJhbCB2YWx1ZSBgMHgwYC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIEpTU09OLVJQQ1xuICogIG51bWVyaWMgdmFsdWVzLlxuICovXG5mdW5jdGlvbiB0b1F1YW50aXR5KHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9ICgwLCBkYXRhX2pzXzEuaGV4bGlmeSkoKDAsIGRhdGFfanNfMS5pc0J5dGVzTGlrZSkodmFsdWUpID8gdmFsdWUgOiB0b0JlQXJyYXkodmFsdWUpKS5zdWJzdHJpbmcoMik7XG4gICAgd2hpbGUgKHJlc3VsdC5zdGFydHNXaXRoKFwiMFwiKSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ID09PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZXhwb3J0cy50b1F1YW50aXR5ID0gdG9RdWFudGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvUXVhbnRpdHkiLCJ0b0JlQXJyYXkiLCJ0b0JlSGV4IiwidG9OdW1iZXIiLCJnZXROdW1iZXIiLCJ0b0JpZ0ludCIsImdldFVpbnQiLCJnZXRCaWdJbnQiLCJtYXNrIiwidG9Ud29zIiwiZnJvbVR3b3MiLCJkYXRhX2pzXzEiLCJyZXF1aXJlIiwiZXJyb3JzX2pzXzEiLCJCTl8wIiwiQmlnSW50IiwiQk5fMSIsIm1heFZhbHVlIiwiX3ZhbHVlIiwiX3dpZHRoIiwid2lkdGgiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJmYXVsdCIsImxpbWl0IiwiX2JpdHMiLCJiaXRzIiwibmFtZSIsImFzc2VydEFyZ3VtZW50IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJlIiwibWVzc2FnZSIsInJlc3VsdCIsIk5pYmJsZXMiLCJVaW50OEFycmF5IiwidiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaGV4IiwiaSIsIm9mZnNldCIsInBhcnNlSW50IiwiaGV4bGlmeSIsImlzQnl0ZXNMaWtlIiwic3RhcnRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/properties.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = exports.resolveProperties = void 0;\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map((t)=>t.trim());\n    for(let i = 0; i < types.length; i++){\n        switch(type){\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof value === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */ async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k)=>Promise.resolve(value[k])));\n    return results.reduce((accum, v, index)=>{\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\nexports.resolveProperties = resolveProperties;\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */ function defineProperties(target, values, types) {\n    for(let key in values){\n        let value = values[key];\n        const type = types ? types[key] : null;\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, {\n            enumerable: true,\n            value,\n            writable: false\n        });\n    }\n}\nexports.defineProperties = defineProperties; //# sourceMappingURL=properties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9wcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDNUQsU0FBU0ksVUFBVUgsS0FBSyxFQUFFSSxJQUFJLEVBQUVDLElBQUk7SUFDaEMsTUFBTUMsUUFBUUYsS0FBS0csS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSTtJQUM3QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsTUFBTU0sTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE9BQVFQO1lBQ0osS0FBSztnQkFDRDtZQUNKLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsSUFBSSxPQUFRSixVQUFXSSxNQUFNO29CQUN6QjtnQkFDSjtRQUNSO0lBQ0o7SUFDQSxNQUFNUyxRQUFRLElBQUlDLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRVYsS0FBSyxDQUFDO0lBQ3hEUyxNQUFNRSxJQUFJLEdBQUc7SUFDYkYsTUFBTUcsUUFBUSxHQUFHLENBQUMsTUFBTSxFQUFFWCxLQUFLLENBQUM7SUFDaENRLE1BQU1iLEtBQUssR0FBR0E7SUFDZCxNQUFNYTtBQUNWO0FBQ0E7OztDQUdDLEdBQ0QsZUFBZVgsa0JBQWtCRixLQUFLO0lBQ2xDLE1BQU1pQixPQUFPcEIsT0FBT29CLElBQUksQ0FBQ2pCO0lBQ3pCLE1BQU1rQixVQUFVLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ0gsS0FBS1QsR0FBRyxDQUFDLENBQUNhLElBQU1GLFFBQVFHLE9BQU8sQ0FBQ3RCLEtBQUssQ0FBQ3FCLEVBQUU7SUFDMUUsT0FBT0gsUUFBUUssTUFBTSxDQUFDLENBQUNDLE9BQU9DLEdBQUdDO1FBQzdCRixLQUFLLENBQUNQLElBQUksQ0FBQ1MsTUFBTSxDQUFDLEdBQUdEO1FBQ3JCLE9BQU9EO0lBQ1gsR0FBRyxDQUFDO0FBQ1I7QUFDQXpCLHlCQUF5QixHQUFHRztBQUM1Qjs7OztDQUlDLEdBQ0QsU0FBU0QsaUJBQWlCMEIsTUFBTSxFQUFFQyxNQUFNLEVBQUV0QixLQUFLO0lBQzNDLElBQUssSUFBSXVCLE9BQU9ELE9BQVE7UUFDcEIsSUFBSTVCLFFBQVE0QixNQUFNLENBQUNDLElBQUk7UUFDdkIsTUFBTXpCLE9BQVFFLFFBQVFBLEtBQUssQ0FBQ3VCLElBQUksR0FBRztRQUNuQyxJQUFJekIsTUFBTTtZQUNORCxVQUFVSCxPQUFPSSxNQUFNeUI7UUFDM0I7UUFDQWhDLE9BQU9DLGNBQWMsQ0FBQzZCLFFBQVFFLEtBQUs7WUFBRUMsWUFBWTtZQUFNOUI7WUFBTytCLFVBQVU7UUFBTTtJQUNsRjtBQUNKO0FBQ0FoQyx3QkFBd0IsR0FBR0Usa0JBQzNCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3Byb3BlcnRpZXMuanM/YTk4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFByb3BlcnR5IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6UHJvcGVydGllcyAgW2Fib3V0LXByb3BlcnRpZXNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSB2b2lkIDA7XG5mdW5jdGlvbiBjaGVja1R5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpLm1hcCh0ID0+IHQudHJpbSgpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIHR5cGUgJHt0eXBlfWApO1xuICAgIGVycm9yLmNvZGUgPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBlcnJvci5hcmd1bWVudCA9IGB2YWx1ZS4ke25hbWV9YDtcbiAgICBlcnJvci52YWx1ZSA9IHZhbHVlO1xuICAgIHRocm93IGVycm9yO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gYSBuZXcgb2JqZWN0IHRoYXQgaXMgYSBjb3B5IG9mICUldmFsdWUlJSwgYnV0IHdpdGggYWxsXG4gKiAgdmFsdWVzIHJlc29sdmVkLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyh2YWx1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGtleXMubWFwKChrKSA9PiBQcm9taXNlLnJlc29sdmUodmFsdWVba10pKSk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgdiwgaW5kZXgpID0+IHtcbiAgICAgICAgYWNjdW1ba2V5c1tpbmRleF1dID0gdjtcbiAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSByZXNvbHZlUHJvcGVydGllcztcbi8qKlxuICogIEFzc2lnbnMgdGhlICUldmFsdWVzJSUgdG8gJSV0YXJnZXQlJSBhcyByZWFkLW9ubHkgdmFsdWVzLlxuICpcbiAqICBJdCAlJXR5cGVzJSUgaXMgc3BlY2lmaWVkLCB0aGUgdmFsdWVzIGFyZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgdmFsdWVzLCB0eXBlcykge1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAodHlwZXMgPyB0eXBlc1trZXldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBjaGVja1R5cGUodmFsdWUsIHR5cGUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnRpZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlc29sdmVQcm9wZXJ0aWVzIiwiY2hlY2tUeXBlIiwidHlwZSIsIm5hbWUiLCJ0eXBlcyIsInNwbGl0IiwibWFwIiwidCIsInRyaW0iLCJpIiwibGVuZ3RoIiwiZXJyb3IiLCJFcnJvciIsImNvZGUiLCJhcmd1bWVudCIsImtleXMiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsImsiLCJyZXNvbHZlIiwicmVkdWNlIiwiYWNjdW0iLCJ2IiwiaW5kZXgiLCJ0YXJnZXQiLCJ2YWx1ZXMiLCJrZXkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/properties.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/rlp-decode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//See: https://github.com/ethereum/wiki/wiki/RLP\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeRlp = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst data_js_2 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nfunction hexlifyByte(value) {\n    let result = value.toString(16);\n    while(result.length < 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        (0, errors_js_1.assert)(childOffset <= offset + 1 + length, \"child data too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length,\n            offset\n        });\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    (0, errors_js_1.assert)(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\n        buffer: data,\n        length: 0,\n        offset: 1\n    });\n    const checkOffset = (offset)=>{\n        (0, errors_js_1.assert)(offset <= data.length, \"data short segment too short\", \"BUFFER_OVERRUN\", {\n            buffer: data,\n            length: data.length,\n            offset\n        });\n    };\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        checkOffset(offset + 1 + length);\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        checkOffset(offset + 1 + lengthLength);\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        checkOffset(offset + 1 + lengthLength + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        checkOffset(offset + 1 + length);\n        const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: hexlifyByte(data[offset])\n    };\n}\n/**\n *  Decodes %%data%% into the structured data it represents.\n */ function decodeRlp(_data) {\n    const data = (0, data_js_2.getBytes)(_data, \"data\");\n    const decoded = _decode(data, 0);\n    (0, errors_js_1.assertArgument)(decoded.consumed === data.length, \"unexpected junk after rlp payload\", \"data\", _data);\n    return decoded.result;\n}\nexports.decodeRlp = decodeRlp; //# sourceMappingURL=rlp-decode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZGVjb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZ0RBQWdEO0FBQ2hEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxTQUFTRyxZQUFZTixLQUFLO0lBQ3RCLElBQUlPLFNBQVNQLE1BQU1RLFFBQVEsQ0FBQztJQUM1QixNQUFPRCxPQUFPRSxNQUFNLEdBQUcsRUFBRztRQUN0QkYsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT0E7QUFDbEI7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsTUFBTSxFQUFFSCxNQUFNO0lBQzNDLElBQUlGLFNBQVM7SUFDYixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUM3Qk4sU0FBUyxTQUFVLE1BQU9JLElBQUksQ0FBQ0MsU0FBU0MsRUFBRTtJQUM5QztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTTyxnQkFBZ0JILElBQUksRUFBRUMsTUFBTSxFQUFFRyxXQUFXLEVBQUVOLE1BQU07SUFDdEQsTUFBTUYsU0FBUyxFQUFFO0lBQ2pCLE1BQU9RLGNBQWNILFNBQVMsSUFBSUgsT0FBUTtRQUN0QyxNQUFNTyxVQUFVQyxRQUFRTixNQUFNSTtRQUM5QlIsT0FBT1csSUFBSSxDQUFDRixRQUFRVCxNQUFNO1FBQzFCUSxlQUFlQyxRQUFRRyxRQUFRO1FBQzlCLElBQUdmLFlBQVlnQixNQUFNLEVBQUVMLGVBQWVILFNBQVMsSUFBSUgsUUFBUSx3QkFBd0Isa0JBQWtCO1lBQ2xHWSxRQUFRVjtZQUFNRjtZQUFRRztRQUMxQjtJQUNKO0lBQ0EsT0FBTztRQUFFTyxVQUFXLElBQUlWO1FBQVNGLFFBQVFBO0lBQU87QUFDcEQ7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU1UsUUFBUU4sSUFBSSxFQUFFQyxNQUFNO0lBQ3hCLElBQUdSLFlBQVlnQixNQUFNLEVBQUVULEtBQUtGLE1BQU0sS0FBSyxHQUFHLGtCQUFrQixrQkFBa0I7UUFDM0VZLFFBQVFWO1FBQU1GLFFBQVE7UUFBR0csUUFBUTtJQUNyQztJQUNBLE1BQU1VLGNBQWMsQ0FBQ1Y7UUFDaEIsSUFBR1IsWUFBWWdCLE1BQU0sRUFBRVIsVUFBVUQsS0FBS0YsTUFBTSxFQUFFLGdDQUFnQyxrQkFBa0I7WUFDN0ZZLFFBQVFWO1lBQU1GLFFBQVFFLEtBQUtGLE1BQU07WUFBRUc7UUFDdkM7SUFDSjtJQUNBLGlDQUFpQztJQUNqQyxJQUFJRCxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQ3RCLE1BQU1XLGVBQWVaLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ3BDVSxZQUFZVixTQUFTLElBQUlXO1FBQ3pCLE1BQU1kLFNBQVNDLGtCQUFrQkMsTUFBTUMsU0FBUyxHQUFHVztRQUNuREQsWUFBWVYsU0FBUyxJQUFJVyxlQUFlZDtRQUN4QyxPQUFPSyxnQkFBZ0JILE1BQU1DLFFBQVFBLFNBQVMsSUFBSVcsY0FBY0EsZUFBZWQ7SUFDbkYsT0FDSyxJQUFJRSxJQUFJLENBQUNDLE9BQU8sSUFBSSxNQUFNO1FBQzNCLE1BQU1ILFNBQVNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQzlCVSxZQUFZVixTQUFTLElBQUlIO1FBQ3pCLE9BQU9LLGdCQUFnQkgsTUFBTUMsUUFBUUEsU0FBUyxHQUFHSDtJQUNyRCxPQUNLLElBQUlFLElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDM0IsTUFBTVcsZUFBZVosSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDcENVLFlBQVlWLFNBQVMsSUFBSVc7UUFDekIsTUFBTWQsU0FBU0Msa0JBQWtCQyxNQUFNQyxTQUFTLEdBQUdXO1FBQ25ERCxZQUFZVixTQUFTLElBQUlXLGVBQWVkO1FBQ3hDLE1BQU1GLFNBQVMsQ0FBQyxHQUFHTCxVQUFVc0IsT0FBTyxFQUFFYixLQUFLYyxLQUFLLENBQUNiLFNBQVMsSUFBSVcsY0FBY1gsU0FBUyxJQUFJVyxlQUFlZDtRQUN4RyxPQUFPO1lBQUVVLFVBQVcsSUFBSUksZUFBZWQ7WUFBU0YsUUFBUUE7UUFBTztJQUNuRSxPQUNLLElBQUlJLElBQUksQ0FBQ0MsT0FBTyxJQUFJLE1BQU07UUFDM0IsTUFBTUgsU0FBU0UsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDOUJVLFlBQVlWLFNBQVMsSUFBSUg7UUFDekIsTUFBTUYsU0FBUyxDQUFDLEdBQUdMLFVBQVVzQixPQUFPLEVBQUViLEtBQUtjLEtBQUssQ0FBQ2IsU0FBUyxHQUFHQSxTQUFTLElBQUlIO1FBQzFFLE9BQU87WUFBRVUsVUFBVyxJQUFJVjtZQUFTRixRQUFRQTtRQUFPO0lBQ3BEO0lBQ0EsT0FBTztRQUFFWSxVQUFVO1FBQUdaLFFBQVFELFlBQVlLLElBQUksQ0FBQ0MsT0FBTztJQUFFO0FBQzVEO0FBQ0E7O0NBRUMsR0FDRCxTQUFTWCxVQUFVeUIsS0FBSztJQUNwQixNQUFNZixPQUFPLENBQUMsR0FBR04sVUFBVXNCLFFBQVEsRUFBRUQsT0FBTztJQUM1QyxNQUFNVixVQUFVQyxRQUFRTixNQUFNO0lBQzdCLElBQUdQLFlBQVl3QixjQUFjLEVBQUVaLFFBQVFHLFFBQVEsS0FBS1IsS0FBS0YsTUFBTSxFQUFFLHFDQUFxQyxRQUFRaUI7SUFDL0csT0FBT1YsUUFBUVQsTUFBTTtBQUN6QjtBQUNBUixpQkFBaUIsR0FBR0UsV0FDcEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvcmxwLWRlY29kZS5qcz84NjA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVJscCA9IHZvaWQgMDtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGRhdGFfanNfMiA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5mdW5jdGlvbiBoZXhsaWZ5Qnl0ZSh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoY2hpbGRPZmZzZXQgPCBvZmZzZXQgKyAxICsgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGRhdGEsIGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZC5yZXN1bHQpO1xuICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0KShjaGlsZE9mZnNldCA8PSBvZmZzZXQgKyAxICsgbGVuZ3RoLCBcImNoaWxkIGRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGgsIG9mZnNldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKGRhdGEubGVuZ3RoICE9PSAwLCBcImRhdGEgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICBidWZmZXI6IGRhdGEsIGxlbmd0aDogMCwgb2Zmc2V0OiAxXG4gICAgfSk7XG4gICAgY29uc3QgY2hlY2tPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnQpKG9mZnNldCA8PSBkYXRhLmxlbmd0aCwgXCJkYXRhIHNob3J0IHNlZ21lbnQgdG9vIHNob3J0XCIsIFwiQlVGRkVSX09WRVJSVU5cIiwge1xuICAgICAgICAgICAgYnVmZmVyOiBkYXRhLCBsZW5ndGg6IGRhdGEubGVuZ3RoLCBvZmZzZXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBcnJheSB3aXRoIGV4dHJhIGxlbmd0aCBwcmVmaXhcbiAgICBpZiAoZGF0YVtvZmZzZXRdID49IDB4ZjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhmNztcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhiOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGI3O1xuICAgICAgICBjaGVja09mZnNldChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgY2hlY2tPZmZzZXQob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBkYXRhX2pzXzEuaGV4bGlmeSkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCArIDEgKyBsZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgZGF0YV9qc18xLmhleGxpZnkpKGRhdGEuc2xpY2Uob2Zmc2V0ICsgMSwgb2Zmc2V0ICsgMSArIGxlbmd0aCkpO1xuICAgICAgICByZXR1cm4geyBjb25zdW1lZDogKDEgKyBsZW5ndGgpLCByZXN1bHQ6IHJlc3VsdCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb25zdW1lZDogMSwgcmVzdWx0OiBoZXhsaWZ5Qnl0ZShkYXRhW29mZnNldF0pIH07XG59XG4vKipcbiAqICBEZWNvZGVzICUlZGF0YSUlIGludG8gdGhlIHN0cnVjdHVyZWQgZGF0YSBpdCByZXByZXNlbnRzLlxuICovXG5mdW5jdGlvbiBkZWNvZGVSbHAoX2RhdGEpIHtcbiAgICBjb25zdCBkYXRhID0gKDAsIGRhdGFfanNfMi5nZXRCeXRlcykoX2RhdGEsIFwiZGF0YVwiKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCAwKTtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGRlY29kZWQuY29uc3VtZWQgPT09IGRhdGEubGVuZ3RoLCBcInVuZXhwZWN0ZWQganVuayBhZnRlciBybHAgcGF5bG9hZFwiLCBcImRhdGFcIiwgX2RhdGEpO1xuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjb2RlUmxwID0gZGVjb2RlUmxwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmxwLWRlY29kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVSbHAiLCJkYXRhX2pzXzEiLCJyZXF1aXJlIiwiZXJyb3JzX2pzXzEiLCJkYXRhX2pzXzIiLCJoZXhsaWZ5Qnl0ZSIsInJlc3VsdCIsInRvU3RyaW5nIiwibGVuZ3RoIiwidW5hcnJheWlmeUludGVnZXIiLCJkYXRhIiwib2Zmc2V0IiwiaSIsIl9kZWNvZGVDaGlsZHJlbiIsImNoaWxkT2Zmc2V0IiwiZGVjb2RlZCIsIl9kZWNvZGUiLCJwdXNoIiwiY29uc3VtZWQiLCJhc3NlcnQiLCJidWZmZXIiLCJjaGVja09mZnNldCIsImxlbmd0aExlbmd0aCIsImhleGxpZnkiLCJzbGljZSIsIl9kYXRhIiwiZ2V0Qnl0ZXMiLCJhc3NlcnRBcmd1bWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-decode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js":
/*!**************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/rlp-encode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//See: https://github.com/ethereum/wiki/wiki/RLP\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeRlp = void 0;\nconst data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    const data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, \"object\"));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nconst nibbles = \"0123456789abcdef\";\n/**\n *  Encodes %%object%% as an RLP-encoded [[DataHexString]].\n */ function encodeRlp(object) {\n    let result = \"0x\";\n    for (const v of _encode(object)){\n        result += nibbles[v >> 4];\n        result += nibbles[v & 0xf];\n    }\n    return result;\n}\nexports.encodeRlp = encodeRlp; //# sourceMappingURL=rlp-encode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy9ybHAtZW5jb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZ0RBQWdEO0FBQ2hEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxTQUFTQyxnQkFBZ0JKLEtBQUs7SUFDMUIsTUFBTUssU0FBUyxFQUFFO0lBQ2pCLE1BQU9MLE1BQU87UUFDVkssT0FBT0MsT0FBTyxDQUFDTixRQUFRO1FBQ3ZCQSxVQUFVO0lBQ2Q7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU0UsUUFBUUMsTUFBTTtJQUNuQixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFNBQVM7UUFDdkIsSUFBSUcsVUFBVSxFQUFFO1FBQ2hCSCxPQUFPSSxPQUFPLENBQUMsU0FBVUMsS0FBSztZQUMxQkYsVUFBVUEsUUFBUUcsTUFBTSxDQUFDUCxRQUFRTTtRQUNyQztRQUNBLElBQUlGLFFBQVFJLE1BQU0sSUFBSSxJQUFJO1lBQ3RCSixRQUFRTCxPQUFPLENBQUMsT0FBT0ssUUFBUUksTUFBTTtZQUNyQyxPQUFPSjtRQUNYO1FBQ0EsTUFBTUksU0FBU1gsZ0JBQWdCTyxRQUFRSSxNQUFNO1FBQzdDQSxPQUFPVCxPQUFPLENBQUMsT0FBT1MsT0FBT0EsTUFBTTtRQUNuQyxPQUFPQSxPQUFPRCxNQUFNLENBQUNIO0lBQ3pCO0lBQ0EsTUFBTUssT0FBT1AsTUFBTVEsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQyxDQUFDLEdBQUdqQixVQUFVa0IsUUFBUSxFQUFFWixRQUFRO0lBQ3hFLElBQUlRLEtBQUtELE1BQU0sS0FBSyxLQUFLQyxJQUFJLENBQUMsRUFBRSxJQUFJLE1BQU07UUFDdEMsT0FBT0E7SUFDWCxPQUNLLElBQUlBLEtBQUtELE1BQU0sSUFBSSxJQUFJO1FBQ3hCQyxLQUFLVixPQUFPLENBQUMsT0FBT1UsS0FBS0QsTUFBTTtRQUMvQixPQUFPQztJQUNYO0lBQ0EsTUFBTUQsU0FBU1gsZ0JBQWdCWSxLQUFLRCxNQUFNO0lBQzFDQSxPQUFPVCxPQUFPLENBQUMsT0FBT1MsT0FBT0EsTUFBTTtJQUNuQyxPQUFPQSxPQUFPRCxNQUFNLENBQUNFO0FBQ3pCO0FBQ0EsTUFBTUssVUFBVTtBQUNoQjs7Q0FFQyxHQUNELFNBQVNwQixVQUFVTyxNQUFNO0lBQ3JCLElBQUlILFNBQVM7SUFDYixLQUFLLE1BQU1pQixLQUFLZixRQUFRQyxRQUFTO1FBQzdCSCxVQUFVZ0IsT0FBTyxDQUFDQyxLQUFLLEVBQUU7UUFDekJqQixVQUFVZ0IsT0FBTyxDQUFDQyxJQUFJLElBQUk7SUFDOUI7SUFDQSxPQUFPakI7QUFDWDtBQUNBTixpQkFBaUIsR0FBR0UsV0FDcEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvcmxwLWVuY29kZS5qcz9mODI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy9TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvUkxQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVJscCA9IHZvaWQgMDtcbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5jb25jYXQoX2VuY29kZShjaGlsZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVuc2hpZnQoMHhjMCArIHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aC51bnNoaWZ0KDB4ZjcgKyBsZW5ndGgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aC5jb25jYXQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCgoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShvYmplY3QsIFwib2JqZWN0XCIpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuY29uc3QgbmliYmxlcyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqXG4gKiAgRW5jb2RlcyAlJW9iamVjdCUlIGFzIGFuIFJMUC1lbmNvZGVkIFtbRGF0YUhleFN0cmluZ11dLlxuICovXG5mdW5jdGlvbiBlbmNvZGVSbHAob2JqZWN0KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiMHhcIjtcbiAgICBmb3IgKGNvbnN0IHYgb2YgX2VuY29kZShvYmplY3QpKSB7XG4gICAgICAgIHJlc3VsdCArPSBuaWJibGVzW3YgPj4gNF07XG4gICAgICAgIHJlc3VsdCArPSBuaWJibGVzW3YgJiAweGZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5lbmNvZGVSbHAgPSBlbmNvZGVSbHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ybHAtZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVuY29kZVJscCIsImRhdGFfanNfMSIsInJlcXVpcmUiLCJhcnJheWlmeUludGVnZXIiLCJyZXN1bHQiLCJ1bnNoaWZ0IiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJsZW5ndGgiLCJkYXRhIiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiZ2V0Qnl0ZXMiLCJuaWJibGVzIiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/rlp-encode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/units.js":
/*!*********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/units.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */ const errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nconst fixednumber_js_1 = __webpack_require__(/*! ./fixednumber.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/fixednumber.js\");\nconst maths_js_1 = __webpack_require__(/*! ./maths.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/maths.js\");\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */ function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0, errors_js_1.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0, maths_js_1.getNumber)(unit, \"unit\");\n    }\n    return fixednumber_js_1.FixedNumber.fromValue(value, decimals, {\n        decimals,\n        width: 512\n    }).toString();\n}\nexports.formatUnits = formatUnits;\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */ function parseUnits(value, unit) {\n    (0, errors_js_1.assertArgument)(typeof value === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof unit === \"string\") {\n        const index = names.indexOf(unit);\n        (0, errors_js_1.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    } else if (unit != null) {\n        decimals = (0, maths_js_1.getNumber)(unit, \"unit\");\n    }\n    return fixednumber_js_1.FixedNumber.fromString(value, {\n        decimals,\n        width: 512\n    }).value;\n}\nexports.parseUnits = parseUnits;\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */ function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nexports.formatEther = formatEther;\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */ function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\nexports.parseEther = parseEther; //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91bml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUMzRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FDRCxNQUFNTSxjQUFjQyxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxNQUFNQyxtQkFBbUJELG1CQUFPQSxDQUFDLHVGQUFrQjtBQUNuRCxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywyRUFBWTtBQUN2QyxNQUFNRyxRQUFRO0lBQ1Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEOzs7OztDQUtDLEdBQ0QsU0FBU0wsWUFBWUosS0FBSyxFQUFFVSxJQUFJO0lBQzVCLElBQUlDLFdBQVc7SUFDZixJQUFJLE9BQVFELFNBQVUsVUFBVTtRQUM1QixNQUFNRSxRQUFRSCxNQUFNSSxPQUFPLENBQUNIO1FBQzNCLElBQUdMLFlBQVlTLGNBQWMsRUFBRUYsU0FBUyxHQUFHLGdCQUFnQixRQUFRRjtRQUNwRUMsV0FBVyxJQUFJQztJQUNuQixPQUNLLElBQUlGLFFBQVEsTUFBTTtRQUNuQkMsV0FBVyxDQUFDLEdBQUdILFdBQVdPLFNBQVMsRUFBRUwsTUFBTTtJQUMvQztJQUNBLE9BQU9ILGlCQUFpQlMsV0FBVyxDQUFDQyxTQUFTLENBQUNqQixPQUFPVyxVQUFVO1FBQUVBO1FBQVVPLE9BQU87SUFBSSxHQUFHQyxRQUFRO0FBQ3JHO0FBQ0FwQixtQkFBbUIsR0FBR0s7QUFDdEI7Ozs7Q0FJQyxHQUNELFNBQVNELFdBQVdILEtBQUssRUFBRVUsSUFBSTtJQUMxQixJQUFHTCxZQUFZUyxjQUFjLEVBQUUsT0FBUWQsVUFBVyxVQUFVLDBCQUEwQixTQUFTQTtJQUNoRyxJQUFJVyxXQUFXO0lBQ2YsSUFBSSxPQUFRRCxTQUFVLFVBQVU7UUFDNUIsTUFBTUUsUUFBUUgsTUFBTUksT0FBTyxDQUFDSDtRQUMzQixJQUFHTCxZQUFZUyxjQUFjLEVBQUVGLFNBQVMsR0FBRyxnQkFBZ0IsUUFBUUY7UUFDcEVDLFdBQVcsSUFBSUM7SUFDbkIsT0FDSyxJQUFJRixRQUFRLE1BQU07UUFDbkJDLFdBQVcsQ0FBQyxHQUFHSCxXQUFXTyxTQUFTLEVBQUVMLE1BQU07SUFDL0M7SUFDQSxPQUFPSCxpQkFBaUJTLFdBQVcsQ0FBQ0ksVUFBVSxDQUFDcEIsT0FBTztRQUFFVztRQUFVTyxPQUFPO0lBQUksR0FBR2xCLEtBQUs7QUFDekY7QUFDQUQsa0JBQWtCLEdBQUdJO0FBQ3JCOztDQUVDLEdBQ0QsU0FBU0QsWUFBWW1CLEdBQUc7SUFDcEIsT0FBT2pCLFlBQVlpQixLQUFLO0FBQzVCO0FBQ0F0QixtQkFBbUIsR0FBR0c7QUFDdEI7OztDQUdDLEdBQ0QsU0FBU0QsV0FBV3FCLEtBQUs7SUFDckIsT0FBT25CLFdBQVdtQixPQUFPO0FBQzdCO0FBQ0F2QixrQkFBa0IsR0FBR0UsWUFDckIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvdXRpbHMvdW5pdHMuanM/ZjAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VFdGhlciA9IGV4cG9ydHMuZm9ybWF0RXRoZXIgPSBleHBvcnRzLnBhcnNlVW5pdHMgPSBleHBvcnRzLmZvcm1hdFVuaXRzID0gdm9pZCAwO1xuLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuY29uc3QgZml4ZWRudW1iZXJfanNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkbnVtYmVyLmpzXCIpO1xuY29uc3QgbWF0aHNfanNfMSA9IHJlcXVpcmUoXCIuL21hdGhzLmpzXCIpO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXQpIHtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKSh1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZG51bWJlcl9qc18xLkZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZm9ybWF0VW5pdHMgPSBmb3JtYXRVbml0cztcbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSV2YWx1ZSUlIHRvIGEgQmlnSW50LCBhc3N1bWluZ1xuICogICUldW5pdCUlIGRlY2ltYWwgcGxhY2VzLiBUaGUgJSV1bml0JSUgbWF5IHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAqICBvciB0aGUgbmFtZSBvZiBhIHVuaXQgKGUuZy4gYGBcImd3ZWlcImBgIGZvciA5IGRlY2ltYWwgcGxhY2VzKS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIsIFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICBpZiAodHlwZW9mICh1bml0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdCk7XG4gICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCwgXCJpbnZhbGlkIHVuaXRcIiwgXCJ1bml0XCIsIHVuaXQpO1xuICAgICAgICBkZWNpbWFscyA9IDMgKiBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gKDAsIG1hdGhzX2pzXzEuZ2V0TnVtYmVyKSh1bml0LCBcInVuaXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmaXhlZG51bWJlcl9qc18xLkZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIHsgZGVjaW1hbHMsIHdpZHRoOiA1MTIgfSkudmFsdWU7XG59XG5leHBvcnRzLnBhcnNlVW5pdHMgPSBwYXJzZVVuaXRzO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8gdXNpbmcgMTggZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSkge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIDE4KTtcbn1cbmV4cG9ydHMuZm9ybWF0RXRoZXIgPSBmb3JtYXRFdGhlcjtcbi8qKlxuICogIENvbnZlcnRzIHRoZSAvL2RlY2ltYWwgc3RyaW5nLy8gJSVldGhlciUlIHRvIGEgQmlnSW50LCB1c2luZyAxOFxuICogIGRlY2ltYWwgcGxhY2VzLlxuICovXG5mdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbmV4cG9ydHMucGFyc2VFdGhlciA9IHBhcnNlRXRoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZUV0aGVyIiwiZm9ybWF0RXRoZXIiLCJwYXJzZVVuaXRzIiwiZm9ybWF0VW5pdHMiLCJlcnJvcnNfanNfMSIsInJlcXVpcmUiLCJmaXhlZG51bWJlcl9qc18xIiwibWF0aHNfanNfMSIsIm5hbWVzIiwidW5pdCIsImRlY2ltYWxzIiwiaW5kZXgiLCJpbmRleE9mIiwiYXNzZXJ0QXJndW1lbnQiLCJnZXROdW1iZXIiLCJGaXhlZE51bWJlciIsImZyb21WYWx1ZSIsIndpZHRoIiwidG9TdHJpbmciLCJmcm9tU3RyaW5nIiwid2VpIiwiZXRoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/units.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/utf8.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;\n/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */ const data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/errors.js\");\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    (0, errors_js_1.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        (0, errors_js_1.assertArgument)(typeof badCodepoint === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */ exports.Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = exports.Utf8ErrorFuncs.error;\n    }\n    const bytes = (0, data_js_1.getBytes)(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            } else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8Bytes(str, form) {\n    if (form != null) {\n        (0, errors_js_1.assertNormalize)(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            (0, errors_js_1.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\nexports.toUtf8Bytes = toUtf8Bytes;\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */ function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexports.toUtf8String = toUtf8String;\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */ function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\nexports.toUtf8CodePoints = toUtf8CodePoints; //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dGY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLG1CQUFtQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ3RHOzs7Ozs7O0NBT0MsR0FDRCxNQUFNTSxZQUFZQyxtQkFBT0EsQ0FBQyx5RUFBVztBQUNyQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw2RUFBYTtBQUN6QyxTQUFTRSxVQUFVQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDekQsSUFBR04sWUFBWU8sY0FBYyxFQUFFLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRUosT0FBTyxFQUFFLEVBQUVELE9BQU8sQ0FBQyxFQUFFLFNBQVNFO0FBQ3hHO0FBQ0EsU0FBU0ksV0FBV04sTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxZQUFZO0lBQzNELHVHQUF1RztJQUN2RyxJQUFJSixXQUFXLGdCQUFnQkEsV0FBVyx1QkFBdUI7UUFDN0QsSUFBSU8sSUFBSTtRQUNSLElBQUssSUFBSUMsSUFBSVAsU0FBUyxHQUFHTyxJQUFJTixNQUFNTyxNQUFNLEVBQUVELElBQUs7WUFDNUMsSUFBSU4sS0FBSyxDQUFDTSxFQUFFLElBQUksTUFBTSxNQUFNO2dCQUN4QjtZQUNKO1lBQ0FEO1FBQ0o7UUFDQSxPQUFPQTtJQUNYO0lBQ0Esd0VBQXdFO0lBQ3hFLG1FQUFtRTtJQUNuRSxJQUFJUCxXQUFXLFdBQVc7UUFDdEIsT0FBT0UsTUFBTU8sTUFBTSxHQUFHUixTQUFTO0lBQ25DO0lBQ0Esa0JBQWtCO0lBQ2xCLE9BQU87QUFDWDtBQUNBLFNBQVNTLFlBQVlWLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsWUFB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QUFVLElBQUssT0FBUTtZQUNuQ1MsT0FBT1QsSUFBSSxDQUFDLE9BQVEsT0FBUTtRQUNoQyxPQUNLO1lBQ0RTLE9BQU9ULElBQUksQ0FBQyxLQUFNLEtBQU07WUFDeEJTLE9BQU9ULElBQUksQ0FBQyxLQUFPLElBQUssT0FBUTtZQUNoQ1MsT0FBT1QsSUFBSSxDQUFDLElBQUssT0FBUTtRQUM3QjtJQUNKO0lBQ0EsT0FBTyxJQUFJdUIsV0FBV2Q7QUFDMUI7QUFDQTlCLG1CQUFtQixHQUFHSTs7QUFFdEIsU0FBUztBQUNULFNBQVN5QyxjQUFjQyxVQUFVO0lBQzdCLE9BQU9BLFdBQVdDLEdBQUcsQ0FBQyxDQUFDQztRQUNuQixJQUFJQSxhQUFhLFFBQVE7WUFDckIsT0FBT0MsT0FBT0MsWUFBWSxDQUFDRjtRQUMvQjtRQUNBQSxhQUFhO1FBQ2IsT0FBT0MsT0FBT0MsWUFBWSxDQUFFLENBQUMsYUFBYyxLQUFNLEtBQUksSUFBSyxRQUFVLENBQUNGLFlBQVksS0FBSSxJQUFLO0lBQzlGLEdBQUdHLElBQUksQ0FBQztBQUNaO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU2hELGFBQWFTLEtBQUssRUFBRWdCLE9BQU87SUFDaEMsT0FBT2lCLGNBQWNuQixrQkFBa0JkLE9BQU9nQjtBQUNsRDtBQUNBNUIsb0JBQW9CLEdBQUdHO0FBQ3ZCOzs7O0NBSUMsR0FDRCxTQUFTRCxpQkFBaUJtQyxHQUFHLEVBQUVDLElBQUk7SUFDL0IsT0FBT1osa0JBQWtCdEIsWUFBWWlDLEtBQUtDO0FBQzlDO0FBQ0F0Qyx3QkFBd0IsR0FBR0Usa0JBQzNCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3V0aWxzL3V0ZjguanM/NDY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IGV4cG9ydHMudG9VdGY4U3RyaW5nID0gZXhwb3J0cy50b1V0ZjhCeXRlcyA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSB2b2lkIDA7XG4vKipcbiAqICBVc2luZyBzdHJpbmdzIGluIEV0aGVyZXVtIChvciBhbnkgc2VjdXJpdHktYmFzZCBzeXN0ZW0pIHJlcXVpcmVzXG4gKiAgYWRkaXRpb25hbCBjYXJlLiBUaGVzZSB1dGlsaXRpZXMgYXR0ZW1wdCB0byBtaXRpZ2F0ZSBzb21lIG9mIHRoZVxuICogIHNhZmV0eSBpc3N1ZXMgYXMgd2VsbCBhcyBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIHJlY292ZXIgYW5kIGFuYWx5c2VcbiAqICBzdHJpbmdzLlxuICpcbiAqICBAX3N1YnNlY3Rpb24gYXBpL3V0aWxzOlN0cmluZ3MgYW5kIFVURi04ICBbYWJvdXQtc3RyaW5nc11cbiAqL1xuY29uc3QgZGF0YV9qc18xID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBgaW52YWxpZCBjb2RlcG9pbnQgYXQgb2Zmc2V0ICR7b2Zmc2V0fTsgJHtyZWFzb259YCwgXCJieXRlc1wiLCBieXRlcyk7XG59XG5mdW5jdGlvbiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG4gICAgaWYgKHJlYXNvbiA9PT0gXCJCQURfUFJFRklYXCIgfHwgcmVhc29uID09PSBcIlVORVhQRUNURURfQ09OVElOVUVcIikge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8vIFRoaXMgYnl0ZSBydW5zIHVzIHBhc3QgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzbyBqdXN0IGp1bXAgdG8gdGhlIGVuZFxuICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcbiAgICBpZiAocmVhc29uID09PSBcIk9WRVJSVU5cIikge1xuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IC0gMTtcbiAgICB9XG4gICAgLy8gTm90aGluZyB0byBza2lwXG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gT3ZlcmxvbmcgcmVwcmVzZW50YXRpb25zIGFyZSBvdGhlcndpc2UgXCJ2YWxpZFwiIGNvZGUgcG9pbnRzOyBqdXN0IG5vbi1kZWlzdGluZ3Rpc2hlZFxuICAgIGlmIChyZWFzb24gPT09IFwiT1ZFUkxPTkdcIikge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0QXJndW1lbnQpKHR5cGVvZiAoYmFkQ29kZXBvaW50KSA9PT0gXCJudW1iZXJcIiwgXCJpbnZhbGlkIGJhZCBjb2RlIHBvaW50IGZvciByZXBsYWNlbWVudFwiLCBcImJhZENvZGVwb2ludFwiLCBiYWRDb2RlcG9pbnQpO1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vKipcbiAqICBBIGhhbmRmdWwgb2YgcG9wdWxhciwgYnVpbHQtaW4gVVRGLTggZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ2llcy5cbiAqXG4gKiAgKipgYFwiZXJyb3JcImBgKiogLSB0aHJvd3Mgb24gQU5ZIGlsbGVnYWwgVVRGLTggc2VxdWVuY2Ugb3JcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50cyAodGhpcyBpcyB0aGUgZGVmYXVsdClcbiAqXG4gKiAgKipgYFwiaWdub3JlXCJgYCoqIC0gc2lsZW50bHkgZHJvcHMgYW55IGlsbGVnYWwgVVRGLTggc2VxdWVuY2VcbiAqICBhbmQgYWNjZXB0cyBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICAqKmBgXCJyZXBsYWNlXCJgYCoqIC0gcmVwbGFjZSBhbnkgaWxsZWdhbCBVVEYtOCBzZXF1ZW5jZSB3aXRoIHRoZVxuICogIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoaS5lLiBgYFwiXFxcXHVmZmZkXCJgYCkgYW5kIGFjY2VwdHNcbiAqICBub24tY2Fub25pY2FsIChvdmVybG9uZykgY29kZXBvaW50c1xuICpcbiAqICBAcmV0dXJuczogUmVjb3JkPFwiZXJyb3JcIiB8IFwiaWdub3JlXCIgfCBcInJlcGxhY2VcIiwgVXRmOEVycm9yRnVuYz5cbiAqL1xuZXhwb3J0cy5VdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoX2J5dGVzLCBvbkVycm9yKSB7XG4gICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBvbkVycm9yID0gZXhwb3J0cy5VdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShfYnl0ZXMsIFwiYnl0ZXNcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCIsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIkJBRF9QUkVGSVhcIiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFwiT1ZFUlJVTlwiLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihcIk1JU1NJTkdfQ09OVElOVUVcIiwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVVRfT0ZfUkFOR0VcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJVVEYxNl9TVVJST0dBVEVcIiwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoXCJPVkVSTE9OR1wiLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggYnl0ZSByZXByZXNlbnRhdGlvbiBvZiAlJXN0ciUlLlxuICpcbiAqICBJZiAlJWZvcm0lJSBpcyBzcGVjaWZpZWQsIHRoZSBzdHJpbmcgaXMgbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSB7XG4gICAgaWYgKGZvcm0gIT0gbnVsbCkge1xuICAgICAgICAoMCwgZXJyb3JzX2pzXzEuYXNzZXJ0Tm9ybWFsaXplKShmb3JtKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICgwLCBlcnJvcnNfanNfMS5hc3NlcnRBcmd1bWVudCkoaSA8IHN0ci5sZW5ndGggJiYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCksIFwiaW52YWxpZCBzdXJyb2dhdGUgcGFpclwiLCBcInN0clwiLCBzdHIpO1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5leHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG47XG4vL2V4cG9ydCBcbmZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiAgUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBVVEYtOCBkYXRhICUlYnl0ZXMlJS5cbiAqXG4gKiAgV2hlbiAlJW9uRXJyb3IlJSBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIGl0IGlzIGNhbGxlZCBvbiBVVEYtOFxuICogIGVycm9ycyBhbGxvd2luZyByZWNvdmVyeSB1c2luZyB0aGUgW1tVdGY4RXJyb3JGdW5jXV0gQVBJLlxuICogIChkZWZhdWx0OiBbZXJyb3JdKFV0ZjhFcnJvckZ1bmNzKSlcbiAqL1xuZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbmV4cG9ydHMudG9VdGY4U3RyaW5nID0gdG9VdGY4U3RyaW5nO1xuLyoqXG4gKiAgUmV0dXJucyB0aGUgVVRGLTggY29kZS1wb2ludHMgZm9yICUlc3RyJSUuXG4gKlxuICogIElmICUlZm9ybSUlIGlzIHNwZWNpZmllZCwgdGhlIHN0cmluZyBpcyBub3JtYWxpemVkLlxuICovXG5mdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbmV4cG9ydHMudG9VdGY4Q29kZVBvaW50cyA9IHRvVXRmOENvZGVQb2ludHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvVXRmOENvZGVQb2ludHMiLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhCeXRlcyIsIlV0ZjhFcnJvckZ1bmNzIiwiZGF0YV9qc18xIiwicmVxdWlyZSIsImVycm9yc19qc18xIiwiZXJyb3JGdW5jIiwicmVhc29uIiwib2Zmc2V0IiwiYnl0ZXMiLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJhc3NlcnRBcmd1bWVudCIsImlnbm9yZUZ1bmMiLCJpIiwibyIsImxlbmd0aCIsInJlcGxhY2VGdW5jIiwicHVzaCIsImZyZWV6ZSIsImVycm9yIiwiaWdub3JlIiwicmVwbGFjZSIsImdldFV0ZjhDb2RlUG9pbnRzIiwiX2J5dGVzIiwib25FcnJvciIsImdldEJ5dGVzIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwic3RyIiwiZm9ybSIsImFzc2VydE5vcm1hbGl6ZSIsIm5vcm1hbGl6ZSIsImNoYXJDb2RlQXQiLCJjMiIsInBhaXIiLCJVaW50OEFycmF5IiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJtYXAiLCJjb2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/utf8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/utils/uuid.js":
/*!********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/utils/uuid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uuidV4 = void 0;\n/**\n *  Explain UUID and link to RFC here.\n *\n *  @_subsection: api/utils:UUID  [about-uuid]\n */ const data_js_1 = __webpack_require__(/*! ./data.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/data.js\");\n/**\n *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.\n *\n *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n */ function uuidV4(randomBytes) {\n    const bytes = (0, data_js_1.getBytes)(randomBytes, \"randomBytes\");\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = bytes[6] & 0x0f | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    const value = (0, data_js_1.hexlify)(bytes);\n    return [\n        value.substring(2, 10),\n        value.substring(10, 14),\n        value.substring(14, 18),\n        value.substring(18, 22),\n        value.substring(22, 34)\n    ].join(\"-\");\n}\nexports.uuidV4 = uuidV4; //# sourceMappingURL=uuid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0Qjs7OztDQUlDLEdBQ0QsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMseUVBQVc7QUFDckM7Ozs7Q0FJQyxHQUNELFNBQVNGLE9BQU9HLFdBQVc7SUFDdkIsTUFBTUMsUUFBUSxDQUFDLEdBQUdILFVBQVVJLFFBQVEsRUFBRUYsYUFBYTtJQUNuRCxrQkFBa0I7SUFDbEIsd0NBQXdDO0lBQ3hDQyxLQUFLLENBQUMsRUFBRSxHQUFHLEtBQU0sQ0FBQyxFQUFFLEdBQUcsT0FBUTtJQUMvQixjQUFjO0lBQ2QsdUNBQXVDO0lBQ3ZDLHVDQUF1QztJQUN2Q0EsS0FBSyxDQUFDLEVBQUUsR0FBRyxLQUFNLENBQUMsRUFBRSxHQUFHLE9BQVE7SUFDL0IsTUFBTUwsUUFBUSxDQUFDLEdBQUdFLFVBQVVLLE9BQU8sRUFBRUY7SUFDckMsT0FBTztRQUNITCxNQUFNUSxTQUFTLENBQUMsR0FBRztRQUNuQlIsTUFBTVEsU0FBUyxDQUFDLElBQUk7UUFDcEJSLE1BQU1RLFNBQVMsQ0FBQyxJQUFJO1FBQ3BCUixNQUFNUSxTQUFTLENBQUMsSUFBSTtRQUNwQlIsTUFBTVEsU0FBUyxDQUFDLElBQUk7S0FDdkIsQ0FBQ0MsSUFBSSxDQUFDO0FBQ1g7QUFDQVYsY0FBYyxHQUFHRSxRQUNqQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy91dGlscy91dWlkLmpzPzMyZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV1aWRWNCA9IHZvaWQgMDtcbi8qKlxuICogIEV4cGxhaW4gVVVJRCBhbmQgbGluayB0byBSRkMgaGVyZS5cbiAqXG4gKiAgQF9zdWJzZWN0aW9uOiBhcGkvdXRpbHM6VVVJRCAgW2Fib3V0LXV1aWRdXG4gKi9cbmNvbnN0IGRhdGFfanNfMSA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG4vKipcbiAqICBSZXR1cm5zIHRoZSB2ZXJzaW9uIDQgW1tsaW5rLXV1aWRdXSBmb3IgdGhlICUlcmFuZG9tQnl0ZXMlJS5cbiAqXG4gKiAgQHNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcbiAqL1xuZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgZGF0YV9qc18xLmdldEJ5dGVzKShyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcbiAgICAvLyBTZWN0aW9uOiA0LjEuMzpcbiAgICAvLyAtIHRpbWVfaGlfYW5kX3ZlcnNpb25bMTI6MTZdID0gMGIwMTAwXG4gICAgYnl0ZXNbNl0gPSAoYnl0ZXNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgLy8gU2VjdGlvbiA0LjRcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbNl0gPSAwYjBcbiAgICAvLyAtIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRbN10gPSAwYjFcbiAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICBjb25zdCB2YWx1ZSA9ICgwLCBkYXRhX2pzXzEuaGV4bGlmeSkoYnl0ZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyLCAxMCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTQsIDE4KSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDE4LCAyMiksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG5leHBvcnRzLnV1aWRWNCA9IHV1aWRWNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV1aWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXVpZFY0IiwiZGF0YV9qc18xIiwicmVxdWlyZSIsInJhbmRvbUJ5dGVzIiwiYnl0ZXMiLCJnZXRCeXRlcyIsImhleGxpZnkiLCJzdWJzdHJpbmciLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/utils/uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/base-wallet.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseWallet = void 0;\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../providers/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */ class BaseWallet extends index_js_3.AbstractSigner {\n    #signingKey;\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */ constructor(privateKey, provider){\n        super(provider);\n        (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n        this.#signingKey = privateKey;\n        const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);\n        (0, index_js_5.defineProperties)(this, {\n            address\n        });\n    }\n    // Store private values behind getters to reduce visibility\n    // in console.log\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */ get signingKey() {\n        return this.#signingKey;\n    }\n    /**\n     *  The private key for this wallet.\n     */ get privateKey() {\n        return this.signingKey.privateKey;\n    }\n    async getAddress() {\n        return this.address;\n    }\n    connect(provider) {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n    async signTransaction(tx) {\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await (0, index_js_5.resolveProperties)({\n            to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,\n            from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined\n        });\n        if (to != null) {\n            tx.to = to;\n        }\n        if (from != null) {\n            tx.from = from;\n        }\n        if (tx.from != null) {\n            (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n        // Build the transaction\n        const btx = index_js_4.Transaction.from(tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n        return btx.serialized;\n    }\n    async signMessage(message) {\n        return this.signMessageSync(message);\n    }\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */ signMessageSync(message) {\n        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;\n    }\n    async signTypedData(domain, types, value) {\n        // Populate any ENS names\n        const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types, value, async (name)=>{\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n            (0, index_js_5.assert)(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: {\n                    name\n                }\n            });\n            const address = await this.provider.resolveName(name);\n            (0, index_js_5.assert)(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n            return address;\n        });\n        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\nexports.BaseWallet = BaseWallet; //# sourceMappingURL=base-wallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvYmFzZS13YWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsc0ZBQXFCO0FBQ2hELE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGdGQUFrQjtBQUM3QyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBdUI7QUFDbEQsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3BELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5Qzs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUYsbUJBQW1CSSxXQUFXRyxjQUFjO0lBSzlDLENBQUNDLFVBQVUsQ0FBQztJQUNaOzs7Ozs7S0FNQyxHQUNEQyxZQUFZQyxVQUFVLEVBQUVDLFFBQVEsQ0FBRTtRQUM5QixLQUFLLENBQUNBO1FBQ0wsSUFBR0wsV0FBV00sY0FBYyxFQUFFRixjQUFjLE9BQVFBLFdBQVdHLElBQUksS0FBTSxZQUFZLHVCQUF1QixjQUFjO1FBQzNILElBQUksQ0FBQyxDQUFDTCxVQUFVLEdBQUdFO1FBQ25CLE1BQU1JLFVBQVUsQ0FBQyxHQUFHVCxXQUFXVSxjQUFjLEVBQUUsSUFBSSxDQUFDUCxVQUFVLENBQUNRLFNBQVM7UUFDdkUsSUFBR1YsV0FBV1csZ0JBQWdCLEVBQUUsSUFBSSxFQUFFO1lBQUVIO1FBQVE7SUFDckQ7SUFDQSwyREFBMkQ7SUFDM0QsaUJBQWlCO0lBQ2pCOztLQUVDLEdBQ0QsSUFBSU4sYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNBLFVBQVU7SUFBRTtJQUM1Qzs7S0FFQyxHQUNELElBQUlFLGFBQWE7UUFBRSxPQUFPLElBQUksQ0FBQ0YsVUFBVSxDQUFDRSxVQUFVO0lBQUU7SUFDdEQsTUFBTVEsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDSixPQUFPO0lBQUU7SUFDMUNLLFFBQVFSLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSVgsV0FBVyxJQUFJLENBQUMsQ0FBQ1EsVUFBVSxFQUFFRztJQUM1QztJQUNBLE1BQU1TLGdCQUFnQkMsRUFBRSxFQUFFO1FBQ3RCLHNEQUFzRDtRQUN0RCxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUdqQixXQUFXa0IsaUJBQWlCLEVBQUU7WUFDekRGLElBQUtELEdBQUdDLEVBQUUsR0FBRyxDQUFDLEdBQUdyQixXQUFXd0IsY0FBYyxFQUFFSixHQUFHQyxFQUFFLEVBQUUsSUFBSSxDQUFDWCxRQUFRLElBQUllO1lBQ3BFSCxNQUFPRixHQUFHRSxJQUFJLEdBQUcsQ0FBQyxHQUFHdEIsV0FBV3dCLGNBQWMsRUFBRUosR0FBR0UsSUFBSSxFQUFFLElBQUksQ0FBQ1osUUFBUSxJQUFJZTtRQUM5RTtRQUNBLElBQUlKLE1BQU0sTUFBTTtZQUNaRCxHQUFHQyxFQUFFLEdBQUdBO1FBQ1o7UUFDQSxJQUFJQyxRQUFRLE1BQU07WUFDZEYsR0FBR0UsSUFBSSxHQUFHQTtRQUNkO1FBQ0EsSUFBSUYsR0FBR0UsSUFBSSxJQUFJLE1BQU07WUFDaEIsSUFBR2pCLFdBQVdNLGNBQWMsRUFBRSxDQUFDLEdBQUdYLFdBQVdpQixVQUFVLEVBQUdHLEdBQUdFLElBQUksTUFBTyxJQUFJLENBQUNULE9BQU8sRUFBRSxxQ0FBcUMsV0FBV08sR0FBR0UsSUFBSTtZQUM5SSxPQUFPRixHQUFHRSxJQUFJO1FBQ2xCO1FBQ0Esd0JBQXdCO1FBQ3hCLE1BQU1JLE1BQU10QixXQUFXdUIsV0FBVyxDQUFDTCxJQUFJLENBQUNGO1FBQ3hDTSxJQUFJRSxTQUFTLEdBQUcsSUFBSSxDQUFDckIsVUFBVSxDQUFDSyxJQUFJLENBQUNjLElBQUlHLFlBQVk7UUFDckQsT0FBT0gsSUFBSUksVUFBVTtJQUN6QjtJQUNBLE1BQU1DLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtJQUNoQztJQUNBLGtFQUFrRTtJQUNsRSw0QkFBNEI7SUFDNUI7O0tBRUMsR0FDREMsZ0JBQWdCRCxPQUFPLEVBQUU7UUFDckIsT0FBTyxJQUFJLENBQUN6QixVQUFVLENBQUNLLElBQUksQ0FBQyxDQUFDLEdBQUdWLFdBQVdnQyxXQUFXLEVBQUVGLFVBQVVGLFVBQVU7SUFDaEY7SUFDQSxNQUFNSyxjQUFjQyxNQUFNLEVBQUVDLEtBQUssRUFBRXZDLEtBQUssRUFBRTtRQUN0Qyx5QkFBeUI7UUFDekIsTUFBTXdDLFlBQVksTUFBTXBDLFdBQVdxQyxnQkFBZ0IsQ0FBQ0MsWUFBWSxDQUFDSixRQUFRQyxPQUFPdkMsT0FBTyxPQUFPMkM7WUFDMUYsc0RBQXNEO1lBQ3RELHlCQUF5QjtZQUN4QixJQUFHcEMsV0FBV3FDLE1BQU0sRUFBRSxJQUFJLENBQUNoQyxRQUFRLElBQUksTUFBTSwrQ0FBK0MseUJBQXlCO2dCQUNsSGlDLFdBQVc7Z0JBQ1hDLE1BQU07b0JBQUVIO2dCQUFLO1lBQ2pCO1lBQ0EsTUFBTTVCLFVBQVUsTUFBTSxJQUFJLENBQUNILFFBQVEsQ0FBQ21DLFdBQVcsQ0FBQ0o7WUFDL0MsSUFBR3BDLFdBQVdxQyxNQUFNLEVBQUU3QixXQUFXLE1BQU0seUJBQXlCLHFCQUFxQjtnQkFDbEZmLE9BQU8yQztZQUNYO1lBQ0EsT0FBTzVCO1FBQ1g7UUFDQSxPQUFPLElBQUksQ0FBQ04sVUFBVSxDQUFDSyxJQUFJLENBQUNWLFdBQVdxQyxnQkFBZ0IsQ0FBQ08sSUFBSSxDQUFDUixVQUFVRixNQUFNLEVBQUVDLE9BQU9DLFVBQVV4QyxLQUFLLEdBQUdnQyxVQUFVO0lBQ3RIO0FBQ0o7QUFDQWpDLGtCQUFrQixHQUFHRSxZQUNyQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvYmFzZS13YWxsZXQuanM/ZDg0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVdhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vcHJvdmlkZXJzL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbi9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzUgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG4vKipcbiAqICBUaGUgKipCYXNlV2FsbGV0KiogaXMgYSBzdHJlYW0tbGluZWQgaW1wbGVtZW50YXRpb24gb2YgYVxuICogIFtbU2lnbmVyXV0gdGhhdCBvcGVyYXRlcyB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFtbV2FsbGV0XV0gY2xhc3MsIGFzIGl0IG9mZmVyc1xuICogIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSBhbmQgc2ltcGxpZmllcyBsb2FkaW5nIGEgdmFyaWV0eVxuICogIG9mIEpTT04gZm9ybWF0cywgTW5lbW9uaWMgUGhyYXNlcywgZXRjLlxuICpcbiAqICBUaGlzIGNsYXNzIG1heSBiZSBvZiB1c2UgZm9yIHRob3NlIGF0dGVtcHRpbmcgdG8gaW1wbGVtZW50XG4gKiAgYSBtaW5pbWFsIFNpZ25lci5cbiAqL1xuY2xhc3MgQmFzZVdhbGxldCBleHRlbmRzIGluZGV4X2pzXzMuQWJzdHJhY3RTaWduZXIge1xuICAgIC8qKlxuICAgICAqICBUaGUgd2FsbGV0IGFkZHJlc3MuXG4gICAgICovXG4gICAgYWRkcmVzcztcbiAgICAjc2lnbmluZ0tleTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBCYXNlV2FsbGV0IGZvciAlJXByaXZhdGVLZXklJSwgb3B0aW9uYWxseVxuICAgICAqICBjb25uZWN0ZWQgdG8gJSVwcm92aWRlciUlLlxuICAgICAqXG4gICAgICogIElmICUlcHJvdmlkZXIlJSBpcyBub3Qgc3BlY2lmaWVkLCBvbmx5IG9mZmxpbmUgbWV0aG9kcyBjYW5cbiAgICAgKiAgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5LCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KShwcml2YXRlS2V5ICYmIHR5cGVvZiAocHJpdmF0ZUtleS5zaWduKSA9PT0gXCJmdW5jdGlvblwiLCBcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICB0aGlzLiNzaWduaW5nS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbmRleF9qc180LmNvbXB1dGVBZGRyZXNzKSh0aGlzLnNpZ25pbmdLZXkucHVibGljS2V5KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzUuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBhZGRyZXNzIH0pO1xuICAgIH1cbiAgICAvLyBTdG9yZSBwcml2YXRlIHZhbHVlcyBiZWhpbmQgZ2V0dGVycyB0byByZWR1Y2UgdmlzaWJpbGl0eVxuICAgIC8vIGluIGNvbnNvbGUubG9nXG4gICAgLyoqXG4gICAgICogIFRoZSBbW1NpZ25pbmdLZXldXSB1c2VkIGZvciBzaWduaW5nIHBheWxvYWRzLlxuICAgICAqL1xuICAgIGdldCBzaWduaW5nS2V5KCkgeyByZXR1cm4gdGhpcy4jc2lnbmluZ0tleTsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgcHJpdmF0ZSBrZXkgZm9yIHRoaXMgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnByaXZhdGVLZXk7IH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKCkgeyByZXR1cm4gdGhpcy5hZGRyZXNzOyB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VXYWxsZXQodGhpcy4jc2lnbmluZ0tleSwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHgpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBhbnkgQWRkcmVzc2FibGUgb3IgRU5TIG5hbWUgd2l0aCBhbiBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHsgdG8sIGZyb20gfSA9IGF3YWl0ICgwLCBpbmRleF9qc181LnJlc29sdmVQcm9wZXJ0aWVzKSh7XG4gICAgICAgICAgICB0bzogKHR4LnRvID8gKDAsIGluZGV4X2pzXzEucmVzb2x2ZUFkZHJlc3MpKHR4LnRvLCB0aGlzLnByb3ZpZGVyKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICBmcm9tOiAodHguZnJvbSA/ICgwLCBpbmRleF9qc18xLnJlc29sdmVBZGRyZXNzKSh0eC5mcm9tLCB0aGlzLnByb3ZpZGVyKSA6IHVuZGVmaW5lZClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0byAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50byA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc181LmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKSgodHguZnJvbSkpID09PSB0aGlzLmFkZHJlc3MsIFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHguZnJvbVwiLCB0eC5mcm9tKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0eC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBjb25zdCBidHggPSBpbmRleF9qc180LlRyYW5zYWN0aW9uLmZyb20odHgpO1xuICAgICAgICBidHguc2lnbmF0dXJlID0gdGhpcy5zaWduaW5nS2V5LnNpZ24oYnR4LnVuc2lnbmVkSGFzaCk7XG4gICAgICAgIHJldHVybiBidHguc2VyaWFsaXplZDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduTWVzc2FnZVN5bmMobWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBBZGQgYSBzZWNpYWxpemVkIHNpZ25UeCBhbmQgc2lnblR5cGVkIHN5bmMgdGhhdCBlbmZvcmNlc1xuICAgIC8vIGFsbCBwYXJhbWV0ZXJzIGFyZSBrbm93bj9cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2lnbmF0dXJlIGZvciAlJW1lc3NhZ2UlJSBzaWduZWQgd2l0aCB0aGlzIHdhbGxldC5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZVN5bmMobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnNpZ24oKDAsIGluZGV4X2pzXzIuaGFzaE1lc3NhZ2UpKG1lc3NhZ2UpKS5zZXJpYWxpemVkO1xuICAgIH1cbiAgICBhc3luYyBzaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXNcbiAgICAgICAgY29uc3QgcG9wdWxhdGVkID0gYXdhaXQgaW5kZXhfanNfMi5UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIC8vIEBUT0RPOiB0aGlzIHNob3VsZCB1c2UgcmVzb2x2ZU5hbWU7IGFkZHJlc3NlcyBkb24ndFxuICAgICAgICAgICAgLy8gICAgICAgIG5lZWQgYSBwcm92aWRlclxuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzUuYXNzZXJ0KSh0aGlzLnByb3ZpZGVyICE9IG51bGwsIFwiY2Fubm90IHJlc29sdmUgRU5TIG5hbWVzIHdpdGhvdXQgYSBwcm92aWRlclwiLCBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCIsXG4gICAgICAgICAgICAgICAgaW5mbzogeyBuYW1lIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNS5hc3NlcnQpKGFkZHJlc3MgIT0gbnVsbCwgXCJ1bmNvbmZpZ3VyZWQgRU5TIG5hbWVcIiwgXCJVTkNPTkZJR1VSRURfTkFNRVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduaW5nS2V5LnNpZ24oaW5kZXhfanNfMi5UeXBlZERhdGFFbmNvZGVyLmhhc2gocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpLnNlcmlhbGl6ZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlV2FsbGV0ID0gQmFzZVdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2Utd2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VXYWxsZXQiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJpbmRleF9qc18zIiwiaW5kZXhfanNfNCIsImluZGV4X2pzXzUiLCJBYnN0cmFjdFNpZ25lciIsInNpZ25pbmdLZXkiLCJjb25zdHJ1Y3RvciIsInByaXZhdGVLZXkiLCJwcm92aWRlciIsImFzc2VydEFyZ3VtZW50Iiwic2lnbiIsImFkZHJlc3MiLCJjb21wdXRlQWRkcmVzcyIsInB1YmxpY0tleSIsImRlZmluZVByb3BlcnRpZXMiLCJnZXRBZGRyZXNzIiwiY29ubmVjdCIsInNpZ25UcmFuc2FjdGlvbiIsInR4IiwidG8iLCJmcm9tIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJyZXNvbHZlQWRkcmVzcyIsInVuZGVmaW5lZCIsImJ0eCIsIlRyYW5zYWN0aW9uIiwic2lnbmF0dXJlIiwidW5zaWduZWRIYXNoIiwic2VyaWFsaXplZCIsInNpZ25NZXNzYWdlIiwibWVzc2FnZSIsInNpZ25NZXNzYWdlU3luYyIsImhhc2hNZXNzYWdlIiwic2lnblR5cGVkRGF0YSIsImRvbWFpbiIsInR5cGVzIiwicG9wdWxhdGVkIiwiVHlwZWREYXRhRW5jb2RlciIsInJlc29sdmVOYW1lcyIsIm5hbWUiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJpbmZvIiwicmVzb2x2ZU5hbWUiLCJoYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/hdwallet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;\n/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */ const index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../providers/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/providers/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nconst base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nconst mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nconst json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */ exports.defaultPath = \"m/44'/60'/0'/0/0\";\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([\n    66,\n    105,\n    116,\n    99,\n    111,\n    105,\n    110,\n    32,\n    115,\n    101,\n    101,\n    100\n]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value, length) {\n    let result = \"\";\n    while(value){\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while(result.length < length * 2){\n        result = \"0\" + result;\n    }\n    return \"0x\" + result;\n}\nfunction encodeBase58Check(_value) {\n    const value = (0, index_js_4.getBytes)(_value);\n    const check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);\n    const bytes = (0, index_js_4.concat)([\n        value,\n        check\n    ]);\n    return (0, index_js_4.encodeBase58)(bytes);\n}\nconst _guard = {};\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n    const data = new Uint8Array(37);\n    if (index & HardenedBit) {\n        (0, index_js_4.assert)(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n        // Data = 0x00 || ser_256(k_par)\n        data.set((0, index_js_4.getBytes)(privateKey), 1);\n    } else {\n        // Data = ser_p(point(k_par))\n        data.set((0, index_js_4.getBytes)(publicKey));\n    }\n    // Data += ser_32(i)\n    for(let i = 24; i >= 0; i -= 8){\n        data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n    }\n    const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", chainCode, data));\n    return {\n        IL: I.slice(0, 32),\n        IR: I.slice(32)\n    };\n}\nfunction derivePath(node, path) {\n    const components = path.split(\"/\");\n    (0, index_js_4.assertArgument)(components.length > 0 && (components[0] === \"m\" || node.depth > 0), \"invalid path\", \"path\", path);\n    if (components[0] === \"m\") {\n        components.shift();\n    }\n    let result = node;\n    for(let i = 0; i < components.length; i++){\n        const component = components[i];\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            (0, index_js_4.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(HardenedBit + index);\n        } else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            (0, index_js_4.assertArgument)(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n            result = result.deriveChild(index);\n        } else {\n            (0, index_js_4.assertArgument)(false, \"invalid path component\", `path[${i}]`, component);\n        }\n    }\n    return result;\n}\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */ class HDNodeWallet extends base_wallet_js_1.BaseWallet {\n    /**\n     *  @private\n     */ constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider){\n        super(signingKey, provider);\n        (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeWallet\");\n        (0, index_js_4.defineProperties)(this, {\n            publicKey: signingKey.compressedPublicKey\n        });\n        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(this.publicKey)), 0, 4);\n        (0, index_js_4.defineProperties)(this, {\n            parentFingerprint,\n            fingerprint,\n            chainCode,\n            path,\n            index,\n            depth\n        });\n        (0, index_js_4.defineProperties)(this, {\n            mnemonic\n        });\n    }\n    connect(provider) {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n    #account() {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n        return account;\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */ async encrypt(password, progressCallback) {\n        return await (0, json_keystore_js_1.encryptKeystoreJson)(this.#account(), password, {\n            progressCallback\n        });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */ encryptSync(password) {\n        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(this.#account(), password);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */ get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"extendedKey\"\n        });\n        return encodeBase58Check((0, index_js_4.concat)([\n            \"0x0488ADE4\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            (0, index_js_4.concat)([\n                \"0x00\",\n                this.privateKey\n            ])\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */ hasPath() {\n        return this.path != null;\n    }\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */ neuter() {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n    }\n    /**\n     *  Return the child for %%index%%.\n     */ deriveChild(_index) {\n        const index = (0, index_js_4.getNumber)(_index, \"index\");\n        (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));\n        return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n    }\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */ derivePath(path) {\n        return derivePath(this, path);\n    }\n    static #fromSeed(_seed, mnemonic) {\n        (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const seed = (0, index_js_4.getBytes)(_seed, \"seed\");\n        (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n        const I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)(\"sha512\", MasterSecret, seed));\n        const signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", (0, index_js_4.hexlify)(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n    }\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */ static fromExtendedKey(extendedKey) {\n        const bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact\n        (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n        const depth = bytes[4];\n        const parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));\n        const index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n        switch((0, index_js_4.hexlify)(bytes.slice(0, 4))){\n            // Public Key\n            case \"0x0488b21e\":\n            case \"0x043587cf\":\n                {\n                    const publicKey = (0, index_js_4.hexlify)(key);\n                    return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n                }\n            // Private Key\n            case \"0x0488ade4\":\n            case \"0x04358394 \":\n                if (key[0] !== 0) {\n                    break;\n                }\n                return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n        (0, index_js_4.assertArgument)(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n    /**\n     *  Creates a new random HDNode.\n     */ static createRandom(password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = exports.defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */ static fromMnemonic(mnemonic, path) {\n        if (!path) {\n            path = exports.defaultPath;\n        }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */ static fromPhrase(phrase, password, path, wordlist) {\n        if (password == null) {\n            password = \"\";\n        }\n        if (path == null) {\n            path = exports.defaultPath;\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        const mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */ static fromSeed(seed) {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\nexports.HDNodeWallet = HDNodeWallet;\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */ class HDNodeVoidWallet extends index_js_2.VoidSigner {\n    /**\n     *  @private\n     */ constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider){\n        super(address, provider);\n        (0, index_js_4.assertPrivate)(guard, _guard, \"HDNodeVoidWallet\");\n        (0, index_js_4.defineProperties)(this, {\n            publicKey\n        });\n        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);\n        (0, index_js_4.defineProperties)(this, {\n            publicKey,\n            fingerprint,\n            parentFingerprint,\n            chainCode,\n            path,\n            index,\n            depth\n        });\n    }\n    connect(provider) {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */ get extendedKey() {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n        (0, index_js_4.assert)(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"extendedKey\"\n        });\n        return encodeBase58Check((0, index_js_4.concat)([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey\n        ]));\n    }\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */ hasPath() {\n        return this.path != null;\n    }\n    /**\n     *  Return the child for %%index%%.\n     */ deriveChild(_index) {\n        const index = (0, index_js_4.getNumber)(_index, \"index\");\n        (0, index_js_4.assertArgument)(index <= 0xffffffff, \"invalid index\", \"index\", index);\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) {\n                path += \"'\";\n            }\n        }\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);\n        const address = (0, index_js_3.computeAddress)(Ki);\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);\n    }\n    /**\n     *  Return the signer for %%path%% from this node.\n     */ derivePath(path) {\n        return derivePath(this, path);\n    }\n}\nexports.HDNodeVoidWallet = HDNodeVoidWallet;\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/ /**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */ function getAccountPath(_index) {\n    const index = (0, index_js_4.getNumber)(_index, \"index\");\n    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${index}'/0/0`;\n}\nexports.getAccountPath = getAccountPath;\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */ function getIndexedAccountPath(_index) {\n    const index = (0, index_js_4.getNumber)(_index, \"index\");\n    (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${index}`;\n}\nexports.getIndexedAccountPath = getIndexedAccountPath; //# sourceMappingURL=hdwallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaGR3YWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQ3RJOzs7O0NBSUMsR0FDRCxNQUFNTyxhQUFhQyxtQkFBT0EsQ0FBQyxvRkFBb0I7QUFDL0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEZBQXVCO0FBQ2xELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDhGQUF5QjtBQUNwRCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyxrRkFBbUI7QUFDOUMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsOEZBQXlCO0FBQ3RELE1BQU1LLG1CQUFtQkwsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1NLGdCQUFnQk4sbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTU8scUJBQXFCUCxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDdkQ7O0NBRUMsR0FDRFIsbUJBQW1CLEdBQUc7QUFDdEIsaUJBQWlCO0FBQ2pCLE1BQU1nQixlQUFlLElBQUlDLFdBQVc7SUFBQztJQUFJO0lBQUs7SUFBSztJQUFJO0lBQUs7SUFBSztJQUFLO0lBQUk7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUM3RixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLElBQUlDLE9BQU87QUFDakIsTUFBTUMsVUFBVTtBQUNoQixTQUFTQyxLQUFLckIsS0FBSyxFQUFFc0IsTUFBTTtJQUN2QixJQUFJQyxTQUFTO0lBQ2IsTUFBT3ZCLE1BQU87UUFDVnVCLFNBQVNILE9BQU8sQ0FBQ3BCLFFBQVEsR0FBRyxHQUFHdUI7UUFDL0J2QixRQUFRd0IsS0FBS0MsS0FBSyxDQUFDekIsUUFBUTtJQUMvQjtJQUNBLE1BQU91QixPQUFPRCxNQUFN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U29CO0lBQ3BHLE9BQU8sQ0FBQyxlQUFlLEVBQUVBLE1BQU0sQ0FBQztBQUNwQztBQUNBdEMsNkJBQTZCLEdBQUdFLHVCQUNoQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaGR3YWxsZXQuanM/M2IzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SW5kZXhlZEFjY291bnRQYXRoID0gZXhwb3J0cy5nZXRBY2NvdW50UGF0aCA9IGV4cG9ydHMuSEROb2RlVm9pZFdhbGxldCA9IGV4cG9ydHMuSEROb2RlV2FsbGV0ID0gZXhwb3J0cy5kZWZhdWx0UGF0aCA9IHZvaWQgMDtcbi8qKlxuICogIEV4cGxhaW4gSEQgV2FsbGV0cy4uXG4gKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpIRCBXYWxsZXRzICBbaGQtd2FsbGV0c11cbiAqL1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jcnlwdG8vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3Byb3ZpZGVycy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgbGFuZ19lbl9qc18xID0gcmVxdWlyZShcIi4uL3dvcmRsaXN0cy9sYW5nLWVuLmpzXCIpO1xuY29uc3QgYmFzZV93YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2Jhc2Utd2FsbGV0LmpzXCIpO1xuY29uc3QgbW5lbW9uaWNfanNfMSA9IHJlcXVpcmUoXCIuL21uZW1vbmljLmpzXCIpO1xuY29uc3QganNvbl9rZXlzdG9yZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1rZXlzdG9yZS5qc1wiKTtcbi8qKlxuICogIFRoZSBkZWZhdWx0IGRlcml2YXRpb24gcGF0aCBmb3IgRXRoZXJldW0gSEQgTm9kZXMuIChpLmUuIGBgXCJtLzQ0Jy82MCcvMCcvMC8wXCJgYClcbiAqL1xuZXhwb3J0cy5kZWZhdWx0UGF0aCA9IFwibS80NCcvNjAnLzAnLzAvMFwiO1xuLy8gXCJCaXRjb2luIHNlZWRcIlxuY29uc3QgTWFzdGVyU2VjcmV0ID0gbmV3IFVpbnQ4QXJyYXkoWzY2LCAxMDUsIDExNiwgOTksIDExMSwgMTA1LCAxMTAsIDMyLCAxMTUsIDEwMSwgMTAxLCAxMDBdKTtcbmNvbnN0IEhhcmRlbmVkQml0ID0gMHg4MDAwMDAwMDtcbmNvbnN0IE4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG5jb25zdCBOaWJibGVzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5mdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0ID0gTmliYmxlc1t2YWx1ZSAlIDE2XSArIHJlc3VsdDtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnRydW5jKHZhbHVlIC8gMTYpO1xuICAgIH1cbiAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBlbmNvZGVCYXNlNThDaGVjayhfdmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShfdmFsdWUpO1xuICAgIGNvbnN0IGNoZWNrID0gKDAsIGluZGV4X2pzXzQuZGF0YVNsaWNlKSgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKCgwLCBpbmRleF9qc18xLnNoYTI1NikodmFsdWUpKSwgMCwgNCk7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgaW5kZXhfanNfNC5jb25jYXQpKFt2YWx1ZSwgY2hlY2tdKTtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzQuZW5jb2RlQmFzZTU4KShieXRlcyk7XG59XG5jb25zdCBfZ3VhcmQgPSB7fTtcbmZ1bmN0aW9uIHNlcl9JKGluZGV4LCBjaGFpbkNvZGUsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XG4gICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KShwcml2YXRlS2V5ICE9IG51bGwsIFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZXJpdmVDaGlsZFwiXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEYXRhID0gMHgwMCB8fCBzZXJfMjU2KGtfcGFyKVxuICAgICAgICBkYXRhLnNldCgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykocHJpdmF0ZUtleSksIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRGF0YSA9IHNlcl9wKHBvaW50KGtfcGFyKSlcbiAgICAgICAgZGF0YS5zZXQoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKHB1YmxpY0tleSkpO1xuICAgIH1cbiAgICAvLyBEYXRhICs9IHNlcl8zMihpKVxuICAgIGZvciAobGV0IGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcbiAgICAgICAgZGF0YVszMyArIChpID4+IDMpXSA9ICgoaW5kZXggPj4gKDI0IC0gaSkpICYgMHhmZik7XG4gICAgfVxuICAgIGNvbnN0IEkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEuY29tcHV0ZUhtYWMpKFwic2hhNTEyXCIsIGNoYWluQ29kZSwgZGF0YSkpO1xuICAgIHJldHVybiB7IElMOiBJLnNsaWNlKDAsIDMyKSwgSVI6IEkuc2xpY2UoMzIpIH07XG59XG5mdW5jdGlvbiBkZXJpdmVQYXRoKG5vZGUsIHBhdGgpIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGNvbXBvbmVudHMubGVuZ3RoID4gMCAmJiAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIgfHwgbm9kZS5kZXB0aCA+IDApLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgcGF0aCk7XG4gICAgaWYgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiKSB7XG4gICAgICAgIGNvbXBvbmVudHMuc2hpZnQoKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IG5vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSsnJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudC5zdWJzdHJpbmcoMCwgY29tcG9uZW50Lmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgcGF0aCBpbmRleFwiLCBgcGF0aFske2l9XWAsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZGVyaXZlQ2hpbGQoSGFyZGVuZWRCaXQgKyBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIHBhdGggaW5kZXhcIiwgYHBhdGhbJHtpfV1gLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRlcml2ZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShmYWxzZSwgXCJpbnZhbGlkIHBhdGggY29tcG9uZW50XCIsIGBwYXRoWyR7aX1dYCwgY29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiAgQW4gKipIRE5vZGVXYWxsZXQqKiBpcyBhIFtbU2lnbmVyXV0gYmFja2VkIGJ5IHRoZSBwcml2YXRlIGtleSBkZXJpdmVkXG4gKiAgZnJvbSBhbiBIRCBOb2RlIHVzaW5nIHRoZSBbW2xpbmstYmlwLTMyXV0gc3RhbnRhcmQuXG4gKlxuICogIEFuIEhEIE5vZGUgZm9ybXMgYSBoaWVyYXJjaGFsIHN0cnVjdHVyZSB3aXRoIGVhY2ggSEQgTm9kZSBoYXZpbmcgYVxuICogIHByaXZhdGUga2V5IGFuZCB0aGUgYWJpbGl0eSB0byBkZXJpdmUgY2hpbGQgSEQgTm9kZXMsIGRlZmluZWQgYnlcbiAqICBhIHBhdGggaW5kaWNhdGluZyB0aGUgaW5kZXggb2YgZWFjaCBjaGlsZC5cbiAqL1xuY2xhc3MgSEROb2RlV2FsbGV0IGV4dGVuZHMgYmFzZV93YWxsZXRfanNfMS5CYXNlV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaW5nZXJwcmludC5cbiAgICAgKlxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXG4gICAgICogIGJ1dCBkZXZlbG9wZXJzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBkZWFsIHdpdGggY29sbGlzaW9ucyBhcyBpdFxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJlbnQgZmluZ2VycHJpbnQuXG4gICAgICovXG4gICAgcGFyZW50RmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBtbmVtb25pYyB1c2VkIHRvIGNyZWF0ZSB0aGlzIEhEIE5vZGUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqICBTb3VyY2VzIHN1Y2ggYXMgZXh0ZW5kZWQga2V5cyBkbyBub3QgZW5jb2RlIHRoZSBtbmVtb25pYywgaW5cbiAgICAgKiAgd2hpY2ggY2FzZSB0aGlzIHdpbGwgYmUgYGBudWxsYGAuXG4gICAgICovXG4gICAgbW5lbW9uaWM7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGFpbmNvZGUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGEgcHVibGljIGtleSB1c2VkXG4gICAgICogIHRvIGRlcml2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjaGFpbkNvZGU7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXJpdmF0aW9uIHBhdGggb2YgdGhpcyB3YWxsZXQuXG4gICAgICpcbiAgICAgKiAgU2luY2UgZXh0ZW5kZWQga2V5cyBkbyBub3QgcHJvdmlkZXIgZnVsbCBwYXRoIGRldGFpbHMsIHRoaXNcbiAgICAgKiAgbWF5IGJlIGBgbnVsbGBgLCBpZiBpbnN0YW50aWF0ZWQgZnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90XG4gICAgICogIGVub2NkZSBpdC5cbiAgICAgKi9cbiAgICBwYXRoO1xuICAgIC8qKlxuICAgICAqICBUaGUgY2hpbGQgaW5kZXggb2YgdGhpcyB3YWxsZXQuIFZhbHVlcyBvdmVyIGBgMiAqXFwqIDMxYGAgaW5kaWNhdGVcbiAgICAgKiAgdGhlIG5vZGUgaXMgaGFyZGVuZWQuXG4gICAgICovXG4gICAgaW5kZXg7XG4gICAgLyoqXG4gICAgICogIFRoZSBkZXB0aCBvZiB0aGlzIHdhbGxldCwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICogIGluIGl0cyBwYXRoLlxuICAgICAqL1xuICAgIGRlcHRoO1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBzaWduaW5nS2V5LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGgsIG1uZW1vbmljLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlV2FsbGV0XCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHB1YmxpY0tleTogc2lnbmluZ0tleS5jb21wcmVzc2VkUHVibGljS2V5IH0pO1xuICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9ICgwLCBpbmRleF9qc180LmRhdGFTbGljZSkoKDAsIGluZGV4X2pzXzEucmlwZW1kMTYwKSgoMCwgaW5kZXhfanNfMS5zaGEyNTYpKHRoaXMucHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCwgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGUsIHBhdGgsIGluZGV4LCBkZXB0aFxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBtbmVtb25pYyB9KTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHRoaXMuc2lnbmluZ0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5tbmVtb25pYywgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAjYWNjb3VudCgpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IHsgYWRkcmVzczogdGhpcy5hZGRyZXNzLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXkgfTtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMubW5lbW9uaWM7XG4gICAgICAgIGlmICh0aGlzLnBhdGggJiYgbSAmJiBtLndvcmRsaXN0LmxvY2FsZSA9PT0gXCJlblwiICYmIG0ucGFzc3dvcmQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogXCJlblwiLFxuICAgICAgICAgICAgICAgIGVudHJvcHk6IG0uZW50cm9weVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc29sdmVzIHRvIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cHRlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzQ2FsbGJhY2slJSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwgcmVjZWl2ZSBwZXJpb2RpY1xuICAgICAqICB1cGRhdGVzIGFzIHRoZSBlbmNyeXB0aW9uIHByb2Nlc3MgcHJvZ3Jlc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuY3J5cHQocGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBqc29uX2tleXN0b3JlX2pzXzEuZW5jcnlwdEtleXN0b3JlSnNvbikodGhpcy4jYWNjb3VudCgpLCBwYXNzd29yZCwgeyBwcm9ncmVzc0NhbGxiYWNrIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXBlZCB3aXRoXG4gICAgICogICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZW5jcnlwdCkgaW5zdGVhZCxcbiAgICAgKiAgd2hpY2ggYWxsb3dzIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8ga2VlcCB0aGUgdXNlciBpbmZvcm1lZC5cbiAgICAgKlxuICAgICAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsXG4gICAgICogIGl0IGlzIGNvbXBsZXRlLCB3aGljaCBtYXkgYmUgYSBub24tdHJpdmlhbCBkdXJhdGlvbi5cbiAgICAgKi9cbiAgICBlbmNyeXB0U3luYyhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gKDAsIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uU3luYykodGhpcy4jYWNjb3VudCgpLCBwYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBUaGUgZXh0ZW5kZWQga2V5LlxuICAgICAqXG4gICAgICogIFRoaXMga2V5IHdpbGwgYmVnaW4gd2l0aCB0aGUgcHJlZml4IGBgeHByaXZgYCBhbmQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgcmVjb25zdHJ1Y3QgdGhpcyBIRCBOb2RlIHRvIGRlcml2ZSBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcbiAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW50aW1lbnQgaXMgdGhhdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcbiAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KSh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjaygoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcbiAgICAgICAgICAgIFwiMHgwNDg4QURFNFwiLCB6cGFkKHRoaXMuZGVwdGgsIDEpLCB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgenBhZCh0aGlzLmluZGV4LCA0KSwgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcIjB4MDBcIiwgdGhpcy5wcml2YXRlS2V5XSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV1dGVyZWQgSEQgTm9kZSwgd2hpY2ggcmVtb3ZlcyB0aGUgcHJpdmF0ZSBkZXRhaWxzXG4gICAgICogIG9mIGFuIEhEIE5vZGUuXG4gICAgICpcbiAgICAgKiAgQSBuZXV0ZXJlZCBub2RlIGhhcyBubyBwcml2YXRlIGtleSwgYnV0IGNhbiBiZSB1c2VkIHRvIGRlcml2ZVxuICAgICAqICBjaGlsZCBhZGRyZXNzZXMgYW5kIG90aGVyIHB1YmxpYyBkYXRhIGFib3V0IHRoZSBIRCBOb2RlLlxuICAgICAqL1xuICAgIG5ldXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCB0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBraSA9IG5ldyBpbmRleF9qc18xLlNpZ25pbmdLZXkoKDAsIGluZGV4X2pzXzQudG9CZUhleCkoKCgwLCBpbmRleF9qc180LnRvQmlnSW50KShJTCkgKyBCaWdJbnQodGhpcy5wcml2YXRlS2V5KSkgJSBOLCAzMikpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIGtpLCB0aGlzLmZpbmdlcnByaW50LCAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJUiksIHBhdGgsIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgdGhpcy5tbmVtb25pYywgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIEhETm9kZSBmb3IgJSVwYXRoJSUgZnJvbSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBkZXJpdmVQYXRoKHRoaXMsIHBhdGgpO1xuICAgIH1cbiAgICBzdGF0aWMgI2Zyb21TZWVkKF9zZWVkLCBtbmVtb25pYykge1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoKDAsIGluZGV4X2pzXzQuaXNCeXRlc0xpa2UpKF9zZWVkKSwgXCJpbnZhbGlkIHNlZWRcIiwgXCJzZWVkXCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgY29uc3Qgc2VlZCA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShfc2VlZCwgXCJzZWVkXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoc2VlZC5sZW5ndGggPj0gMTYgJiYgc2VlZC5sZW5ndGggPD0gNjQsIFwiaW52YWxpZCBzZWVkXCIsIFwic2VlZFwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIGNvbnN0IEkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzEuY29tcHV0ZUhtYWMpKFwic2hhNTEyXCIsIE1hc3RlclNlY3JldCwgc2VlZCkpO1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IGluZGV4X2pzXzEuU2lnbmluZ0tleSgoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJLnNsaWNlKDAsIDMyKSkpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVdhbGxldChfZ3VhcmQsIHNpZ25pbmdLZXksIFwiMHgwMDAwMDAwMFwiLCAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShJLnNsaWNlKDMyKSksIFwibVwiLCAwLCAwLCBtbmVtb25pYywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IEhEIE5vZGUgZnJvbSAlJWV4dGVuZGVkS2V5JSUuXG4gICAgICpcbiAgICAgKiAgSWYgdGhlICUlZXh0ZW5kZWRLZXklJSB3aWxsIGVpdGhlciBoYXZlIGEgcHJlZml4IG9yIGBgeHB1YmBgIG9yXG4gICAgICogIGBgeHByaXZgYCwgcmV0dXJuaW5nIGEgbmV1dGVyZWQgSEQgTm9kZSAoW1tIRE5vZGVWb2lkV2FsbGV0XV0pXG4gICAgICogIG9yIGZ1bGwgSEQgTm9kZSAoW1tIRE5vZGVXYWxsZXQpIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIGluZGV4X2pzXzQudG9CZUFycmF5KSgoMCwgaW5kZXhfanNfNC5kZWNvZGVCYXNlNTgpKGV4dGVuZGVkS2V5KSk7IC8vIEBUT0RPOiByZWRhY3RcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGJ5dGVzLmxlbmd0aCA9PT0gODIgfHwgZW5jb2RlQmFzZTU4Q2hlY2soYnl0ZXMuc2xpY2UoMCwgNzgpKSA9PT0gZXh0ZW5kZWRLZXksIFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShieXRlcy5zbGljZSg1LCA5KSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoOSwgMTMpKS5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoYnl0ZXMuc2xpY2UoMCwgNCkpKSB7XG4gICAgICAgICAgICAvLyBQdWJsaWMgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YjIxZVwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTg3Y2ZcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgKDAsIGluZGV4X2pzXzMuY29tcHV0ZUFkZHJlc3MpKHB1YmxpY0tleSksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgbnVsbCwgaW5kZXgsIGRlcHRoLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDg4YWRlNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTgzOTQgXCI6XG4gICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVXYWxsZXQoX2d1YXJkLCBuZXcgaW5kZXhfanNfMS5TaWduaW5nS2V5KGtleS5zbGljZSgxKSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIG51bGwsIGluZGV4LCBkZXB0aCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGZhbHNlLCBcImludmFsaWQgZXh0ZW5kZWQga2V5IHByZWZpeFwiLCBcImV4dGVuZGVkS2V5XCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyByYW5kb20gSEROb2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocGFzc3dvcmQsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmIChwYXNzd29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IGV4cG9ydHMuZGVmYXVsdFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1uZW1vbmljID0gbW5lbW9uaWNfanNfMS5NbmVtb25pYy5mcm9tRW50cm9weSgoMCwgaW5kZXhfanNfMS5yYW5kb21CeXRlcykoMTYpLCBwYXNzd29yZCwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhbiBIRCBOb2RlIGZyb20gJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChtbmVtb25pYy5jb21wdXRlU2VlZCgpLCBtbmVtb25pYykuZGVyaXZlUGF0aChwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYW4gSEQgTm9kZSBmcm9tIGEgbW5lbW9uaWMgJSVwaHJhc2UlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCBwYXRoLCB3b3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGggPSBleHBvcnRzLmRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IG1uZW1vbmljX2pzXzEuTW5lbW9uaWMuZnJvbVBocmFzZShwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBIRE5vZGVXYWxsZXQuI2Zyb21TZWVkKG1uZW1vbmljLmNvbXB1dGVTZWVkKCksIG1uZW1vbmljKS5kZXJpdmVQYXRoKHBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhbiBIRCBOb2RlIGZyb20gYSAlJXNlZWQlJS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgICAgICByZXR1cm4gSEROb2RlV2FsbGV0LiNmcm9tU2VlZChzZWVkLCBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkhETm9kZVdhbGxldCA9IEhETm9kZVdhbGxldDtcbi8qKlxuICogIEEgKipIRE5vZGVWb2lkV2FsbGV0KiogY2Fubm90IHNpZ24sIGJ1dCBwcm92aWRlcyBhY2Nlc3MgdG9cbiAqICB0aGUgY2hpbGRyZW4gbm9kZXMgb2YgYSBbW2xpbmstYmlwLTMyXV0gSEQgd2FsbGV0IGFkZHJlc3Nlcy5cbiAqXG4gKiAgVGhlIGNhbiBiZSBjcmVhdGVkIGJ5IHVzaW5nIGFuIGV4dGVuZGVkIGBgeHB1YmBgIGtleSB0b1xuICogIFtbSEROb2RlV2FsbGV0X2Zyb21FeHRlbmRlZEtleV1dIG9yIGJ5XG4gKiAgW251ZXRlcmluZ10oSEROb2RlV2FsbGV0LW5ldXRlcikgYSBbW0hETm9kZVdhbGxldF1dLlxuICovXG5jbGFzcyBIRE5vZGVWb2lkV2FsbGV0IGV4dGVuZHMgaW5kZXhfanNfMi5Wb2lkU2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAgICAgKi9cbiAgICBwdWJsaWNLZXk7XG4gICAgLyoqXG4gICAgICogIFRoZSBmaW5nZXJwcmludC5cbiAgICAgKlxuICAgICAqICBBIGZpbmdlcnByaW50IGFsbG93cyBxdWljayBxYXkgdG8gZGV0ZWN0IHBhcmVudCBhbmQgY2hpbGQgbm9kZXMsXG4gICAgICogIGJ1dCBkZXZlbG9wZXJzIHNob3VsZCBiZSBwcmVwYXJlZCB0byBkZWFsIHdpdGggY29sbGlzaW9ucyBhcyBpdFxuICAgICAqICBpcyBvbmx5IDQgYnl0ZXMuXG4gICAgICovXG4gICAgZmluZ2VycHJpbnQ7XG4gICAgLyoqXG4gICAgICogIFRoZSBwYXJlbnQgbm9kZSBmaW5nZXJwcmludC5cbiAgICAgKi9cbiAgICBwYXJlbnRGaW5nZXJwcmludDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGNoYWluY29kZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYSBwdWJsaWMga2V5IHVzZWRcbiAgICAgKiAgdG8gZGVyaXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGNoYWluQ29kZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRlcml2YXRpb24gcGF0aCBvZiB0aGlzIHdhbGxldC5cbiAgICAgKlxuICAgICAqICBTaW5jZSBleHRlbmRlZCBrZXlzIGRvIG5vdCBwcm92aWRlciBmdWxsIHBhdGggZGV0YWlscywgdGhpc1xuICAgICAqICBtYXkgYmUgYGBudWxsYGAsIGlmIGluc3RhbnRpYXRlZCBmcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3RcbiAgICAgKiAgZW5vY2RlIGl0LlxuICAgICAqL1xuICAgIHBhdGg7XG4gICAgLyoqXG4gICAgICogIFRoZSBjaGlsZCBpbmRleCBvZiB0aGlzIHdhbGxldC4gVmFsdWVzIG92ZXIgYGAyICpcXCogMzFgYCBpbmRpY2F0ZVxuICAgICAqICB0aGUgbm9kZSBpcyBoYXJkZW5lZC5cbiAgICAgKi9cbiAgICBpbmRleDtcbiAgICAvKipcbiAgICAgKiAgVGhlIGRlcHRoIG9mIHRoaXMgd2FsbGV0LCB3aGljaCBpcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHNcbiAgICAgKiAgaW4gaXRzIHBhdGguXG4gICAgICovXG4gICAgZGVwdGg7XG4gICAgLyoqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ3VhcmQsIGFkZHJlc3MsIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgcGF0aCwgaW5kZXgsIGRlcHRoLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcihhZGRyZXNzLCBwcm92aWRlcik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydFByaXZhdGUpKGd1YXJkLCBfZ3VhcmQsIFwiSEROb2RlVm9pZFdhbGxldFwiKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuZGVmaW5lUHJvcGVydGllcykodGhpcywgeyBwdWJsaWNLZXkgfSk7XG4gICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gKDAsIGluZGV4X2pzXzQuZGF0YVNsaWNlKSgoMCwgaW5kZXhfanNfMS5yaXBlbWQxNjApKCgwLCBpbmRleF9qc18xLnNoYTI1NikocHVibGljS2V5KSksIDAsIDQpO1xuICAgICAgICAoMCwgaW5kZXhfanNfNC5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7XG4gICAgICAgICAgICBwdWJsaWNLZXksIGZpbmdlcnByaW50LCBwYXJlbnRGaW5nZXJwcmludCwgY2hhaW5Db2RlLCBwYXRoLCBpbmRleCwgZGVwdGhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGVWb2lkV2FsbGV0KF9ndWFyZCwgdGhpcy5hZGRyZXNzLCB0aGlzLnB1YmxpY0tleSwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucGF0aCwgdGhpcy5pbmRleCwgdGhpcy5kZXB0aCwgcHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIGV4dGVuZGVkIGtleS5cbiAgICAgKlxuICAgICAqICBUaGlzIGtleSB3aWxsIGJlZ2luIHdpdGggdGhlIHByZWZpeCBgYHhwdWJgYCBhbmQgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgcmVjb25zdHJ1Y3QgdGhpcyBuZXV0ZXJlZCBrZXkgdG8gZGVyaXZlIGl0cyBjaGlsZHJlbiBhZGRyZXNzZXMuXG4gICAgICovXG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIG1haW5uZXQgdmFsdWVzIGZvciBub3csIGJ1dCBpZiBhbnlvbmUgbmVlZHNcbiAgICAgICAgLy8gdGVzdG5ldCB2YWx1ZXMsIGxldCBtZSBrbm93LiBJIGJlbGlldmUgY3VycmVudCBzZW50aW1lbnQgaXMgdGhhdFxuICAgICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIHVzZSBtYWlubmV0LCBhbmQgdXNlIEJJUC00NCB0byBkZXJpdmUgdGhlIG5ldHdvcmtcbiAgICAgICAgLy8gICAtIE1haW5uZXQ6IHB1YmxpYz0weDA0ODhCMjFFLCBwcml2YXRlPTB4MDQ4OEFERTRcbiAgICAgICAgLy8gICAtIFRlc3RuZXQ6IHB1YmxpYz0weDA0MzU4N0NGLCBwcml2YXRlPTB4MDQzNTgzOTRcbiAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0KSh0aGlzLmRlcHRoIDwgMjU2LCBcIkRlcHRoIHRvbyBkZWVwXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHsgb3BlcmF0aW9uOiBcImV4dGVuZGVkS2V5XCIgfSk7XG4gICAgICAgIHJldHVybiBlbmNvZGVCYXNlNThDaGVjaygoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtcbiAgICAgICAgICAgIFwiMHgwNDg4QjIxRVwiLFxuICAgICAgICAgICAgenBhZCh0aGlzLmRlcHRoLCAxKSxcbiAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICB6cGFkKHRoaXMuaW5kZXgsIDQpLFxuICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgICAgICB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIHRoaXMgd2FsbGV0IGhhcyBhIHBhdGgsIHByb3ZpZGluZyBhIFR5cGUgR3VhcmRcbiAgICAgKiAgdGhhdCB0aGUgcGF0aCBpcyBub24tbnVsbC5cbiAgICAgKi9cbiAgICBoYXNQYXRoKCkgeyByZXR1cm4gKHRoaXMucGF0aCAhPSBudWxsKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gdGhlIGNoaWxkIGZvciAlJWluZGV4JSUuXG4gICAgICovXG4gICAgZGVyaXZlQ2hpbGQoX2luZGV4KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShpbmRleCA8PSAweGZmZmZmZmZmLCBcImludmFsaWQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICYgSGFyZGVuZWRCaXQpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgSVIsIElMIH0gPSBzZXJfSShpbmRleCwgdGhpcy5jaGFpbkNvZGUsIHRoaXMucHVibGljS2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgS2kgPSBpbmRleF9qc18xLlNpZ25pbmdLZXkuYWRkUG9pbnRzKElMLCB0aGlzLnB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaW5kZXhfanNfMy5jb21wdXRlQWRkcmVzcykoS2kpO1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZVZvaWRXYWxsZXQoX2d1YXJkLCBhZGRyZXNzLCBLaSwgdGhpcy5maW5nZXJwcmludCwgKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoSVIpLCBwYXRoLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIHRoaXMucHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHRoZSBzaWduZXIgZm9yICUlcGF0aCUlIGZyb20gdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGRlcml2ZVBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gZGVyaXZlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG59XG5leHBvcnRzLkhETm9kZVZvaWRXYWxsZXQgPSBIRE5vZGVWb2lkV2FsbGV0O1xuLypcbmV4cG9ydCBjbGFzcyBIRE5vZGVXYWxsZXRNYW5hZ2VyIHtcbiAgICAjcm9vdDogSEROb2RlV2FsbGV0O1xuXG4gICAgY29uc3RydWN0b3IocGhyYXNlOiBzdHJpbmcsIHBhc3N3b3JkPzogbnVsbCB8IHN0cmluZywgcGF0aD86IG51bGwgfCBzdHJpbmcsIGxvY2FsZT86IG51bGwgfCBXb3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkgeyBwYXNzd29yZCA9IFwiXCI7IH1cbiAgICAgICAgaWYgKHBhdGggPT0gbnVsbCkgeyBwYXRoID0gXCJtLzQ0Jy82MCcvMCcvMFwiOyB9XG4gICAgICAgIGlmIChsb2NhbGUgPT0gbnVsbCkgeyBsb2NhbGUgPSBMYW5nRW4ud29yZGxpc3QoKTsgfVxuICAgICAgICB0aGlzLiNyb290ID0gSEROb2RlV2FsbGV0LmZyb21QaHJhc2UocGhyYXNlLCBwYXNzd29yZCwgcGF0aCwgbG9jYWxlKTtcbiAgICB9XG5cbiAgICBnZXRTaWduZXIoaW5kZXg/OiBudW1iZXIpOiBIRE5vZGVXYWxsZXQge1xuICAgICAgICByZXR1cm4gdGhpcy4jcm9vdC5kZXJpdmVDaGlsZCgoaW5kZXggPT0gbnVsbCkgPyAwOiBpbmRleCk7XG4gICAgfVxufVxuKi9cbi8qKlxuICogIFJldHVybnMgdGhlIFtbbGluay1iaXAtMzJdXSBwYXRoIGZvciB0aGUgYWNjb3VudCBhdCAlJWluZGV4JSUuXG4gKlxuICogIFRoaXMgaXMgdGhlIHBhdHRlcm4gdXNlZCBieSB3YWxsZXRzIGxpa2UgTGVkZ2VyLlxuICpcbiAqICBUaGVyZSBpcyBhbHNvIGFuIFthbHRlcm5hdGUgcGF0dGVybl0oZ2V0SW5kZXhlZEFjY291bnRQYXRoKSB1c2VkIGJ5XG4gKiAgc29tZSBzb2Z0d2FyZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWNjb3VudFBhdGgoX2luZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSAoMCwgaW5kZXhfanNfNC5nZXROdW1iZXIpKF9pbmRleCwgXCJpbmRleFwiKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IEhhcmRlbmVkQml0LCBcImludmFsaWQgYWNjb3VudCBpbmRleFwiLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICByZXR1cm4gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYDtcbn1cbmV4cG9ydHMuZ2V0QWNjb3VudFBhdGggPSBnZXRBY2NvdW50UGF0aDtcbi8qKlxuICogIFJldHVybnMgdGhlIHBhdGggdXNpbmcgYW4gYWx0ZXJuYXRpdmUgcGF0dGVybiBmb3IgZGVyaXZpbmcgYWNjb3VudHMsXG4gKiAgYXQgJSVpbmRleCUlLlxuICpcbiAqICBUaGlzIGRlcml2YXRpb24gcGF0aCB1c2VzIHRoZSAvL2luZGV4Ly8gY29tcG9uZW50IHJhdGhlciB0aGFuIHRoZVxuICogIC8vYWNjb3VudC8vIGNvbXBvbmVudCB0byBkZXJpdmUgc2VxdWVudGlhbCBhY2NvdW50cy5cbiAqXG4gKiAgVGhpcyBpcyB0aGUgcGF0dGVybiB1c2VkIGJ5IHdhbGxldHMgbGlrZSBNZXRhTWFzay5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5kZXhlZEFjY291bnRQYXRoKF9pbmRleCkge1xuICAgIGNvbnN0IGluZGV4ID0gKDAsIGluZGV4X2pzXzQuZ2V0TnVtYmVyKShfaW5kZXgsIFwiaW5kZXhcIik7XG4gICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCBIYXJkZW5lZEJpdCwgXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgcmV0dXJuIGBtLzQ0Jy82MCcvMCcvMC8ke2luZGV4fWA7XG59XG5leHBvcnRzLmdldEluZGV4ZWRBY2NvdW50UGF0aCA9IGdldEluZGV4ZWRBY2NvdW50UGF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkd2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEluZGV4ZWRBY2NvdW50UGF0aCIsImdldEFjY291bnRQYXRoIiwiSEROb2RlVm9pZFdhbGxldCIsIkhETm9kZVdhbGxldCIsImRlZmF1bHRQYXRoIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18yIiwiaW5kZXhfanNfMyIsImluZGV4X2pzXzQiLCJsYW5nX2VuX2pzXzEiLCJiYXNlX3dhbGxldF9qc18xIiwibW5lbW9uaWNfanNfMSIsImpzb25fa2V5c3RvcmVfanNfMSIsIk1hc3RlclNlY3JldCIsIlVpbnQ4QXJyYXkiLCJIYXJkZW5lZEJpdCIsIk4iLCJCaWdJbnQiLCJOaWJibGVzIiwienBhZCIsImxlbmd0aCIsInJlc3VsdCIsIk1hdGgiLCJ0cnVuYyIsImVuY29kZUJhc2U1OENoZWNrIiwiX3ZhbHVlIiwiZ2V0Qnl0ZXMiLCJjaGVjayIsImRhdGFTbGljZSIsInNoYTI1NiIsImJ5dGVzIiwiY29uY2F0IiwiZW5jb2RlQmFzZTU4IiwiX2d1YXJkIiwic2VyX0kiLCJpbmRleCIsImNoYWluQ29kZSIsInB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJkYXRhIiwiYXNzZXJ0Iiwib3BlcmF0aW9uIiwic2V0IiwiaSIsIkkiLCJjb21wdXRlSG1hYyIsIklMIiwic2xpY2UiLCJJUiIsImRlcml2ZVBhdGgiLCJub2RlIiwicGF0aCIsImNvbXBvbmVudHMiLCJzcGxpdCIsImFzc2VydEFyZ3VtZW50IiwiZGVwdGgiLCJzaGlmdCIsImNvbXBvbmVudCIsIm1hdGNoIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJkZXJpdmVDaGlsZCIsIkJhc2VXYWxsZXQiLCJjb25zdHJ1Y3RvciIsImd1YXJkIiwic2lnbmluZ0tleSIsInBhcmVudEZpbmdlcnByaW50IiwibW5lbW9uaWMiLCJwcm92aWRlciIsImFzc2VydFByaXZhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29tcHJlc3NlZFB1YmxpY0tleSIsImZpbmdlcnByaW50IiwicmlwZW1kMTYwIiwiY29ubmVjdCIsImFjY291bnQiLCJhZGRyZXNzIiwibSIsIndvcmRsaXN0IiwibG9jYWxlIiwicGFzc3dvcmQiLCJlbnRyb3B5IiwiZW5jcnlwdCIsInByb2dyZXNzQ2FsbGJhY2siLCJlbmNyeXB0S2V5c3RvcmVKc29uIiwiZW5jcnlwdFN5bmMiLCJlbmNyeXB0S2V5c3RvcmVKc29uU3luYyIsImV4dGVuZGVkS2V5IiwiaGFzUGF0aCIsIm5ldXRlciIsIl9pbmRleCIsImdldE51bWJlciIsImtpIiwiU2lnbmluZ0tleSIsInRvQmVIZXgiLCJ0b0JpZ0ludCIsImhleGxpZnkiLCJmcm9tU2VlZCIsIl9zZWVkIiwiaXNCeXRlc0xpa2UiLCJzZWVkIiwiZnJvbUV4dGVuZGVkS2V5IiwidG9CZUFycmF5IiwiZGVjb2RlQmFzZTU4Iiwia2V5IiwiY29tcHV0ZUFkZHJlc3MiLCJjcmVhdGVSYW5kb20iLCJMYW5nRW4iLCJNbmVtb25pYyIsImZyb21FbnRyb3B5IiwicmFuZG9tQnl0ZXMiLCJjb21wdXRlU2VlZCIsImZyb21NbmVtb25pYyIsImZyb21QaHJhc2UiLCJwaHJhc2UiLCJWb2lkU2lnbmVyIiwiS2kiLCJhZGRQb2ludHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  When interacting with Ethereum, it is necessary to use a private\n *  key authenticate actions by signing a payload.\n *\n *  Wallets are the simplest way to expose the concept of an\n *  //Externally Owner Account// (EOA) as it wraps a private key\n *  and supports high-level methods to sign common types of interaction\n *  and send transactions.\n *\n *  The class most developers will want to use is [[Wallet]], which\n *  can load a private key directly or from any common wallet format.\n *\n *  The [[HDNodeWallet]] can be used when it is necessary to access\n *  low-level details of how an HD wallets are derived, exported\n *  or imported.\n *\n *  @_section: api/wallet:Wallets  [about-wallets]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;\nvar base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nObject.defineProperty(exports, \"BaseWallet\", ({\n    enumerable: true,\n    get: function() {\n        return base_wallet_js_1.BaseWallet;\n    }\n}));\nvar hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\");\nObject.defineProperty(exports, \"defaultPath\", ({\n    enumerable: true,\n    get: function() {\n        return hdwallet_js_1.defaultPath;\n    }\n}));\nObject.defineProperty(exports, \"getAccountPath\", ({\n    enumerable: true,\n    get: function() {\n        return hdwallet_js_1.getAccountPath;\n    }\n}));\nObject.defineProperty(exports, \"getIndexedAccountPath\", ({\n    enumerable: true,\n    get: function() {\n        return hdwallet_js_1.getIndexedAccountPath;\n    }\n}));\nObject.defineProperty(exports, \"HDNodeWallet\", ({\n    enumerable: true,\n    get: function() {\n        return hdwallet_js_1.HDNodeWallet;\n    }\n}));\nObject.defineProperty(exports, \"HDNodeVoidWallet\", ({\n    enumerable: true,\n    get: function() {\n        return hdwallet_js_1.HDNodeVoidWallet;\n    }\n}));\nvar json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\");\nObject.defineProperty(exports, \"isCrowdsaleJson\", ({\n    enumerable: true,\n    get: function() {\n        return json_crowdsale_js_1.isCrowdsaleJson;\n    }\n}));\nObject.defineProperty(exports, \"decryptCrowdsaleJson\", ({\n    enumerable: true,\n    get: function() {\n        return json_crowdsale_js_1.decryptCrowdsaleJson;\n    }\n}));\nvar json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\nObject.defineProperty(exports, \"isKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return json_keystore_js_1.isKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"decryptKeystoreJsonSync\", ({\n    enumerable: true,\n    get: function() {\n        return json_keystore_js_1.decryptKeystoreJsonSync;\n    }\n}));\nObject.defineProperty(exports, \"decryptKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return json_keystore_js_1.decryptKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"encryptKeystoreJson\", ({\n    enumerable: true,\n    get: function() {\n        return json_keystore_js_1.encryptKeystoreJson;\n    }\n}));\nObject.defineProperty(exports, \"encryptKeystoreJsonSync\", ({\n    enumerable: true,\n    get: function() {\n        return json_keystore_js_1.encryptKeystoreJsonSync;\n    }\n}));\nvar mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nObject.defineProperty(exports, \"Mnemonic\", ({\n    enumerable: true,\n    get: function() {\n        return mnemonic_js_1.Mnemonic;\n    }\n}));\nvar wallet_js_1 = __webpack_require__(/*! ./wallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/wallet.js\");\nObject.defineProperty(exports, \"Wallet\", ({\n    enumerable: true,\n    get: function() {\n        return wallet_js_1.Wallet;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLCtCQUErQixHQUFHQSwyQkFBMkIsR0FBR0EsMkJBQTJCLEdBQUdBLCtCQUErQixHQUFHQSxzQkFBc0IsR0FBR0EsNEJBQTRCLEdBQUdBLHVCQUF1QixHQUFHQSx3QkFBd0IsR0FBR0Esb0JBQW9CLEdBQUdBLDZCQUE2QixHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDalosSUFBSWlCLG1CQUFtQkMsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ2pEcEIsOENBQTZDO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxpQkFBaUJELFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SCxJQUFJSyxnQkFBZ0JILG1CQUFPQSxDQUFDLGtGQUFlO0FBQzNDcEIsK0NBQThDO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxjQUFjTixXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0hqQixrREFBaUQ7SUFBRXFCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGNBQWNQLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNqSWhCLHlEQUF3RDtJQUFFcUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsY0FBY1IscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0lmLGdEQUErQztJQUFFcUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsY0FBY1QsWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzdIZCxvREFBbUQ7SUFBRXFCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGNBQWNWLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JJLElBQUlXLHNCQUFzQkosbUJBQU9BLENBQUMsOEZBQXFCO0FBQ3ZEcEIsbURBQWtEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxvQkFBb0JaLGVBQWU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN6SVosd0RBQXVEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxvQkFBb0JiLG9CQUFvQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25KLElBQUljLHFCQUFxQkwsbUJBQU9BLENBQUMsNEZBQW9CO0FBQ3JEcEIsa0RBQWlEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxtQkFBbUJmLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0SVYsMkRBQTBEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxtQkFBbUJoQix1QkFBdUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SlQsdURBQXNEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxtQkFBbUJqQixtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNoSlIsdURBQXNEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxtQkFBbUJsQixtQkFBbUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNoSlAsMkRBQTBEO0lBQUVxQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxtQkFBbUJuQix1QkFBdUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SixJQUFJb0IsZ0JBQWdCTixtQkFBT0EsQ0FBQyxrRkFBZTtBQUMzQ3BCLDRDQUEyQztJQUFFcUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0ksY0FBY3JCLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySCxJQUFJc0IsY0FBY1AsbUJBQU9BLENBQUMsOEVBQWE7QUFDdkNwQiwwQ0FBeUM7SUFBRXFCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLFlBQVl2QixNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDL0csaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L2luZGV4LmpzPzlhNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBXaGVuIGludGVyYWN0aW5nIHdpdGggRXRoZXJldW0sIGl0IGlzIG5lY2Vzc2FyeSB0byB1c2UgYSBwcml2YXRlXG4gKiAga2V5IGF1dGhlbnRpY2F0ZSBhY3Rpb25zIGJ5IHNpZ25pbmcgYSBwYXlsb2FkLlxuICpcbiAqICBXYWxsZXRzIGFyZSB0aGUgc2ltcGxlc3Qgd2F5IHRvIGV4cG9zZSB0aGUgY29uY2VwdCBvZiBhblxuICogIC8vRXh0ZXJuYWxseSBPd25lciBBY2NvdW50Ly8gKEVPQSkgYXMgaXQgd3JhcHMgYSBwcml2YXRlIGtleVxuICogIGFuZCBzdXBwb3J0cyBoaWdoLWxldmVsIG1ldGhvZHMgdG8gc2lnbiBjb21tb24gdHlwZXMgb2YgaW50ZXJhY3Rpb25cbiAqICBhbmQgc2VuZCB0cmFuc2FjdGlvbnMuXG4gKlxuICogIFRoZSBjbGFzcyBtb3N0IGRldmVsb3BlcnMgd2lsbCB3YW50IHRvIHVzZSBpcyBbW1dhbGxldF1dLCB3aGljaFxuICogIGNhbiBsb2FkIGEgcHJpdmF0ZSBrZXkgZGlyZWN0bHkgb3IgZnJvbSBhbnkgY29tbW9uIHdhbGxldCBmb3JtYXQuXG4gKlxuICogIFRoZSBbW0hETm9kZVdhbGxldF1dIGNhbiBiZSB1c2VkIHdoZW4gaXQgaXMgbmVjZXNzYXJ5IHRvIGFjY2Vzc1xuICogIGxvdy1sZXZlbCBkZXRhaWxzIG9mIGhvdyBhbiBIRCB3YWxsZXRzIGFyZSBkZXJpdmVkLCBleHBvcnRlZFxuICogIG9yIGltcG9ydGVkLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS93YWxsZXQ6V2FsbGV0cyAgW2Fib3V0LXdhbGxldHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0ID0gZXhwb3J0cy5NbmVtb25pYyA9IGV4cG9ydHMuZW5jcnlwdEtleXN0b3JlSnNvblN5bmMgPSBleHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb24gPSBleHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb24gPSBleHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5pc0tleXN0b3JlSnNvbiA9IGV4cG9ydHMuZGVjcnlwdENyb3dkc2FsZUpzb24gPSBleHBvcnRzLmlzQ3Jvd2RzYWxlSnNvbiA9IGV4cG9ydHMuSEROb2RlVm9pZFdhbGxldCA9IGV4cG9ydHMuSEROb2RlV2FsbGV0ID0gZXhwb3J0cy5nZXRJbmRleGVkQWNjb3VudFBhdGggPSBleHBvcnRzLmdldEFjY291bnRQYXRoID0gZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGV4cG9ydHMuQmFzZVdhbGxldCA9IHZvaWQgMDtcbnZhciBiYXNlX3dhbGxldF9qc18xID0gcmVxdWlyZShcIi4vYmFzZS13YWxsZXQuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlV2FsbGV0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlX3dhbGxldF9qc18xLkJhc2VXYWxsZXQ7IH0gfSk7XG52YXIgaGR3YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL2hkd2FsbGV0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdFBhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuZGVmYXVsdFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGR3YWxsZXRfanNfMS5nZXRBY2NvdW50UGF0aDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEluZGV4ZWRBY2NvdW50UGF0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGR3YWxsZXRfanNfMS5nZXRJbmRleGVkQWNjb3VudFBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIRE5vZGVXYWxsZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhkd2FsbGV0X2pzXzEuSEROb2RlV2FsbGV0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSEROb2RlVm9pZFdhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGR3YWxsZXRfanNfMS5IRE5vZGVWb2lkV2FsbGV0OyB9IH0pO1xudmFyIGpzb25fY3Jvd2RzYWxlX2pzXzEgPSByZXF1aXJlKFwiLi9qc29uLWNyb3dkc2FsZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQ3Jvd2RzYWxlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9jcm93ZHNhbGVfanNfMS5pc0Nyb3dkc2FsZUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0Q3Jvd2RzYWxlSnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNvbl9jcm93ZHNhbGVfanNfMS5kZWNyeXB0Q3Jvd2RzYWxlSnNvbjsgfSB9KTtcbnZhciBqc29uX2tleXN0b3JlX2pzXzEgPSByZXF1aXJlKFwiLi9qc29uLWtleXN0b3JlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fa2V5c3RvcmVfanNfMS5pc0tleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY3J5cHRLZXlzdG9yZUpzb25TeW5jXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZGVjcnlwdEtleXN0b3JlSnNvblN5bmM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNyeXB0S2V5c3RvcmVKc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc29uX2tleXN0b3JlX2pzXzEuZGVjcnlwdEtleXN0b3JlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY3J5cHRLZXlzdG9yZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jcnlwdEtleXN0b3JlSnNvblN5bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzb25fa2V5c3RvcmVfanNfMS5lbmNyeXB0S2V5c3RvcmVKc29uU3luYzsgfSB9KTtcbnZhciBtbmVtb25pY19qc18xID0gcmVxdWlyZShcIi4vbW5lbW9uaWMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNbmVtb25pY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW5lbW9uaWNfanNfMS5NbmVtb25pYzsgfSB9KTtcbnZhciB3YWxsZXRfanNfMSA9IHJlcXVpcmUoXCIuL3dhbGxldC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldhbGxldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0X2pzXzEuV2FsbGV0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiV2FsbGV0IiwiTW5lbW9uaWMiLCJlbmNyeXB0S2V5c3RvcmVKc29uU3luYyIsImVuY3J5cHRLZXlzdG9yZUpzb24iLCJkZWNyeXB0S2V5c3RvcmVKc29uIiwiZGVjcnlwdEtleXN0b3JlSnNvblN5bmMiLCJpc0tleXN0b3JlSnNvbiIsImRlY3J5cHRDcm93ZHNhbGVKc29uIiwiaXNDcm93ZHNhbGVKc29uIiwiSEROb2RlVm9pZFdhbGxldCIsIkhETm9kZVdhbGxldCIsImdldEluZGV4ZWRBY2NvdW50UGF0aCIsImdldEFjY291bnRQYXRoIiwiZGVmYXVsdFBhdGgiLCJCYXNlV2FsbGV0IiwiYmFzZV93YWxsZXRfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiaGR3YWxsZXRfanNfMSIsImpzb25fY3Jvd2RzYWxlX2pzXzEiLCJqc29uX2tleXN0b3JlX2pzXzEiLCJtbmVtb25pY19qc18xIiwid2FsbGV0X2pzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;\nconst aes_js_1 = __webpack_require__(/*! aes-js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/utils.js\");\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */ function isCrowdsaleJson(json) {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) {\n            return true;\n        }\n    } catch (error) {}\n    return false;\n}\nexports.isCrowdsaleJson = isCrowdsaleJson;\n// See: https://github.com/ethereum/pyethsaletool\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */ function decryptCrowdsaleJson(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    // Ethereum Address\n    const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, \"ethaddr:string!\"));\n    // Encrypted Seed\n    const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, \"encseed:string!\"));\n    (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, \"invalid encseed\", \"json\", json);\n    const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes_js_1.CBC(key, iv);\n    const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for(let i = 0; i < seed.length; i++){\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    return {\n        address,\n        privateKey: (0, index_js_3.id)(seedHex)\n    };\n}\nexports.decryptCrowdsaleJson = decryptCrowdsaleJson; //# sourceMappingURL=json-crowdsale.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1jcm93ZHNhbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Q0FFQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDOUQsTUFBTUksV0FBV0MsbUJBQU9BLENBQUMscUZBQVE7QUFDakMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsc0ZBQXFCO0FBQ2hELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyxnRkFBa0I7QUFDN0MsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDOztDQUVDLEdBQ0QsU0FBU0YsZ0JBQWdCUSxJQUFJO0lBQ3pCLElBQUk7UUFDQSxNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO1FBQ3hCLElBQUlDLEtBQUtHLE9BQU8sRUFBRTtZQUNkLE9BQU87UUFDWDtJQUNKLEVBQ0EsT0FBT0MsT0FBTyxDQUFFO0lBQ2hCLE9BQU87QUFDWDtBQUNBaEIsdUJBQXVCLEdBQUdHO0FBQzFCLGlEQUFpRDtBQUNqRDs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTRCxxQkFBcUJTLElBQUksRUFBRU0sU0FBUztJQUN6QyxNQUFNTCxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO0lBQ3hCLE1BQU1PLFdBQVcsQ0FBQyxHQUFHUixXQUFXUyxXQUFXLEVBQUVGO0lBQzdDLG1CQUFtQjtJQUNuQixNQUFNRyxVQUFVLENBQUMsR0FBR2QsV0FBV2UsVUFBVSxFQUFFLENBQUMsR0FBR1gsV0FBV1ksT0FBTyxFQUFFVixNQUFNO0lBQ3pFLGlCQUFpQjtJQUNqQixNQUFNRyxVQUFVLENBQUMsR0FBR0wsV0FBV2EsYUFBYSxFQUFFLENBQUMsR0FBR2IsV0FBV1ksT0FBTyxFQUFFVixNQUFNO0lBQzNFLElBQUdILFdBQVdlLGNBQWMsRUFBRVQsV0FBVyxRQUFTVSxNQUFNLEdBQUcsT0FBUSxHQUFHLG1CQUFtQixRQUFRZDtJQUNsRyxNQUFNZSxNQUFNLENBQUMsR0FBR2pCLFdBQVdrQixRQUFRLEVBQUUsQ0FBQyxHQUFHcEIsV0FBV3FCLE1BQU0sRUFBRVYsVUFBVUEsVUFBVSxNQUFNLElBQUksV0FBV1csS0FBSyxDQUFDLEdBQUc7SUFDOUcsTUFBTUMsS0FBS2YsUUFBUWMsS0FBSyxDQUFDLEdBQUc7SUFDNUIsTUFBTUUsZ0JBQWdCaEIsUUFBUWMsS0FBSyxDQUFDO0lBQ3BDLG1CQUFtQjtJQUNuQixNQUFNRyxTQUFTLElBQUk1QixTQUFTNkIsR0FBRyxDQUFDUCxLQUFLSTtJQUNyQyxNQUFNSSxPQUFPLENBQUMsR0FBRzlCLFNBQVMrQixVQUFVLEVBQUUsQ0FBQyxHQUFHMUIsV0FBV2tCLFFBQVEsRUFBRUssT0FBT0ksT0FBTyxDQUFDTDtJQUM5RSw2RUFBNkU7SUFDN0UsSUFBSU0sVUFBVTtJQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixLQUFLVCxNQUFNLEVBQUVhLElBQUs7UUFDbENELFdBQVdFLE9BQU9DLFlBQVksQ0FBQ04sSUFBSSxDQUFDSSxFQUFFO0lBQzFDO0lBQ0EsT0FBTztRQUFFbEI7UUFBU3FCLFlBQVksQ0FBQyxHQUFHakMsV0FBV2tDLEVBQUUsRUFBRUw7SUFBUztBQUM5RDtBQUNBckMsNEJBQTRCLEdBQUdFLHNCQUMvQiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1jcm93ZHNhbGUuanM/YTc0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEBfc3Vic2VjdGlvbjogYXBpL3dhbGxldDpKU09OIFdhbGxldHMgIFtqc29uLXdhbGxldHNdXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjcnlwdENyb3dkc2FsZUpzb24gPSBleHBvcnRzLmlzQ3Jvd2RzYWxlSnNvbiA9IHZvaWQgMDtcbmNvbnN0IGFlc19qc18xID0gcmVxdWlyZShcImFlcy1qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vYWRkcmVzcy9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMyA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfNCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKlxuICogIFJldHVybnMgdHJ1ZSBpZiAlJWpzb24lJSBpcyBhIHZhbGlkIEpTT04gQ3Jvd2RzYWxlIHdhbGxldC5cbiAqL1xuZnVuY3Rpb24gaXNDcm93ZHNhbGVKc29uKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgaWYgKGRhdGEuZW5jc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzQ3Jvd2RzYWxlSnNvbiA9IGlzQ3Jvd2RzYWxlSnNvbjtcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3B5ZXRoc2FsZXRvb2xcbi8qKlxuICogIEJlZm9yZSBFdGhlcmV1bSBsYXVuY2hlZCwgaXQgd2FzIG5lY2Vzc2FyeSB0byBjcmVhdGUgYSB3YWxsZXRcbiAqICBmb3JtYXQgZm9yIGJhY2tlcnMgdG8gdXNlLCB3aGljaCB3b3VsZCBiZSB1c2VkIHRvIHJlY2VpdmUgZXRoZXJcbiAqICBhcyBhIHJld2FyZCBmb3IgY29udHJpYnV0aW5nIHRvIHRoZSBwcm9qZWN0LlxuICpcbiAqICBUaGUgW1tsaW5rLWNyb3dkc2FsZV1dIGZvcm1hdCBpcyBub3cgb2Jzb2xldGUsIGJ1dCBpdCBpcyBzdGlsbFxuICogIHVzZWZ1bCB0byBzdXBwb3J0IGFuZCB0aGUgYWRkaXRpb25hbCBjb2RlIGlzIGZhaXJseSB0cml2aWFsIGFzXG4gKiAgYWxsIHRoZSBwcmltaXRpdmVzIHJlcXVpcmVkIGFyZSB1c2VkIHRocm91Z2ggY29yZSBwb3J0aW9ucyBvZlxuICogIHRoZSBsaWJyYXJ5LlxuICovXG5mdW5jdGlvbiBkZWNyeXB0Q3Jvd2RzYWxlSnNvbihqc29uLCBfcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShfcGFzc3dvcmQpO1xuICAgIC8vIEV0aGVyZXVtIEFkZHJlc3NcbiAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzEuZ2V0QWRkcmVzcykoKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJldGhhZGRyOnN0cmluZyFcIikpO1xuICAgIC8vIEVuY3J5cHRlZCBTZWVkXG4gICAgY29uc3QgZW5jc2VlZCA9ICgwLCB1dGlsc19qc18xLmxvb3NlQXJyYXlpZnkpKCgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiZW5jc2VlZDpzdHJpbmchXCIpKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZW5jc2VlZCAmJiAoZW5jc2VlZC5sZW5ndGggJSAxNikgPT09IDAsIFwiaW52YWxpZCBlbmNzZWVkXCIsIFwianNvblwiLCBqc29uKTtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoKDAsIGluZGV4X2pzXzIucGJrZGYyKShwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcbiAgICBjb25zdCBhZXNDYmMgPSBuZXcgYWVzX2pzXzEuQ0JDKGtleSwgaXYpO1xuICAgIGNvbnN0IHNlZWQgPSAoMCwgYWVzX2pzXzEucGtjczdTdHJpcCkoKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cbiAgICBsZXQgc2VlZEhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgYWRkcmVzcywgcHJpdmF0ZUtleTogKDAsIGluZGV4X2pzXzMuaWQpKHNlZWRIZXgpIH07XG59XG5leHBvcnRzLmRlY3J5cHRDcm93ZHNhbGVKc29uID0gZGVjcnlwdENyb3dkc2FsZUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWNyb3dkc2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNyeXB0Q3Jvd2RzYWxlSnNvbiIsImlzQ3Jvd2RzYWxlSnNvbiIsImFlc19qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzEiLCJpbmRleF9qc18yIiwiaW5kZXhfanNfMyIsImluZGV4X2pzXzQiLCJ1dGlsc19qc18xIiwianNvbiIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJlbmNzZWVkIiwiZXJyb3IiLCJfcGFzc3dvcmQiLCJwYXNzd29yZCIsImdldFBhc3N3b3JkIiwiYWRkcmVzcyIsImdldEFkZHJlc3MiLCJzcGVsdW5rIiwibG9vc2VBcnJheWlmeSIsImFzc2VydEFyZ3VtZW50IiwibGVuZ3RoIiwia2V5IiwiZ2V0Qnl0ZXMiLCJwYmtkZjIiLCJzbGljZSIsIml2IiwiZW5jcnlwdGVkU2VlZCIsImFlc0NiYyIsIkNCQyIsInNlZWQiLCJwa2NzN1N0cmlwIiwiZGVjcnlwdCIsInNlZWRIZXgiLCJpIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicHJpdmF0ZUtleSIsImlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/json-keystore.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;\nconst aes_js_1 = __webpack_require__(/*! aes-js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../address/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/address/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/utils.js\");\nconst _version_js_1 = __webpack_require__(/*! ../_version.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/_version.js\");\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */ function isKeystoreJson(json) {\n    try {\n        const data = JSON.parse(json);\n        const version = data.version != null ? parseInt(data.version) : 0;\n        if (version === 3) {\n            return true;\n        }\n    } catch (error) {}\n    return false;\n}\nexports.isKeystoreJson = isKeystoreJson;\nfunction decrypt(data, key, ciphertext) {\n    const cipher = (0, utils_js_1.spelunk)(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = (0, utils_js_1.spelunk)(data, \"crypto.cipherparams.iv:data!\");\n        const aesCtr = new aes_js_1.CTR(key, iv);\n        return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));\n    }\n    (0, index_js_4.assert)(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\nfunction getAccount(data, _key) {\n    const key = (0, index_js_4.getBytes)(_key);\n    const ciphertext = (0, utils_js_1.spelunk)(data, \"crypto.ciphertext:data!\");\n    const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([\n        key.slice(16, 32),\n        ciphertext\n    ]))).substring(2);\n    (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, \"crypto.mac:string!\").toLowerCase(), \"incorrect password\", \"password\", \"[ REDACTED ]\");\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n    const address = (0, index_js_3.computeAddress)(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) {\n            check = \"0x\" + check;\n        }\n        (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n    const account = {\n        address,\n        privateKey\n    };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = (0, utils_js_1.spelunk)(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n        const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = (0, utils_js_1.spelunk)(data, \"x-ethers.mnemonicCounter:data!\");\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        account.mnemonic = {\n            path: (0, utils_js_1.spelunk)(data, \"x-ethers.path:string\") || defaultPath,\n            locale: (0, utils_js_1.spelunk)(data, \"x-ethers.locale:string\") || \"en\",\n            entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n    return account;\n}\nfunction getDecryptKdfParams(data) {\n    const kdf = (0, utils_js_1.spelunk)(data, \"crypto.kdf:string\");\n    if (kdf && typeof kdf === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const N = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.n:int!\");\n            const r = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.r:int!\");\n            const p = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.p:int!\");\n            // Make sure N is a power of 2\n            (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            (0, index_js_4.assertArgument)(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n            return {\n                name: \"scrypt\",\n                salt,\n                N,\n                r,\n                p,\n                dkLen: 64\n            };\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.salt:data!\");\n            const prf = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            (0, index_js_4.assertArgument)(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n            const count = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.c:int!\");\n            const dkLen = (0, utils_js_1.spelunk)(data, \"crypto.kdfparams.dklen:int!\");\n            (0, index_js_4.assertArgument)(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n            return {\n                name: \"pbkdf2\",\n                salt,\n                count,\n                dkLen,\n                algorithm\n            };\n        }\n    }\n    (0, index_js_4.assertArgument)(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */ function decryptKeystoreJsonSync(json, _password) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n        params\n    });\n    const { salt, N, r, p, dkLen } = params;\n    const key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            resolve();\n        }, duration);\n    });\n}\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */ async function decryptKeystoreJson(json, _password, progress) {\n    const data = JSON.parse(json);\n    const password = (0, utils_js_1.getPassword)(_password);\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = (0, index_js_2.pbkdf2)(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n    (0, index_js_4.assert)(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\n        params\n    });\n    const { salt, N, r, p, dkLen } = params;\n    const key = await (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\nexports.decryptKeystoreJson = decryptKeystoreJson;\nfunction getEncryptKdfParams(options) {\n    // Check/generate the salt\n    const salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, \"options.salt\") : (0, index_js_2.randomBytes)(32);\n    // Override the scrypt password-based key derivation function parameters\n    let N = 1 << 17, r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    (0, index_js_4.assertArgument)(typeof N === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    (0, index_js_4.assertArgument)(typeof r === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    (0, index_js_4.assertArgument)(typeof p === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n    return {\n        name: \"scrypt\",\n        dkLen: 32,\n        salt,\n        N,\n        r,\n        p\n    };\n}\nfunction _encryptKeystore(key, kdf, account, options) {\n    const privateKey = (0, index_js_4.getBytes)(account.privateKey, \"privateKey\");\n    // Override initialization vector\n    const iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, \"options.iv\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n    // Override the uuid\n    const uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, \"options.uuid\") : (0, index_js_2.randomBytes)(16);\n    (0, index_js_4.assertArgument)(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n    // Encrypt the private key\n    const aesCtr = new aes_js_1.CTR(derivedKey, iv);\n    const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([\n        macPrefix,\n        ciphertext\n    ]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data = {\n        address: account.address.substring(2).toLowerCase(),\n        id: (0, index_js_4.uuidV4)(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: (0, index_js_4.hexlify)(iv).substring(2)\n            },\n            ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = options.client != null ? options.client : `ethers/${_version_js_1.version}`;\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n        const mnemonicKey = key.slice(32, 64);\n        const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = (0, index_js_2.randomBytes)(16);\n        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));\n        const now = new Date();\n        const timestamp = now.getUTCFullYear() + \"-\" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + \"T\" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + \"-\" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + \".0Z\";\n        const gethFilename = \"UTC--\" + timestamp + \"--\" + data.address;\n        data[\"x-ethers\"] = {\n            client,\n            gethFilename,\n            path,\n            locale,\n            mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),\n            mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n    return JSON.stringify(data);\n}\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */ function encryptKeystoreJsonSync(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */ async function encryptKeystoreJson(account, password, options) {\n    if (options == null) {\n        options = {};\n    }\n    const passwordBytes = (0, utils_js_1.getPassword)(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);\n}\nexports.encryptKeystoreJson = encryptKeystoreJson; //# sourceMappingURL=json-keystore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvanNvbi1rZXlzdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Q0FTQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLCtCQUErQixHQUFHQSwyQkFBMkIsR0FBR0EsK0JBQStCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDOUosTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMscUZBQVE7QUFDakMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsc0ZBQXFCO0FBQ2hELE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLG9GQUFvQjtBQUMvQyxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyw4RkFBeUI7QUFDcEQsTUFBTUksYUFBYUosbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1NLGdCQUFnQk4sbUJBQU9BLENBQUMsNEVBQWdCO0FBQzlDLE1BQU1PLGNBQWM7QUFDcEI7O0NBRUMsR0FDRCxTQUFTVCxlQUFlVSxJQUFJO0lBQ3hCLElBQUk7UUFDQSxNQUFNQyxPQUFPQyxLQUFLQyxLQUFLLENBQUNIO1FBQ3hCLE1BQU1JLFVBQVcsS0FBTUEsT0FBTyxJQUFJLE9BQVFDLFNBQVNKLEtBQUtHLE9BQU8sSUFBSTtRQUNuRSxJQUFJQSxZQUFZLEdBQUc7WUFDZixPQUFPO1FBQ1g7SUFDSixFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQXRCLHNCQUFzQixHQUFHTTtBQUN6QixTQUFTaUIsUUFBUU4sSUFBSSxFQUFFTyxHQUFHLEVBQUVDLFVBQVU7SUFDbEMsTUFBTUMsU0FBUyxDQUFDLEdBQUdiLFdBQVdjLE9BQU8sRUFBRVYsTUFBTTtJQUM3QyxJQUFJUyxXQUFXLGVBQWU7UUFDMUIsTUFBTUUsS0FBSyxDQUFDLEdBQUdmLFdB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RUFBRVosTUFBTW9DLEtBQUtWLFNBQVNvQztBQUN6RTtBQUNBdEYsK0JBQStCLEdBQUdHO0FBQ2xDOzs7Ozs7OztDQVFDLEdBQ0QsZUFBZUQsb0JBQW9CZ0QsT0FBTyxFQUFFdUIsUUFBUSxFQUFFYSxPQUFPO0lBQ3pELElBQUlBLFdBQVcsTUFBTTtRQUNqQkEsVUFBVSxDQUFDO0lBQ2Y7SUFDQSxNQUFNa0MsZ0JBQWdCLENBQUMsR0FBRzNHLFdBQVc2RCxXQUFXLEVBQUVEO0lBQ2xELE1BQU1iLE1BQU15QixvQkFBb0JDO0lBQ2hDLE1BQU05RCxNQUFNLE1BQU0sQ0FBQyxHQUFHZCxXQUFXMEUsTUFBTSxFQUFFb0MsZUFBZTVELElBQUlDLElBQUksRUFBRUQsSUFBSUUsQ0FBQyxFQUFFRixJQUFJRyxDQUFDLEVBQUVILElBQUlJLENBQUMsRUFBRSxJQUFJc0IsUUFBUW1DLGdCQUFnQjtJQUNuSCxPQUFPOUIsaUJBQWlCLENBQUMsR0FBRy9FLFdBQVd3QixRQUFRLEVBQUVaLE1BQU1vQyxLQUFLVixTQUFTb0M7QUFDekU7QUFDQXRGLDJCQUEyQixHQUFHRSxxQkFDOUIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L2pzb24ta2V5c3RvcmUuanM/YjI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIFRoZSBKU09OIFdhbGxldCBmb3JtYXRzIGFsbG93IGEgc2ltcGxlIHdheSB0byBzdG9yZSB0aGUgcHJpdmF0ZVxuICogIGtleXMgbmVlZGVkIGluIEV0aGVyZXVtIGFsb25nIHdpdGggcmVsYXRlZCBpbmZvcm1hdGlvbiBhbmQgYWxsb3dzXG4gKiAgZm9yIGV4dGVuc2libGUgZm9ybXMgb2YgZW5jcnlwdGlvbi5cbiAqXG4gKiAgVGhlc2UgdXRpbGl0aWVzIGZhY2lsaXRhdGUgZGVjcnlwdGluZyBhbmQgZW5jcnlwdGluZyB0aGUgbW9zdCBjb21tb25cbiAqICBKU09OIFdhbGxldCBmb3JtYXRzLlxuICpcbiAqICBAX3N1YnNlY3Rpb246IGFwaS93YWxsZXQ6SlNPTiBXYWxsZXRzICBbanNvbi13YWxsZXRzXVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb24gPSBleHBvcnRzLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uID0gZXhwb3J0cy5kZWNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGV4cG9ydHMuaXNLZXlzdG9yZUpzb24gPSB2b2lkIDA7XG5jb25zdCBhZXNfanNfMSA9IHJlcXVpcmUoXCJhZXMtanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3MvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzMgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb24vaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc180ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgX3ZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9fdmVyc2lvbi5qc1wiKTtcbmNvbnN0IGRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG4vKipcbiAqICBSZXR1cm5zIHRydWUgaWYgJSVqc29uJSUgaXMgYSB2YWxpZCBKU09OIEtleXN0b3JlIFdhbGxldC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlzdG9yZUpzb24oanNvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gKChkYXRhLnZlcnNpb24gIT0gbnVsbCkgPyBwYXJzZUludChkYXRhLnZlcnNpb24pIDogMCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNLZXlzdG9yZUpzb24gPSBpc0tleXN0b3JlSnNvbjtcbmZ1bmN0aW9uIGRlY3J5cHQoZGF0YSwga2V5LCBjaXBoZXJ0ZXh0KSB7XG4gICAgY29uc3QgY2lwaGVyID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8uY2lwaGVyOnN0cmluZ1wiKTtcbiAgICBpZiAoY2lwaGVyID09PSBcImFlcy0xMjgtY3RyXCIpIHtcbiAgICAgICAgY29uc3QgaXYgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5jaXBoZXJwYXJhbXMuaXY6ZGF0YSFcIik7XG4gICAgICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBhZXNfanNfMS5DVFIoa2V5LCBpdik7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShhZXNDdHIuZGVjcnlwdChjaXBoZXJ0ZXh0KSk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQgY2lwaGVyXCIsIFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCIsIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcImRlY3J5cHRcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWNjb3VudChkYXRhLCBfa2V5KSB7XG4gICAgY29uc3Qga2V5ID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKF9rZXkpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5jaXBoZXJ0ZXh0OmRhdGEhXCIpO1xuICAgIGNvbnN0IGNvbXB1dGVkTUFDID0gKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzIua2VjY2FrMjU2KSgoMCwgaW5kZXhfanNfNC5jb25jYXQpKFtrZXkuc2xpY2UoMTYsIDMyKSwgY2lwaGVydGV4dF0pKSkuc3Vic3RyaW5nKDIpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShjb21wdXRlZE1BQyA9PT0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ubWFjOnN0cmluZyFcIikudG9Mb3dlckNhc2UoKSwgXCJpbmNvcnJlY3QgcGFzc3dvcmRcIiwgXCJwYXNzd29yZFwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZGVjcnlwdChkYXRhLCBrZXkuc2xpY2UoMCwgMTYpLCBjaXBoZXJ0ZXh0KTtcbiAgICBjb25zdCBhZGRyZXNzID0gKDAsIGluZGV4X2pzXzMuY29tcHV0ZUFkZHJlc3MpKHByaXZhdGVLZXkpO1xuICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gZGF0YS5hZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghY2hlY2suc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSgoMCwgaW5kZXhfanNfMS5nZXRBZGRyZXNzKShjaGVjaykgPT09IGFkZHJlc3MsIFwia2V5c3RvcmUgYWRkcmVzcy9wcml2YXRlS2V5IG1pc21hdGNoXCIsIFwiYWRkcmVzc1wiLCBkYXRhLmFkZHJlc3MpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0geyBhZGRyZXNzLCBwcml2YXRlS2V5IH07XG4gICAgLy8gVmVyc2lvbiAwLjEgeC1ldGhlcnMgbWV0YWRhdGEgbXVzdCBjb250YWluIGFuIGVuY3J5cHRlZCBtbmVtb25pYyBwaHJhc2VcbiAgICBjb25zdCB2ZXJzaW9uID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJ4LWV0aGVycy52ZXJzaW9uOnN0cmluZ1wiKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gXCIwLjFcIikge1xuICAgICAgICBjb25zdCBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NpcGhlcnRleHQgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcIngtZXRoZXJzLm1uZW1vbmljQ2lwaGVydGV4dDpkYXRhIVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNJdiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwieC1ldGhlcnMubW5lbW9uaWNDb3VudGVyOmRhdGEhXCIpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0Flc0N0ciA9IG5ldyBhZXNfanNfMS5DVFIobW5lbW9uaWNLZXksIG1uZW1vbmljSXYpO1xuICAgICAgICBhY2NvdW50Lm1uZW1vbmljID0ge1xuICAgICAgICAgICAgcGF0aDogKCgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwieC1ldGhlcnMucGF0aDpzdHJpbmdcIikgfHwgZGVmYXVsdFBhdGgpLFxuICAgICAgICAgICAgbG9jYWxlOiAoKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJ4LWV0aGVycy5sb2NhbGU6c3RyaW5nXCIpIHx8IFwiZW5cIiksXG4gICAgICAgICAgICBlbnRyb3B5OiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KSgoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnQ7XG59XG5mdW5jdGlvbiBnZXREZWNyeXB0S2RmUGFyYW1zKGRhdGEpIHtcbiAgICBjb25zdCBrZGYgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGY6c3RyaW5nXCIpO1xuICAgIGlmIChrZGYgJiYgdHlwZW9mIChrZGYpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChrZGYudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3J5cHRcIikge1xuICAgICAgICAgICAgY29uc3Qgc2FsdCA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5zYWx0OmRhdGEhXCIpO1xuICAgICAgICAgICAgY29uc3QgTiA9ICgwLCB1dGlsc19qc18xLnNwZWx1bmspKGRhdGEsIFwiY3J5cHRvLmtkZnBhcmFtcy5uOmludCFcIik7XG4gICAgICAgICAgICBjb25zdCByID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnI6aW50IVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHAgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucDppbnQhXCIpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIE4gaXMgYSBwb3dlciBvZiAyXG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoTiA+IDAgJiYgKE4gJiAoTiAtIDEpKSA9PT0gMCwgXCJpbnZhbGlkIGtkZi5OXCIsIFwia2RmLk5cIiwgTik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkociA+IDAgJiYgcCA+IDAsIFwiaW52YWxpZCBrZGZcIiwgXCJrZGZcIiwga2RmKTtcbiAgICAgICAgICAgIGNvbnN0IGRrTGVuID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLmRrbGVuOmludCFcIik7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZGtMZW4gPT09IDMyLCBcImludmFsaWQga2RmLmRrbGVuXCIsIFwia2RmLmRmbGVuXCIsIGRrTGVuKTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IFwic2NyeXB0XCIsIHNhbHQsIE4sIHIsIHAsIGRrTGVuOiA2NCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gKDAsIHV0aWxzX2pzXzEuc3BlbHVuaykoZGF0YSwgXCJjcnlwdG8ua2RmcGFyYW1zLnNhbHQ6ZGF0YSFcIik7XG4gICAgICAgICAgICBjb25zdCBwcmYgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMucHJmOnN0cmluZyFcIik7XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBwcmYuc3BsaXQoXCItXCIpLnBvcCgpO1xuICAgICAgICAgICAgKDAsIGluZGV4X2pzXzQuYXNzZXJ0QXJndW1lbnQpKGFsZ29yaXRobSA9PT0gXCJzaGEyNTZcIiB8fCBhbGdvcml0aG0gPT09IFwic2hhNTEyXCIsIFwiaW52YWxpZCBrZGYucGRmXCIsIFwia2RmLnBkZlwiLCBwcmYpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuYzppbnQhXCIpO1xuICAgICAgICAgICAgY29uc3QgZGtMZW4gPSAoMCwgdXRpbHNfanNfMS5zcGVsdW5rKShkYXRhLCBcImNyeXB0by5rZGZwYXJhbXMuZGtsZW46aW50IVwiKTtcbiAgICAgICAgICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KShka0xlbiA9PT0gMzIsIFwiaW52YWxpZCBrZGYuZGtsZW5cIiwgXCJrZGYuZGtsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJwYmtkZjJcIiwgc2FsdCwgY291bnQsIGRrTGVuLCBhbGdvcml0aG0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwidW5zdXBwb3J0ZWQga2V5LWRlcml2YXRpb24gZnVuY3Rpb25cIiwgXCJrZGZcIiwga2RmKTtcbn1cbi8qKlxuICogIFJldHVybnMgdGhlIGFjY291bnQgZGV0YWlscyBmb3IgdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0ICUlanNvbiUlXG4gKiAgdXNpbmcgJSVwYXNzd29yZCUlLlxuICpcbiAqICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIHRoZSBbYXN5bmMgdmVyc2lvbl0oZGVjcnlwdEtleXN0b3JlSnNvbilcbiAqICBpbnN0ZWFkLCB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkXG4gKiAgYXMgdG8gdGhlIGRlY3J5cHRpb24gc3RhdHVzLlxuICpcbiAqICBUaGlzIG1ldGhvZCB3aWxsIGJsb2NrIHRoZSBldmVudCBsb29wIChmcmVlemluZyBhbGwgVUkpIHVudGlsIGRlY3J5cHRpb25cbiAqICBpcyBjb21wbGV0ZSwgd2hpY2ggY2FuIHRha2UgcXVpdGUgc29tZSB0aW1lLCBkZXBlbmRpbmcgb24gdGhlIHdhbGxldFxuICogIHBhcmFtdGVycyBhbmQgcGxhdGZvcm0uXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKGpzb24sIF9wYXNzd29yZCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIGNvbnN0IHBhc3N3b3JkID0gKDAsIHV0aWxzX2pzXzEuZ2V0UGFzc3dvcmQpKF9wYXNzd29yZCk7XG4gICAgY29uc3QgcGFyYW1zID0gZ2V0RGVjcnlwdEtkZlBhcmFtcyhkYXRhKTtcbiAgICBpZiAocGFyYW1zLm5hbWUgPT09IFwicGJrZGYyXCIpIHtcbiAgICAgICAgY29uc3QgeyBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMi5wYmtkZjIpKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIGFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydCkocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xuICAgIGNvbnN0IHsgc2FsdCwgTiwgciwgcCwgZGtMZW4gfSA9IHBhcmFtcztcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMi5zY3J5cHRTeW5jKShwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pO1xuICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG59XG5leHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jID0gZGVjcnlwdEtleXN0b3JlSnNvblN5bmM7XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4geyBzZXRUaW1lb3V0KCgpID0+IHsgcmVzb2x2ZSgpOyB9LCBkdXJhdGlvbik7IH0pO1xufVxuLyoqXG4gKiAgUmVzb2x2ZXMgdG8gdGhlIGRlY3J5cHRlZCBKU09OIEtleXN0b3JlIFdhbGxldCAlJWpzb24lJSB1c2luZyB0aGVcbiAqICAlJXBhc3N3b3JkJSUuXG4gKlxuICogIElmIHByb3ZpZGVkLCAlJXByb2dyZXNzJSUgd2lsbCBiZSBjYWxsZWQgcGVyaW9kaWNhbGx5IGR1cmluZyB0aGVcbiAqICBkZWNycHl0aW9uIHRvIHByb3ZpZGUgZmVlZGJhY2ssIGFuZCBpZiB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogIGBgZmFsc2VgYCB3aWxsIGhhbHQgZGVjcnlwdGlvbi5cbiAqXG4gKiAgVGhlICUlcHJvZ3Jlc3NDYWxsYmFjayUlIHdpbGwgKiphbHdheXMqKiByZWNlaXZlIGBgMGBgIGJlZm9yZVxuICogIGRlY3J5cHRpb24gYmVnaW5zIGFuZCBgYDFgYCB3aGVuIGNvbXBsZXRlLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0S2V5c3RvcmVKc29uKGpzb24sIF9wYXNzd29yZCwgcHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBwYXNzd29yZCA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShfcGFzc3dvcmQpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGdldERlY3J5cHRLZGZQYXJhbXMoZGF0YSk7XG4gICAgaWYgKHBhcmFtcy5uYW1lID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgICAgcHJvZ3Jlc3MoMCk7XG4gICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCBpbmRleF9qc18yLnBia2RmMikocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBwcm9ncmVzcygxKTtcbiAgICAgICAgICAgIGF3YWl0IHN0YWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG4gICAgfVxuICAgICgwLCBpbmRleF9qc180LmFzc2VydCkocGFyYW1zLm5hbWUgPT09IFwic2NyeXB0XCIsIFwiY2Fubm90IGJlIHJlYWNoZWRcIiwgXCJVTktOT1dOX0VSUk9SXCIsIHsgcGFyYW1zIH0pO1xuICAgIGNvbnN0IHsgc2FsdCwgTiwgciwgcCwgZGtMZW4gfSA9IHBhcmFtcztcbiAgICBjb25zdCBrZXkgPSBhd2FpdCAoMCwgaW5kZXhfanNfMi5zY3J5cHQpKHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3MpO1xuICAgIHJldHVybiBnZXRBY2NvdW50KGRhdGEsIGtleSk7XG59XG5leHBvcnRzLmRlY3J5cHRLZXlzdG9yZUpzb24gPSBkZWNyeXB0S2V5c3RvcmVKc29uO1xuZnVuY3Rpb24gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKSB7XG4gICAgLy8gQ2hlY2svZ2VuZXJhdGUgdGhlIHNhbHRcbiAgICBjb25zdCBzYWx0ID0gKG9wdGlvbnMuc2FsdCAhPSBudWxsKSA/ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShvcHRpb25zLnNhbHQsIFwib3B0aW9ucy5zYWx0XCIpIDogKDAsIGluZGV4X2pzXzIucmFuZG9tQnl0ZXMpKDMyKTtcbiAgICAvLyBPdmVycmlkZSB0aGUgc2NyeXB0IHBhc3N3b3JkLWJhc2VkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICBsZXQgTiA9ICgxIDw8IDE3KSwgciA9IDgsIHAgPSAxO1xuICAgIGlmIChvcHRpb25zLnNjcnlwdCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQuTikge1xuICAgICAgICAgICAgTiA9IG9wdGlvbnMuc2NyeXB0Lk47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnIpIHtcbiAgICAgICAgICAgIHIgPSBvcHRpb25zLnNjcnlwdC5yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5wKSB7XG4gICAgICAgICAgICBwID0gb3B0aW9ucy5zY3J5cHQucDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChOKSA9PT0gXCJudW1iZXJcIiAmJiBOID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihOKSAmJiAoQmlnSW50KE4pICYgQmlnSW50KE4gLSAxKSkgPT09IEJpZ0ludCgwKSwgXCJpbnZhbGlkIHNjcnlwdCBOIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMuTlwiLCBOKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChyKSA9PT0gXCJudW1iZXJcIiAmJiByID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihyKSwgXCJpbnZhbGlkIHNjcnlwdCByIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMuclwiLCByKTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkodHlwZW9mIChwKSA9PT0gXCJudW1iZXJcIiAmJiBwID4gMCAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihwKSwgXCJpbnZhbGlkIHNjcnlwdCBwIHBhcmFtZXRlclwiLCBcIm9wdGlvbnMucFwiLCBwKTtcbiAgICByZXR1cm4geyBuYW1lOiBcInNjcnlwdFwiLCBka0xlbjogMzIsIHNhbHQsIE4sIHIsIHAgfTtcbn1cbmZ1bmN0aW9uIF9lbmNyeXB0S2V5c3RvcmUoa2V5LCBrZGYsIGFjY291bnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKGFjY291bnQucHJpdmF0ZUtleSwgXCJwcml2YXRlS2V5XCIpO1xuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxuICAgIGNvbnN0IGl2ID0gKG9wdGlvbnMuaXYgIT0gbnVsbCkgPyAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykob3B0aW9ucy5pdiwgXCJvcHRpb25zLml2XCIpIDogKDAsIGluZGV4X2pzXzIucmFuZG9tQnl0ZXMpKDE2KTtcbiAgICAoMCwgaW5kZXhfanNfNC5hc3NlcnRBcmd1bWVudCkoaXYubGVuZ3RoID09PSAxNiwgXCJpbnZhbGlkIG9wdGlvbnMuaXYgbGVuZ3RoXCIsIFwib3B0aW9ucy5pdlwiLCBvcHRpb25zLml2KTtcbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuICAgIGNvbnN0IHV1aWRSYW5kb20gPSAob3B0aW9ucy51dWlkICE9IG51bGwpID8gKDAsIGluZGV4X2pzXzQuZ2V0Qnl0ZXMpKG9wdGlvbnMudXVpZCwgXCJvcHRpb25zLnV1aWRcIikgOiAoMCwgaW5kZXhfanNfMi5yYW5kb21CeXRlcykoMTYpO1xuICAgICgwLCBpbmRleF9qc180LmFzc2VydEFyZ3VtZW50KSh1dWlkUmFuZG9tLmxlbmd0aCA9PT0gMTYsIFwiaW52YWxpZCBvcHRpb25zLnV1aWQgbGVuZ3RoXCIsIFwib3B0aW9ucy51dWlkXCIsIG9wdGlvbnMuaXYpO1xuICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIHdhbGxldCAoYXMgcGVyIFdlYjMgc2VjcmV0IHN0b3JhZ2UpXG4gICAgLy8gLSAzMiBieXRlcyAgIEFzIG5vcm1hbCBmb3IgdGhlIFdlYjMgc2VjcmV0IHN0b3JhZ2UgKGRlcml2ZWRLZXksIG1hY1ByZWZpeClcbiAgICAvLyAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcbiAgICBjb25zdCBtYWNQcmVmaXggPSBrZXkuc2xpY2UoMTYsIDMyKTtcbiAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgIGNvbnN0IGFlc0N0ciA9IG5ldyBhZXNfanNfMS5DVFIoZGVyaXZlZEtleSwgaXYpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoYWVzQ3RyLmVuY3J5cHQocHJpdmF0ZUtleSkpO1xuICAgIC8vIENvbXB1dGUgdGhlIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSwgdXNlZCB0byBjaGVjayB0aGUgcGFzc3dvcmRcbiAgICBjb25zdCBtYWMgPSAoMCwgaW5kZXhfanNfMi5rZWNjYWsyNTYpKCgwLCBpbmRleF9qc180LmNvbmNhdCkoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBpZDogKDAsIGluZGV4X2pzXzQudXVpZFY0KSh1dWlkUmFuZG9tKSxcbiAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgQ3J5cHRvOiB7XG4gICAgICAgICAgICBjaXBoZXI6IFwiYWVzLTEyOC1jdHJcIixcbiAgICAgICAgICAgIGNpcGhlcnBhcmFtczoge1xuICAgICAgICAgICAgICAgIGl2OiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShpdikuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNpcGhlcnRleHQ6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcbiAgICAgICAgICAgIGtkZnBhcmFtczoge1xuICAgICAgICAgICAgICAgIHNhbHQ6ICgwLCBpbmRleF9qc180LmhleGxpZnkpKGtkZi5zYWx0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICAgICAgbjoga2RmLk4sXG4gICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuICAgICAgICAgICAgICAgIHA6IGtkZi5wLFxuICAgICAgICAgICAgICAgIHI6IGtkZi5yXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFjOiBtYWMuc3Vic3RyaW5nKDIpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUgYSBtbmVtb25pYywgZW5jcnlwdCBpdCBpbnRvIHRoZSBKU09OIHdhbGxldFxuICAgIGlmIChhY2NvdW50Lm1uZW1vbmljKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IChvcHRpb25zLmNsaWVudCAhPSBudWxsKSA/IG9wdGlvbnMuY2xpZW50IDogYGV0aGVycy8ke192ZXJzaW9uX2pzXzEudmVyc2lvbn1gO1xuICAgICAgICBjb25zdCBwYXRoID0gYWNjb3VudC5tbmVtb25pYy5wYXRoIHx8IGRlZmF1bHRQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSBhY2NvdW50Lm1uZW1vbmljLmxvY2FsZSB8fCBcImVuXCI7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljS2V5ID0ga2V5LnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSAoMCwgaW5kZXhfanNfNC5nZXRCeXRlcykoYWNjb3VudC5tbmVtb25pYy5lbnRyb3B5LCBcImFjY291bnQubW5lbW9uaWMuZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgbW5lbW9uaWNJdiA9ICgwLCBpbmRleF9qc18yLnJhbmRvbUJ5dGVzKSgxNik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IGFlc19qc18xLkNUUihtbmVtb25pY0tleSwgbW5lbW9uaWNJdik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9ICgwLCBpbmRleF9qc180LmdldEJ5dGVzKShtbmVtb25pY0Flc0N0ci5lbmNyeXB0KGVudHJvcHkpKTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuenBhZCkobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLnpwYWQpKG5vdy5nZXRVVENEYXRlKCksIDIpICsgXCJUXCIgK1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuenBhZCkobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuenBhZCkobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS56cGFkKShub3cuZ2V0VVRDU2Vjb25kcygpLCAyKSArIFwiLjBaXCIpO1xuICAgICAgICBjb25zdCBnZXRoRmlsZW5hbWUgPSAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKTtcbiAgICAgICAgZGF0YVtcIngtZXRoZXJzXCJdID0ge1xuICAgICAgICAgICAgY2xpZW50LCBnZXRoRmlsZW5hbWUsIHBhdGgsIGxvY2FsZSxcbiAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogKDAsIGluZGV4X2pzXzQuaGV4bGlmeSkobW5lbW9uaWNJdikuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgbW5lbW9uaWNDaXBoZXJ0ZXh0OiAoMCwgaW5kZXhfanNfNC5oZXhsaWZ5KShtbmVtb25pY0NpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgIHZlcnNpb246IFwiMC4xXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuLyoqXG4gKiAgUmV0dXJuIHRoZSBKU09OIEtleXN0b3JlIFdhbGxldCBmb3IgJSVhY2NvdW50JSUgZW5jcnlwdGVkIHdpdGhcbiAqICAlJXBhc3N3b3JkJSUuXG4gKlxuICogIFRoZSAlJW9wdGlvbnMlJSBjYW4gYmUgdXNlZCB0byB0dW5lIHRoZSBwYXNzd29yZC1iYXNlZCBrZXlcbiAqICBkZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIGV4cGxpY2l0bHkgc2V0IHRoZSByYW5kb20gdmFsdWVzXG4gKiAgdXNlZC4gQW55IHByb3ZpZGVkIFtbUHJvZ3Jlc3NDYWxsYmFja11dIGlzIGlnbm9yZC5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvblN5bmMoYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcGFzc3dvcmRCeXRlcyA9ICgwLCB1dGlsc19qc18xLmdldFBhc3N3b3JkKShwYXNzd29yZCk7XG4gICAgY29uc3Qga2RmID0gZ2V0RW5jcnlwdEtkZlBhcmFtcyhvcHRpb25zKTtcbiAgICBjb25zdCBrZXkgPSAoMCwgaW5kZXhfanNfMi5zY3J5cHRTeW5jKShwYXNzd29yZEJ5dGVzLCBrZGYuc2FsdCwga2RmLk4sIGtkZi5yLCBrZGYucCwgNjQpO1xuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKCgwLCBpbmRleF9qc180LmdldEJ5dGVzKShrZXkpLCBrZGYsIGFjY291bnQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uU3luYyA9IGVuY3J5cHRLZXlzdG9yZUpzb25TeW5jO1xuLyoqXG4gKiAgUmVzb2x2ZWQgdG8gdGhlIEpTT04gS2V5c3RvcmUgV2FsbGV0IGZvciAlJWFjY291bnQlJSBlbmNyeXB0ZWRcbiAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAqXG4gKiAgVGhlICUlb3B0aW9ucyUlIGNhbiBiZSB1c2VkIHRvIHR1bmUgdGhlIHBhc3N3b3JkLWJhc2VkIGtleVxuICogIGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVycywgZXhwbGljaXRseSBzZXQgdGhlIHJhbmRvbSB2YWx1ZXNcbiAqICB1c2VkIGFuZCBwcm92aWRlIGEgW1tQcm9ncmVzc0NhbGxiYWNrXV0gdG8gcmVjZWl2ZSBwZXJpb2RpYyB1cGRhdGVzXG4gKiAgb24gdGhlIGNvbXBsZXRpb24gc3RhdHVzLi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEtleXN0b3JlSnNvbihhY2NvdW50LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBwYXNzd29yZEJ5dGVzID0gKDAsIHV0aWxzX2pzXzEuZ2V0UGFzc3dvcmQpKHBhc3N3b3JkKTtcbiAgICBjb25zdCBrZGYgPSBnZXRFbmNyeXB0S2RmUGFyYW1zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0ICgwLCBpbmRleF9qc18yLnNjcnlwdCkocGFzc3dvcmRCeXRlcywga2RmLnNhbHQsIGtkZi5OLCBrZGYuciwga2RmLnAsIDY0LCBvcHRpb25zLnByb2dyZXNzQ2FsbGJhY2spO1xuICAgIHJldHVybiBfZW5jcnlwdEtleXN0b3JlKCgwLCBpbmRleF9qc180LmdldEJ5dGVzKShrZXkpLCBrZGYsIGFjY291bnQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5lbmNyeXB0S2V5c3RvcmVKc29uID0gZW5jcnlwdEtleXN0b3JlSnNvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24ta2V5c3RvcmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW5jcnlwdEtleXN0b3JlSnNvbiIsImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwiZGVjcnlwdEtleXN0b3JlSnNvbiIsImRlY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwiaXNLZXlzdG9yZUpzb24iLCJhZXNfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18xIiwiaW5kZXhfanNfMiIsImluZGV4X2pzXzMiLCJpbmRleF9qc180IiwidXRpbHNfanNfMSIsIl92ZXJzaW9uX2pzXzEiLCJkZWZhdWx0UGF0aCIsImpzb24iLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwidmVyc2lvbiIsInBhcnNlSW50IiwiZXJyb3IiLCJkZWNyeXB0Iiwia2V5IiwiY2lwaGVydGV4dCIsImNpcGhlciIsInNwZWx1bmsiLCJpdiIsImFlc0N0ciIsIkNUUiIsImhleGxpZnkiLCJhc3NlcnQiLCJvcGVyYXRpb24iLCJnZXRBY2NvdW50IiwiX2tleSIsImdldEJ5dGVzIiwiY29tcHV0ZWRNQUMiLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJzbGljZSIsInN1YnN0cmluZyIsImFzc2VydEFyZ3VtZW50IiwidG9Mb3dlckNhc2UiLCJwcml2YXRlS2V5IiwiYWRkcmVzcyIsImNvbXB1dGVBZGRyZXNzIiwiY2hlY2siLCJzdGFydHNXaXRoIiwiZ2V0QWRkcmVzcyIsImFjY291bnQiLCJtbmVtb25pY0tleSIsIm1uZW1vbmljQ2lwaGVydGV4dCIsIm1uZW1vbmljSXYiLCJtbmVtb25pY0Flc0N0ciIsIm1uZW1vbmljIiwicGF0aCIsImxvY2FsZSIsImVudHJvcHkiLCJnZXREZWNyeXB0S2RmUGFyYW1zIiwia2RmIiwic2FsdCIsIk4iLCJyIiwicCIsImRrTGVuIiwibmFtZSIsInByZiIsImFsZ29yaXRobSIsInNwbGl0IiwicG9wIiwiY291bnQiLCJfcGFzc3dvcmQiLCJwYXNzd29yZCIsImdldFBhc3N3b3JkIiwicGFyYW1zIiwicGJrZGYyIiwic2NyeXB0U3luYyIsInN0YWxsIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJwcm9ncmVzcyIsInNjcnlwdCIsImdldEVuY3J5cHRLZGZQYXJhbXMiLCJvcHRpb25zIiwicmFuZG9tQnl0ZXMiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiQmlnSW50IiwiX2VuY3J5cHRLZXlzdG9yZSIsImxlbmd0aCIsInV1aWRSYW5kb20iLCJ1dWlkIiwiZGVyaXZlZEtleSIsIm1hY1ByZWZpeCIsImVuY3J5cHQiLCJtYWMiLCJpZCIsInV1aWRWNCIsIkNyeXB0byIsImNpcGhlcnBhcmFtcyIsImtkZnBhcmFtcyIsIm4iLCJka2xlbiIsImNsaWVudCIsIm5vdyIsIkRhdGUiLCJ0aW1lc3RhbXAiLCJnZXRVVENGdWxsWWVhciIsInpwYWQiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0aEZpbGVuYW1lIiwibW5lbW9uaWNDb3VudGVyIiwic3RyaW5naWZ5IiwicGFzc3dvcmRCeXRlcyIsInByb2dyZXNzQ2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/mnemonic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Mnemonic = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ../wordlists/lang-en.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return (1 << bits) - 1 << 8 - bits & 0xff;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return (1 << bits) - 1 & 0xff;\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    (0, index_js_2.assertNormalize)(\"NFKD\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const words = wordlist.split(mnemonic);\n    (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n    let offset = 0;\n    for(let i = 0; i < words.length; i++){\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        (0, index_js_2.assertArgument)(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n        for(let bit = 0; bit < 11; bit++){\n            if (index & 1 << 10 - bit) {\n                entropy[offset >> 3] |= 1 << 7 - offset % 8;\n            }\n            offset++;\n        }\n    }\n    const entropyBits = 32 * words.length / 3;\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n    const checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n    (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n    return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n    if (wordlist == null) {\n        wordlist = lang_en_js_1.LangEn.wordlist();\n    }\n    const indices = [\n        0\n    ];\n    let remainingBits = 11;\n    for(let i = 0; i < entropy.length; i++){\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n    return wordlist.join(indices.map((index)=>wordlist.getWord(index)));\n}\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */ class Mnemonic {\n    /**\n     *  @private\n     */ constructor(guard, entropy, phrase, password, wordlist){\n        if (password == null) {\n            password = \"\";\n        }\n        if (wordlist == null) {\n            wordlist = lang_en_js_1.LangEn.wordlist();\n        }\n        (0, index_js_2.assertPrivate)(guard, _guard, \"Mnemonic\");\n        (0, index_js_2.defineProperties)(this, {\n            phrase,\n            password,\n            wordlist,\n            entropy\n        });\n    }\n    /**\n     *  Returns the seed for the mnemonic.\n     */ computeSeed() {\n        const salt = (0, index_js_2.toUtf8Bytes)(\"mnemonic\" + this.password, \"NFKD\");\n        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */ static fromPhrase(phrase, password, wordlist) {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */ static fromEntropy(_entropy, password, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);\n    }\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */ static entropyToPhrase(_entropy, wordlist) {\n        const entropy = (0, index_js_2.getBytes)(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */ static phraseToEntropy(phrase, wordlist) {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */ static isValidMnemonic(phrase, wordlist) {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        } catch (error) {}\n        return false;\n    }\n}\nexports.Mnemonic = Mnemonic; //# sourceMappingURL=mnemonic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvbW5lbW9uaWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsb0ZBQW9CO0FBQy9DLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyw4RkFBeUI7QUFDdEQsdUNBQXVDO0FBQ3ZDLFNBQVNHLGFBQWFDLElBQUk7SUFDdEIsT0FBTyxDQUFFLEtBQUtBLElBQUcsSUFBSyxLQUFPLElBQUlBLE9BQVE7QUFDN0M7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBU0MsYUFBYUQsSUFBSTtJQUN0QixPQUFPLENBQUUsS0FBS0EsSUFBRyxJQUFLLElBQUs7QUFDL0I7QUFDQSxTQUFTRSxrQkFBa0JDLFFBQVEsRUFBRUMsUUFBUTtJQUN4QyxJQUFHUCxXQUFXUSxlQUFlLEVBQUU7SUFDaEMsSUFBSUQsWUFBWSxNQUFNO1FBQ2xCQSxXQUFXTixhQUFhUSxNQUFNLENBQUNGLFFBQVE7SUFDM0M7SUFDQSxNQUFNRyxRQUFRSCxTQUFTSSxLQUFLLENBQUNMO0lBQzVCLElBQUdOLFdBQVdZLGNBQWMsRUFBRSxNQUFPQyxNQUFNLEdBQUcsTUFBTyxLQUFLSCxNQUFNRyxNQUFNLElBQUksTUFBTUgsTUFBTUcsTUFBTSxJQUFJLElBQUksMkJBQTJCLFlBQVk7SUFDNUksTUFBTUMsVUFBVSxJQUFJQyxXQUFXQyxLQUFLQyxJQUFJLENBQUMsS0FBS1AsTUFBTUcsTUFBTSxHQUFHO0lBQzdELElBQUlLLFNBQVM7SUFDYixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsTUFBTUcsTUFBTSxFQUFFTSxJQUFLO1FBQ25DLElBQUlDLFFBQVFiLFNBQVNjLFlBQVksQ0FBQ1gsS0FBSyxDQUFDUyxFQUFF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QUFRQyxVQUFVdEM7SUFDcEY7SUFDQTs7S0FFQyxHQUNELE9BQU9nRCxnQkFBZ0JELFFBQVEsRUFBRS9DLFFBQVEsRUFBRTtRQUN2QyxNQUFNTyxVQUFVLENBQUMsR0FBR2QsV0FBVzRCLFFBQVEsRUFBRTBCLFVBQVU7UUFDbkQsT0FBT3RCLGtCQUFrQmxCLFNBQVNQO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRCxPQUFPaUQsZ0JBQWdCWixNQUFNLEVBQUVyQyxRQUFRLEVBQUU7UUFDckMsT0FBT0Ysa0JBQWtCdUMsUUFBUXJDO0lBQ3JDO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPa0QsZ0JBQWdCYixNQUFNLEVBQUVyQyxRQUFRLEVBQUU7UUFDckMsSUFBSTtZQUNBRixrQkFBa0J1QyxRQUFRckM7WUFDMUIsT0FBTztRQUNYLEVBQ0EsT0FBT21ELE9BQU8sQ0FBRTtRQUNoQixPQUFPO0lBQ1g7QUFDSjtBQUNBL0QsZ0JBQWdCLEdBQUdFLFVBQ25CLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dhbGxldC9tbmVtb25pYy5qcz8xMjI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NbmVtb25pYyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGxhbmdfZW5fanNfMSA9IHJlcXVpcmUoXCIuLi93b3JkbGlzdHMvbGFuZy1lbi5qc1wiKTtcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKSAmIDB4ZmY7XG59XG4vLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBMU0IgYml0cyBzZXRcbmZ1bmN0aW9uIGdldExvd2VyTWFzayhiaXRzKSB7XG4gICAgcmV0dXJuICgoMSA8PCBiaXRzKSAtIDEpICYgMHhmZjtcbn1cbmZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydE5vcm1hbGl6ZSkoXCJORktEXCIpO1xuICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHdvcmRsaXN0ID0gbGFuZ19lbl9qc18xLkxhbmdFbi53b3JkbGlzdCgpO1xuICAgIH1cbiAgICBjb25zdCB3b3JkcyA9IHdvcmRsaXN0LnNwbGl0KG1uZW1vbmljKTtcbiAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoKHdvcmRzLmxlbmd0aCAlIDMpID09PSAwICYmIHdvcmRzLmxlbmd0aCA+PSAxMiAmJiB3b3Jkcy5sZW5ndGggPD0gMjQsIFwiaW52YWxpZCBtbmVtb25pYyBsZW5ndGhcIiwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICBjb25zdCBlbnRyb3B5ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKDExICogd29yZHMubGVuZ3RoIC8gOCkpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGluZGV4ID0gd29yZGxpc3QuZ2V0V29yZEluZGV4KHdvcmRzW2ldLm5vcm1hbGl6ZShcIk5GS0RcIikpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCwgYGludmFsaWQgbW5lbW9uaWMgd29yZCBhdCBpbmRleCAke2l9YCwgXCJtbmVtb25pY1wiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgZm9yIChsZXQgYml0ID0gMDsgYml0IDwgMTE7IGJpdCsrKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiAoMSA8PCAoMTAgLSBiaXQpKSkge1xuICAgICAgICAgICAgICAgIGVudHJvcHlbb2Zmc2V0ID4+IDNdIHw9ICgxIDw8ICg3IC0gKG9mZnNldCAlIDgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbnRyb3B5Qml0cyA9IDMyICogd29yZHMubGVuZ3RoIC8gMztcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtTWFzayA9IGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKCgwLCBpbmRleF9qc18xLnNoYTI1NikoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKSlbMF0gJiBjaGVja3N1bU1hc2s7XG4gICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGNoZWNrc3VtID09PSAoZW50cm9weVtlbnRyb3B5Lmxlbmd0aCAtIDFdICYgY2hlY2tzdW1NYXNrKSwgXCJpbnZhbGlkIG1uZW1vbmljIGNoZWNrc3VtXCIsIFwibW5lbW9uaWNcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18yLmhleGxpZnkpKGVudHJvcHkuc2xpY2UoMCwgZW50cm9weUJpdHMgLyA4KSk7XG59XG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KSgoZW50cm9weS5sZW5ndGggJSA0KSA9PT0gMCAmJiBlbnRyb3B5Lmxlbmd0aCA+PSAxNiAmJiBlbnRyb3B5Lmxlbmd0aCA8PSAzMiwgXCJpbnZhbGlkIGVudHJvcHkgc2l6ZVwiLCBcImVudHJvcHlcIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgd29yZGxpc3QgPSBsYW5nX2VuX2pzXzEuTGFuZ0VuLndvcmRsaXN0KCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXMgPSBbMF07XG4gICAgbGV0IHJlbWFpbmluZ0JpdHMgPSAxMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gQ29uc3VtZSB0aGUgd2hvbGUgYnl0ZSAod2l0aCBzdGlsbCBtb3JlIHRvIGdvKVxuICAgICAgICBpZiAocmVtYWluaW5nQml0cyA+IDgpIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gODtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyAtPSA4O1xuICAgICAgICAgICAgLy8gVGhpcyBieXRlIHdpbGwgY29tcGxldGUgYW4gMTEtYml0IGluZGV4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IHJlbWFpbmluZ0JpdHM7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gZW50cm9weVtpXSA+PiAoOCAtIHJlbWFpbmluZ0JpdHMpO1xuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIG5leHQgd29yZFxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGVudHJvcHlbaV0gJiBnZXRMb3dlck1hc2soOCAtIHJlbWFpbmluZ0JpdHMpKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBjaGVja3N1bSBiaXRzXG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gZW50cm9weS5sZW5ndGggLyA0O1xuICAgIGNvbnN0IGNoZWNrc3VtID0gcGFyc2VJbnQoKDAsIGluZGV4X2pzXzEuc2hhMjU2KShlbnRyb3B5KS5zdWJzdHJpbmcoMiwgNCksIDE2KSAmIGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IGNoZWNrc3VtQml0cztcbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gfD0gKGNoZWNrc3VtID4+ICg4IC0gY2hlY2tzdW1CaXRzKSk7XG4gICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoKGluZGV4KSA9PiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KSkpO1xufVxuY29uc3QgX2d1YXJkID0ge307XG4vKipcbiAqICBBICoqTW5lbW9uaWMqKiB3cmFwcyBhbGwgcHJvcGVydGllcyByZXF1aXJlZCB0byBjb21wdXRlIFtbbGluay1iaXAtMzldXVxuICogIHNlZWRzIGFuZCBjb252ZXJ0IGJldHdlZW4gcGhyYXNlcyBhbmQgZW50cm9weS5cbiAqL1xuY2xhc3MgTW5lbW9uaWMge1xuICAgIC8qKlxuICAgICAqICBUaGUgbW5lbW9uaWMgcGhyYXNlIG9mIDEyLCAxNSwgMTgsIDIxIG9yIDI0IHdvcmRzLlxuICAgICAqXG4gICAgICogIFVzZSB0aGUgW1t3b3JkbGlzdF1dIGBgc3BsaXRgYCBtZXRob2QgdG8gZ2V0IHRoZSBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqL1xuICAgIHBocmFzZTtcbiAgICAvKipcbiAgICAgKiAgVGhlIHBhc3N3b3JkIHVzZWQgZm9yIHRoaXMgbW5lbW9uaWMuIElmIG5vIHBhc3N3b3JkIGlzIHVzZWQgdGhpc1xuICAgICAqICBpcyB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGBgXCJcImBgKSBhcyBwZXIgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgICovXG4gICAgcGFzc3dvcmQ7XG4gICAgLyoqXG4gICAgICogIFRoZSB3b3JkbGlzdCBmb3IgdGhpcyBtbmVtb25pYy5cbiAgICAgKi9cbiAgICB3b3JkbGlzdDtcbiAgICAvKipcbiAgICAgKiAgVGhlIHVuZGVybHlpbmcgZW50cm9weSB3aGljaCB0aGUgbW5lbW9uaWMgZW5jb2Rlcy5cbiAgICAgKi9cbiAgICBlbnRyb3B5O1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCBlbnRyb3B5LCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCkge1xuICAgICAgICBpZiAocGFzc3dvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRQcml2YXRlKShndWFyZCwgX2d1YXJkLCBcIk1uZW1vbmljXCIpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0LCBlbnRyb3B5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGUgc2VlZCBmb3IgdGhlIG1uZW1vbmljLlxuICAgICAqL1xuICAgIGNvbXB1dGVTZWVkKCkge1xuICAgICAgICBjb25zdCBzYWx0ID0gKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKFwibW5lbW9uaWNcIiArIHRoaXMucGFzc3dvcmQsIFwiTkZLRFwiKTtcbiAgICAgICAgcmV0dXJuICgwLCBpbmRleF9qc18xLnBia2RmMikoKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKHRoaXMucGhyYXNlLCBcIk5GS0RcIiksIHNhbHQsIDIwNDgsIDY0LCBcInNoYTUxMlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgTW5lbW9uaWMgZm9yIHRoZSAlJXBocmFzZSUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0ICUlcGFzc3dvcmQlJSBpcyB0aGUgZW1wdHkgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdFxuICAgICAqICB3b3JkbGlzdCBpcyB0aGUgW0VuZ2xpc2ggd29yZGxpc3RzXShMYW5nRW4pLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUGhyYXNlKHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgY2FzZSBhbmQgc3BhY2U7IHRocm93cyBpZiBpbnZhbGlkXG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcbiAgICAgICAgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoKDAsIGluZGV4X2pzXzIuZ2V0Qnl0ZXMpKGVudHJvcHkpLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiBuZXcgTW5lbW9uaWMoX2d1YXJkLCBlbnRyb3B5LCBwaHJhc2UsIHBhc3N3b3JkLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGUgYSBuZXcgKipNbmVtb25pYyoqIGZyb20gdGhlICUlZW50cm9weSUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWZhdWx0ICUlcGFzc3dvcmQlJSBpcyB0aGUgZW1wdHkgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdFxuICAgICAqICB3b3JkbGlzdCBpcyB0aGUgW0VuZ2xpc2ggd29yZGxpc3RzXShMYW5nRW4pLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW50cm9weShfZW50cm9weSwgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgY29uc3QgcGhyYXNlID0gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpO1xuICAgICAgICByZXR1cm4gbmV3IE1uZW1vbmljKF9ndWFyZCwgKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkoZW50cm9weSksIHBocmFzZSwgcGFzc3dvcmQsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIHBocmFzZSBmb3IgJSVtbmVtb25pYyUlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbnRyb3B5VG9QaHJhc2UoX2VudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSAoMCwgaW5kZXhfanNfMi5nZXRCeXRlcykoX2VudHJvcHksIFwiZW50cm9weVwiKTtcbiAgICAgICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhlIGVudHJvcHkgZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIHBocmFzZVRvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KSB7XG4gICAgICAgIHJldHVybiBtbmVtb25pY1RvRW50cm9weShwaHJhc2UsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXBocmFzZSUlIGlzIGEgdmFsaWQgW1tsaW5rLWJpcC0zOV1dIHBocmFzZS5cbiAgICAgKlxuICAgICAqICBUaGlzIGNoZWNrcyBhbGwgdGhlIHByb3ZpZGVkIHdvcmRzIGJlbG9uZyB0byB0aGUgJSV3b3JkbGlzdCUlLFxuICAgICAqICB0aGF0IHRoZSBsZW5ndGggaXMgdmFsaWQgYW5kIHRoZSBjaGVja3N1bSBpcyBjb3JyZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkTW5lbW9uaWMocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5NbmVtb25pYyA9IE1uZW1vbmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW5lbW9uaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTW5lbW9uaWMiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJsYW5nX2VuX2pzXzEiLCJnZXRVcHBlck1hc2siLCJiaXRzIiwiZ2V0TG93ZXJNYXNrIiwibW5lbW9uaWNUb0VudHJvcHkiLCJtbmVtb25pYyIsIndvcmRsaXN0IiwiYXNzZXJ0Tm9ybWFsaXplIiwiTGFuZ0VuIiwid29yZHMiLCJzcGxpdCIsImFzc2VydEFyZ3VtZW50IiwibGVuZ3RoIiwiZW50cm9weSIsIlVpbnQ4QXJyYXkiLCJNYXRoIiwiY2VpbCIsIm9mZnNldCIsImkiLCJpbmRleCIsImdldFdvcmRJbmRleCIsIm5vcm1hbGl6ZSIsImJpdCIsImVudHJvcHlCaXRzIiwiY2hlY2tzdW1CaXRzIiwiY2hlY2tzdW1NYXNrIiwiY2hlY2tzdW0iLCJnZXRCeXRlcyIsInNoYTI1NiIsInNsaWNlIiwiaGV4bGlmeSIsImVudHJvcHlUb01uZW1vbmljIiwiaW5kaWNlcyIsInJlbWFpbmluZ0JpdHMiLCJwdXNoIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJqb2luIiwibWFwIiwiZ2V0V29yZCIsIl9ndWFyZCIsImNvbnN0cnVjdG9yIiwiZ3VhcmQiLCJwaHJhc2UiLCJwYXNzd29yZCIsImFzc2VydFByaXZhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29tcHV0ZVNlZWQiLCJzYWx0IiwidG9VdGY4Qnl0ZXMiLCJwYmtkZjIiLCJmcm9tUGhyYXNlIiwiZnJvbUVudHJvcHkiLCJfZW50cm9weSIsImVudHJvcHlUb1BocmFzZSIsInBocmFzZVRvRW50cm9weSIsImlzVmFsaWRNbmVtb25pYyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n *  @_ignore\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nfunction looseArrayify(hexString) {\n    if (typeof hexString === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return (0, index_js_1.getBytesCopy)(hexString);\n}\nexports.looseArrayify = looseArrayify;\nfunction zpad(value, length) {\n    value = String(value);\n    while(value.length < length){\n        value = \"0\" + value;\n    }\n    return value;\n}\nexports.zpad = zpad;\nfunction getPassword(password) {\n    if (typeof password === \"string\") {\n        return (0, index_js_1.toUtf8Bytes)(password, \"NFKC\");\n    }\n    return (0, index_js_1.getBytesCopy)(password);\n}\nexports.getPassword = getPassword;\nfunction spelunk(object, _path) {\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    (0, index_js_1.assertArgument)(match != null, \"invalid path\", \"path\", _path);\n    const path = match[1];\n    const type = match[3];\n    const reqd = match[4] === \"!\";\n    let cur = object;\n    for (const comp of path.toLowerCase().split(\".\")){\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) {\n                break;\n            }\n            cur = cur[parseInt(comp)];\n        } else if (typeof cur === \"object\") {\n            let found = null;\n            for(const key in cur){\n                if (key.toLowerCase() === comp) {\n                    found = cur[key];\n                    break;\n                }\n            }\n            cur = found;\n        } else {\n            cur = null;\n        }\n        if (cur == null) {\n            break;\n        }\n    }\n    (0, index_js_1.assertArgument)(!reqd || cur != null, \"missing required value\", \"path\", path);\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return parseInt(cur);\n            } else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n        if (type === \"number\") {\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return parseFloat(cur);\n            }\n        }\n        if (type === \"data\") {\n            if (typeof cur === \"string\") {\n                return looseArrayify(cur);\n            }\n        }\n        if (type === \"array\" && Array.isArray(cur)) {\n            return cur;\n        }\n        if (type === typeof cur) {\n            return cur;\n        }\n        (0, index_js_1.assertArgument)(false, `wrong type found for ${type} `, \"path\", path);\n    }\n    return cur;\n}\nexports.spelunk = spelunk; /*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/  // See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n /*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/  //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Q0FFQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsWUFBWSxHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ3BGLE1BQU1NLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxTQUFTRixjQUFjRyxTQUFTO0lBQzVCLElBQUksT0FBUUEsY0FBZSxZQUFZLENBQUNBLFVBQVVDLFVBQVUsQ0FBQyxPQUFPO1FBQ2hFRCxZQUFZLE9BQU9BO0lBQ3ZCO0lBQ0EsT0FBTyxDQUFDLEdBQUdGLFdBQVdJLFlBQVksRUFBRUY7QUFDeEM7QUFDQVIscUJBQXFCLEdBQUdLO0FBQ3hCLFNBQVNELEtBQUtILEtBQUssRUFBRVUsTUFBTTtJQUN2QlYsUUFBUVcsT0FBT1g7SUFDZixNQUFPQSxNQUFNVSxNQUFNLEdBQUdBLE9BQVE7UUFDMUJWLFFBQVEsTUFBTUE7SUFDbEI7SUFDQSxPQUFPQTtBQUNYO0FBQ0FELFlBQVksR0FBR0k7QUFDZixTQUFTRCxZQUFZVSxRQUFRO0lBQ3pCLElBQUksT0FBUUEsYUFBYyxVQUFVO1FBQ2hDLE9BQU8sQ0FBQyxHQUFHUCxXQUFXUSxXQUFXLEVBQUVELFVBQVU7SUFDakQ7SUFDQSxPQUFPLENBQUMsR0FBR1AsV0FBV0ksWUFBWSxFQUFFRztBQUN4QztBQUNBYixtQkFBbUIsR0FBR0c7QUFDdEIsU0FBU0QsUUFBUWEsTUFBTSxFQUFFQyxLQUFLO0lBQzFCLE1BQU1DLFFBQVFELE1BQU1DLEtBQUssQ0FBQztJQUN6QixJQUFHWCxXQUFXWSxjQUFjLEVBQUVELFNBQVMsTUFBTSxnQkFBZ0IsUUFBUUQ7SUFDdEUsTUFBTUcsT0FBT0YsS0FBSyxDQUFDLEVBQUU7SUFDckIsTUFBTUcsT0FBT0gsS0FBSyxDQUFDLEVBQUU7SUFDckIsTUFBTUksT0FBUUosS0FBSyxDQUFDLEVBQUUsS0FBSztJQUMzQixJQUFJSyxNQUFNUDtJQUNWLEtBQUssTUFBTVEsUUFBUUosS0FBS0ssV0FBVyxHQUFHQyxLQUFLLENBQUMsS0FBTTtRQUM5QyxpRUFBaUU7UUFDakUsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTCxNQUFNO1lBQ3BCLElBQUksQ0FBQ0MsS0FBS04sS0FBSyxDQUFDLGFBQWE7Z0JBQ3pCO1lBQ0o7WUFDQUssTUFBTUEsR0FBRyxDQUFDTSxTQUFTTCxNQUFNO1FBQzdCLE9BQ0ssSUFBSSxPQUFRRCxRQUFTLFVBQVU7WUFDaEMsSUFBSU8sUUFBUTtZQUNaLElBQUssTUFBTUMsT0FBT1IsSUFBSztnQkFDbkIsSUFBSVEsSUFBSU4sV0FBVyxPQUFPRCxNQUFNO29CQUM1Qk0sUUFBUVAsR0FBRyxDQUFDUSxJQUFJO29CQUNoQjtnQkFDSjtZQUNKO1lBQ0FSLE1BQU1PO1FBQ1YsT0FDSztZQUNEUCxNQUFNO1FBQ1Y7UUFDQSxJQUFJQSxPQUFPLE1BQU07WUFDYjtRQUNKO0lBQ0o7SUFDQyxJQUFHaEIsV0FBV1ksY0FBYyxFQUFFLENBQUNHLFFBQVFDLE9BQU8sTUFBTSwwQkFBMEIsUUFBUUg7SUFDdkYsSUFBSUMsUUFBUUUsT0FBTyxNQUFNO1FBQ3JCLElBQUlGLFNBQVMsT0FBTztZQUNoQixJQUFJLE9BQVFFLFFBQVMsWUFBWUEsSUFBSUwsS0FBSyxDQUFDLGVBQWU7Z0JBQ3RELE9BQU9XLFNBQVNOO1lBQ3BCLE9BQ0ssSUFBSVMsT0FBT0MsYUFBYSxDQUFDVixNQUFNO2dCQUNoQyxPQUFPQTtZQUNYO1FBQ0o7UUFDQSxJQUFJRixTQUFTLFVBQVU7WUFDbkIsSUFBSSxPQUFRRSxRQUFTLFlBQVlBLElBQUlMLEtBQUssQ0FBQyxnQkFBZ0I7Z0JBQ3ZELE9BQU9nQixXQUFXWDtZQUN0QjtRQUNKO1FBQ0EsSUFBSUYsU0FBUyxRQUFRO1lBQ2pCLElBQUksT0FBUUUsUUFBUyxVQUFVO2dCQUMzQixPQUFPakIsY0FBY2lCO1lBQ3pCO1FBQ0o7UUFDQSxJQUFJRixTQUFTLFdBQVdNLE1BQU1DLE9BQU8sQ0FBQ0wsTUFBTTtZQUN4QyxPQUFPQTtRQUNYO1FBQ0EsSUFBSUYsU0FBUyxPQUFRRSxLQUFNO1lBQ3ZCLE9BQU9BO1FBQ1g7UUFDQyxJQUFHaEIsV0FBV1ksY0FBYyxFQUFFLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRUUsS0FBSyxDQUFDLENBQUMsRUFBRSxRQUFRRDtJQUNuRjtJQUNBLE9BQU9HO0FBQ1g7QUFDQXRCLGVBQWUsR0FBR0UsU0FDbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQSxJQUNBLDBEQUEwRDtDQUMxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsSUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvdXRpbHMuanM/OTUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3BlbHVuayA9IGV4cG9ydHMuZ2V0UGFzc3dvcmQgPSBleHBvcnRzLnpwYWQgPSBleHBvcnRzLmxvb3NlQXJyYXlpZnkgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIChoZXhTdHJpbmcpID09PSBcInN0cmluZ1wiICYmICFoZXhTdHJpbmcuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICAgIGhleFN0cmluZyA9IFwiMHhcIiArIGhleFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkoaGV4U3RyaW5nKTtcbn1cbmV4cG9ydHMubG9vc2VBcnJheWlmeSA9IGxvb3NlQXJyYXlpZnk7XG5mdW5jdGlvbiB6cGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLnpwYWQgPSB6cGFkO1xuZnVuY3Rpb24gZ2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBpZiAodHlwZW9mIChwYXNzd29yZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoMCwgaW5kZXhfanNfMS50b1V0ZjhCeXRlcykocGFzc3dvcmQsIFwiTkZLQ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbmRleF9qc18xLmdldEJ5dGVzQ29weSkocGFzc3dvcmQpO1xufVxuZXhwb3J0cy5nZXRQYXNzd29yZCA9IGdldFBhc3N3b3JkO1xuZnVuY3Rpb24gc3BlbHVuayhvYmplY3QsIF9wYXRoKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBfcGF0aC5tYXRjaCgvXihbYS16MC05JF8uLV0qKSg6KFthLXpdKykpPyghKT8kL2kpO1xuICAgICgwLCBpbmRleF9qc18xLmFzc2VydEFyZ3VtZW50KShtYXRjaCAhPSBudWxsLCBcImludmFsaWQgcGF0aFwiLCBcInBhdGhcIiwgX3BhdGgpO1xuICAgIGNvbnN0IHBhdGggPSBtYXRjaFsxXTtcbiAgICBjb25zdCB0eXBlID0gbWF0Y2hbM107XG4gICAgY29uc3QgcmVxZCA9IChtYXRjaFs0XSA9PT0gXCIhXCIpO1xuICAgIGxldCBjdXIgPSBvYmplY3Q7XG4gICAgZm9yIChjb25zdCBjb21wIG9mIHBhdGgudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgICAgIGlmICghY29tcC5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyW3BhcnNlSW50KGNvbXApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGN1cikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBjdXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIGluZGV4X2pzXzEuYXNzZXJ0QXJndW1lbnQpKCFyZXFkIHx8IGN1ciAhPSBudWxsLCBcIm1pc3NpbmcgcmVxdWlyZWQgdmFsdWVcIiwgXCJwYXRoXCIsIHBhdGgpO1xuICAgIGlmICh0eXBlICYmIGN1ciAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjdXIpID09PSBcInN0cmluZ1wiICYmIGN1ci5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihjdXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIiAmJiBjdXIubWF0Y2goL14tP1swLTkuXSokLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY3VyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUFycmF5aWZ5KGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IHR5cGVvZiAoY3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIGB3cm9uZyB0eXBlIGZvdW5kIGZvciAke3R5cGV9IGAsIFwicGF0aFwiLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbn1cbmV4cG9ydHMuc3BlbHVuayA9IHNwZWx1bms7XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGZvbGxvdyhvYmplY3Q6IGFueSwgcGF0aDogc3RyaW5nKTogbnVsbCB8IHN0cmluZyB7XG4gICAgbGV0IGN1cnJlbnRDaGlsZCA9IG9iamVjdDtcblxuICAgIGZvciAoY29uc3QgY29tcCBvZiBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKSkge1xuXG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XG4gICAgICAgIGxldCBtYXRjaGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBjb21wKSB7XG4gICAgICAgICAgICAgICAgIG1hdGNoaW5nQ2hpbGQgPSBjdXJyZW50Q2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoaW5nQ2hpbGQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgICBjdXJyZW50Q2hpbGQgPSBtYXRjaGluZ0NoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50Q2hpbGQ7XG59XG5cbi8vIFwicGF0aC90by9zb21ldGhpbmc6dHlwZSFcIlxuZXhwb3J0IGZ1bmN0aW9uIGZvbGxvd1JlcXVpcmVkKGRhdGE6IGFueSwgcGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YWx1ZSA9IGZvbGxvdyhkYXRhLCBwYXRoKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgeyByZXR1cm4gdmFsdWU7IH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIiwgYGRhdGE6JHsgcGF0aCB9YCxcbiAgICBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG4qL1xuLy8gU2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuLypcbmV4cG9ydCBmdW5jdGlvbiB1dWlkVjQocmFuZG9tQnl0ZXM6IEJ5dGVzTGlrZSk6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZXMgPSBnZXRCeXRlcyhyYW5kb21CeXRlcywgXCJyYW5kb21CeXRlc1wiKTtcblxuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcblxuICAgIC8vIFNlY3Rpb24gNC40XG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzZdID0gMGIwXG4gICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzddID0gMGIxXG4gICAgYnl0ZXNbOF0gPSAoYnl0ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgICBjb25zdCB2YWx1ZSA9IGhleGxpZnkoYnl0ZXMpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxuICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuICAgIF0uam9pbihcIi1cIik7XG59XG4qL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic3BlbHVuayIsImdldFBhc3N3b3JkIiwienBhZCIsImxvb3NlQXJyYXlpZnkiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImhleFN0cmluZyIsInN0YXJ0c1dpdGgiLCJnZXRCeXRlc0NvcHkiLCJsZW5ndGgiLCJTdHJpbmciLCJwYXNzd29yZCIsInRvVXRmOEJ5dGVzIiwib2JqZWN0IiwiX3BhdGgiLCJtYXRjaCIsImFzc2VydEFyZ3VtZW50IiwicGF0aCIsInR5cGUiLCJyZXFkIiwiY3VyIiwiY29tcCIsInRvTG93ZXJDYXNlIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUludCIsImZvdW5kIiwia2V5IiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsInBhcnNlRmxvYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wallet/wallet.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wallet/wallet.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Wallet = void 0;\nconst index_js_1 = __webpack_require__(/*! ../crypto/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/crypto/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst base_wallet_js_1 = __webpack_require__(/*! ./base-wallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/base-wallet.js\");\nconst hdwallet_js_1 = __webpack_require__(/*! ./hdwallet.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/hdwallet.js\");\nconst json_crowdsale_js_1 = __webpack_require__(/*! ./json-crowdsale.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js\");\nconst json_keystore_js_1 = __webpack_require__(/*! ./json-keystore.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/json-keystore.js\");\nconst mnemonic_js_1 = __webpack_require__(/*! ./mnemonic.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wallet/mnemonic.js\");\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            resolve();\n        }, duration);\n    });\n}\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */ class Wallet extends base_wallet_js_1.BaseWallet {\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */ constructor(key, provider){\n        if (typeof key === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n        let signingKey = typeof key === \"string\" ? new index_js_1.SigningKey(key) : key;\n        super(signingKey, provider);\n    }\n    connect(provider) {\n        return new Wallet(this.signingKey, provider);\n    }\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */ async encrypt(password, progressCallback) {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, {\n            progressCallback\n        });\n    }\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */ encryptSync(password) {\n        const account = {\n            address: this.address,\n            privateKey: this.privateKey\n        };\n        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);\n    }\n    static #fromAccount(account) {\n        (0, index_js_2.assertArgument)(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n        const wallet = new Wallet(account.privateKey);\n        (0, index_js_2.assertArgument)(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n        return wallet;\n    }\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */ static async fromEncryptedJson(json, password, progress) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);\n        } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            if (progress) {\n                progress(0);\n                await stall(0);\n            }\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n            if (progress) {\n                progress(1);\n                await stall(0);\n            }\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */ static fromEncryptedJsonSync(json, password) {\n        let account = null;\n        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {\n            account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);\n        } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {\n            account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);\n        } else {\n            (0, index_js_2.assertArgument)(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n        return Wallet.#fromAccount(account);\n    }\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the avavilable\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */ static createRandom(provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.createRandom();\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */ static fromPhrase(phrase, provider) {\n        const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);\n        if (provider) {\n            return wallet.connect(provider);\n        }\n        return wallet;\n    }\n}\nexports.Wallet = Wallet; //# sourceMappingURL=wallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93YWxsZXQvd2FsbGV0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyxvRkFBb0I7QUFDL0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1HLGdCQUFnQkgsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUksc0JBQXNCSixtQkFBT0EsQ0FBQyw4RkFBcUI7QUFDekQsTUFBTUsscUJBQXFCTCxtQkFBT0EsQ0FBQyw0RkFBb0I7QUFDdkQsTUFBTU0sZ0JBQWdCTixtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxTQUFTTyxNQUFNQyxRQUFRO0lBQ25CLE9BQU8sSUFBSUMsUUFBUSxDQUFDQztRQUFjQyxXQUFXO1lBQVFEO1FBQVcsR0FBR0Y7SUFBVztBQUNsRjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1WLGVBQWVJLGlCQUFpQlUsVUFBVTtJQUM1Qzs7O0tBR0MsR0FDREMsWUFBWUMsR0FBRyxFQUFFQyxRQUFRLENBQUU7UUFDdkIsSUFBSSxPQUFRRCxRQUFTLFlBQVksQ0FBQ0EsSUFBSUUsVUFBVSxDQUFDLE9BQU87WUFDcERGLE1BQU0sT0FBT0E7UUFDakI7UUFDQSxJQUFJRyxhQUFhLE9BQVNILFFBQVMsV0FBWSxJQUFJZixXQUFXbUIsVUFBVSxDQUFDSixPQUFPQTtRQUNoRixLQUFLLENBQUNHLFlBQVlGO0lBQ3RCO0lBQ0FJLFFBQVFKLFFBQVEsRUFBRTtRQUNkLE9BQU8sSUFBSWpCLE9BQU8sSUFBSSxDQUFDbUIsVUFBVSxFQUFFRjtJQUN2QztJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1LLFFBQVFDLFFBQVEsRUFBRUMsZ0JBQWdC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Y2tDLFlBQVksQ0FBQ2MsWUFBWTtRQUN0RCxJQUFJcEMsVUFBVTtZQUNWLE9BQU9xQixPQUFPakIsT0FBTyxDQUFDSjtRQUMxQjtRQUNBLE9BQU9xQjtJQUNYO0lBQ0E7O0tBRUMsR0FDRCxPQUFPZ0IsV0FBV0MsTUFBTSxFQUFFdEMsUUFBUSxFQUFFO1FBQ2hDLE1BQU1xQixTQUFTakMsY0FBY2tDLFlBQVksQ0FBQ2UsVUFBVSxDQUFDQztRQUNyRCxJQUFJdEMsVUFBVTtZQUNWLE9BQU9xQixPQUFPakIsT0FBTyxDQUFDSjtRQUMxQjtRQUNBLE9BQU9xQjtJQUNYO0FBQ0o7QUFDQXhDLGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd2FsbGV0L3dhbGxldC5qcz9mYTZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYWxsZXQgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBiYXNlX3dhbGxldF9qc18xID0gcmVxdWlyZShcIi4vYmFzZS13YWxsZXQuanNcIik7XG5jb25zdCBoZHdhbGxldF9qc18xID0gcmVxdWlyZShcIi4vaGR3YWxsZXQuanNcIik7XG5jb25zdCBqc29uX2Nyb3dkc2FsZV9qc18xID0gcmVxdWlyZShcIi4vanNvbi1jcm93ZHNhbGUuanNcIik7XG5jb25zdCBqc29uX2tleXN0b3JlX2pzXzEgPSByZXF1aXJlKFwiLi9qc29uLWtleXN0b3JlLmpzXCIpO1xuY29uc3QgbW5lbW9uaWNfanNfMSA9IHJlcXVpcmUoXCIuL21uZW1vbmljLmpzXCIpO1xuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHsgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgZHVyYXRpb24pOyB9KTtcbn1cbi8qKlxuICogIEEgKipXYWxsZXQqKiBtYW5hZ2VzIGEgc2luZ2xlIHByaXZhdGUga2V5IHdoaWNoIGlzIHVzZWQgdG8gc2lnblxuICogIHRyYW5zYWN0aW9ucywgbWVzc2FnZXMgYW5kIG90aGVyIGNvbW1vbiBwYXlsb2Fkcy5cbiAqXG4gKiAgVGhpcyBjbGFzcyBpcyBnZW5lcmFsbHkgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGRldmVsb3BlcnNcbiAqICB0aGF0IHdpc2ggdG8gdXNlIGEgcHJpdmF0ZSBrZXkgZGlyZWN0bHksIGFzIGl0IGNhbiBjcmVhdGVcbiAqICBpbnN0YW5jZXMgZnJvbSBhIGxhcmdlIHZhcmlldHkgb2YgY29tbW9uIHNvdXJjZXMsIGluY2x1ZGluZ1xuICogIHJhdyBwcml2YXRlIGtleSwgW1tsaW5rLWJpcC0zOV1dIG1uZW1vbmljcyBhbmQgZW5jcnlwdGUgSlNPTlxuICogIHdhbGxldHMuXG4gKi9cbmNsYXNzIFdhbGxldCBleHRlbmRzIGJhc2Vfd2FsbGV0X2pzXzEuQmFzZVdhbGxldCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBhIG5ldyB3YWxsZXQgZm9yIHRoZSBwcml2YXRlICUla2V5JSUsIG9wdGlvbmFsbHkgY29ubmVjdGVkXG4gICAgICogIHRvICUlcHJvdmlkZXIlJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihrZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIgJiYgIWtleS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgIGtleSA9IFwiMHhcIiArIGtleTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmluZ0tleSA9ICh0eXBlb2YgKGtleSkgPT09IFwic3RyaW5nXCIpID8gbmV3IGluZGV4X2pzXzEuU2lnbmluZ0tleShrZXkpIDoga2V5O1xuICAgICAgICBzdXBlcihzaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcy5zaWduaW5nS2V5LCBwcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXNvbHZlcyB0byBhIFtKU09OIEtleXN0b3JlIFdhbGxldF0oanNvbi13YWxsZXRzKSBlbmNyeXB0ZWQgd2l0aFxuICAgICAqICAlJXBhc3N3b3JkJSUuXG4gICAgICpcbiAgICAgKiAgSWYgJSVwcm9ncmVzc0NhbGxiYWNrJSUgaXMgc3BlY2lmaWVkLCBpdCB3aWxsIHJlY2VpdmUgcGVyaW9kaWNcbiAgICAgKiAgdXBkYXRlcyBhcyB0aGUgZW5jcnlwdGlvbiBwcm9jZXNzIHByb2dyZXNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmNyeXB0KHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiBhd2FpdCAoMCwganNvbl9rZXlzdG9yZV9qc18xLmVuY3J5cHRLZXlzdG9yZUpzb24pKGFjY291bnQsIHBhc3N3b3JkLCB7IHByb2dyZXNzQ2FsbGJhY2sgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgW0pTT04gS2V5c3RvcmUgV2FsbGV0XShqc29uLXdhbGxldHMpIGVuY3J5cGVkIHdpdGhcbiAgICAgKiAgJSVwYXNzd29yZCUlLlxuICAgICAqXG4gICAgICogIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgdGhlIFthc3luYyB2ZXJzaW9uXShlbmNyeXB0KSBpbnN0ZWFkLFxuICAgICAqICB3aGljaCBhbGxvd3MgYSBbW1Byb2dyZXNzQ2FsbGJhY2tdXSB0byBrZWVwIHRoZSB1c2VyIGluZm9ybWVkLlxuICAgICAqXG4gICAgICogIFRoaXMgbWV0aG9kIHdpbGwgYmxvY2sgdGhlIGV2ZW50IGxvb3AgKGZyZWV6aW5nIGFsbCBVSSkgdW50aWxcbiAgICAgKiAgaXQgaXMgY29tcGxldGUsIHdoaWNoIG1heSBiZSBhIG5vbi10cml2aWFsIGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGVuY3J5cHRTeW5jKHBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcywgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5IH07XG4gICAgICAgIHJldHVybiAoMCwganNvbl9rZXlzdG9yZV9qc18xLmVuY3J5cHRLZXlzdG9yZUpzb25TeW5jKShhY2NvdW50LCBwYXNzd29yZCk7XG4gICAgfVxuICAgIHN0YXRpYyAjZnJvbUFjY291bnQoYWNjb3VudCkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoYWNjb3VudCwgXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIsIFwianNvblwiLCBcIlsgUkVEQUNURUQgXVwiKTtcbiAgICAgICAgaWYgKFwibW5lbW9uaWNcIiBpbiBhY2NvdW50ICYmIGFjY291bnQubW5lbW9uaWMgJiYgYWNjb3VudC5tbmVtb25pYy5sb2NhbGUgPT09IFwiZW5cIikge1xuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBtbmVtb25pY19qc18xLk1uZW1vbmljLmZyb21FbnRyb3B5KGFjY291bnQubW5lbW9uaWMuZW50cm9weSk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIGFjY291bnQubW5lbW9uaWMucGF0aCk7XG4gICAgICAgICAgICBpZiAod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcyAmJiB3YWxsZXQucHJpdmF0ZUtleSA9PT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV0FSTklORzogSlNPTiBtaXNtYXRjaCBhZGRyZXNzL3ByaXZhdGVLZXkgIT0gbW5lbW9uaWM7IGZhbGxiYWNrIG9udG8gcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldChhY2NvdW50LnByaXZhdGVLZXkpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkod2FsbGV0LmFkZHJlc3MgPT09IGFjY291bnQuYWRkcmVzcywgXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIiwgXCJqc29uXCIsIFwiWyBSRURBQ1RFRCBdXCIpO1xuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyAoYXN5bmNocm9ub3VzbHkpIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJVxuICAgICAqICB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBJZiAlJXByb2dyZXNzJSUgaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCBwZXJpb2RpY2FsbHkgZHVyaW5nXG4gICAgICogIGRlY3J5cHRpb24gc28gdGhhdCBhbnkgVUkgY2FuIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21FbmNyeXB0ZWRKc29uKGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzcykge1xuICAgICAgICBsZXQgYWNjb3VudCA9IG51bGw7XG4gICAgICAgIGlmICgoMCwganNvbl9rZXlzdG9yZV9qc18xLmlzS2V5c3RvcmVKc29uKShqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGF3YWl0ICgwLCBqc29uX2tleXN0b3JlX2pzXzEuZGVjcnlwdEtleXN0b3JlSnNvbikoanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwganNvbl9jcm93ZHNhbGVfanNfMS5pc0Nyb3dkc2FsZUpzb24pKGpzb24pKSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcygwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdGFsbCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY291bnQgPSAoMCwganNvbl9jcm93ZHNhbGVfanNfMS5kZWNyeXB0Q3Jvd2RzYWxlSnNvbikoanNvbiwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RhbGwoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgKipXYWxsZXQqKiBieSBkZWNyeXB0aW5nIHRoZSAlJWpzb24lJSB3aXRoICUlcGFzc3dvcmQlJS5cbiAgICAgKlxuICAgICAqICBUaGUgW1tmcm9tRW5jcnlwdGVkSnNvbl1dIG1ldGhvZCBpcyBwcmVmZXJyZWQsIGFzIHRoaXMgbWV0aG9kXG4gICAgICogIHdpbGwgbG9jayB1cCBhbmQgZnJlZXplIHRoZSBVSSBkdXJpbmcgZGVjcnlwdGlvbiwgd2hpY2ggbWF5IHRha2VcbiAgICAgKiAgc29tZSB0aW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRW5jcnlwdGVkSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpIHtcbiAgICAgICAgbGV0IGFjY291bnQgPSBudWxsO1xuICAgICAgICBpZiAoKDAsIGpzb25fa2V5c3RvcmVfanNfMS5pc0tleXN0b3JlSnNvbikoanNvbikpIHtcbiAgICAgICAgICAgIGFjY291bnQgPSAoMCwganNvbl9rZXlzdG9yZV9qc18xLmRlY3J5cHRLZXlzdG9yZUpzb25TeW5jKShqc29uLCBwYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGpzb25fY3Jvd2RzYWxlX2pzXzEuaXNDcm93ZHNhbGVKc29uKShqc29uKSkge1xuICAgICAgICAgICAgYWNjb3VudCA9ICgwLCBqc29uX2Nyb3dkc2FsZV9qc18xLmRlY3J5cHRDcm93ZHNhbGVKc29uKShqc29uLCBwYXNzd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoZmFsc2UsIFwiaW52YWxpZCBKU09OIHdhbGxldFwiLCBcImpzb25cIiwgXCJbIFJFREFDVEVEIF1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdhbGxldC4jZnJvbUFjY291bnQoYWNjb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IHJhbmRvbSBbW0hETm9kZVdhbGxldF1dIHVzaW5nIHRoZSBhdmF2aWxhYmxlXG4gICAgICogIFtjcnlwdG9ncmFwaGljIHJhbmRvbSBzb3VyY2VdKHJhbmRvbUJ5dGVzKS5cbiAgICAgKlxuICAgICAqICBJZiB0aGVyZSBpcyBubyBjcnl0b2dyYXBoaWMgcmFuZG9tIHNvdXJjZSwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYW5kb20ocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gaGR3YWxsZXRfanNfMS5IRE5vZGVXYWxsZXQuY3JlYXRlUmFuZG9tKCk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIFtbSEROb2RlV2FsbGV0XV0gZm9yICUlcGhyYXNlJSUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21QaHJhc2UocGhyYXNlLCBwcm92aWRlcikge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBoZHdhbGxldF9qc18xLkhETm9kZVdhbGxldC5mcm9tUGhyYXNlKHBocmFzZSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5jb25uZWN0KHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldhbGxldCIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImJhc2Vfd2FsbGV0X2pzXzEiLCJoZHdhbGxldF9qc18xIiwianNvbl9jcm93ZHNhbGVfanNfMSIsImpzb25fa2V5c3RvcmVfanNfMSIsIm1uZW1vbmljX2pzXzEiLCJzdGFsbCIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiQmFzZVdhbGxldCIsImNvbnN0cnVjdG9yIiwia2V5IiwicHJvdmlkZXIiLCJzdGFydHNXaXRoIiwic2lnbmluZ0tleSIsIlNpZ25pbmdLZXkiLCJjb25uZWN0IiwiZW5jcnlwdCIsInBhc3N3b3JkIiwicHJvZ3Jlc3NDYWxsYmFjayIsImFjY291bnQiLCJhZGRyZXNzIiwicHJpdmF0ZUtleSIsImVuY3J5cHRLZXlzdG9yZUpzb24iLCJlbmNyeXB0U3luYyIsImVuY3J5cHRLZXlzdG9yZUpzb25TeW5jIiwiZnJvbUFjY291bnQiLCJhc3NlcnRBcmd1bWVudCIsIm1uZW1vbmljIiwibG9jYWxlIiwiTW5lbW9uaWMiLCJmcm9tRW50cm9weSIsImVudHJvcHkiLCJ3YWxsZXQiLCJIRE5vZGVXYWxsZXQiLCJmcm9tTW5lbW9uaWMiLCJwYXRoIiwiY29uc29sZSIsImxvZyIsImZyb21FbmNyeXB0ZWRKc29uIiwianNvbiIsInByb2dyZXNzIiwiaXNLZXlzdG9yZUpzb24iLCJkZWNyeXB0S2V5c3RvcmVKc29uIiwiaXNDcm93ZHNhbGVKc29uIiwiZGVjcnlwdENyb3dkc2FsZUpzb24iLCJmcm9tRW5jcnlwdGVkSnNvblN5bmMiLCJkZWNyeXB0S2V5c3RvcmVKc29uU3luYyIsImNyZWF0ZVJhbmRvbSIsImZyb21QaHJhc2UiLCJwaHJhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wallet/wallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeBits = void 0;\nconst Base64 = \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\";\n/**\n *  @_ignore\n */ function decodeBits(width, data) {\n    const maxValue = (1 << width) - 1;\n    const result = [];\n    let accum = 0, bits = 0, flood = 0;\n    for(let i = 0; i < data.length; i++){\n        // Accumulate 6 bits of data\n        accum = accum << 6 | Base64.indexOf(data[i]);\n        bits += 6;\n        // While we have enough for a word...\n        while(bits >= width){\n            // ...read the word\n            const value = accum >> bits - width;\n            accum &= (1 << bits - width) - 1;\n            bits -= width;\n            // A value of 0 indicates we exceeded maxValue, it\n            // floods over into the next value\n            if (value === 0) {\n                flood += maxValue;\n            } else {\n                result.push(value + flood);\n                flood = 0;\n            }\n        }\n    }\n    return result;\n}\nexports.decodeBits = decodeBits; //# sourceMappingURL=bit-reader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvYml0LXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxTQUFTO0FBQ2Y7O0NBRUMsR0FDRCxTQUFTRCxXQUFXRSxLQUFLLEVBQUVDLElBQUk7SUFDM0IsTUFBTUMsV0FBVyxDQUFDLEtBQUtGLEtBQUksSUFBSztJQUNoQyxNQUFNRyxTQUFTLEVBQUU7SUFDakIsSUFBSUMsUUFBUSxHQUFHQyxPQUFPLEdBQUdDLFFBQVE7SUFDakMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLEtBQUtPLE1BQU0sRUFBRUQsSUFBSztRQUNsQyw0QkFBNEI7UUFDNUJILFFBQVMsU0FBVSxJQUFLTCxPQUFPVSxPQUFPLENBQUNSLElBQUksQ0FBQ00sRUFBRTtRQUM5Q0YsUUFBUTtRQUNSLHFDQUFxQztRQUNyQyxNQUFPQSxRQUFRTCxNQUFPO1lBQ2xCLG1CQUFtQjtZQUNuQixNQUFNSCxRQUFTTyxTQUFVQyxPQUFPTDtZQUNoQ0ksU0FBUyxDQUFDLEtBQU1DLE9BQU9MLEtBQUssSUFBSztZQUNqQ0ssUUFBUUw7WUFDUixrREFBa0Q7WUFDbEQsa0NBQWtDO1lBQ2xDLElBQUlILFVBQVUsR0FBRztnQkFDYlMsU0FBU0o7WUFDYixPQUNLO2dCQUNEQyxPQUFPTyxJQUFJLENBQUNiLFFBQVFTO2dCQUNwQkEsUUFBUTtZQUNaO1FBQ0o7SUFDSjtJQUNBLE9BQU9IO0FBQ1g7QUFDQVAsa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9iaXQtcmVhZGVyLmpzPzVlYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUJpdHMgPSB2b2lkIDA7XG5jb25zdCBCYXNlNjQgPSBcIikhQCMkJV4mKihBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV9cIjtcbi8qKlxuICogIEBfaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUJpdHMod2lkdGgsIGRhdGEpIHtcbiAgICBjb25zdCBtYXhWYWx1ZSA9ICgxIDw8IHdpZHRoKSAtIDE7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGFjY3VtID0gMCwgYml0cyA9IDAsIGZsb29kID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gQWNjdW11bGF0ZSA2IGJpdHMgb2YgZGF0YVxuICAgICAgICBhY2N1bSA9ICgoYWNjdW0gPDwgNikgfCBCYXNlNjQuaW5kZXhPZihkYXRhW2ldKSk7XG4gICAgICAgIGJpdHMgKz0gNjtcbiAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZSBlbm91Z2ggZm9yIGEgd29yZC4uLlxuICAgICAgICB3aGlsZSAoYml0cyA+PSB3aWR0aCkge1xuICAgICAgICAgICAgLy8gLi4ucmVhZCB0aGUgd29yZFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoYWNjdW0gPj4gKGJpdHMgLSB3aWR0aCkpO1xuICAgICAgICAgICAgYWNjdW0gJj0gKDEgPDwgKGJpdHMgLSB3aWR0aCkpIC0gMTtcbiAgICAgICAgICAgIGJpdHMgLT0gd2lkdGg7XG4gICAgICAgICAgICAvLyBBIHZhbHVlIG9mIDAgaW5kaWNhdGVzIHdlIGV4Y2VlZGVkIG1heFZhbHVlLCBpdFxuICAgICAgICAgICAgLy8gZmxvb2RzIG92ZXIgaW50byB0aGUgbmV4dCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmxvb2QgKz0gbWF4VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSArIGZsb29kKTtcbiAgICAgICAgICAgICAgICBmbG9vZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVjb2RlQml0cyA9IGRlY29kZUJpdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXQtcmVhZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlY29kZUJpdHMiLCJCYXNlNjQiLCJ3aWR0aCIsImRhdGEiLCJtYXhWYWx1ZSIsInJlc3VsdCIsImFjY3VtIiwiYml0cyIsImZsb29kIiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeOwl = exports.decode = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\";\nconst Word = /^[a-z]*$/i;\nfunction unfold(words, sep) {\n    let initial = 97;\n    return words.reduce((accum, word)=>{\n        if (word === sep) {\n            initial++;\n        } else if (word.match(Word)) {\n            accum.push(String.fromCharCode(initial) + word);\n        } else {\n            initial = 97;\n            accum.push(word);\n        }\n        return accum;\n    }, []);\n}\n/**\n *  @_ignore\n */ function decode(data, subs) {\n    // Replace all the substitutions with their expanded form\n    for(let i = subsChrs.length - 1; i >= 0; i--){\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));\n    }\n    // Get all tle clumps; each suffix, first-increment and second-increment\n    const clumps = [];\n    const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word)=>{\n        if (semi) {\n            for(let i = parseInt(semi); i >= 0; i--){\n                clumps.push(\";\");\n            }\n        } else {\n            clumps.push(item.toLowerCase());\n        }\n        return \"\";\n    });\n    /* c8 ignore start */ if (leftover) {\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);\n    }\n    /* c8 ignore stop */ return unfold(unfold(clumps, \";\"), \":\");\n}\nexports.decode = decode;\n/**\n *  @_ignore\n */ function decodeOwl(data) {\n    (0, index_js_1.assertArgument)(data[0] === \"0\", \"unsupported auwl data\", \"data\", data);\n    return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));\n}\nexports.decodeOwl = decodeOwl; //# sourceMappingURL=decode-owl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQzFDLE1BQU1JLGFBQWFDLG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLE9BQU87QUFDYixTQUFTQyxPQUFPQyxLQUFLLEVBQUVDLEdBQUc7SUFDdEIsSUFBSUMsVUFBVTtJQUNkLE9BQU9GLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxPQUFPQztRQUN4QixJQUFJQSxTQUFTSixLQUFLO1lBQ2RDO1FBQ0osT0FDSyxJQUFJRyxLQUFLQyxLQUFLLENBQUNSLE9BQU87WUFDdkJNLE1BQU1HLElBQUksQ0FBQ0MsT0FBT0MsWUFBWSxDQUFDUCxXQUFXRztRQUM5QyxPQUNLO1lBQ0RILFVBQVU7WUFDVkUsTUFBTUcsSUFBSSxDQUFDRjtRQUNmO1FBQ0EsT0FBT0Q7SUFDWCxHQUFHLEVBQUU7QUFDVDtBQUNBOztDQUVDLEdBQ0QsU0FBU1YsT0FBT2dCLElBQUksRUFBRUMsSUFBSTtJQUN0Qix5REFBeUQ7SUFDekQsSUFBSyxJQUFJQyxJQUFJZixTQUFTZ0IsTUFBTSxHQUFHLEdBQUdELEtBQUssR0FBR0EsSUFBSztRQUMzQ0YsT0FBT0EsS0FBS0ksS0FBSyxDQUFDakIsUUFBUSxDQUFDZSxFQUFFLEVBQUVHLElBQUksQ0FBQ0osS0FBS0ssU0FBUyxDQUFDLElBQUlKLEdBQUcsSUFBSUEsSUFBSTtJQUN0RTtJQUNBLHdFQUF3RTtJQUN4RSxNQUFNSyxTQUFTLEVBQUU7SUFDakIsTUFBTUMsV0FBV1IsS0FBS1MsT0FBTyxDQUFDLDhCQUE4QixDQUFDQyxLQUFLQyxNQUFNQyxNQUFNakI7UUFDMUUsSUFBSWlCLE1BQU07WUFDTixJQUFLLElBQUlWLElBQUlXLFNBQVNELE9BQU9WLEtBQUssR0FBR0EsSUFBSztnQkFDdENLLE9BQU9WLElBQUksQ0FBQztZQUNoQjtRQUNKLE9BQ0s7WUFDRFUsT0FBT1YsSUFBSSxDQUFDYyxLQUFLRyxXQUFXO1FBQ2hDO1FBQ0EsT0FBTztJQUNYO0lBQ0EsbUJBQW1CLEdBQ25CLElBQUlOLFVBQVU7UUFDVixNQUFNLElBQUlPLE1BQU0sQ0FBQyxXQUFXLEVBQUVDLEtBQUtDLFNBQVMsQ0FBQ1QsVUFBVSxDQUFDO0lBQzVEO0lBQ0Esa0JBQWtCLEdBQ2xCLE9BQU9uQixPQUFPQSxPQUFPa0IsUUFBUSxNQUFNO0FBQ3ZDO0FBQ0ExQixjQUFjLEdBQUdHO0FBQ2pCOztDQUVDLEdBQ0QsU0FBU0QsVUFBVWlCLElBQUk7SUFDbEIsSUFBR2YsV0FBV2lDLGNBQWMsRUFBRWxCLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSyx5QkFBeUIsUUFBUUE7SUFDakYsT0FBT2hCLE9BQU9nQixLQUFLTSxTQUFTLENBQUMsSUFBSSxJQUFJbkIsU0FBU2dCLE1BQU0sR0FBR0gsS0FBS00sU0FBUyxDQUFDLEdBQUcsSUFBSSxJQUFJbkIsU0FBU2dCLE1BQU07QUFDcEc7QUFDQXRCLGlCQUFpQixHQUFHRSxXQUNwQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bC5qcz9iMzRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVPd2wgPSBleHBvcnRzLmRlY29kZSA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCBzdWJzQ2hycyA9IFwiICEjJCUmJygpKissLS4vPD0+P0BbXV5fYHt8fX5cIjtcbmNvbnN0IFdvcmQgPSAvXlthLXpdKiQvaTtcbmZ1bmN0aW9uIHVuZm9sZCh3b3Jkcywgc2VwKSB7XG4gICAgbGV0IGluaXRpYWwgPSA5NztcbiAgICByZXR1cm4gd29yZHMucmVkdWNlKChhY2N1bSwgd29yZCkgPT4ge1xuICAgICAgICBpZiAod29yZCA9PT0gc2VwKSB7XG4gICAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod29yZC5tYXRjaChXb3JkKSkge1xuICAgICAgICAgICAgYWNjdW0ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXRpYWwpICsgd29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsID0gOTc7XG4gICAgICAgICAgICBhY2N1bS5wdXNoKHdvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqICBAX2lnbm9yZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoZGF0YSwgc3Vicykge1xuICAgIC8vIFJlcGxhY2UgYWxsIHRoZSBzdWJzdGl0dXRpb25zIHdpdGggdGhlaXIgZXhwYW5kZWQgZm9ybVxuICAgIGZvciAobGV0IGkgPSBzdWJzQ2hycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zcGxpdChzdWJzQ2hyc1tpXSkuam9pbihzdWJzLnN1YnN0cmluZygyICogaSwgMiAqIGkgKyAyKSk7XG4gICAgfVxuICAgIC8vIEdldCBhbGwgdGxlIGNsdW1wczsgZWFjaCBzdWZmaXgsIGZpcnN0LWluY3JlbWVudCBhbmQgc2Vjb25kLWluY3JlbWVudFxuICAgIGNvbnN0IGNsdW1wcyA9IFtdO1xuICAgIGNvbnN0IGxlZnRvdmVyID0gZGF0YS5yZXBsYWNlKC8oOnwoWzAtOV0pfChbQS1aXVthLXpdKikpL2csIChhbGwsIGl0ZW0sIHNlbWksIHdvcmQpID0+IHtcbiAgICAgICAgaWYgKHNlbWkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJzZUludChzZW1pKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjbHVtcHMucHVzaChcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbHVtcHMucHVzaChpdGVtLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH0pO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChsZWZ0b3Zlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxlZnRvdmVyczogJHtKU09OLnN0cmluZ2lmeShsZWZ0b3Zlcil9YCk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgcmV0dXJuIHVuZm9sZCh1bmZvbGQoY2x1bXBzLCBcIjtcIiksIFwiOlwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlT3dsKGRhdGEpIHtcbiAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkoZGF0YVswXSA9PT0gXCIwXCIsIFwidW5zdXBwb3J0ZWQgYXV3bCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlKGRhdGEuc3Vic3RyaW5nKDEgKyAyICogc3Vic0NocnMubGVuZ3RoKSwgZGF0YS5zdWJzdHJpbmcoMSwgMSArIDIgKiBzdWJzQ2hycy5sZW5ndGgpKTtcbn1cbmV4cG9ydHMuZGVjb2RlT3dsID0gZGVjb2RlT3dsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLW93bC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVPd2wiLCJkZWNvZGUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsInN1YnNDaHJzIiwiV29yZCIsInVuZm9sZCIsIndvcmRzIiwic2VwIiwiaW5pdGlhbCIsInJlZHVjZSIsImFjY3VtIiwid29yZCIsIm1hdGNoIiwicHVzaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRhdGEiLCJzdWJzIiwiaSIsImxlbmd0aCIsInNwbGl0Iiwiam9pbiIsInN1YnN0cmluZyIsImNsdW1wcyIsImxlZnRvdmVyIiwicmVwbGFjZSIsImFsbCIsIml0ZW0iLCJzZW1pIiwicGFyc2VJbnQiLCJ0b0xvd2VyQ2FzZSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImFzc2VydEFyZ3VtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeOwlA = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst bit_reader_js_1 = __webpack_require__(/*! ./bit-reader.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/bit-reader.js\");\nconst decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\");\n/**\n *  @_ignore\n */ function decodeOwlA(data, accents) {\n    let words = (0, decode_owl_js_1.decodeOwl)(data).join(\",\");\n    // Inject the accents\n    accents.split(/,/g).forEach((accent)=>{\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);\n        (0, index_js_1.assertArgument)(match !== null, \"internal error parsing accents\", \"accents\", accents);\n        let posOffset = 0;\n        const positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);\n        const charCode = parseInt(match[2]);\n        const regex = new RegExp(`([${match[1]}])`, \"g\");\n        words = words.replace(regex, (all, letter)=>{\n            const rem = --positions[posOffset];\n            if (rem === 0) {\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode);\n                posOffset++;\n            }\n            return letter;\n        });\n    });\n    return words.split(\",\");\n}\nexports.decodeOwlA = decodeOwlA; //# sourceMappingURL=decode-owla.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvZGVjb2RlLW93bGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDLE1BQU1DLGtCQUFrQkQsbUJBQU9BLENBQUMseUZBQWlCO0FBQ2pELE1BQU1FLGtCQUFrQkYsbUJBQU9BLENBQUMseUZBQWlCO0FBQ2pEOztDQUVDLEdBQ0QsU0FBU0YsV0FBV0ssSUFBSSxFQUFFQyxPQUFPO0lBQzdCLElBQUlDLFFBQVEsQ0FBQyxHQUFHSCxnQkFBZ0JJLFNBQVMsRUFBRUgsTUFBTUksSUFBSSxDQUFDO0lBQ3RELHFCQUFxQjtJQUNyQkgsUUFBUUksS0FBSyxDQUFDLE1BQU1DLE9BQU8sQ0FBQyxDQUFDQztRQUN6QixNQUFNQyxRQUFRRCxPQUFPQyxLQUFLLENBQUM7UUFDMUIsSUFBR1osV0FBV2EsY0FBYyxFQUFFRCxVQUFVLE1BQU0sa0NBQWtDLFdBQVdQO1FBQzVGLElBQUlTLFlBQVk7UUFDaEIsTUFBTUMsWUFBWSxDQUFDLEdBQUdiLGdCQUFnQmMsVUFBVSxFQUFFQyxTQUFTTCxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRTtRQUM5RSxNQUFNTSxXQUFXRCxTQUFTTCxLQUFLLENBQUMsRUFBRTtRQUNsQyxNQUFNTyxRQUFRLElBQUlDLE9BQU8sQ0FBQyxFQUFFLEVBQUVSLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDNUNOLFFBQVFBLE1BQU1lLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDRyxLQUFLQztZQUMvQixNQUFNQyxNQUFNLEVBQUVULFNBQVMsQ0FBQ0QsVUFBVTtZQUNsQyxJQUFJVSxRQUFRLEdBQUc7Z0JBQ1hELFNBQVNFLE9BQU9DLFlBQVksQ0FBQ0gsT0FBT0ksVUFBVSxDQUFDLElBQUlUO2dCQUNuREo7WUFDSjtZQUNBLE9BQU9TO1FBQ1g7SUFDSjtJQUNBLE9BQU9qQixNQUFNRyxLQUFLLENBQUM7QUFDdkI7QUFDQVosa0JBQWtCLEdBQUdFLFlBQ3JCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9kZWNvZGUtb3dsYS5qcz9hMTM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVPd2xBID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGJpdF9yZWFkZXJfanNfMSA9IHJlcXVpcmUoXCIuL2JpdC1yZWFkZXIuanNcIik7XG5jb25zdCBkZWNvZGVfb3dsX2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGUtb3dsLmpzXCIpO1xuLyoqXG4gKiAgQF9pZ25vcmVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlT3dsQShkYXRhLCBhY2NlbnRzKSB7XG4gICAgbGV0IHdvcmRzID0gKDAsIGRlY29kZV9vd2xfanNfMS5kZWNvZGVPd2wpKGRhdGEpLmpvaW4oXCIsXCIpO1xuICAgIC8vIEluamVjdCB0aGUgYWNjZW50c1xuICAgIGFjY2VudHMuc3BsaXQoLywvZykuZm9yRWFjaCgoYWNjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gYWNjZW50Lm1hdGNoKC9eKFthLXpdKikoWzAtOV0rKShbMC05XSkoLiopJC8pO1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5hc3NlcnRBcmd1bWVudCkobWF0Y2ggIT09IG51bGwsIFwiaW50ZXJuYWwgZXJyb3IgcGFyc2luZyBhY2NlbnRzXCIsIFwiYWNjZW50c1wiLCBhY2NlbnRzKTtcbiAgICAgICAgbGV0IHBvc09mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9ICgwLCBiaXRfcmVhZGVyX2pzXzEuZGVjb2RlQml0cykocGFyc2VJbnQobWF0Y2hbM10pLCBtYXRjaFs0XSk7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYChbJHttYXRjaFsxXX1dKWAsIFwiZ1wiKTtcbiAgICAgICAgd29yZHMgPSB3b3Jkcy5yZXBsYWNlKHJlZ2V4LCAoYWxsLCBsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbSA9IC0tcG9zaXRpb25zW3Bvc09mZnNldF07XG4gICAgICAgICAgICBpZiAocmVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShsZXR0ZXIuY2hhckNvZGVBdCgwKSwgY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgIHBvc09mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxldHRlcjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdvcmRzLnNwbGl0KFwiLFwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlT3dsQSA9IGRlY29kZU93bEE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGUtb3dsYS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVPd2xBIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJiaXRfcmVhZGVyX2pzXzEiLCJkZWNvZGVfb3dsX2pzXzEiLCJkYXRhIiwiYWNjZW50cyIsIndvcmRzIiwiZGVjb2RlT3dsIiwiam9pbiIsInNwbGl0IiwiZm9yRWFjaCIsImFjY2VudCIsIm1hdGNoIiwiYXNzZXJ0QXJndW1lbnQiLCJwb3NPZmZzZXQiLCJwb3NpdGlvbnMiLCJkZWNvZGVCaXRzIiwicGFyc2VJbnQiLCJjaGFyQ29kZSIsInJlZ2V4IiwiUmVnRXhwIiwicmVwbGFjZSIsImFsbCIsImxldHRlciIsInJlbSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNoYXJDb2RlQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;\n/**\n *  A Wordlist is a set of 2048 words used to encode private keys\n *  (or other binary data) that is easier for humans to write down,\n *  transcribe and dictate.\n *\n *  The [[link-bip-39]] standard includes several checksum bits,\n *  depending on the size of the mnemonic phrase.\n *\n *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For\n *  most purposes 12 word mnemonics should be used, as including\n *  additional words increases the difficulty and potential for\n *  mistakes and does not offer any effective improvement on security.\n *\n *  There are a variety of [[link-bip39-wordlists]] for different\n *  languages, but for maximal compatibility, the\n *  [English Wordlist](LangEn) is recommended.\n *\n *  @_section: api/wordlists:Wordlists [about-wordlists]\n */ var wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nObject.defineProperty(exports, \"Wordlist\", ({\n    enumerable: true,\n    get: function() {\n        return wordlist_js_1.Wordlist;\n    }\n}));\nvar lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nObject.defineProperty(exports, \"LangEn\", ({\n    enumerable: true,\n    get: function() {\n        return lang_en_js_1.LangEn;\n    }\n}));\nvar wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nObject.defineProperty(exports, \"WordlistOwl\", ({\n    enumerable: true,\n    get: function() {\n        return wordlist_owl_js_1.WordlistOwl;\n    }\n}));\nvar wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nObject.defineProperty(exports, \"WordlistOwlA\", ({\n    enumerable: true,\n    get: function() {\n        return wordlist_owla_js_1.WordlistOwlA;\n    }\n}));\nvar wordlists_js_1 = __webpack_require__(/*! ./wordlists.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js\");\nObject.defineProperty(exports, \"wordlists\", ({\n    enumerable: true,\n    get: function() {\n        return wordlists_js_1.wordlists;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUMxRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0QsSUFBSU8sZ0JBQWdCQyxtQkFBT0EsQ0FBQyxxRkFBZTtBQUMzQ1YsNENBQTJDO0lBQUVXLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGNBQWNELFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySCxJQUFJSyxlQUFlSCxtQkFBT0EsQ0FBQyxtRkFBYztBQUN6Q1YsMENBQXlDO0lBQUVXLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLGFBQWFOLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUNoSCxJQUFJTyxvQkFBb0JKLG1CQUFPQSxDQUFDLDZGQUFtQjtBQUNuRFYsK0NBQThDO0lBQUVXLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGtCQUFrQlIsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9ILElBQUlTLHFCQUFxQkwsbUJBQU9BLENBQUMsK0ZBQW9CO0FBQ3JEVixnREFBK0M7SUFBRVcsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csbUJBQW1CVixZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEksSUFBSVcsaUJBQWlCTixtQkFBT0EsQ0FBQyx1RkFBZ0I7QUFDN0NWLDZDQUE0QztJQUFFVyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSSxlQUFlWixTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDeEgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2luZGV4LmpzPzRlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndvcmRsaXN0cyA9IGV4cG9ydHMuV29yZGxpc3RPd2xBID0gZXhwb3J0cy5Xb3JkbGlzdE93bCA9IGV4cG9ydHMuTGFuZ0VuID0gZXhwb3J0cy5Xb3JkbGlzdCA9IHZvaWQgMDtcbi8qKlxuICogIEEgV29yZGxpc3QgaXMgYSBzZXQgb2YgMjA0OCB3b3JkcyB1c2VkIHRvIGVuY29kZSBwcml2YXRlIGtleXNcbiAqICAob3Igb3RoZXIgYmluYXJ5IGRhdGEpIHRoYXQgaXMgZWFzaWVyIGZvciBodW1hbnMgdG8gd3JpdGUgZG93bixcbiAqICB0cmFuc2NyaWJlIGFuZCBkaWN0YXRlLlxuICpcbiAqICBUaGUgW1tsaW5rLWJpcC0zOV1dIHN0YW5kYXJkIGluY2x1ZGVzIHNldmVyYWwgY2hlY2tzdW0gYml0cyxcbiAqICBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIG1uZW1vbmljIHBocmFzZS5cbiAqXG4gKiAgQSBtbmVtb25pYyBwaHJhc2UgbWF5IGJlIDEyLCAxNSwgMTgsIDIxIG9yIDI0IHdvcmRzIGxvbmcuIEZvclxuICogIG1vc3QgcHVycG9zZXMgMTIgd29yZCBtbmVtb25pY3Mgc2hvdWxkIGJlIHVzZWQsIGFzIGluY2x1ZGluZ1xuICogIGFkZGl0aW9uYWwgd29yZHMgaW5jcmVhc2VzIHRoZSBkaWZmaWN1bHR5IGFuZCBwb3RlbnRpYWwgZm9yXG4gKiAgbWlzdGFrZXMgYW5kIGRvZXMgbm90IG9mZmVyIGFueSBlZmZlY3RpdmUgaW1wcm92ZW1lbnQgb24gc2VjdXJpdHkuXG4gKlxuICogIFRoZXJlIGFyZSBhIHZhcmlldHkgb2YgW1tsaW5rLWJpcDM5LXdvcmRsaXN0c11dIGZvciBkaWZmZXJlbnRcbiAqICBsYW5ndWFnZXMsIGJ1dCBmb3IgbWF4aW1hbCBjb21wYXRpYmlsaXR5LCB0aGVcbiAqICBbRW5nbGlzaCBXb3JkbGlzdF0oTGFuZ0VuKSBpcyByZWNvbW1lbmRlZC5cbiAqXG4gKiAgQF9zZWN0aW9uOiBhcGkvd29yZGxpc3RzOldvcmRsaXN0cyBbYWJvdXQtd29yZGxpc3RzXVxuICovXG52YXIgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdvcmRsaXN0X2pzXzEuV29yZGxpc3Q7IH0gfSk7XG52YXIgbGFuZ19lbl9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1lbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxhbmdFblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGFuZ19lbl9qc18xLkxhbmdFbjsgfSB9KTtcbnZhciB3b3JkbGlzdF9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmRsaXN0T3dsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkbGlzdF9vd2xfanNfMS5Xb3JkbGlzdE93bDsgfSB9KTtcbnZhciB3b3JkbGlzdF9vd2xhX2pzXzEgPSByZXF1aXJlKFwiLi93b3JkbGlzdC1vd2xhLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29yZGxpc3RPd2xBXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkbGlzdF9vd2xhX2pzXzEuV29yZGxpc3RPd2xBOyB9IH0pO1xudmFyIHdvcmRsaXN0c19qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3RzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid29yZGxpc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3b3JkbGlzdHNfanNfMS53b3JkbGlzdHM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ3b3JkbGlzdHMiLCJXb3JkbGlzdE93bEEiLCJXb3JkbGlzdE93bCIsIkxhbmdFbiIsIldvcmRsaXN0Iiwid29yZGxpc3RfanNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibGFuZ19lbl9qc18xIiwid29yZGxpc3Rfb3dsX2pzXzEiLCJ3b3JkbGlzdF9vd2xhX2pzXzEiLCJ3b3JkbGlzdHNfanNfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangCz = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk\";\nconst checksum = \"0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-cz]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangCz extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Czech language Wordlist.\n     *\n     *  Using the constructor should be unnecessary, instead use the\n     *  [[wordlist]] singleton method.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"cz\", words, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangCz``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangCz();\n        }\n        return wordlist;\n    }\n}\nexports.LangCz = LangCz; //# sourceMappingURL=lang-cz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1jei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsb0JBQW9CQyxtQkFBT0EsQ0FBQyw2RkFBbUI7QUFDckQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFdBQVc7QUFDakIsSUFBSUMsV0FBVztBQUNmOzs7O0NBSUMsR0FDRCxNQUFNTCxlQUFlQyxrQkFBa0JLLFdBQVc7SUFDOUM7Ozs7Ozs7S0FPQyxHQUNEQyxhQUFjO1FBQUUsS0FBSyxDQUFDLE1BQU1KLE9BQU9DO0lBQVc7SUFDOUM7OztLQUdDLEdBQ0QsT0FBT0MsV0FBVztRQUNkLElBQUlBLFlBQVksTUFBTTtZQUNsQkEsV0FBVyxJQUFJTDtRQUNuQjtRQUNBLE9BQU9LO0lBQ1g7QUFDSjtBQUNBUCxjQUFjLEdBQUdFLFFBQ2pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLWN6LmpzP2RjZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdDeiA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBpdGF0a2FzdGNlbmFvdm8kdGFvdWxlcmFla2kmY2hvcip0ZWNpJWVuYmFsb2RhZWxhZGV0JyFDaG49MERpIyVFJV4xUmVzYTJSZXNlM0NlVCcjMEVqS29ob2wwUHUpJTBBJnNEdWwjRWtkbylLZSlUaSNVbHwzfWFPZ2FuJTBGYWx0SSRAdFBpLCVUbWFUcm9ub20wTGFzTHtpI09sMFRvYnVzNFlsOkIjfTxDaWxDdWwjRCFfR2UpR3JIbm9LdGVyaWVMYV5MeyNMa29uTG9uLUx2YW5MemFNYnVzTmtvbSFSW3JSe1JtYW5Sb2tvUnZhVGVyI1RvaFZsJlphbCNaaWxpI1p1IzNEJlJhblNlXlN0aWVUb25aaW4jWm1vY1opazNDeWtsRF1GdC1LaW55TGFuJU9nLGZPXWdUdmFab24yQWhvYnl0QXQqL0UvYUVkdStFc2tJayFJeiZPa3xPdWQgVWQyQi1CckRsLkR+SCEoSmtvdEp8Szx5c0xlJFI+Uic/VGFVYl9VLyFVXlUrVXIhWGVyMkFediNBbWJvLEFuI0F0ckVwKUlrZSlLb0xvaE9uek9za2V2VW57I1VzaW4jWl5aeTJCbC5Cbnx9KUQgX0QjRCdhRntKYXIoS3Y/TGRva0x2YU5eTmtyUnphVGlrVm9sWm9sYTNEK3RMLlQnIzBVa290OlBhcnRSZXYmM0RyRHUrSi9KbkxhTGVyTGtlbUxuP04uTm4oTicjTnRydW1OejxTdG9waXNUIzJBbHVwYUFwYF1BciBhQSlFL3QhRW1pZUkvb3RJcnVyZ0xgTGVbTHViIE1fTXUsT2JvdE8vb2xPZFtPKyxPbT1PcCBPcm9bT3ZSYXBvdFJsIFJ0UnVwVGl2KFVkLlV0biFWIVZpbCNWKFlbWSQhWXQgMEJ1K0dhcmUpSF8mSGxhTmtvdFJrdXNTdGVyJlRhJVRydXNaaW4+WigyTyYyS29saXZVdiE0SXRfTigwRG4oS2UpS3JQb3QwQWt+QWxJa1Jrb3QyS2xpJGE6TC1vUmVbVF9UdW0xRSwxQiFhfScjQ2liX0ZpYyBGbGElS2xLcntNb2tyIVByZXNlUmJ5UyNULXRpdjNLb2Isekt0fE9eUF1tU2tTcCtqVmBdVm8vMkFoYU91aG9VaG9waXMxRXMwQnJvQnl0LUNAdH11dCBEbmVzSCtkSG9eSCxKZW1Kbj9LbGBLb2xhS3Q8S3VtQHRMYXJMZXZhTC5NYU0ubnRNbHV2IE0nTnV0IFBgUGlzUGxuIFBvc3VkUHInb2RQdSQgUmF6IFIoUnRTYWhTbCdTdCEtU3VkU3kpVGF6VC1Ua35VZiFVdG4hVm96JVpgdVpuIVo8JTJBaG8pQWtBbSFpa0F2PkF6ZURvbE9ibihPZ2VyaWVPemRTbihUIFooMkJAfSdub0QtSGFIJyNTIFNub1QoME9qP09yPjJOYW0gOjlPXWdPbm9taWUwRWt0cm9uSXBzYTBBaWxJc2VPJVAhaWUySXpvXk8vYU9wZWpPczJFakVuJUs8KUt5bW8wSWtlKTBGPGllME9sdSUxRWt1JUt1cnplUGVkP1BdemVQPHRULGt0OkMjSmYjS3VsKU4haWtOKXppZVJtYWNpZVY8IFpvKzNEZSwlSntvbk4jM0FsI0d1LG50TG96b2ZMdHJOYW4lTilYYSUwT3JkMUFuX0lydE90aWxhMk5kU2Y8VFtsVCNUb24yQWslRXMjT24pMkthck5rJTNaaSM6TGVqZVJhbnQzTntpI09dZzNMb3QuMkF6dSxFanQyTGVtTGZpJGFUaSMyQWZBbW9mb25BbnUrRXBJbE9nT3RlcyMyTWE6RD9EckxhTEAjTltOb3Bpc1JmYVJwdSZWLG4zQmsoSiNsSm5vSnRtYW5LKXJMbWFNIW9tUj5SJlNdWmt5M1N0PGlrMkFkJyNBc2l2a3lBdmFFZCFFbk9edj5PaE91cChUIVViLlUvbykwQXRPKVl6MElzT2ppdm9PdXQwQmwuQm9qfURpbnlEbCFEbm8pRHxKbihLZWpMaW4jTCNMdWJNbytOIFtObywlUmFsUl5SaXpvbnRSa29SbGl2PlJtb25Sbi5Sb3Nrb3BSJHZvU3BvXlN0LlQnKFVbVWZVcCFVcyNWPDJBZFtBbj9BdihBel5CbytrRC5EXUQoTi1PYiNPbWFeT3RPdV5PekBTdCNVYihZeiEyQkAoQn5EW0tvdE1yUyBhU3RvKTBPemQyQm4oRCxudEdpZSZNJlN0ZXJpazoyWWwjM05lZDJPJjBVemUwVW4gYTBGLSVGbGElS2Fzb092YSVTcC0lVGVybntWYWxpXlZlJDxaZXIlM09uaWU6Qmxrb30pSG9eS21pK0soTCc+TilyUm1hcmtSb1NhblNub1QjVjxaeWszRGluPkQrRG4hX0hsYW5Lb3RMQEwgb01uKE5vbVA/U3tlclYgWmQ+WmVybzNOYWtOZHlOby9TayxTdG8pVHJuP1p2YTNFbnwxR3VydDVSKTpCYXJ7Ql9CaW57fSZEe0RpZF1IYW5KYWtKdSlLYW9LdHVzTGFtIGFMaG90eUxpYnJMbihNZSxNa29saXZNJk5pW2xOb2VOdDxQYWwuUF9hUCBvbGFQI1ArUG8pUHJQdSRhUHlbLFJhbV9Sb3QjUnRvblNhVGFdZ1RlZCxVJVV6YVZhK2NaYWojWmUpWml2KDJFa29saXZFc2kwRGx1YkBNcFJhbWkjM05vMkEla0FkaXZvQW1BcG90QXNpI0F1bkVjRW5bRXAhRXN+SWRJbWFJcyZPYiprTyNuT3BhT3ViVWInJlVzIVV6aygwRW5JdCFPdHIwSWhhT3QwQWw/QmVyPkIjQmxpaGFCeWxhQypySD1KQD5Lb3NLdGVqbExhcHNMZV5MaXplTG9NYW5kb01lKU1pa01uIWFNbyxNcGFzTXVuIGFOIU4lcHROZD9OPk5mZXNlTmdyZXNOLk5rdXJzTilrdE56ZXJ2YVBhbj5QaWVQflByJyNSYl9SLXQ8Um1pZF1Sb3B0ZXZScHVzUnUmUnl0b1J6e1MhPlN0I1RfVCspVCpsVWshVXBfJlVzLVV6XVZib2paYVo8b2gyQWI/QS9Bai5BbHxBc29waXNBdiFhRWQgRWpjYXJFc1tFdmUpSWt7SXRpa0l6ZUthdj5NZStjTWl2b09jYW5Pa09uaSNPcCBPdXBhT3YjVC1VaGBdVXA/VXQoVmluI1kvK1lwKVkkYWxZdDJEbGFuI0ZySm4oS2xhTGFqXkxpL0wjTG9te0x0dSxOYVBvZGl2dVJ0Uno8VGlsMEFsIGFBc2luI0UkPDJOb11nU18uVGEsVD9UI1QnPlZgXTpCLGQ8fSluRG4oSWtLb20+TV9hTXBhTicjUz9Tb1N0dSxUaW4jVi4zQiNDa2R5REBEbj9EJyNEdi5HQF5HaWVHLCVIJUhrKEh+S3R2YXJOby9vZE50aWwjUEAjUGlkXVRgXVQ+VG1vVG9rcnVoVmhhcnRWIGElVm9ib2szQix9b3QjRG9qZWREc2soSCcuSmF2PkwtTXsjTmllTiNObyt1bVN0b3BgVC5UfDVCaSRhRGl2b2RHaSNHb3BlZEthbCBhS3tNY3xQIWFQdS9SZFNvc1RyVV5sVWhVI1VzayFWPjNUaXYoMUNlciZDaWZlck1wU2tTdCwlMEklMlJhUmkjUy46RGFtRF1HaSRySGFnb25Key1KIF9KPCBhS2FrSyc/S3JfYUxbTC5MfEx2P01pbiNOZCtOa29SbihTYWtyU2tvdFNvcHUkVD9UcmkjVHVyIGFaYW4+Wml2b1psIFp1ciMyTG9bMH1hbmlrRCBhJUQnLkxhc2FMKm5OdG9sI1RsYVRvXlRyWmUsM0csJUh+SHUrSy5Lcm9mb25MQD5MaW17ckwoTWkjTmMnJk5pW3JOb217TnVsKFMjU3RyWHwyQWQoSGFIJy5Pa1MhVXYgMUkvT2hlbTBCaWxDbihEXyNEbCBbSHlsYUtyb0wtdWxhTUB0I05hci9hTm9rbE4kcnVtTnR8Tnp1blNhelNreXRTdFRpdmElVDwjVHkjVS9hVWRyKFphaSNaLVpvbDJBbTxBdkA+S2V2VHZvbGFae1p1dCgwVCBfMURyY0ZdbkwhTWllTj9Te1RhJVpldW1aaSNudDNTbGl2PjBEYTpCKnIhfXl0IURhJURieXQtRGhvekRvYnJvRHBpc0hsYXNIbiFIb2RpK0gsZCBJdiBhSmVkbipKaSRvSm09S11uIEtvbj5Lcm0gTGV2b01heiFNbHV2IE5vbXtyT2tvT3Bha08kcm9QYCFQZXZub1BsbiBQflBvcytkUHIob1JvZCBSdWJ5UnkvXVNgIFMtIVMrcG9TdCFUb2xpa1ZALVZyL1Z6ZDx5WnYhM0JlfSFDa3lEYStrb0RiIUR1aEdhJUh7SG9eSkBKcHJ2ZUtsaWRMaWIoTWlsKE1vY08vbylPbiNQb2tvalIoUnZTbXlzbFMqbGBUdjxVcm9uVi5adnlrKzNDbylKYWtLYW1LZHlLbEt0ZSxrVHJvNUMraEhhdj9NLiVSYVItUyBfU24oVXplVmlueVZvKVpkLDVEYUQrR3tUIFRuKFRyaWUzTWZhOjBBbEFydiBBdmFEaXZFY0VobiFFam09RXogYUhham9bSWxuP0phc24gSi10S11wIExhJEwtTGlbTG9oYUx1Xk5vc09oISBPai1PdXRSYXo+UiZSdVtSeXNTYWhTbHVoYVMpciFVdlZhelZpbiBWb2RWeWsrWXYhX1o8MEFzRWxFbiBIbGAgSG8pSCwmSXR+MEJvakJ5dH1vZENpeiBFYnIhRXNsIUV2emQhRXp2YUhgJUhvZCBKe0ppbnVkS2F6SypwIExpdkx1I01sI09sbihQYFBpc1BsPVA8UHUkIFB5ayFSYXojUypkIFN0dXBTdW5Ub2tUdWRWYWhhVmUpVm9sIVYsJXRaJmsxSSZTYWpkMUxhc05pc2tvUmFeUm96IFJ5ei0yQXBFbj9MaSNOb091emwgT3Z5UmFzYVJlc1JzLVJ1aFVwYW50VXIjVXMgMEVqbi5JenwwQWtFKylFeiBMYC5MKnYhTHV2YVlsMEVoZHkxQWt8QXMtRSwlSSVJbChJc3xPLE96P1JhdmR1Um90aTFCIGFsfWUkckdpZUw/TG9qVF8wQV59fkkjSXZvTGF2YUxlcCBMbiBMJyBOJ2FPW09sIFBhK2NUQFQsaGFUdV5UeS9Wb2ogMEVwbCBJc2tPcFJoIVJsKFJva1J1YnlWPDFBfkFyRXNMaXZuIE8lMUlkMURvWzp9IV9DaUB0RCovSDwtS3RMYW5eTD5MaXZvTHVbTWYrdE1scy1OQCNOaSNOJk58TiR2b050b2YrUHJpI1JrZSlSb2RpZVIpUnUjUnlbU2UjU2l2IGFTdF8jVEB0VHJvJlYqa1puZWh0WipyLTNDI0RhZ29nSnMtS11Mb3Rvbk5hbClOZHItTnplUmlza29wUm9TdHIoVGFyXlQ/VHJvK2pWbi5YZXNvM0FuaSRhSGFKYXY/SytLbmlrTC5MbihMdWwjTnplKVBlKVMhX1N0bytUZXYmVm4/VidhcjJBJW4pQWshQW1AQW5lKUEkaSNBdCBBdmlkXUF6RS9FbUBvRW4pRXNFdGl2b0V2X0l2IU4gTm9PL2FPZC5PbVtPdXRVa1luMkJhdiBCeXR9b2RDIEN0aXY+RCFEJW4gRGVwcyFEaCtkRGl2IERrbGBEbWFuIERuaWtEb1tEcG8sRCx6RCQhYUR2b2REemltRXppZUhhbiNIbnV0I0gnPEhyb21hSHliSW4pSmkkI0ptPUtheiBLK3NLb2pLcm9rS3UpS3luTGVkbmVMaWItTGt+TG9oYUx5bm9tTWFsdU1pfk1sI01vY00kYU15cyt0TmUvIU48I051cihQYCFQX1Bpcy1QbGEvUHJvcyBQcyFQdWRSYCVSJVJvZFJ1L2FSeXZTYCBTZWRTaWxhU2tva1NsYW4+UypkIFNwb2x1Uyl2YVN1ZC1TeXBUYWhUI25UK3NrVG9tLVQsdmFUdXBhVHZvLFUjelV0b1V6ZHJvVmFoYVZpZGxhVmxha1ZvelZyL1YkIVZ5a1Z6ZGUvWmQsdlplbS1abiEtWjxadiEyQWN8QWg8eUFrdGkjQStzQW90PkFwPC1Bc2VBdl5JbmNpcEtub09idWQgTyVudG9PZGVqT2Zlc2VPaCxPai10T11tIE9taStPbmlrIU9wYE9yb2tPc1tPdG9uT3V0LU92YXpTI3YjU3RAVWRrKFV0Vi1Wb2g8eTBBbj5Pdm9kVHJ1aDBBY3R2bzBCZXIpfURsS2F2PktsLktyK0x0TXBhTmNQQFNhU2luI1N0LlR8VHkjM1JhbWleU2tUXzo6Qy19b3REaWElRG4/RG9uRnRHYnlLZSlLJy5NQG9NcCovTmRlUmEvUiBhUycmU3RyVG8rJFphbiVaaWRdM0FnfEFrJUNlcHREYWt0PEZlckB0Rit4Sm5va0tsYW1hSzxkS3J1dEt0PFB1KSVWaXplVm1hVm9sdmVyWmVydmEzU2t8WmlrbzVCb3RpI0Rva21ASCcjSytLb2tvTWFue29QJ29kUHUvYVJlanNTb2xTdGwuVG1pJHJUb3BlZFR1bl5VYkAjVS9vVXBVLFYuVm4/WmI8Wi9vZFpkIVplem4hWmhvZCVaaW4jWmplemRaI3paXWhhWm1hclpwYFpydS9ac2FoWnRva1p1bVp2b2Q1QnJpI31gXUthdj9Lb3BpczNCYUJvbCd9bChEXVBgXVQuWig6RGkkYUghS29NPk1pemQhTW8pTiAjUmRpbiNTYW4jVF8gWltaQD8wT3IwSHwxQixuI0Nlc2VEYF1EaW1AdERdSG4hSm09S2UsSylLdW5eS3ZvamVNQG9Ob1J2aXNTYCBTaG8sU2tva1NsIVN0LFN1dlN5cCFUW1QuVGshVH5UcnYhVmVyWiZtMk9eUn4wRm9uTG4/UiNSb3QtUnVwVHVhJTFBZmFuZHJBbGlza29BbnpAQXV0RXB0aWtJY2FMYFtMQD9Mb0x1ek9bTyNuT3JvUmlwKVJ6VXAuVihWciYwQWJpI0FkaWRdQW4uQSRBdm4oRWR8RXA+RXZhRXouSWJJJkl6bj9Pbk91cC1Pdm9VL1VoYVVuJVVwI1phMEEsZ2RFKSZJbCR2b0wqdmFPZ1JgUmtSdCNVdC1Zc2wwQWRBaGFPYjBCbyl9YUQnI0tvbFAjVHZhVWJvalVjIFVkJVVobGFzVWxgVW0sa1VwLHZhVXNlZFV0b2tVdmlzezBBbCcmQXMgX0lzTGF2T2QtT2pAPk9sdU9uejxPcm4oT3UkYVIvYVUkIDFBbl5BekQlTmFOPk92biFQQFN0VWIxQW4/QXIoYUF0aSNBdltFaG5vRXojT2RvbGFPK2tPcGFPcm5vT3VwIVJhL1Jlc1JoflJvbVJ1JlVkJlVwbj9Wb2xZazBCai10QnRyb3B5fWFyRChLbm9OZCFOPVJpayFhUicuMEFoQWwkdm9FdHJBdFtBei1JcytJdC1PYm9eT2RpZF1PciNSYWIyS2F2I0tvdE4tTic+UCFQayhSJyhTX1QoOkIrdCNCdStIKm5KZW1ub0pmdW5KZ2FKIEpuKEt0aSNNaCtNcG9uTmN8Tj5Oa2VyUGUpVkAuWiFfM31uaSNIZHlLdXQuTGVmb25Nbm8pTmRAJU5pJGFOPFBdKVAmUHJ2ZVJhcGllUm1vcyNYdGlsM31vU2tvcGlzVHUrazFBZCtjQW4uMEFwI0VzayFVa290VXBhMEVsMUErKVBpbiNQb2xSem9VaGFVK2MyQWQ/QWt0PEFtcEFzYUF2ZXJ6YUVmIEUkRXo8SGF2LkhsLk8vdU9qP09zI091W1AlUCBfUGsoVWI+VS9sIFVobD9Vc1YhMkR5SH5IKE5kLFJpJGFSJmpaZW1za28wQXJvaE9yW1JkKFJ6MkdyS2V2OjBPaChPemVSIVIqcy1SdXNZdCcmMEhvVGl2KDBJdiAzUmAgMUVkbiFJJCBNPTBBeiFfTGlkbiBMb24gT3R2IFJvaiAwSSVJKU92IDBZdmBdMEF2IElmPG1hSWt+MUFkfkwhbiBMeX5PdXQhUmF2IDFBbkF6IDBFZH5JbHxNcnQgTmBuIE49T3VkIFRsIVRyfjBBaHxLIUx1bSBPfk9wQD5SKnMgMUFsIE9sbiBPeicjM0QsdiBFbEVuLkwuTiE6R29uTC9hTCpuTmFOXmxOaWwjUmFuUmhhbnlSfDFFbGt1SG9kME92YTBEcm9HZSklSiVMYmwqZEx7cmhMIF9MbW9jTHJ5W05rJ1Jhbl5SemVTXyNTa3J6ZVNuP1Nwb2R1UylUZXIuVmVyIzNCLCV9ckRlb2gsRC5EK0xhTj9Te1RhbCBhWmVaICMwRXpkMExgVXMwQWojQWtBcz5Fdm9IayhJdk4nI091cCExVWN8VWswRGFEaXYoRG96JmtEJHZvSkBza3lKJkpza29MYW50TFtMIExub1NrJyNaaWRdWicmMFJhdm8xQWI+QSV0QWhBKUJhfW8ra0ghU3R2YVR1KzBBZCBUKnAgVHVwMElwNEJhdiBCciF9fEQhRCxGb3QgSCtkIUh+SG9kIEgsZCBIdWIgSmFzbiBKe0ptPUtdcCBLb24hTC0hTWF6IU1leiBNaXp7TXlzK3ROZS8hTmlrIU51dCBQYCFQbCEgUCx2IFB1JCBSYXogUiduIVJ2IVNsJyBTb2tvUyl2IFN1flN5cCFUYXMgVGVzIVRyISBWaX5Wb2whVnJoX1pkb2IgWm4hMEFkdUJ1ZCB9b3AgRDxEdS9EeS8hRSR1cEgrZGVtS2F6THlrIU5pa09yLVAqLFRhaFQtOjo5OTNMb2Zvbjo6QnIhQnlkK3R9fERhcm1vRHVzIEYqayFIbHQgSG9kIEgsXkh5fkohPkp7SmkkIEsrcCFLKnAgTGVwIE1leiBNb3QhTXlzK3ROZS8hTmlrIVBsISBQb2ogUHMhUmF6IFMpdiBTdX5UYWogVGVtbiBUa35Vam09VmFsIFZlK3RWaW4gVm9sIVZydCFadm9uIDBBdiBSdXN1VWR8WXQtMUErI0FybWFBdG4oSXZvT2IgUm9qVmloWW1gXTBMQC5NYW5NLlB0IVpgdVpkb2xhMkF0IEx0fkx1Ym8jT3QnIFJ1WzBNYU1uPzBFbW4gMExhbSFPdW0hUiEjVW1hdiMwQXRvRWgjT1tPbU8kT3p2eWswQXB8QXJBdC1JamVJentPY24gT2RyIVJ6bC5VdHwwQWtBbChBbUAhT3Z1MEIseiBUYXYgVWItVWZhKzBMb2QgT21hbCBSYXZhUiggUnVkI1J2dTFBXkFuIENgXU4gKE5vT3YmWS9sIFphdigxSS9hUiEgMEInLkJyMEVkfkVua3VFc19hT25SIVVrJ29kWWtcIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDI1ZjQ0NTU1ZjRhZjI1YjUxYTcxMTEzNmUxYzdkNmU1MGNlOWY4OTE3ZDM5ZDZiMWYwNzZiMmJiNGQyZmFjMWFcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LWN6XV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdDeiBleHRlbmRzIHdvcmRsaXN0X293bF9qc18xLldvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ3plY2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVXNpbmcgdGhlIGNvbnN0cnVjdG9yIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSwgaW5zdGVhZCB1c2UgdGhlXG4gICAgICogIFtbd29yZGxpc3RdXSBzaW5nbGV0b24gbWV0aG9kLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImN6XCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0N6YGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdDeigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdDeiA9IExhbmdDejtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctY3ouanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGFuZ0N6Iiwid29yZGxpc3Rfb3dsX2pzXzEiLCJyZXF1aXJlIiwid29yZHMiLCJjaGVja3N1bSIsIndvcmRsaXN0IiwiV29yZGxpc3RPd2wiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-en.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangEn = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\";\nconst checksum = \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangEn extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the English language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEn]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"en\", words, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangEn``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEn();\n        }\n        return wordlist;\n    }\n}\nexports.LangEn = LangEn; //# sourceMappingURL=lang-en.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsb0JBQW9CQyxtQkFBT0EsQ0FBQyw2RkFBbUI7QUFDckQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFdBQVc7QUFDakIsSUFBSUMsV0FBVztBQUNmOzs7O0NBSUMsR0FDRCxNQUFNTCxlQUFlQyxrQkFBa0JLLFdBQVc7SUFDOUM7Ozs7Ozs7S0FPQyxHQUNEQyxhQUFjO1FBQUUsS0FBSyxDQUFDLE1BQU1KLE9BQU9DO0lBQVc7SUFDOUM7OztLQUdDLEdBQ0QsT0FBT0MsV0FBVztRQUNkLElBQUlBLFlBQVksTUFBTTtZQUNsQkEsV0FBVyxJQUFJTDtRQUNuQjtRQUNBLE9BQU9LO0lBQ1g7QUFDSjtBQUNBUCxjQUFjLEdBQUdFLFFBQ2pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLWVuLmpzPzYxZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdFbiA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBlcmxlb25hbG9yZW5zZWluY2VyZWdlc3RpY2l0U3RhbnZldGVhcmN0c3NpI2NoMkF0aGNrJnRuZUxsMEFuZCNJbC55TGVPdXRPPVN8UyViL3JhQFN1cmRVJzBDZVtDaWR8Q291bnRDdSdIaWU9SWRPdSwtUXVpKlJvW1RUXVQlVCpbVHUkMEFwdERELXREKltKdSxNLlVsdFY8KVZpKTBSb2ItMEZhaXJGJWRSYWlkMEEoRUVudFJlZTBFYWQwTVJScCV0UyFfcm1CdW1Db2hvbEVydEkmTExleUxvd01vLE99UGhhUmVhZHlTb1QgV2F5czBBPnVyQXooZ09uZ091bnRVJ2QwQWx5LENoJUNpfEcgRyFHcnlJbSRLIU5vdW4pTnUkT2AgU3cgVCZuYVRpcXVlWGlldHlZMUFydE9sb2d5UGU/UCFQcm89UmlsMUNoQ3QtRWFFbmFHdWVNTWVkTSVNeU91bmRSPCtSZSxSaT1Sb3dUVGVmYUBUaSxUdyVrMEtQZUBTYXVsdFNldFNpLFN1bWVUaG1hMEghPk9tVGF7VCZkVC51ZGVUcmFAMEN0XUQuR3UsTnRUaCVUb1R1bW4wRXJhK09jYWRvT2lkMEFrZUEqQXlFc29tZUZ1bEt3P2QwSXM6QnlDaGVsJUMjRCtHTDwpTGMjeX5NYm9vTjxhTm4gUlJlbHlSZ2EoUipsU2VTLVNrZXRUdCEzQV5BbkF1dHlDYXUnQ29tZUVmRiVlRyhIYT1IKGRMaWU9TG93THROXk5lZi4vVHJheVR0IFR3ZSZZI2QzQ3ljIURLZU5kT2xvZ3lSZFJgVHQgX3tBZGVBbWVBbmtldEEsRWFrRVtJbmRPb2RPW29tT3UnVWVVclVzaF9yZEF0RHlJbE1iTmVOdXNPa08sUmQgUihnUnJvd1NzVHRvbVVuKVhZX3tldEEoQW5kQVtBPUVhZEVlemVJe0lkK0llZklnaHRJbmdJc2tPY2NvbGlPayZPbnplT29tT2AgT3duVXNoMkJiIURkeUQrdEZmJG9JbGRMYkxrTCF0TmQhTmsgUmQmUmcgUixTUyhlW1N5VHQgWSBaejpCYmErQihCIUN0dXNHZUtlfkxtTSBhTXBOTiROKWxOZHlObiNOb2VOdmFzTnkjUGFiIVAuJFB0YShSUmIjUmRSZ29ScGV0UnJ5UnRTZVNoUyhvLyFTdSRUVCRvZ1ReVGVnJXlUdCFVZ2h0VSdVdF1WZTNJbChnTCB5TXxOc3VzTnR1cnlSZSRSdGEoX2lyQWxrQW1wXUFuK0Fvc0FwdCBBcitBJ0F0RWFwRXtFZSdFZkVycnlFLEl7JkllZklsZEltfXlPaSlPbydSIy1VeyFVbmtVcm4wRz9ObmFtI1JjIVRpeiZUeVZpbF9pbUFwQXJpZnlBd0F5RTxFcmtFdiBJe0l8SWZmSW1iSW4tSXBPe09nTydPYE91ZE93blViVW1wVSwgVXReX15BLEMjdXREZUZmZWVJbEluTCFATCVMdW1uTWIoZU1lTWYldE0tTW0jTXA8eU5jIHROZHVATmZpcm1OZypbTn1ATnNpZCBOdHJvbE52KClPa09sUHAgUHlSJFJlUm5SKkAvVHQjVV5VbnRyeVVwIVVyJ1VzKFYgWW8+X3tBZCFBZnRBbUF9QXNoQXQgQXdsQXp5RWFtRWQuRWVrRXdJe2V0SW1lSXNwSXQtT3BPW091Xk93ZFVjaSRVZWxVaSdVbWIhVW5eVXNoWVksJDJCZUx0dSpQUGJvP2RSaW91c1JyfFJ0YShSPVNoXS9vbVRlM0MhOkRNYStNcE4pTmcgUihnU2hVZ2h0IFduWTNBbEJhPkJyaXNDYWRlQ2VtYiBDaWRlQ2woZUMlYT5DKmEnRXJGJidGKGVGeUcqZUxheUxpdiBNPGRNaSdOaSROdGksTnlQP3RQJmRQb3MuUGBQdXR5Umk9U2NyaWJlUyB0U2lnblNrU3BhaXIvcm95VGFpbFRlQFZlbG9wVmkpVm8+M0FncmFtQWxBbSNkQXJ5Q2VFJ2xFdEZmIEcuJEduLnlMZW1tYU5uIE5vc2F1clJlQFJ0U2FnKmVTY292IFNlYSdTaFNtaVtTJWQgU3BsYXkvPClWIHRWaWRlViUpWnp5NUN0JUN1bXxHfkxwaChNYShOYT5Oa2V5TiVPclNlVWIhVmVfZnRBZyNBbWFBLC1Bd0VhbUVbSWZ0SWxsSW5rSXBJPU9wVW1ZMkNrTWJOZVIoZy9UXlR5MUFyZjFOYW0tOkcgRyFSbHlSblJgU2lseS9TeTFIb09sb2d5T25vbXkwR2VJdFVjYT4xRiV0MEcxR2h0VGggMkJvd0QgRUByLUVnPHRFbXxFcGg8dEV2YXQlST5TZTBCP2tCb2R5QnJhKUVyK090XVBsb3lQb3cgUHR5MEFiIUFAREQhW0QlJ0VteUVyZ3lGJSlHYStHKGVIPClKb3lMaSxPdWdoUi1oUm9sbFN1KlQgVGkqVHJ5VmVsb3BlMUlzb2RlMFUkVWlwMEFBJ09kZU9zXVIlVXB0MENhcGVTYXlTJilUYT4wRXJuJEgtczFJZCYpSWxPa2VPbD0xQUBBbXAhQ2VbQ2g8K0MuZUNsdWRlQ3UnRWN1PkVyY2knSGF1LEhpYi5JIUksSXRPdC1QPGRQZUBQaSpQbGEoUG8nUCpbVCZkVHJhMEVFYnJvdzpCci1DZUN1bHR5RGVJbnRJYH5MJ01lTWlseU1vdXNOTmN5TnRhc3lSbVNoXVRUJFRoIFRpZ3VlVWx0ViUuZTNBdHUqQnJ1P3lEICRFRWRFbE1hIU4pL2l2JFReViBXM0IgQ3RdRWxkR3UqTGVMbUx0IE4kTmROZU5nIE5pc2hSZVJtUixTYyRTaFRUfVtYX2dBbWVBc2hBdEF2JUVlSWdodElwT2F0T3tPJU93IFVpZFVzaFlfbUN1c0dJbExkfm93T2RPdFIpUmUsUit0UmtSdHV9UnVtUnc/ZFNzaWwvIFVuZFhfZ2khQW1lRXF1fEVzaEkmZEluK09nT250TyxPd25PeiZVLjJFbE5ObnlSbmEpUnlUdSo6RCt0SW5MYXh5fiB5TWVQUmErUmJhK1JkJlJsLVJtfFNTcFRlVGggVStaZTNOICROaXVzTipOdCFOdShlL3UqMk8sMEFudEZ0R2chTmcgUmFmZmVSbFZlX2RBbilBKkFbSWRlSW1wJ09iZU9vbU9yeU89T3dVZV90RGRlW0xkT2RPJ1JpbGxhU3BlbFNzaXBWIG5Xbl9iQSlBKEFudEFwZUFbQXYueUVhdEUmSWRJZWZJdE9jIHlPdXBPd1VudF9yZEVbSWRlSWx0SXQ/TjNNOkIuSXJMZk1tIE0sIE5kUHB5UmIlUmRSc2hSPSxUVmVXa1o/ZDNBZEFsYEFydEF2eUQraG9nSWdodH5vTG1ldExwTlJvM0RkJkdofk50UFJlLyV5NUJieUNrZXlMZExlTGlkYXl+b3dNZU5leU9kUGVSblJyJVInU3AuJC9UZWxVclYgNUJHZU08TWIhTSVOZCpkTmdyeU50UmQhUnJ5UnRTYjxkM0JyaWQ6MUVPbjBFYUVudGlmeUxlMk4lZTRMTGVnJEx9WzBBK0l0YT5NJidNdX1QYUBQbydQcm89UHVsJzBDaENsdWRlQ29tZUMqYSdEZXhELWE+RG8lRHUscnlGPHRGbC10RiVtSGEhSCAuSXRpJEplQEp1cnlNYT5OIE5vY3xQdXRRdWlyeVM8ZVNlQFNpZGVTcGkqLyRsVGFAVCBlLFRvVmUsVi5lVm9sPTNPbjBMPGRPbGE+U3VlMEVtMU9yeTpDa2V0R3U/Ulp6M0Fsb3VzQW5zfnlXZWw5QkluS2VVcn15WTVEK0kpTXBOZyFOaSVOay86Tmc/b28zRW5FcFRedXBZM0NrRER9eU5kTmdkb21Tc1RUXiZUZVR0JldpNEVlSWZlT3tPdzpCQmVsQiVEZCBEeUtlTXBOZ3VhK1B0b3BSK1QgVChVZ2hVbmRyeVZhV1duV3N1LlkgWnkzQWQgQWZBcm5BPUN0dSpGdEdHJEcmZElzdSpNI05kTmdgTnNPcD9kU3MjVHQgVmVsM0FyQiB0eUJyP3lDJidGZUZ0R2h0S2VNYk0uTmtPblF1aWQvVHQhVmVaP2Q1QWRBbkIsIEMkQ2tHLU5lbHlOZ09wVHQgeVVkVW4rVmVZJDVDa3lHZ2ErTWIgTj9OXlh1cnkzUi1zOkNoKGVERy1HfXRJZElsSW5KJUtlTW0kTk5hK05kYT5OZ29Oc11OdSRQIVJiIVJeUmcoUihlUmtldFJyaWErU2tTcy8gVF5UIGkkVGhUcml4VHQgWGltdW1aZTNBZG93QW5Bc3UqQXRDaDwtRCREaWFMb2R5THRNYiBNJXlOdF1OdVJjeVIrUi5ScnlTaFNzYStUJFRob2QzRGQhRG5pZ2h0TGt+XU0tTmROaW11bU4lTnU+UmFjIVJyJVMgeVNzL2FrZVhYZWRYdHUqNUJpIURlbERpZnlNTXxOLiVOa2V5TiwgTmBPblIkUmVSbihnU3F1Lm9UaCBUXVQlVW50YShVJ1ZlVmllNUNoRmYoTGVMdGlwbHlTYyFTZXVtU2hyb29tUy0vVHUkM1NlbGYvIHlUaDpJPU1lUGsoUnJvdy95VF1UdSozQXJDa0VkR2F0aT1HIUBJYCBQaGV3Uj0vVFR3JWtVdHIkViBXc1h0M0NlR2h0NUIhSSdNKGVlT2QhUm0kUmBTZVRhYiFUZVRoKGdUaSlWZWxXNUMhP01iIFInVDpLMEV5SmVATGkrU2N1KlMgPVRhKFZpb3VzMEN1ckU8VG9iIDBPcjFGRiBGaSlUJjJMMUF5MERJPVltcC0wSXQwQ2VFSSNMKGVMeTFFbkVyYUluXVBvJ1RdMUFuK0IuQ2g/ZEQgRCg/eUc8SXxJZygkUGg8MFRyLWgwSCAwVGRvJVQgVHB1dFRzaWRlMEFsRW5FcjBOTiAwWWcmMC8gME99OkN0RGQhR2VJckxhKUxtTmRhTmVsTi1OYCBQIFJhZGVSfFJrUnJvdFJ0eVNzVF5UaFRpfFRyb2xUdCBuVSdWZVltfDNBKUFudXRBckFzPHRMLTxOTiR0eU5jaWxPcCFQcCBSZmVAUm0uUnMjVDJPfU90b1JhJ1lzLSQwQW5vQ24tQ3R1KkUpR0dlI35Mb3ROa099IFBlL29sVF5aemFfKUF9dEEsLUE+QXlFYSdFZCtVe1VnVW4rMkVtRXRJbnRMP0xlTGkpTmROeU9sUHVsP1J0XVMuXVNzaWIhL1RhdG9UdCB5ViB0eVdkIFcgX0BpKUFpJ0VkLXRFZiBFcGEqRXN8RXR0eUV2fEkpSWRlSW0/eUludEklLnlJcyNJdmE+SXplT2IhbU8pW09kdSlPZi5PZ3JhbU9qZUBPbW8+T29mT3AgdHlPc3AgTz5AT3VkT3ZpZGUyQmwtRGQoZ35McEwnTXBrKE5eUGlsUHB5Ul5hJ1IueVJwbydSJ1NoVFp6ITNSYW1pZDo5OUFsLnlBbnR1bUFydCBFLF1Je0l0SXpPPjpCYi5DY28jQ2VDa0Q/RGlvSWxJbkknfnlNcE5eTmRvbU4rUGlkUmVUZVRoIFYmV1olM0FkeUFsQXMjQmVsQnVpbGRDJGxDZWk9Q2lwZUMlZEN5YyFEdSlGIUBGJW1GdSdHXUcqdEd1bD9KZUBMYXhMZWEnTGllZkx5TWEoTWVtYiBNKGRNbz1OZCBOZXdOdE9wJlBhaXJQZWF0UGxhKVAldFF1aSpTY3VlU2VtYiFTaSxTb3VyKVNwIydTdWx0VGkqVCphdFR1cm5Vbl1WZSRWaWV3Vz9kMllgbTBCQmIjQ2VDaERlRCtGIUdodEdpZE5nT3RQcCFTa1R1JFYkViA1QWRBLEJvdEJ1LENrZXRNPClPZk9raWVPbVNlVGE+VWdoVW5kVT5ZJDVCYiBEZUdMZU5Od2F5UiQ6RERkIUR9W0ZlSWxMYWRMbSNMI0x0THU+TWVNcCFOZFRpc2Z5VG9zaGlVKVVzYStWZVkxQSFBbkEqQXR0IEV9SGVtZUhvb2xJJilJWyVzT3JwXU91dFJhcFJlJlJpcHRSdWIxQUFyXkFzI0F0QyNkQyp0Q3RdQ3VyLnlFZEVrR218TGVAfk0oP05pJU4nTnQmKVJpZXNSdmkpU3NdVHQhVHVwViZfZG93QWZ0QWxsb3dBKkVkRWxsRXJpZmZJZWxkSWZ0SX1JcEl2IE97T2VPb3RPcE9ydE91bGQgTz1SaW1wUnVnVWZmIVkwQmwoZ0NrRGVFK0dodEduTHxMa355THYgTWlsP01wIU4pTmdSJi8gVHVhPlhaZTFBPkV0XklJbGxJbklydFVsbDBBYkFtRWVwRW5kIEkpSWRlSWdodEltT2c8T3RPd1VzaDBBbGxBcnRJIU9rZU9vYDBBe0FrZUFwSWZmT3cwQXBDYyBDaSRDa0RhRnRMP0xkaSBMaWRMdXRdTD1NZSNlTmdPblJyeVJ0VWxVbmRVcFVyKVVgMEEpQSpBdGkkQXduRWFrRWNpJEVlZEVsbEVuZEggZUkpSWQgSWtlSW5Jci5MLk9pbE9ucyVPI09ydE90UmF5UmVhZFIoZ1kwVWEqVWVlemVVaXIqbF9iIUFkaXVtQWZmQStBaXJzQW1wQW5kQXJ0QT5BeUVha0VlbEVtRXBFKm9Je0lsbEluZ097T21hXk99T29sT3J5Tz1SYT5neVJlZXRSaWtlUiNnUnVnZyFVZHxVZmZVbWIhWSEwQmplQEJtLkJ3YXlDKVtDaERkJkZmIEc/RyssSXRNbSBOTm55Tid0UCBQcGx5UCptZVJlUmZhKVIrUnByaSdScm91bmRSPXlTcGVAL2EoMUFsbG93QW1wQXBBcm1FP0VldElmdEltSW5nSXReT3JkMU1ib2xNcHRvbVJ1cC9lbTpCIUNrIUdJbEx8TGtOa1BlUit0U2svZVR0b29YaTNBXkFtfk5OPHRObmlzTnRSbS9YdF9ua0F0RW1lRW5FJXlFKkV5SW5nSXNPdWdodFJlZVJpPVJvd1VtYlVuZCAwQ2tldERlRyBMdE1iIE1lTnlQUmVkU3N1ZVQhNUEsQmFjY29EYXlEZGwgRUdlYCBJIXRLJk1hdG9NJXJvd05lTmd1ZU5pZ2h0T2xPYFBQLVBwIVJeUm5hZG9SdG9pJ1NzVCRVcmksVz9kVyBXbllfe0FkZUFmZi1BZy1BKEFuc2YgQXBBc2hBPWxBeUVhdEVlRW5kSSRJYmVJe0lnZyBJbUlwT3BoeU91YiFVe1VlVWx5VW1wZXRVLFVgWTJCZUl0XU1iIU5hTn1sUmtleVJuUnQhMUVsPUVudHlJKUluSSxPMVBlUC0kOjVMeTVCKmxsYTBBYiFBd2EqQyFDb3YgRCBEb0ZhaXJGb2xkSGFwcHlJZiVtSXF1ZUl0SXYgJ0tub3duTG97VGlsVXN1JFZlaWwxRGE+R3JhZGVIb2xkT25QIFNldDFCPEdlMEErRUVkRWZ1bEUhW1UkMElsLnk6Qzx0Q3V1bUd1ZUxpZEwheUw9Tk5pc2hQJVJpb3VzL1VsdDNILSFMPXROZCVOdHUqTnVlUmJSaWZ5UnNdUnlTJ2xUIDwzQWIhQnI8dENpb3VzQ3QleURlb0V3fmErTnRhK09sKFJ0dSRSdXNTYVMuU3UkVCRWaWQ1QyRJKUlkTGM8b0x1bWVUZVlhKzpHZUcjSXRMa35MbnV0TnRSZmEqUm1ScmklU2hTcC9lVCBWZVkzQWxgQXAjQXJBJ2xBYCBCRGQoZ0VrJmRJcmRMY29tZS9UXyFBdEVhdEVlbEVuRSpJcElzcCAwRGVEYEZlTGR+Tk5kb3dOZU5nTmtObiBOdCBSZVNkb21TZVNoVH1bNUxmTTxOZCBPZE9sUmRSa1JsZFJyeVJgX3BFe0UsIUksST5Pbmc6OlJkM0Fyfm93OVVVbmdVYDozQnJhUm85TmVPXCI7XG5jb25zdCBjaGVja3N1bSA9IFwiMHgzYzhhY2MxZTdiMDhkOGU3NmY5ZmRhMDE1ZWY0OGRjOGM3MTBhNzNjYjdlMGY3N2IyYzE4YTliNWE3YWRkZTYwXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuLyoqXG4gKiAgVGhlIFtbbGluay1iaXAzOS1lbl1dIGZvciBbbW5lbW9uaWMgcGhyYXNlc10obGluay1iaXAtMzkpLlxuICpcbiAqICBAX2RvY2xvYzogYXBpL3dvcmRsaXN0c1xuICovXG5jbGFzcyBMYW5nRW4gZXh0ZW5kcyB3b3JkbGlzdF9vd2xfanNfMS5Xb3JkbGlzdE93bCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nRW5dXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJlblwiLCB3b3JkcywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFbmBgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nRW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nRW4gPSBMYW5nRW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVuLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxhbmdFbiIsIndvcmRsaXN0X293bF9qc18xIiwicmVxdWlyZSIsIndvcmRzIiwiY2hlY2tzdW0iLCJ3b3JkbGlzdCIsIldvcmRsaXN0T3dsIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangEs = void 0;\nconst wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nconst words = \"0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&\";\nconst accents = \"aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M\";\nconst checksum = \"0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-es]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangEs extends wordlist_owla_js_1.WordlistOwlA {\n    /**\n     *  Creates a new instance of the Spanish language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langEs]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"es\", words, accents, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangEs``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangEs();\n        }\n        return wordlist;\n    }\n}\nexports.LangEs = LangEs; //# sourceMappingURL=lang-es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcscUJBQXFCQyxtQkFBT0EsQ0FBQywrRkFBb0I7QUFDdkQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsV0FBVztBQUNqQixJQUFJQyxXQUFXO0FBQ2Y7Ozs7Q0FJQyxHQUNELE1BQU1OLGVBQWVDLG1CQUFtQk0sWUFBWTtJQUNoRDs7Ozs7OztLQU9DLEdBQ0RDLGFBQWM7UUFBRSxLQUFLLENBQUMsTUFBTUwsT0FBT0MsU0FBU0M7SUFBVztJQUN2RDs7O0tBR0MsR0FDRCxPQUFPQyxXQUFXO1FBQ2QsSUFBSUEsWUFBWSxNQUFNO1lBQ2xCQSxXQUFXLElBQUlOO1FBQ25CO1FBQ0EsT0FBT007SUFDWDtBQUNKO0FBQ0FSLGNBQWMsR0FBR0UsUUFDakIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctZXMuanM/NjU1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0VzID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsYV9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsYS5qc1wiKTtcbmNvbnN0IHdvcmRzID0gXCIwYXJlcnRvaW90YWRvbm9hUnRlaXJyb2VuYU5vbmFMc29sb2NvaWxpYXJhbGFvcnJlbmFkYUNob04kbjBBPkRvbSxFamFJISNPZ2EmTydPciNSYXpvUipVZT1VPDBBYiBBZGVtQENlPEN+RWkpRWxnYUVuI0VwdCBJJkwgIE5lT2chTzxUaXZvVG9Ucml6VHUgVWQqVSEmVXMgMEljI01pdCpPcHQgT3InVWFgVWwjMFJlbzBFY3QgSWN+SW4gSXJtIDBJbEl0IE9uQE9zI090IFJlZyBSJFVhVSZVP2FVamEwT2dvT3IrMFJlU2wgMEVkX3pFJ1VzKTFBY1tuQW1iX0FybWFCYUJ1bUNhbGRlRGVhRWdfRWogRXIlRSVGPyFHYUdvJm5JYSZJLCNJdiRNYU1lamFNaWIgVCBUZXphVGl2b1RvVHVbVW0nWiAwQWJsZUFuKUFwb11BcmdvQXMgQiBCaSNFJ0lnb0lzJWRPclAgb1BsJDB8b0NAJ0NdRCBELEVtQEd1PUlsPUltb0lzT3QgVCxhVGlndW9Ub2pvVWFsVWwgVW5jJEFkKkVqb08xQWcgQVsjRXRpI0lvTGljIE8mT3IpT3lvUixkIVJvYiBVZXMlVSsxQSZBYEFyQml0K0JvbEJ1cyN8aXZvQ29EIUQ/XUR1b0VhSSZJZXNNLmktZXNPbWFQYVAuUmVnPVJvelJ1Z2FUZVRpcyUwQUEmQWwjQyw8RWd1ciBFb0U8ckksI0k9SXN0Kk5vT21iK1Ahb1Q/XVQrVHUjVW0qVW4jMEFqb0FxdWVBckVuI0VvST5MZSVPbW9SYSFSb3pVbjBEYXpEJEdlTGFNLCNTLClUXjBBbEFuY2VBK0VFbF1gRWBFc3RydXpJLkk8MkVyVXtVJzBBZltuQXJPKVVjIFVmX1VsOkJhQl58ZUhASWxlSiBMYW56L2MuTGRlTWJ1Tj5OZC1vUmIoPlJuaXpSK1NjdV1TI25TdVtUYWxdVCFAVCpUdSVVbFogM0JlQmlkLz1TIFNvU3RAM3xvRW5OZ28yQW4+T3F1ZVVzYTJBQmlgQm9DYUNpYERhRGVnYUluLy8hb0xzYU1iLXtkTmkjTn1zYWlSZGVSciBTcXVlVGVUaW5WZXtaYWwyQXZvQXpvRWNoYUV2ZUlsPUluPklzYU9jYU9tYU9uY2VPKVVqYVVzPlUjMkNlb0NsZUUnRXlGYW57Ri5Ib0l0X0wjUmJ1aihsKCtTYyBUYWNhWi46QmFsPUJlemFCaWBCW0Nhb0RhdiFELGFFckZlSXtJbWFuSmFKLkxMYW0gTGMkTCZMaXtkTGxlTG0vXkx2b01hTWIkTWVsPU1pJ01wfWMhTmQ/TmVsLWd1K05pYy0jTi0uT2JhT3NQYXpQaSVuUG8pUHQgUHVjaCgoYi5SY2VsUmUlUmcoaSdSbmVScGUlUitSJVNhUz5TIW9TcGFTI3JUXmNlVF9Ve2xVc2FabzNCb2xdRCFEK0xkL2ViX0xvPEx1XU0sI05pei10K1JjKCZSZXoob1JyIFIpemFTcGVkVCsyQWNhbEFsZT5BbXB1QW5jXUFwYUFyXUk+SXMpSXZvT3F1ZU96YVVsZSVVcCAwQ2wuRWdvRT1FbkVyI0ZbRyArTS0+TmVOJVBfc1I+UnVlXVNuZVRhVXtkMkFtXkFuQStBc2VBdmVJLClJbWFJbmljYTJCX0NjfnxpJ0NpYENvRGlnb0RvRl9HIUhlKUppbkpvTC9jaC9lZyRMZyBMaW4vbCBMbW9MdW1gTWJhKU0hTWl7TW8mTXByLWRlTmVqfWctb2MhTnNlan10IFBhUGkoYXouUmJhJVJjaG9SJm5SLihyIVMhU21vc1MlMkFuZW9BdCFFIEVjIUVpJkVtYUlhSW0sSXAlSXNpc09tb09uaWNhT3F1ZSVVJlV6MkFkK0FyI0F0K0JvQnIqfCBhRWw9RW4jRXJ7RXMlRXZhSWQgTGVici9wLyNNYl9NcGwqTi1lJU8lUC5QdWwoIFIkPFI8UnZhVGlzOk0teihSJlQ/M0IhQj9DYXtDKkRvRixzYUZpbipKIExmaW5MZ2EmTGkjTV4tPE4lbFBeKVJlY2hvUislU2F5dSdTZW9TZj9lU251JlN0aSdTdiRUYWxsZVQsIVV7M0FBYj1BZGVtYUFtYW4pQWBBciRCdWpvQ3QgRW4pRSVFekZpYz9HJ0xlbS91Kk4hb1JlYyNSaWcqUz5TZSdTZlt6VmFWaSc1QmxlQ2VMXk1pbmd9TiBSYSZSbSpSPFNTaXMyQWcuT2dhMnxhRGFFPUUnTGNlT1F1ZVIgUmV6KG86MEEnUiQwSCBPVWEmcjBBZEljfklmaWMkSSNyVWMgMUVjI0ljYXozRUVtcD0xRWZhbilFZypFbSwjRXYgSXBzZUkpSXgqT2ckVWQqMEJ1Jkl0Kk9jflBhKVBlJ1BsZW9QX3NhMEEnQyBnb3x1ZmVDQEVtaWdvRStGYSZGIW1vR2EnSWdtL2FjZU9ybWVSZSZTYXlvUywgVCFvVHIgVmFzZVYkMU9jYTBVaXBvMEl6bzBDYV1DLGFDb2wgQ3JpYipDdSZFbmNARiFhRnUhem9QYXtQZWpvUEBQb3NhUHVtYVF1aVQgVGVUaT1UdWZhMEFwYUVyJ0ljLUAxQWQqQWx1IEVuI0l0IDFBYyNBbSxDZTxDdXNhRW4jSWcqSWwkSXN0KkkjUCEjUGxpYyBQLiFUX21vOkJyaWNhQnVdfGF7Qz9DI3JFYEovZC89TDxMdCBNYU0/QE1vPFJhLlJtYWNpKG9sUnNhU2VUaWdhVWBWXlgzQnIhb3wvaXpPUmkob3pSdD9Sdl5TdGluM0FibGVBbnphQXJCW0NjfnxhRGVvRWJfRWxFW0VzJUd1W0ogSm9ML2UpTEBsTHQrTk5jLWcqTmkjUm1hMkE+QXUlRWNoYU9yTyVVKlVqb1VeMkJAQ2FHYSVHLkwkTGxlI04mUm0oK1J0dW4oeiBTYVRvMkFjYTxBZz9BbmphQXNlQXVkZUUqRSdFc2FJb0kjVSUyRWdvRW4pRXJ6YUdhTSBOY35OZChnLlJAUz9UYm9sVHUrOkNlXUZhc0klSm9MLyFpLz1NYi0gTmNofWctPFJhamVSemFTb2xpYFN0IFRvVj9hbjNNZT1NKk5OIX0kTilSYW4kUiwpUm0sUyMzR2FuKU1gcyRSIFJvMkFjaSBPYm9PckAyTExmb0xvPExwZU0oJlI/KFtUYVRlb1ogMkF7QWZpPkEnQXNhQXRpc0F2ZUllJUlsPUlwZUlzSSNPPHJVYVVlPFVtb1VwbzJBbilBcG9BcmRARXJbSWFJJ0kuSTxJdCBbU2EnU3QgOkIhQj9CbCBDIXxhRC9sIE1hYyhpYFpaYWAzQj9dQlt8b0xhJkwkTWJyKCpSbWEnUm9lUnYqM0U9RXIrR2EmR2ksZUpvTSdTI3JANUNpPkcgR3UhYUphTWJfTmd9Xk5yKChtaWcoJ1N0P1lvNUU+RWxnYUVyJUU8RXZvSXtJck1hJ01lJk0/ZGVNfWQqUmFjYW5SIzoxTycwRWFsSW9tYU89Mkxlc2kvdVVhbDRFZ2FsVXN+MEFnLEFuSXQgUCBQISRQLiFQdWw8MENhcGF6RGljZUVyKUZpZWxGXm1lRywkSWMkTSw8TXVuZU5hI1NlYyNTJW4pVCFlc1RpbW9UdSpVdD9WaSEnM0FJc09uQDBML28pOkJhbGlCLk0uUmFiZVJkaW5SW1VdWm1pbjNGZVJpbmdhM05lKTVSYGQob2JhVixZYTVFcmdhRXZlc0V6R2EmckdvR3VlKUljJE4+TmdsLSROdCBQaXQhUiBTI1YsP1pnIDo3TG81QV06QiRDJENbRG9EK25HICNHcmltYUd1YEk+TSFNaWBNcCAtLWNoLWdvcyVOemFQaXpSZ29SdmFTdGltYVRhVGV4VCpVX2xWIFpvM0FsQ2N+fGVDI3JFckd+R3VtYl9KYSdOZ3UtI05hT25PcCAmU35UYWxUW1ZlWSx7M0IhJWRCK0NeRCFEaSBFbnpvR2FHIW9NYU1pKU0uTXAkTmNlTiZOZS1nbylOfXQhYFF1aSZTb1MlVCFhVCRUKzJBZ2FBbWFBbiNBdmVFZyBFbiBFdiBPciBPdiFVdkAyQm9DfkNvQ3VbR2ljYUcrTWJyaXpNfWphVGU1fGFDKkcgSn0tZXNQYVN0K1RvWjpDZSV8b0QhYURfRHUrRXN0K0ZAR0BHb0l6THtkTGUlTGwvb01hTWJvTXV0Tj5OJk5laiBOZy1pcXVpTmogTn08TiVOYWBQYVF1aW4oUj5SZShmP1JnLFJpJlJtb2xSK25SKXNSem9TYVNjIGFTaXZvVCBUIUBUaXpUcml6WGltb1leWl5jYTN8YURhbF1EJER1XUo/XUpeTCwvLk1eaS1eTnNhamVOKU51UmNhJlIsZ3VlUmkjU1MuVGFUIVRvJlQrWmNdM0UmRWxFbWIrRy9MYWcrTGl0IExsLk19LSF9aW19dSNPcGVSIFNhUyFAUz9TbW9UYWRUbzV8P2FDfkRhRGU9SG9KIExkZUwhTGknTSwjTWktIGMtZWQtai0jTm9SYWQoZCFSZSdSKlIrUnMoJWxTY2FTdHIgVGl2b1YhVj9abzV8b0QgRWJsZUVdRXIpRXN0W0dfSiFML2UlTCVOJk5lYyhhbFJvU2N1PVNlb1Nnb1NpY2FTPTpDIEN+RCBJcGVSYW5qKGl6UnIgU2FsVGFsVGl2b1R1W2xVc2VhVmFsVmVWaXtkM0MkQ3QgRyBHb2MkRytPblJ2JFRvVXQrViBWIWEzfG9Eb0ViXUUjTmV6Tm9UaSZWZWw1QmxlemF8ZU1pbihpKG0oKVRhVGljQFZhI1ZlXVYkNUJlQ2FDbGVvRD89RG9FW0V2ZUV6TG9NIW9UckA6U2lzMEU8SXNwb0plI1IoIW9TIXYgVCwhViQwQUE8RWEnSCwlSG9Jb1JlVGF2b1R1Yl9VbCNVcCBVcnIqMEkgSW9Jc2VhMFMpMEVuc2FFciVJYyRSZWMhMFJvMURvUjBPMUFFYXtGYSNJdm9MYU1vT3JWaSYwQmxpZ28wRGFaYTFBPkN+RVtJbiBPbiFUIFRpY2FVZXMjMUFjfkEmckFsQmklQ2FELEVqYUdhJ0dAR3VsPUksKUlnLElsXU9RdWVzJVVnYTBBZEBDdStFeidPVFswTydSbzFFamFVPTFJJklnZScwRW4pME8nOkMjRF9FbF1HaWBHb0lzSiBvTGFici8+TGUlTGkmTG0vb20vcCBOTmFsTmk+TnQhLXVlPVBhUGVsUD9dUXVlKVIgUmNlbChlZFIqUm9ScGEmUnF1ZVJbZm9SKVMgU2VvU35Tb1MlVGFUJFRyQFVzYVUlVm9ZYTwzQSNuQ2EmQyFhfG9EYWxEKkcgSW5lTCBMeydMZS9pZytMbGVqb0xvTHVjLS1zIE4uT25PclBpJ1F1ZSdSKGNoKGQhUmV6KGY/Umk+UmwobWk8UitScy5hU2FTY2FTaW1vUyVgVGE9VCtsZW9aWnVgM0MgfC5FRWRbRXJgRXphSmFtLyBMbyNNaSwlTn0jck56LWFPam9QKGElUyBTY2lgU29TJVQuWmNhMkFjYUFuQSVBeWFBemFFaSNFJ09tb1VtYVVbbDJCX0NvRCFEJEVtYUVzQEUlTCxMaWNpLz1Mdm9NYXtNZT1Nb01wLSFSY35SJWxTYXtTZSFTaWJsZVMpVCxjQFQrWm8yQSZFPnpFZ3VuJUVtJEVuc2FFPEV2JEltb0luY2lwZUlzfkl2IE9hT2IgT2NlPE9kdWMjT2V6YU9mZTxyT2dbbWFPbGVPbWVzYU9uI09wJE94aW1vVWViYTJCbGk+fCFvRF5FYj1FciVFcyNMZy8qTG0uTHBvTDxNLSNOYWxOb1BhUD8oZTo5OUVkIEVqYUVtIEVyIUU8SWUjSW1pY2FJbmNlSXQgOkJhJ0JAQm9DfkRpY2FsSXpNYU1wLWNofWdvUGF6UGkmUCNTZ29TcGFUb1lvWmFaLjNBY2N+QWxpe2RCYSdCbylDYSFDZSV8YXpvQ29nIUNfb0MjQ3VyPERELiZEdWMqRmxlam9GXm1hRltuRnVnJEdhPUcqR11HXzxILEknSXJKL2EjTGV2b0xpZXZlTGxlJ0xvak0gTWVkJE19PnJOZCpOJVAgI1BldCpQbzxQdD9TU2NhKVNpYFNwZSNTI1N1bSxUKm9UXidUWyNVbipWZXNWaXMlWVogM0NvRWdvRW57RXNnb0ZhR2kmR15OYy5OLk9RdWV6YVNhVG1vVG9abzVCbGVDZUNpIEQgRGVvRD9dRXJKaXpvSm9NIW9NcCFOTj5Oe1BhUCFvU2FTY2FTdCtUIDVCaUJeRG9Fe0cqSSZJbi9lJUxvTWJvTV5QdHVbVGFUaWA6QmEmQiFCJEJsZUMgR2F6R1smTC8mTCFvTCpMbS5MLkxzLyNMdWRMdiBNYi1jfk5kaS1lIE5nX05pe2ROfSNQb1F1ZVJkaW4oKW5TdF9UYW5VYFhvZi4zQ2N+Q29DXyNDJURHdSpJc0w9THZhTWFgTT9sLWQtPHJOYWxOXlAgIFBAUXVpKFJpZVJtLlJ2KlMsJVN+VGFULCVWIW9Yb1gjM0RbRXMlRSlHPUcnTGFiL2IgTCxjJExdTWJvPU0kUixhUyltYVQkVHUgNUJfQyREJExMYXAveyZMZXtkTGkmTHQgTHVjfk1ici1kZX1pJk5vK05yaXNhUGFQbCBQXilSJlJwX3MoKW9TKW5UYSc1QXZlQipDZTxEXkVnW0U9RSdFcilGcipKZSNMJW5NIFAhIFBsKlAuIVBfbW9SUj5SZSdSZypTI1Q/OkJhPkJpcXVlQl1CdUNvQyNKb0wgTD5MLCNMbC8uTWEnTWJeTmd9cXVlUGFQZSlQQFAuUXU/bChkZVJlKGlmKGplJVJvdFIrUiVUdWFqZVUrWmFaLjNBdCt8b0NdQ25pY2FKYSZKIUppJkwvZWZvJ01hTV5NcD1OYXpOZCFOIU5pc048T3JpKGFwaSg+Um1pJ1JudXIoK3JTaXNTbytTdGlnb1QhYVgjWjNCJEJ1K25FbXBvRW57RXJbRTxHX0ohL2RlTWJfTWkmTX0lT1BpPlBvUiguVGFuVCFlVHU9WmE1QWxdQj89QyBDaSdEb0cvJk0gTn0jUCBQZVF1ZVJheFIhb1JtLCVSbmVvUm9ScGUmUl9SPFJ0dWdhU1M+UyFYaT4yQWJham9BYyNyQSFBZmk+QWdvQWplQW1vQW5jZUEjQXVtYUF6IEVib2xFZ3VhRWluJUVuRXAgRXNJYnVJZ29JcGFJcylJdW5mb09mZW9PbXBhT24+T3BhTylPem9VPlVlJ1VmYTJCIUBCb0VyI01iYU1eTmVsTmljKGJpbihpc21vUidUXjowSWMgOUMhYTBCW2wwSXtkSXJJdiE8T1QgQTNCYSdCZUcsKU5hMEFyVSAkMElsT3BAMUE6Q2FDJEN1YEcgR29JYEo/bC9lTGkmTGxlTF5MdnVdTXAqb1IoaSBSLlNvM0NpJ0MjckhpY3U9SW4pSmV6TC8hb0xvek4tYyFOZC1lJ05nIE4qTiVOdXNSUmEnUmJvUmRlUmVkKGooPFJ0ITNBQWplQnIgQyRDdGltYURhRGVvRHIkRWpvRXJuZXNHXkxMbC1hZ19OfWUmT2xpblJhbFJnb1J0dWRTXlNwIWFTJVRhbWlgVSZWYXpWIW9WKlZvNUxjYW5MdW0sTHYhUmF6VCBUb1o1RT1MZyA6OjpDIVRlM0d1YU0oJ1NvOURvR2FHdXI6Rip9amFQYSNSemE5M04oKzVNb1ImXCI7XG5jb25zdCBhY2NlbnRzID0gXCJhZWlvdTc2OTVAQEJaV1dhdndVSmtPQFktS24pKVlFR3EjRUBPKWNJQCNaa01IdiRlKikpTSEhKUQqKiRHVyFvS20qQWNvaF5rJkl0LXBpXlNZVykkXm4hRyliTyFXa3phbShqUyNYKU9nKl5sXlJXIWJRI1F5Z0JLWGZ6RSkpaHRpIVFtKUNuZyUlYyltSmlJKkhKV2JtWW5pQ0x3TmRZeVklV0tPXmJuVCRQdUdPciFJdkh1JkcoR0tidEJ1aGlXJiFlT0BYTWVvWVFlQ2EjIU1yVEpDcSFPVyZDSEcoV0NjVyUlKSRyZnJJZWd1JCl3IUcpSkdtV1d3KU1uRCVTWFhXSVReTFdBWnVWV0JeVyllVExeeCYkV0dIVyhuS1dFTUEpIyRGJHgkV2Fla3FzLG43NzE1KVcqSE0tJFdBY0NpdShhKSlWQ1opR0clKCpDV1dkVyUkRCFVQ08kTVwiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4Zjc0ZmI3MDkyYWVhY2RmYmY4OTU5NTU3ZGUyMjA5OGRhNTEyMjA3ZmI5ZjEwOWNiNTI2OTk0OTM4Y2Y0MDMwMFwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZXNdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0VzIGV4dGVuZHMgd29yZGxpc3Rfb3dsYV9qc18xLldvcmRsaXN0T3dsQSB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNwYW5pc2ggbGFuZ3VhZ2UgV29yZGxpc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBzaG91bGQgYmUgdW5uZWNlc3NhcnkgbW9zdCBvZiB0aGUgdGltZSBhcyB0aGUgZXhwb3J0ZWRcbiAgICAgKiAgW1tsYW5nRXNdXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoXCJlc1wiLCB3b3JkcywgYWNjZW50cywgY2hlY2tzdW0pOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdFc2BgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nRXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nRXMgPSBMYW5nRXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxhbmdFcyIsIndvcmRsaXN0X293bGFfanNfMSIsInJlcXVpcmUiLCJ3b3JkcyIsImFjY2VudHMiLCJjaGVja3N1bSIsIndvcmRsaXN0IiwiV29yZGxpc3RPd2xBIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangFr = void 0;\nconst wordlist_owla_js_1 = __webpack_require__(/*! ./wordlist-owla.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\");\nconst words = \"0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+\";\nconst accents = \"e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS\";\nconst checksum = \"0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-fr]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangFr extends wordlist_owla_js_1.WordlistOwlA {\n    /**\n     *  Creates a new instance of the French language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langFr]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"fr\", words, accents, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangFr``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangFr();\n        }\n        return wordlist;\n    }\n}\nexports.LangFr = LangFr; //# sourceMappingURL=lang-fr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1mci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcscUJBQXFCQyxtQkFBT0EsQ0FBQywrRkFBb0I7QUFDdkQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsV0FBVztBQUNqQixJQUFJQyxXQUFXO0FBQ2Y7Ozs7Q0FJQyxHQUNELE1BQU1OLGVBQWVDLG1CQUFtQk0sWUFBWTtJQUNoRDs7Ozs7OztLQU9DLEdBQ0RDLGFBQWM7UUFBRSxLQUFLLENBQUMsTUFBTUwsT0FBT0MsU0FBU0M7SUFBVztJQUN2RDs7O0tBR0MsR0FDRCxPQUFPQyxXQUFXO1FBQ2QsSUFBSUEsWUFBWSxNQUFNO1lBQ2xCQSxXQUFXLElBQUlOO1FBQ25CO1FBQ0EsT0FBT007SUFDWDtBQUNKO0FBQ0FSLGNBQWMsR0FBR0UsUUFDakIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL2xhbmctZnIuanM/NjIwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGFuZ0ZyID0gdm9pZCAwO1xuY29uc3Qgd29yZGxpc3Rfb3dsYV9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsYS5qc1wiKTtcbmNvbnN0IHdvcmRzID0gXCIwZXJyZWxlb250aXRldXJpbnVlaXJpZXQgY2VnZWFuc2VhbGkgbWVkZW5lbCBxKWVuaWx1eGF1cyBjaDBBaXN9QW5kJERpcXUgRWAjT2wqT3JkIE91JXJPeSBSYXNpZlJldXYgUmksUm9nIFJ1cHRTXy1Tb2x1UydAVXNpZllzcz0wQUBtK0Fqb3VBcituQ2FiXUNlcCxDbGFtIENvbGFAQ3JvfmVDdX1FcmJlSGF0SGUsSWR1XUkgT21wJlF1ICpSJHk/VGUnVGlmVClsMEVwJkVxdWF0SGVzaWZKZWMlZkp1ZyBNZXR0IU0qIE9wLE9yIE91YypSZXM8Um9pdFVsJlYgYmUwUiBSJGVmMEZhaSFGZWMsRml+ZUYhe0Z1Yl0wQWMgRW5jIEkjSSxSYWYgUmVhYiNSdT8xRCBHdWAjTD5NYWIjUy8tME91LFVzLDFBcm0gQ2hpbStFciZHZWIhRylJXyBJP250TGVnIExpYS5Mb3UgTHVtIE8nZCpQYWdhVGVzPFZlbyMwQSYnQmlndUIhRW5hZyBFcnR1P0lkJElyPU9yYyBPJ092aWIjUGhpYitQIydVcy90MEFseTxBcGhvIUFyfitBdG9tK0MrbkUvJXJHI0dvaXM8R3Uje0ltPU5leCBOJC1OKWxPZChPbT0rT255P09ybT1UX1tUaWRvJlgrezFBaX1FcmklZkwvKk9sb2crUGEhYFBlXVBvcixQdXkgMFVhcml1bVVlZHVjMEJpdCFCdXMmRGUnRG9pPEdfdExlcXUoTWF0dSFNZT9udE1vaSFNdSFQXyxSYX4gUml2IFJvfVNfaWNUICtsVGljIzBQZWN0UGg9JlAqIFN8dFMgdipTK3QmU29jPlMnIFRpY290VCFUdS0wRWw+Tz9SaXVtUm8tVGFeVF8lZlQqIFRyYXAgMEJhKGVCIC5EYS1EaWIjRycgUm8hVG9tW1RydX5lMEFdQW5jIEFyaS1FbipFcjxFdWcjSWEmJ0lASSRJfU8oZU91IFJgMUk9SW8/OkQuRm91IEdhLkcpdCZJZ25hQEwvYyBMYyRMZShlTGlzYS5NYihOY2FpIU5kYS5ObCspTm4+ZU5xdT5SYj5SYFIkUl5ScmEuU3MoUyUkVGFgI1RlfFQsK1Vkcj5WYXJkIDNMZXQmTD5MbyZOZWZpLVItfFJnIFJsKGVSbXVkYVNhLVNvZ1tUYWBVciEzQiAkQ3ljI0R1I0pvdUwvTChnKUxsYXJkTmFpIU9sb2crT3BzK090eXBlU2N1aXRTJFN0bydpVHU/WmFyITJBZmFyZEFnKUFufipFc3MvdEluZCBPbmRPcXUgT3VzJDJCYXJkQihlSSFJfUxpQE5iJE5kKk5oZSdOaWY+TnVzUmR1IVJbVCZVYyNVZXtVZytVbCRVcXUoVXI8VXNzbyNVJV5YZScyQW5+ZUFzPkF2ZUViaXNFfmVFdXZhLkljb11JZ2FASWxsL3RJb35lSV5PfnUhT2QgT256IE91czxPeWUnVT9Vc15VdD1VeS90MkZmI0lzcyRMIyVuUmV8UihTJSBUKCBUbypWYWIjVmV0JjpCLyRCKGVDaGV0JkRlfEQhRmUoZUlsbG91SXNzJExjdV1MZXAoTGliIUxtIExvbW4rTHZhaSFNYXJhQE0gYU1pJE1wYWdbTj1OZXQkTiROJVtOdWxhclBhYiNQb3I9UHJpLVBzdSNQLFB1fmVSYWIoZVJiJGVSZXN9Umlib3VSbmEuUm90JlIhfFJ0JFNjYUBTPlNeU3N1IVV9VSUkVj0+ViBbVmlhcjNEYCNJbnR1IUxlcyZMbHUjTmRyPk5zJyBOdHI9UmMjUmVicj1SaTxSbiBSdmV8U30yQWdyKEFpPEEjJ0FtYiFBbi1BcGl0IUFyYiRBczwnQXQkQXVzcyRBdiogRW1pPEVuYCNFcXU+RXJ+IEV2PUlfSWZmIUlnbiRJbSBlSW90TG9ydSFPY29sYXRPaXMqTzxPKXQmUm8/VSYwR2EhR29nW01fLE5lbWFOdHIgUmN1XVIgUl5UIFtUb3lfVHIkVmAyQSokQT8nQXF1IEFzPEF2PklfdElnbiBJbWF0SXZhLk9+ZU9uYS5PcG9yJjJCPXRCcmFDYXM8Q28lIEQgRGlmPkZmIUduIEhlc2kkSWZmIEluYyBMIGVMaWJyaUxsKGVMbWEsTCRlbE1iYXRNZWQrTW0vQE1wYWN0TmMgdE5kdWkhTmY+Ti5dTm5vLE5zJFtOdGFjdE52ZXhlUGEoUCtSYWBSYmV8UmRhLlJuaX5lUnB1c1IhY3RSJi5TbWleU3R1P1QkVUBVcHUhVXJhLlUmfFV2cipZbyYyQWJlQSgmQXZhJkF5JEVhdHUhRWRpLEU/e0V1fUV2ZXQmSWJdSSBJc3Q9SSxlT2khT3F1IE90YSNVY2k9VWVsWXAsMkJpXkVgbCpJbF1lSXMoZUl2IUxtKCBMJXYgTXVdUGlAUmElZlI8JzNBbnUhQyNMKGQhTmleOklnbiBNPk5nIE48J1VwaCgzQmF0dCFCaSxCb3JkIEJyaWQgQnV0L3RDPSBDZW1iIUNoKiBDaWQgQ2xhciBDb3IgQ3JpIUN1cF1EYSNEdWMlZkVzPEZfc2lmRmldRnJheSBHYWcgR2l2ciBHbHUlckdyYWYgSmV1biBMaS1Mb2cgTS9kIE1lJyBNb2wqTml+IE5vdSBOJmwjTnVkIFBhcnRQX31QaGF9UGxhYyBQb31SL2cgUm9iIFNhc3QhUy1uJlMgdFNpZ24gU29iZSpTcyggU3RyPlRhfiBUZXMsVG8nIFQhczxWL2MgVl8qViggVm8qM0FiI0Fsb2cpQW0vdEMsRmYgIEcgIEdpdD1HW0x1IE0vfmVNKHUgT3h5QFJlYyVmUmlnIFNjdSxTcG99U3NpcCBTdC8tViAlclZpfTVDaSNDJidHP0lndE1hKGVNaWNpI01wLE5hJidOaiRObiBQYW0oZVJ0bypSdSFTYS5TZSdTcz5UYSUkVS8+VWIjVS0nVSxZXzJBZyRBcCBFc31JYmJdT2l0dSEyUCArUCN4ZVJhYiNSYyozTmFzJWU6MExvdSowQXIsSGFycGVIZWwjTGEqIExpcDxMbyFMdTxPI09ub20rT3ItT3UsUmF9UmVtIFJpdmEoUm91VT9VIXVgMElmPlVxdSAxRmFjIEZlYyVmRmlnK0ZvcnRGcmF5IEZ1c2kkMEFsaX1BciAyRWMsMUFib3IgQXJnKkVjdHIkRWcvdEVwaC90RXZlSWdpYiNJJXM/Ty5VY2lkIFVkIDBCPV1CZWxsKkJyeSRFcnxASXNzaSRNXyBPJSRPdXZvKlAgZSdQbG95IFBvcixQcmk8VWxzaSQwQ2FkciBDaCBlQ2xhdmVDb35lRGlndSBEb3N9RHJvaXREdWkhRXJnK0YvLUYgbSBGb3UqR2FnIEcoR2xvYiBJZz9KYW1iIEpldUxldiBOZW1pTnV5ZXtSaX4qUm9iYS5TZWlnW1Rhc31UX2QhVD5UbycgVHJhdiBVbSAgVmFoKlZpYWIjVm95IFp5PzBMK24wQWlzcypBcmdbQXQvdEF1I0ljICtJQG0rSSBJbG9nKUlbSXNvQEl0YXBoZU9eUmV1dmVSb3V2IFVpcy90MFUgIVVpcGUwSWcgT3NpJFJlJ1VwJSQwQz0+UGFkJFBlLVArZyNQbypQcml0UXVpdiBTYXkgU18tUyt1U29yIFRpP1RvbWFjVHJhQDBBZyBlQV1Bbn5lQSVeRShkIUVuZG8qRXJbbEgvb2xIaV5IbitJciBPZmYgT2kjT25uL3RPJ2QqUi8uUm9pdFVAMFBob3IrMEFsdSBBc2kkRW50YWBJQG4tSSxPbHUlZk9xdSAxQWN0QWcgIEF1YyBDZWxdQ2l0L3RDbHVzaWZDdTxFY3UsRW1wI0VyYyBIPSBIb3IsSS5uLUldSXMsTyVeUGVkPlBsb3IgUG99UHJpbSBRdWlzVF9zaWZUcmFpIVVsLDpCI0J1I3tDZXQmQ2kjQ3R1IUlibCpMYWk8TWV7TWAjUi0nUmZlbHVSKGVSb3V+ZVNjKCBUPVRpZylVYyRVJWZWZSdWb3JpM0JyaSNDJGQgRCAgTChNP00nTmRvKk9kPVJtIFJvLVJ2ZSdTJXY9VWAjVXQhVnI+M0FzY29DZV1DJWZEZSNHdSFMYXR1IUxldGEuTD5lTCN1bExtIExvdUx0ciBOL2MgTipPI1I/U3N1IVggMkEqIEFtP0FzXkF0JidFfEV+ZUUnRXhpJE9jJE8hVWN0dSBVaUBVdmk9MkwrTmQgK05naWIjTnRhKGVSYyBSZyAkUm11XVJ0dVtTc2kjVWQhVWcgZVVgXVVsdSFVcm1pMkFnaSNBaTxBbn4qQXBwIEF5ZSdFZ2EmRSggRWwkRW0qRVtzK0UhSWFiI0ljJSRJc3MkSXZvI09pZE9tYS5PbnQ9T3QsVWl0MkdpJWZJJlJlJ1Ire1IlZlNpJFQnOkduIExheCtMICtNYmFkIFIvJXJSZCtuUm4qUnJpZylaZWwjWiQzQW50TGElW0x1I05kYXI/TiA9TitOb3VOJWxPbG9nK08/dCFSL2l1bVI/U3QpbFl9M0I+Q11SYWZlViEyQS1BaXZlSXN9T2JlT2khT3IrezJMZmUnTT9OZl1SLlJgI1VkciRVZmYhVWxvdFVwYCNVcm0vZFV0JjJBZClsQWZmaSVBKGVBbmRBcHAoQXR1aXRBdipFbmF0SWZmdSFJbF1JbXAgT2duIE9uZCBPdCZPdXBlVWcgVSUgVXkgZTJFcGFyZEVycj5JQEltfHZlSXRhIVN0YSVmM01uYXMmUm9zdGF0OkJpdHVAQ2hvKkwmTWV8Tmdhck5bdCRSaWNvdFJtJCtScCRTYXJkM0xpdW1NYXRvP1JiZVJpc3MkUm0oZVIkU2ksVSF7M0IgbiBCb3VMYXIvdFN0b2khViA1TWFyZE1tYS5Nby5bTlsnTm9yIE4me1JAUml6JFJsby5SbSRlUnJpYiNVI3tVczw1QmxvdEkje01hKE1iI01pQE1vJ1JdM0Rybz9sRytbTVtQbm88OjJZbCMyTm9yIFUvZTRMaWNpJkx1c2kkMEEuQmliIEksTV88TW9iaSNNdWFiI1BhY3RQIGk9UGxvciBQb31QcmltIFB1LDBDYXJuIENfZCtDaUBudENsKCBDb2xvIURleCBEaS1EdWMlZkVkaXRFcCVlRXhhY3RGKGlGbGlnIEZvcm0gRnVzaSRHICBIPSBIaWIgSmVjLEp1IU5vLW50T2N1XU9uZCBTY3JpIVNlYyZTaWdbU29saSZTcCogUyVuY3RTdWwsVGFjdFRfPFRpP1RyaWcpVHVpJWZVJSNWYXNpJFZfLFZpLFZvcXUgM09uaV5SYWQ+UmVlbFJpLDBPXTJPaSFSZXM8Okd1YXJJbGwqTWJlTnY+UmQoVWcgVVtWZWxvdDNUYWIjVCRVZGlVW3M8OUluZCFOfiBOZ11VZSdVaXNzaWZVcm49Vmk9WXxZZXs1QmldR2U/bnROaW9yUCRSaXMmUyUtVGV7Vl9pIzpZYWs3TSRvT3NeOkJlbEJpPUJvJyBDICBDdG88R3VbSVtJc31JJSBNYmV8TWVsI01wZU4tJ05nYS5OLFtQKFIuJ1I/VXI+VmFib1ZvKjNDdHUhRz1HIEd1P1NzaXZlVHQhVj5YaV5aYXJkM0FzPEIgIEIhQ18tQ29yW0UuRXYhR2F0dSFHbyxHKU0gTWkmTSRhQE1waUBOZWFpIU5nb3RPbi18UXVpQFM+ZVMsVGhpdW1UaS5UdG9yPVYhJzVHaV5JbnRhKElzKk1icmljVCArVSBVcmRVdCFVdmVZPTVCK0NpQENyYSVmRSdHdWIhSXMvdE0+ZU5haSFOZGlSJFQsWCl7OkNoKGVHYXMoR190YUdpXklnIUlsbCRJbiVfSXIrSXMkSm9yIExheCBMZWZpLUxoZSdMaS1MI3QmTW1vdXRoTmRhLE5pYWIjTnF1L3ROJnxOKWxSYXRoJFJiIVJ+L2RSZGlSaSU/Ul4nUnIkUiZdU2NvdCZTc2lmVCArbFQ+ZVRyYV5VZGkhVXNzYUBVdmVYaW09M0NoL3RDJG51RGFgI0RlYyhEaSxEdTxJbCMnTC8uTG9kK01iIU1vaSFOYWMgTiBOaCpOcyQuTnRvclJjIWRpUmkmUiNTc2FnIFN1IVQ9VGVvIVRob0BUPlViIzNBdV1Dcm9iZUV0JkduJEdyIEwrdUxsaSRNaV5OLU4gPU5pbT1Ob3IgTnUmUmFjI1JvaSxTc2kjWCY1QmkjRCBbRWwje05kaT1OaSYnTm5hK05vdCRlTnN0IU50YWdbTnU/bnRRKSdSLXxSc3UhUiUgVGUnVGlmVX5lVWYjVWwoVXNzJFV0JFV2L3Q1TCVwI05pJSRSYWAjUmVbUm11IVNjI1NldW1TaWMrblRhJSRUIFQpbDNSaWFAUiVsI1MsZVRoaV46R2UnUHBlUnF1b2lzUnIgVGElJFRpJFR1IVVmcmEuVSVeVmkhM0J1I3tDdGFyRmFzJkdhJSRHbGlnIEdvYz5JLlJ2ZXtUdG95IFVyJGVVdHIkVmV1M0NoZUNrZWxUcmEmVmV8NUIjQ2lmQ3QnW0lyLSdJPHQmTWFATWIhe01tIFJtYSVmVGFiI1RpZj5Ub2khVXJyKlV2ZXxWYSYnVmVtYiFWaS01QS5BbmMgSSFJc2liI00gb1AlPVEpVHJpJWY6MEUqSmVjJWZMaWcgU2MnUyB2IFN0YWMjVF8qVCcgMENhc2kkQ3VwIEUvVG9iIVRyb3kgVHVwXVVsYWkhMEUnT3IvdDFGX31GaWM+RnIqMEl2ZTFTZXxTYGwkMkZhYyVmSXY+MEJyYS5FdHQhMEN0KXtEdV1FIXtJcmleMUEjQV5FciBJbmkkUG9ydHVuUHJpbSBUIFRpXjFBLntBbi5CaSZEJG4gRWAjRy9lRylgSWZpLU5lP250USlUKzBDYF1NbzxTYXR1ITBBciswUmFnL1JzJFRgVHJhZyBWcmEuMEElJDFZQFkuWzFPWzpJc2liI0xhLUxtYSFzTG8nQExwIE5hfmVOZGFOZ29sKE5pcXUgTlt8Tm9yYW1hTnQ9JFBheWVQPlBvLFB5cnVzUmFkb3hlUi1sI1JlczxSZnVtIFJdUm8jUnJhKFI8bSBSdGFnIFJ1IVJ2XypTc2kkUyZeVCBbbFQrbi1UciRWYGwkVm9pfVkgWXNhLjNJZ1tJbnQhTGEuTGljL0wjTG91PEx1fmVOZHUjTmV0ciBOaWIjTnNpZk4nK1BpJlBsdW1SZHJpeFJmb3IgUmlvQFJtdSxScCN4ZVJzYFImUyBUYSNUaXRUcipVcCMyQXJhJE9iK09eT3QkUmE8WXNpXjBBbm9DdCc9RS1FciFFdXYhTG8mTi18UGV0JlF1IFJvZylTYyhlU3QkVm8sWGVsWnphMkFjYXJkQWYkZEFpcypBbiBBXkFzdHIkQSZ8RScgRXh1c0lhLk9tYk9uZyBVK1VtYS4yQ2hldCZFcytFJkluJklyPklzcyRJdiFMYWkhTGljPkwjbkx5ZyRlTW1hQE1wPk5jdClsTmQgIE5leVIlXlNpJSRTPGQgU3R1IVRhZyBUZXxUaSRVLVVsYShVbSRVcnAhVXNzKFV2byoyQSorQSVeRWMre0VkaSFFZml4ZUVsdUBFbm9tRTxuLUUmeCZFdm8qSW1pJWZJbi1JcyRJdiBPYiM/Ty1kIE9kaS5PZiRkT2chc08rT2plLE9sb2cpTz9uIE9wIU9zcCBlTyZnIE8pczxPdiBiZVVAbi1VW3wwWX5vPDFCbGljQyAkSX1McGVMc2FyTmFpPE5pJWZQaXQhUmlmPlp6IzNSYW1pQDo5OUFzYXJFIWwjRXMlJElldHVASXQsTyVfdDpDKGVDJCxEK3tHJGQoSUAnSXMoTF8lckxsJC5NYXN9UGlAU2EuVGlzfVZhZyBWKFkkbiAzQWMlZkFnKkFsaX1BbmltIENldm8qQ2ksQ2xhbSBDb2wsQ3J1LEN1XUN5Y11EaWcgRG91LEZhaSFGI3hlRm9ybSBGcmEoRnUuRz0rbkdpJEdsYS5HdWw+SSwgSmUsSm91IExhJWZMZXYgTCtmTWFyXk1lQE1pPE0kLE1wbCpNdSBOYXJkTmZvcnROaWZdTiRjIE50ciBOdm9pUGw+UG9yLFByaTxQJSNRdShTIHZlUyhle1NvdWQhU3BlY3RTLFN1bHRhdFRhYmwqVF8qVGljdSNUb21iIFRyYWMgVW5pJFVzcypWL35lVml2IVZvbCZWdWxzaWYzQ2hlczxEZXxFJ0dpQEdvXU5jIFBvcyxTaWIjU15UKWxWPVY+ZTVDaGV7TS8tTXAhTi1OZChTZXxTPlRhJWZUb3JUdSNVLlVgI1UjfFUlW1l8PzVCL0Jpc0NoZUVsI0cpe0luIElzPHxTIFMlXjNUaD86Ql1CbyxCIUNvfmVGYXJpR2VzPElzKkxhQExpdmVMJEx1IE1lZGlOYyUkTmdsPlJjYXM/UmQoZVQnIFVnIW51VW0kVSxVdmEuVi90ViRuIDFBbHBlbEFuZGEjRV1hdEVuYXJpb0VwdCFIZW1hSV8tSW5kIE8hUnUlblVscCwxQW4tQ2FiI0NoIENvdSBDISxEYSVmRHVpIUlnWydKbydMZWMlZk1hKGVNYl1NXy1NKD1OYSYnTnNpYiNOJm4tUGFyIFEpbi1SZShSLm50Uit7UnJ1IVJ1bVJ2aS1TYT9WKlZyYS5YdHVwIzNEID1FYyNFZyBGZl1HI0duPUxfLUxpY2l1bU1wI05jIGVOaXN0IVBoJFJvcFNtaV5UdSAxSSAzQ2k9QyNEaXVtSWdbe0xkYXRMZWBMaXR1QEx1YiNNYiFNP2BNbm9dTkBOLidOW3QmTm8hUmM+UiVyUytUJTxVYyt7VWR1IVVmZiNVI3YgVXBhcGVVci1VJXIgVXZfKjBBYyt7QSU9RWNpPUggZUlyPTNBYiNBJSRFcm51bUltdWx1c0lwdV1SaWN0VWQre1VwZSdZbGlzJjBCbGk/QnN0cmF0QiVsQnZfKkMtc0MhRmZpeGVHZyAgSXZlJ0xmYSZQIGJlUHBsPlJmYS1SaWNhJlI/biBScHJpPFJzfHRSditTcGVjdDNMbGFiZU1ibyNNZXRyK05hcDxOdGF4ZVMmPzpCYWNCbD5DJSNJbF1MX3RMaXNtL0wkbiBNYm8nTWl9TmdpYiNQaXNRdSggUmQgUmlmUiVbUzxUYW1pVG91YS5VcGVVIXxYIDNNbyhNcG8hbE5hYCNOZCFOZSdOKk5zaSRSbSggUltScmliI1QoZVgmMkU/RW9yK0VyYXArT3JheDBCaWFFQE1pQFJlbGkhUm8qU3N1VC9lVCFUdWIgNUJvZ2cvTCAvdE1hJk5pXk5bfFAkeT9SfmVSZCFSbmFAUnBgI1IhbnRSPFJ0KVRlbVV+IFVybmEuVXN9WChlMkFjJSRBZmljQWdpXkFoKkEoQW5+IEF2YWBFZiNFbXAgRXNvckV1YElhLklidW49SWNvLElsb2crSW9tcGhlSXBdSXQnIEl2aT1PbWIkZU9uY09waWM9T3VwZXwySSNMaXBlTXVsJk5bbFJiKGVUZSdUb3kgWXwzTXAvUGgkUGleUi86MFVlc145VGk/VHJhcyQxQW5pP0lmPkkkSV5JdGFpIUl2IHMzQW5pdW1CYShUaWMvdDBBLklbVWVsVSEwSSNPcCs6Q2FyP0NjKEdhYiRkRylJbGwvdEluYyFJczx8TGFiI0xpPExsJEx2ZU1waSFOYCNQZSdSPlNle1NzPVMmM0MmJ0RldCZHZXQ9SGljdSNJbmFyZExvLU5kIWRpTiAgTmcgTmk/e050b3U8UmR1IVIoUm4qUnJvdVJ9UnR1U3QkVCAvVHVzJlgvdFggM0FkdWNBbkBDdG9pIUQvLkRlb0dbdCZHKSdMYShMbGEuTmFpZyFPbCRQIGVSZT9udFJ0dW88UnVzU2EuU2UnU2kkU157UylsVD1UZXM8VGljbyNUcihlVmEtVmlwYSE1Q2ElJEd1IEkjSXMoSXR1IUxhYCNMYy9MJWcgTHU/UmEtUiZ4VCBVbG8qWWEuWWVsIzpHJDozTiQ6Q2h0OjNCIU5pdGhTJjlPbG9nK1wiO1xuY29uc3QgYWNjZW50cyA9IFwiZTc2OTMmKVUqbyYpUnleKSopVykpKSkjWF4pKSkpQEApI1dmKW0lKSMhKSlBRykmSUlBUUlJSUJJSUhKTkFnQklJTElESkdvKSkpSElRSUlJSUEoSUdnSkhIKEJJSXhYIylPdSlAKklBQVBJSUlKSFFKKSZRSVFQWUkoSFlBUUMlKSEpKVFISkpAKSMpXmYqXkFYQ0opKSQlQ1ApKSUmbSl1KUBlXkEjRyMpKVdAIShJS0slIShJJSkpT0BRQSkpQEdHI2UpKSkpV0hKSVdoKSlteUBJSUJUXikhKUhBWUdFVEhJKikpIVFuVURHKSkpbkJvS0FDKkh3eVFoKSkkJilHJilVR08pRykpKShCWCN2KiopJU8sZTc2ODYpSSkpQCkmKWdkTVAoKSkpdWQpcCNMKSlJXkZJSFlkV0cpKURAREZWKVFBKW8lTXlUaCUqKVopJSluKFhBTmNeUilZU1wiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4NTFkZWI3YWUwMDkxNDlkYzYxYTZiZDE4YTkxOGViN2FjNzhkMjc3NTcyNmM2OGU1OThiOTJkMDAyNTE5YjA0NVwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktZnJdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0ZyIGV4dGVuZHMgd29yZGxpc3Rfb3dsYV9qc18xLldvcmRsaXN0T3dsQSB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEZyZW5jaCBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdGcl1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcImZyXCIsIHdvcmRzLCBhY2NlbnRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ0ZyYGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdGcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdGciA9IExhbmdGcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZnIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGFuZ0ZyIiwid29yZGxpc3Rfb3dsYV9qc18xIiwicmVxdWlyZSIsIndvcmRzIiwiYWNjZW50cyIsImNoZWNrc3VtIiwid29yZGxpc3QiLCJXb3JkbGlzdE93bEEiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-it.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangIt = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa\";\nconst checksum = \"0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-it]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangIt extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Italian language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langIt]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"it\", words, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangIt``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangIt();\n        }\n        return wordlist;\n    }\n}\nexports.LangIt = LangIt; //# sourceMappingURL=lang-it.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsb0JBQW9CQyxtQkFBT0EsQ0FBQyw2RkFBbUI7QUFDckQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFdBQVc7QUFDakIsSUFBSUMsV0FBVztBQUNmOzs7O0NBSUMsR0FDRCxNQUFNTCxlQUFlQyxrQkFBa0JLLFdBQVc7SUFDOUM7Ozs7Ozs7S0FPQyxHQUNEQyxhQUFjO1FBQUUsS0FBSyxDQUFDLE1BQU1KLE9BQU9DO0lBQVc7SUFDOUM7OztLQUdDLEdBQ0QsT0FBT0MsV0FBVztRQUNkLElBQUlBLFlBQVksTUFBTTtZQUNsQkEsV0FBVyxJQUFJTDtRQUNuQjtRQUNBLE9BQU9LO0lBQ1g7QUFDSjtBQUNBUCxjQUFjLEdBQUdFLFFBQ2pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLWl0LmpzPzg4MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdJdCA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjB0b3JlYSBub2ljYSFpb3Nvcm9sb3RhbGVyYXRlbGFuZW5hJW9pYWRvZW5jb3Rpdm9tYWkgdCBjYSVhMEFdQmFnbCdCaW4jRS5JcyhPbGkhUmFzaV9Sb2cjMENhZGUhQ1skQ3VzI0UgPEhpbCxJQFF1YVJlUmlsPlJvYmErVSAwQWcnRGVie0RvbWVFZ3UjRXJpIUlwZU90dCZVbCYxRmFiaSxGZXxGaXMoRi1uIE9yaXNgTyhSfiQwQXZlRW4uRV8sR2FuYydJIUl0Jk9uaXNtb1I+KlJ1bWUgVXp6bzRBYmFyZGFBIEJhdClCZXIjQm9CdW1lQ2VDb2w+RXw8RmFHZWItSWFuLkliaUltWyBMYWcjTGVnKUxpZV9Mb0AvTHVzaV9NZSRPZ2UkUGF9UGVzdCFUYSw9VGVyJFQlYydUKXZlVW4kVmVvKlomMEFsZ2FgQW5pK0EhPUJ7QnIjRWJhRXJ+RV5zK0ldTWFzKE1bZGFNaXImTW9ue08hUCdQbGkmVSwgMEF9ckBBZy1mZUFsaXMrQXJjaD9BdC1DYUNlbC9Dby1EJkQhYUVsKkdlKkdvbCZHdXMgSWBOZWcmTmlkI05vTnVuYydPbmltb1QlaXBvWmkxQXQ+RXJ0dS1PZGVQYXJpIVBlXiBQb2dnJ1ApQFB1biBSaSwxQWJ+QWNoaWRlQWdvcytBbGR+QW5jJ0F0dS1BenpvQml0KUNoaXYnRHtFbmksR1sgR2k8R3UgSWFNb24/TmVzZVJlZCNSaW5nYVJvcyBTWz5Tb1RlZiVlWmlsKjBDaXV8Q29sIEVwc2lFdHQ+RmFsIEkkTy9QaXIjUClTYWdnJ1NlU29sdSBTdXJAVGFUW3UgVCVlVC18MEF2PkVpc21vT20+TyRUZXNhVGl2JlRvciRUcntUdWEsMFNpbCdTdHI/VGlzK1RvJG1vVHVuJDBBbnojRSFWW2khVmkoVm9sZ2UhM0lvPE8gWmltb1p1cik6QmUsQ30kQ2kkQ29EZXNzYURpLytHbiNJK0xdPExATGU9TC8rTHphJE1iaSROZGkhUmFvbmRhUmJhKVJ9UnskUmx1bWVSb2NdU2lsPlMoVG9zK1R0dSBVLFZhVm9zYTNDXUZmYUxnJ0x2YU5kYU5lXyxOaWckTnppPVJlUmxpPVRhM0JpK0NpRG88RmlAR2FMYW5jP01ib05vXSpPKmdvUGVkZVBvbCZSYmFuLlItU118U2VzIFMkbiRTb24uU3R1cmlaemFyKTJBbkBBdCsyTGx7TmlmPlJAU11UYW4+VF4kWnpvKjJBY2MnQWRpcG9BYEFufUF2dS1FLmwvRXZlfEV6emFJZ2w/SWwvbi5JbmQmT2NdKk9AT256aT1VbCpVJDJCYm88Q2FEaSRGZm88SW9MYm9PJFIqPFItc31TKC9TKzpEZXxEdV1MYWApTF0qTGVzc2VMaWIpTG1vTG9yP01idXNhTWUtK00lP01taSRNby9NcGEsTmFwYU5kZS9OZU5pJE5vfE5ePVBhY2VQZWwqUHsqUG9naSlQcGUpUC1Qc3UvUmFwYWNlUn1zc2FSQFJpc2BSb3ZhPVIhfFIgbGk9U2FjYydTfStTZXJgU29TKDxTLmwqU3VhLFRhcytUZT1ULW1lVSBWaWwqM0RpYmksRC0rRmEqTGViIUxsdWwmTmFObzxOLnNpbW9SYW1+UmMmUiBSdW1lUnZlbCpTbz9TcG9UbzJFL0lhKUljfUllZGUhSW1lLUk9SXJ1cmdvSStyLTBBb0NsaXNtb0ZyJkckTGluZClPfCpSfVIpc2lUcj5UK2RpJFVmZm9WZXQrVmksMkFzcz5Jbn5PKTJDXURhckBEJWVFIW4uRyRtZUxsJkxtI0xvIUxwbyhMXnYjTHphTWFNZStNYG5ATW9ATXB1LnJNdTxOY2koTmR1ciFOZmVyYE5nZWwmTml1Z2VOPHMoTm9zY2UhTnN1bW9OXm51b052ZWckUGVyIFAnPFBwP1ByfnBvUmF6emFSZGErUiUjUm4lZVJvbC9ScG9SIUBScz9SLnNlU20+UytuLlR0dS1WIzJBLiFBdmF0K0UjRWRlIUVtbyhFc2NpK0UrSWNlIEk9LElzaUl0Pk9jZU89fU9zKytVYz8sVXN9MkNpIUN1KkdpJExsI1BvL1IjIVIoIVJfU2NpJFMgZGU6RG9JJExgK01lcmkkTmllL04kKE56JlQjVmFuXlZ2ZSkzQnV8Q1tuJ0NpKENsaSRDb2wqQyEgRCUjRmlue0Zvcm1lRyRMZWcmTGZpJExpcidMK01bemFOb3QjTnQpUG9ze1JhcGErUml2JlJvZ2FTY3JpfFNlciBTaWRlcidTdW1lIVRlcnNpX1ZvIDNBbWV0KUNlbWIhRWQpRmUoRmZ1KEdlcmkhR2krLEx1didOYW0+Tj1uemlQaW4gUCpgUG8qUmFkJlJlUm98UnVwb1NhZydTYyEgU2YmU2dlKlNwb3MgUytuemFTdWAkVG9WYSRWZWwgVmlkZSFWb3IjNUIqPENbLkdhPSxHYExjZU0jTVt+TWluJk5AKk5vUm1pIVRlVCAhVnUgWnppPTJBZ29VaUAyQmInQml0JkNhLE5hT21vUGwlZVJhdHUpOjBBJDBDZXMoQ29MaXNzaU8kbT8wRS1JXS9JLEkgcj9VYyYyRW1vbj9MaU9pc21vUmVnJzRBYm9yI0FyZ2khRWdhbi5FbmMjRXxFdiZGPkl9TW9TYVUoMEFuI0IsYEVzKEkpT15fT3onPFBpcj5VKjBEZW0+RHUpRXJnP0Zhc2lPLn1UciZaaWAxQV4uSSpnb0koZCdPfSxQdSEwVSMhMEFyJ0JhQm8oRWRlRW1pK0lnZSFNZXQ+T2VPc2lfUmFuLjBBZ28kQW1lQW5pbWVBdWRpIUNhRW1wJ0VyY3tJYntJZ1suSXMuIUkgT2ZhZ29PcnQjTyhQYW4oUCFzKFNbemFTb1RlKFRpbSZUb24/VCkoVWx0JjBJbD5OPlJ1c11UbzBDbGlkZW9Sb3BhMEEoSWRbemFJdCNPbHUgVml2YTpCYnJ+Q2NbZGFDaGkpTF1NaWdsP05hLE5mYS1OZ29OK3NgUmVSZmFsL1JpJChSYF1TYz9TIChTdWwqVCUmVG9WbyooM0JiIUNvL0RlRyNMcGFMdClNbWk9TmRlIU5vbWUkUm1bIFIpUl4sU3N1LVNeX1QrVUAzQWJhRHVjP0ZhR3VyI0xvTmFuemFOZXN0LU5pIU8hU30sUz5VbWUyQV08QW1bXUVib0VtYE9yaUBVWy5VbykyQj5DYWNjP0NvKERlciNHbCdMYStMYyohTGdvIU5kWy5OZXQ+Tj9OKz1SYntSY2hldCtSZXMrUm1+Uj0nUm9SLnp6YVJ6JlNmI1MoMkF9cyhBPUFzc2kkQS5sKkVjY2V0K0U9K0VzXUlnb09sbGkkT25kZVVnYSxVdCsyQ2kvK0NzP0dnWy5MbWk8TF9NYW4uTWV8TW8oTmVOeic8T11SYm9SZ288Um8hU29UaSw6QmI/JEZmZUxhLm9MbGk9TG9wcG9NYmUpTWBSYW56P1Jib1JvZmEkUnpvPFNAfFNvbCdTdHI+VCBVZCdaZWJvWnplbC8zQ29MYV49TChNZWwqTW0jTmVOeyFOPSdOb15wb1JnbzJFcGFyQElhY2MnSXNhMEFsKkxkYU5lcClPYyZPaWVsKk9yJE92ZVIjUm88VCsrVWRpeidVciNVcyAyT2J1KlVePDFPbW8wQmJhTGZNe01tbzxOZidOPVZlciQyQWNpLEFAQWY+QW1tb0FuZGVBdHQmQV8oQXo/RX1FZ2dlSWZvPElnJ0luemFPdCtVcHBvMkFkYWckQSdBbiBBcmQmRm9JZCY6OjBFcm4jME89MEVudD5JbGwnTypSYVI+Um9nZSQySWU8TmEpTm9yIzRBIUxlKExvZz5MdWRlITBCYWwqQmV2dSBCb2NdQnUgTWE8TWVyKE1vbCNQYWNdUGUgUGllZ29Qb3IgUCluKzBBbCZBcmMmQXReX0NhbiBDW2QnQ2hpJENpc2lfQ2x1KENvbnQpQyljJ0N1Ym9EYWdpPEQ/RG8sRWR7RmF0XkZpbCZGbGl8R2FnZydHZWckRyxzZUdvckBHKXMoTmVzXU9AIU9sdHImT25kI1NhJFNlfFNpZW1lU29ubj9TdWxpPVRhcyNUZSlUbz1dVHV7VW1pZGkhVmFsaUBWZWNlVnsxRXJibyxOb3Q+Ty5zaVB+MUlkZUxhbmRhT24+UmlnI1JvciYwT2wjTyBwb1Rlcj5UaXR1IFRyJWUwQWw/RXImOjo6QmIpQmlyaW4gQ31DZXIjQ3JpYEN1PURAdmVHb01wb05jZXQrTi5yPVJAKFJnYVJpbmdlU3QtVFt6YVRpJFR0dWdhVmFnPVZvKTNHYSxHZ2UpTWJvTi56emFOemFPPFAhU2lfU3MjUyBULi0sVmFWaWcjM0JlKURvRXZ7TC9NYXR1LU1pdCZNcGlATmUmTmd1YVF1aUBSYVJ+U31UZVRpZydWIWE1Q2FuZGFEZUd+TWImTmQtTmdlX1F1YWNlUlt6b1RvVC5yPzVDZUNpZCNNYX1NaSQoTmdvUG9QcG8qU2luZ2FTKFQgOkNhYilDY2hpPUNlKUNpbiNEYWBHPkdsP0c8LkcpSW9sfkxhZmVkZUxnLUBMaW4uKExzYSRMIEx1bW8hTmFOYz9OQHIvTmdpJk5pZmVzIE49KU5vdi1Oc2FyZGFOXmRlTnVicidQcGFSIz1SY2khUmV0K1Jtb1JzdXAnU2NoZS1Tc2E/U14kVGUtcyhUcj4vVCA8VHUpWnVyfTNBbmQpQ31uPkNlPS5EZXNpbW9EaXQmR2FMYXNzYUxpc0xvZD9OaW5nZU5vTigvUmN1cidSW2RhUipTY2hpJFNlU3NlIVMgKlRhbCpUb0BULiEzQWdvbCZDYUNlbCdDaGUsQylib0RvbCpFLEdsJyFMYSRMaS5Nb3NhTmUtLE5pTm8hUmkkUl5sKlNjZS9Tc2l2YVMgU3VyJlRlenphVGlnJlQtVC5uLjRFbW9uPjBEZWwqRGlmfkR1KkdhJEcnTGVMb3MoTmFzLilOXU5kaT1OZStyJ05pLE5vICROKDxOdCNOdmkoUmFSZGUhUnMlI1N0KVRpdiNUb3NlZ2FUIFZbemFWaW1bIFp6bzVDfUNvc2FGZmFHaGV8Rz0nTGF8TGk8bCpMXnAqTW0/TiBPdmUhUmEsU2FTXSpTflRlXyxUbzpCYWJib0YrTm9tZXQpUmNpKFIlZVJyI1NjZSFTdHImVHUtLFV0flZpZ2wnM0J1KnNhQylzaUdhXl9Hb3onTW1lJE9maStSZXxSX1NzdSRUdHUkVXQtLFZlVil0PjNDY2g/TmZhVGlANUJpLENpX0RvTWVNaT1SZD5SYCxSdmVnZXNlU3QtJFQmVGl6P1R0dXIkVmVsLzVDLG9ML01lKU9fVHJpIVZvL1o/LDpTaTBCZWRpIUJsaWdvRWxpc11MJ08qU28sIDBDYXMnPENoJ0NpZFsuQ29yISFDdWx0JlJhVWwjMEllciRPciYxRmVyK0ZyaSFGdXNjIzBHZXxHaU51JDRBbmRlc2VGYXxJI0l2YU9nLW1gVCEwQWdnJ0JlbD5CLUVnYUlzcyc8MERvKEUhSWNlTmlfKU8hXyxUYTFFciNJbic8UG9zIDFBXSpBZm9EaTxFY2NoaSRFZiVlRmEkR2FuPklnaTxJenpvbi5NYU1lZ2cnTmFeX08qZydSW0BSaWJpLFRbcz9UflphK1pvMEEhQ3VyJk1vc2lQZWRhLFBpLlNhU2lkJlRhXSpUZTBJLlJlVGFnbyRUaW1vVG9iITFBLEVzdEkkSXBhKU9je1VucXVlVmkmM0lvOkNjaGV8Q2VDaWY+RGVsL0QpPEVzZUdhR2k9TGF6emk9TGVzJkxsaUBMb0x1ZGVOQClOPGwqTypPPXp6b1ByflJhYm8vUmNlbC9SZSFSZ28qUmlSbCNSby9SXiFSdlt6YVJ6PyxTc2lfU3QlfVRhY31UbypnP1R0dW1lVm88M0NjI0RhbCZEbz0sR2cnTG8oTiZOZCVlTmkoL05udSBOb21iLU5zJk4gL1BlUGkrUmJlPFJdcihSQG4jUmZvciZSZ2FtZT1SJ0BSbWVzKFIkUnAscyhSc3VhKFJ0dWcnUnZhKFMjIVNpcytTb1NeZmUpVGEqVF48VHUvbi5aem8zQWNlIUFuK0F0XiRDY2kkQ296emFFZ2FFdC1GZmUpRz9gR29sJ0cpTGFMaWZlKUwqL0xvK01wYW4uTmUrTj1ObypPZ2c/T21ib1JhbWlkZVJldD5SaS5Sb2xpc2lUbzxaej4yQWNlYm9BbiZBc2BBKyRFPXInMkNoZXp6YURlKShEaXNtb0VzP0dnaSZMWytMaWdvJExsJWVMbW9uaS5McGV0K0woTHQpPUx2ZSFNJWVNb0ApTi5QbyooUmZpQFJvKFJwby1SIVIrK1NhU2leX1NzZXMoU3R1bCNUYXNzJ1RlITJBbnpvQXNzaUF0fkVjbHUoRWR+RWZpcyhFZ2kjRWxpZV9FbWUhRSR0JkVwYXIjRXNbemFFLnMgRXZhbChJYEluY2lwZUl2I09iLGBPY3UtT2R1ciFPZnVtb09nZXxPbHVuZ2FPbWVzc2FPJG1lT3BvcytPKWdhTy4oT3ZhVWRbLlVnPVVyezBJY2hlMUJibD5EfkdpbCNHJExjZUx7THNhbi5OdCZQYXp6b1BpbC9Sbzo5OUFkKUFsXXNhQXNpRSEvTys6Q11sIERAcHAnRH4sRHVuI0ZmfkdhenpvRyc8RyRNYXIpTWluZ29Nb05kYWcnTiBsJlAjUGk9UHAhKFNhdHUtU2NoaSNTWy5Tc2VnPVN0IWwqVGFWdmVkdSAzQSxDZXBpIUNpbiBDbHUrQ29uZHtDdXBlKURke0RpbWUhR2FsI0dpc3QpR28vRyFzKExheic8TSZNbyBOPVBsflByaW1lIVB1dCZTYVNpZFsuU3BvbihTK3UpVGVUaT1Ub3J+VF5mflZvYyMzQXNzdW4gQmFkaSFCZWwsQiF6em9DYXJ+Q11DZXZlIUMlbCNDb3JAQyFkdSBEPipEdXIhRmFzJkYscyhGb3JgRnVnJ0cmR2V0dCNHaGVsKkxhc3MjTGV2I01hPCFNYmFsem9NZWQnTW9yY2gnTmFzY2krTn0pTmZvcnpvTiRfTm9tI05zYXZ7TiBjXU51bmM/TnZbaSFQYXIjUGV0dSBQaWUkUG9ydCZQIXNhUHVsaSFTYStTY2gnU2VydmFTaWJpLFNvU3BlfFMgKVN1bHQjU19sIFRhckBUZWckVG0+VClfVW4nPFZhVmVyKFZpbmNpK1ZvbCBab2A1QmFCb3Q+QnVzIENjP0NvRGFnZydEZSFEeyFHe0xsJ01hbnQ+TXBlIU56J1NvbCZTcG9UYW4uVG9uQFR1L1Zlc2MnNUJpenpvQnJ+R2FMbGkkTWk8TW8pKE8qUGVTcyZTdD46QiNCYmkmQm90I0dvYExhcyhMZGF0dS1MZ2VtYExpdiZMbW88TG88THQmTHUgTF9QZSFQaUBQb3J7UmFjZSRSfXNtb1IgUygoVGVsbGkuVGktVG9sKlR1ciRWYT1WJ1ppIzBBZGlnbCdBbHpvQW5jI0FyLUF0LiFBdiZFbmQmSXJjaSZMb2NjI09jY2kjUmluJlJ1ZmZvPFVmZiYwQWIpKEFkW3phQS9BbWJpJkFuZGEqQXBvL0FyKEEubiZBdiNFbCBFbj5FdHQpSGVkYUhpZT1JYXJwYUlbemFJbmRlIUlwcG9JKXBwb0lfKkxlciZPZGVsL09scHtPbXBhciBPbmZvciBPcHJpIU9yK09zKDxPenplc2VSaWJhUm9sbCZSdV5uJ1VkZXI/VWwgIVVvL1UpVXMmMEViaXQmT2dhbiYwQ310dS1Db25ARGEkR2cnL0c9bCNHIWcjR3V7TGNpI0xldF5fTC9MdmFnZydNYWZvKU1iciZNZU1pbiNNcCFOKE5eIVBvbCBRdVt6YVJhK1JiI1JlJFInUnBbLlItZ2wnUnZpIVNePVRvL1ReYD0wQWNlKkFsZCZBbSNBcnpvKEF0JSNFLUlkYUlsI0luZ2VPYyNPZGVyJk9nb09sXiFPcnojUmF8UnV0dCNVZ2d7VW0mVSgwQWJlbCpBcmIjT25maSZPcmInUmFzcyNVYXJAMUJpKkNdbWVFci1HL0ckIUxbeidML2JhTWJvKk1wYXQ+TXVsI05mb24/TmdvKk5pc3QpTm9OLnNpTnUoaWRlUGFyJ1NgUyAsVHUjMkl0K09nYXR1LU92ZSQwQXJye0Vtb3IjRW5eIEUtbEBJbHpvT250Jk90dCNVc3MjMEVsbGkhRXJ2I09AMEJiYWx6b0JyJ0NdcihDPyxEYSxGZml8RyRMZCNMWzxMaUBML3p6b0xvTHViaSxMdlsuTWF0Pk1gTmRhTmV8Tm5pZmUpUGkhUHBlKFAtUmdlIVJwYXMoUnJpKFIoUi5nZydSX2wjU3BpKVMrVF4sMEFkYUFsL0FyZ2UhQSAvQXZbIEF6em8vRWNpZUVkaSFFZzwhRS90dS1FLW56YUVzKCFFdHQtLEV6eiNJYUlnbyooSWxsI0kkKEktLExbZGlAT3JeX08oUmFuZ2FSZWMmUm9uI1J1enpvVW5eJDBVaWwqMEFkJSZPIGwjMUFiaSxBY11BZmZhQWduJkFtcCNBbnQnQXJudSBBc2UtQXR1IEUqRXBwYUVyem9JLHxJYElycGVJdmEsSXp6byhPbiNPcj5SYXBwb1JlZyNSaWR1KlJvenomUnV8VWNjJlVmb1VwW0AwQlt0KUNdKERvIUdnZXJ7R29MKyRPbiZQZXJib1Bwb3IgUmdlbCNSKWcjU3N1cilUdS0wQWcmRWRlc2VFZ2wnRWwmRW51IEV6P0lsdXBwb0lzK0l6emUtT2wrVW90JjpCYWNdQnVsI0NjaSZDaXR1ciRMZUxpc2AkTXBvPE5uaSRSYVJkaV9SZyNSaWZmYVJwJlIrcnVnYVMgVHQ+VmVyPVZvLytaemEzQ2FDbj5MZWZvJE1lLXInTXBvTXUgTkA8TmUpTnMnPE4rXSpPIWBSbWVSLXp6b1J6ZXxTaVNzZXIjU3QjVClUID8zRiZHZWwvTWIpTiBQPlBvZy1mb1JhZ2cnUm9UYW4nVG8qVHViYW4uWidaem88NUNjJkwsciZMIE1iby9Nb05mb05zaWwvUGF6J1BvKmc/UHBhUmJhUm4mUik8UiAtU30kU3NpIVMrdHUtVGEkMkFib2NdQWNoZWFBZmkvQWdlZD9BbGMnQW1vbiBBbnN7QXBhJEFyIUFzKl1BdHQjQXZlRWNjP0Vtb2wnRXNwbypJYnUgSWNoZV1JZm9nbCdJbCpJbmNlYUlvSXMuenphSXR1ciNJdmVsL09tYmFPJE9wcG9PfC9PdiZVY2MjMkJhdHUtRmYjTGlwYSRNdWwgTmlzP1JiJlJjaGkkVGFUZS86MEljIzBDZWwqQ2koITBJIUleXzFGYUYlJzBVYSw0SXNzZVRpbSMwQSRJLE9yaXNtbzBDaTx8R2UhR2hlIXNlSV1yJElmJSNJKCRJK3InVGUwVm8wVXBhMUFnYSRHW3phTG8wQW56YUEgQ3tJZyQqVS0nMEVuc2ksSWxpenpvT3A/OkNhbi5DY2luI0dhYm9uQEdsaSNMYW5nYUxnb0w+TCx0K0xvKShMdXQmTF8vTXBhK05nJk57KE5vTitnZydOdmUtUG8hUmEkUmMjUj9uLlN9M0RldCtEb3ZhRHUgR2UrLEldKkxjKUxpPUxsdSBMb2NlTiNOZGVtbT9OIFJhY2VSYmEsUmdvZz1SaWZ+Um9ScnV9UnR+LFNjflNzaWwqUyssVGUtJFRyaT1UdXMgM0FuZGFuLkItbi5DW2RhQ2hpbmdvQ2k9bnphRGltJkdpbD9HPCBHbyFMZUwvJE1pbmlOY3shTy9QZS1SZ28vUm8qZ29SdSxuIFNdKFMnPFNwb1NzdSBTdS1UYVRlbCpUXmBWYW5kYVZpQFppJjVDZUdhTGFeLExlIUxwZVJhZ2k8NUx9JDo6OjpNcG9nPU49UHAjVC4tVm9yLTNGaSlMYW4uTG9OemUpUmJpJDNCZXxOXVJdPFQgNUwvVD41Q2NoZSlGbypMdVBwYVwiO1xuY29uc3QgY2hlY2tzdW0gPSBcIjB4NWMxMzYyZDg4ZmQ0Y2Y2MTRhOTZmMzIzNDk0MWQyOWY3ZDM3YzA4YzUyOTJmZGUwM2JmNjJjMmRiNmZmNzYyMFwiO1xubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktaXRdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0l0IGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBJdGFsaWFuIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ0l0XV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwiaXRcIiwgd29yZHMsIGNoZWNrc3VtKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nSXRgYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0l0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0l0ID0gTGFuZ0l0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1pdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMYW5nSXQiLCJ3b3JkbGlzdF9vd2xfanNfMSIsInJlcXVpcmUiLCJ3b3JkcyIsImNoZWNrc3VtIiwid29yZGxpc3QiLCJXb3JkbGlzdE93bCIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangJa = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = [\n    // 4-kana words\n    \"AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR\",\n    // 5-kana words\n    \"ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR\",\n    // 6-kana words\n    \"AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm\",\n    // 7-kana words\n    \"ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC\",\n    // 8-kana words\n    \"BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD\",\n    // 9-kana words\n    \"QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD\",\n    // 10-kana words\n    \"IJBEJqXZJ\"\n];\n// Maps each character into its kana value (the index)\nconst mapping = \"~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt\";\nlet _wordlist = null;\nfunction hex(word) {\n    return (0, index_js_2.hexlify)((0, index_js_2.toUtf8Bytes)(word));\n}\nconst KiYoKu = \"0xe3818de38284e3818f\";\nconst KyoKu = \"0xe3818de38283e3818f\";\nfunction toString(data) {\n    return (0, index_js_2.toUtf8String)(new Uint8Array(data));\n}\nfunction loadWords() {\n    if (_wordlist !== null) {\n        return _wordlist;\n    }\n    const wordlist = [];\n    // Transforms for normalizing (sort is a not quite UTF-8)\n    const transform = {};\n    // Delete the diacritic marks\n    transform[toString([\n        227,\n        130,\n        154\n    ])] = false;\n    transform[toString([\n        227,\n        130,\n        153\n    ])] = false;\n    // Some simple transforms that sort out most of the order\n    transform[toString([\n        227,\n        130,\n        133\n    ])] = toString([\n        227,\n        130,\n        134\n    ]);\n    transform[toString([\n        227,\n        129,\n        163\n    ])] = toString([\n        227,\n        129,\n        164\n    ]);\n    transform[toString([\n        227,\n        130,\n        131\n    ])] = toString([\n        227,\n        130,\n        132\n    ]);\n    transform[toString([\n        227,\n        130,\n        135\n    ])] = toString([\n        227,\n        130,\n        136\n    ]);\n    // Normalize words using the transform\n    function normalize(word) {\n        let result = \"\";\n        for(let i = 0; i < word.length; i++){\n            let kana = word[i];\n            const target = transform[kana];\n            if (target === false) {\n                continue;\n            }\n            if (target) {\n                kana = target;\n            }\n            result += kana;\n        }\n        return result;\n    }\n    // Sort how the Japanese list is sorted\n    function sortJapanese(a, b) {\n        a = normalize(a);\n        b = normalize(b);\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    // Load all the words\n    for(let length = 3; length <= 9; length++){\n        const d = data[length - 3];\n        for(let offset = 0; offset < d.length; offset += length){\n            const word = [];\n            for(let i = 0; i < length; i++){\n                const k = mapping.indexOf(d[offset + i]);\n                word.push(227);\n                word.push(k & 0x40 ? 130 : 129);\n                word.push((k & 0x3f) + 128);\n            }\n            wordlist.push(toString(word));\n        }\n    }\n    wordlist.sort(sortJapanese);\n    // For some reason kyoku and kiyoku are flipped in node (!!).\n    // The order SHOULD be:\n    //   - kyoku\n    //   - kiyoku\n    // This should ignore \"if\", but that doesn't work here??\n    /* c8 ignore start */ if (hex(wordlist[442]) === KiYoKu && hex(wordlist[443]) === KyoKu) {\n        const tmp = wordlist[442];\n        wordlist[442] = wordlist[443];\n        wordlist[443] = tmp;\n    }\n    /* c8 ignore stop */ // Verify the computed list matches the official list\n    /* istanbul ignore if */ const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */ if (checksum !== \"0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600\") {\n        throw new Error(\"BIP39 Wordlist for ja (Japanese) FAILED\");\n    }\n    /* c8 ignore stop */ _wordlist = wordlist;\n    return wordlist;\n}\nlet wordlist = null;\n/**\n *  The [[link-bip39-ja]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangJa extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Japanese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langJa]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"ja\");\n    }\n    getWord(index) {\n        const words = loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords().indexOf(word);\n    }\n    split(phrase) {\n        //logger.assertNormalize();\n        return phrase.split(/(?:\\u3000| )+/g);\n    }\n    join(words) {\n        return words.join(\"　\");\n    }\n    /**\n     *  Returns a singleton instance of a ``LangJa``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangJa();\n        }\n        return wordlist;\n    }\n}\nexports.LangJa = LangJa; //# sourceMappingURL=lang-ja.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1qYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQWtCO0FBQzdDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDLE1BQU1HLE9BQU87SUFDVCxlQUFlO0lBQ2Y7SUFDQSxlQUFlO0lBQ2Y7SUFDQSxlQUFlO0lBQ2Y7SUFDQSxlQUFlO0lBQ2Y7SUFDQSxlQUFlO0lBQ2Y7SUFDQSxlQUFlO0lBQ2Y7SUFDQSxnQkFBZ0I7SUFDaEI7Q0FDSDtBQUNELHNEQUFzRDtBQUN0RCxNQUFNQyxVQUFVO0FBQ2hCLElBQUlDLFlBQVk7QUFDaEIsU0FBU0MsSUFBSUMsSUFBSTtJQUNiLE9BQU8sQ0FBQyxHQUFHTixXQUFXTyxPQUFPLEVBQUUsQ0FBQyxHQUFHUCxXQUFXUSxXQUFXLEVBQUVGO0FBQy9EO0FBQ0EsTUFBTUcsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxTQUFTQyxTQUFTVCxJQUFJO0lBQ2xCLE9BQU8sQ0FBQyxHQUFHRixXQUFXWSxZQUFZLEVBQUUsSUFBSUMsV0FBV1g7QUFDdkQ7QUFDQSxTQUFTWTtJQUNMLElBQUlWLGNBQWMsTUFBTTtRQUNwQixPQUFPQTtJQUNYO0lBQ0EsTUFBTVcsV0FBVyxFQUFFO0lBQ25CLHlEQUF5RDtJQUN6RCxNQUFNQyxZQUFZLENBQUM7SUFDbkIsNkJBQTZCO0lBQzdCQSxTQUFTLENBQUNMLFNBQVM7UUFBQztRQUFLO1FBQUs7S0FBSSxFQUFFLEdBQUc7SUFDdkNLLFNBQVMsQ0FBQ0wsU0FBUztRQUFDO1FBQUs7UUFBSztLQUFJLEVBQUUsR0FBRztJQUN2Qyx5REFBeUQ7SUFDekRLLFNB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QUssQ0FBQztJQUFPO0lBQzdCQyxRQUFRQyxLQUFLLEVBQUU7UUFDWCxNQUFNQyxRQUFRM0I7UUFDYixJQUFHZCxXQUFXMEMsY0FBYyxFQUFFRixTQUFTLEtBQUtBLFFBQVFDLE1BQU1yQixNQUFNLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRW9CLE1BQU0sQ0FBQyxFQUFFLFNBQVNBO1FBQzVHLE9BQU9DLEtBQUssQ0FBQ0QsTUFBTTtJQUN2QjtJQUNBRyxhQUFhckMsSUFBSSxFQUFFO1FBQ2YsT0FBT1EsWUFBWWUsT0FBTyxDQUFDdkI7SUFDL0I7SUFDQXNDLE1BQU1DLE1BQU0sRUFBRTtRQUNWLDJCQUEyQjtRQUMzQixPQUFPQSxPQUFPRCxLQUFLLENBQUM7SUFDeEI7SUFDQVQsS0FBS00sS0FBSyxFQUFFO1FBQ1IsT0FBT0EsTUFBTU4sSUFBSSxDQUFDO0lBQ3RCO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT3BCLFdBQVc7UUFDZCxJQUFJQSxZQUFZLE1BQU07WUFDbEJBLFdBQVcsSUFBSWxCO1FBQ25CO1FBQ0EsT0FBT2tCO0lBQ1g7QUFDSjtBQUNBcEIsY0FBYyxHQUFHRSxRQUNqQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1qYS5qcz8wOTk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nSmEgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuY29uc3QgZGF0YSA9IFtcbiAgICAvLyA0LWthbmEgd29yZHNcbiAgICBcIkFRUkFTUkFHQkFHVUFJUkFIQkFnaEFVUkFkQkFkY0Fub0FNRUFGQkFGQ0JLRkJRUkJTRkJDWEJDREJDSEJHRkJFUUJwQkJwUUJJa0JITkJlT0JnRkJWQ0JoQkJoTkJtT0JtUkJpSEJpRkJVRkJaREJ2RkJzWEJrRkJsY0JqWUJ3REJNQkJUQkJUUkJXQkJXWFhhUVhhUlhRV1hTUlhDRlhZQlhwSFhPUVhIUlhoUlh1UlhtWFhiUlhsWFh3RFhUUlhyQ1hXUVhXR2FCV2FLY2FZZ2FzRmFkUWFsbWFNQmFjQUthUktLQktLWEtLaktRUktEUktDWUtDUktJREtlVktIY0tsWEtqSEtyWU5BSE5CV05hUk5LY05JQk5JT05tWE5zWE5kWE5uQk5NQk5SQk5yWE5XRE5XTU5GT1FBQlFBSFFCclFYQlFYRlFhUlFLWFFLRFFLT1FLRlFOQlFORFFRZ1FDWFFDRFFHQlFHRFFHZFFZWFFwQlFwUVFwSFFMWFFIdVFnQlFoQlFoQ1F1RlFtWFFpRFFVRlFaRFFzRlFkUlFrSFFiUlFsT1FsbVFQRFFqRFF3WFFNQlFNRFFjRlFUQlFUSFFyRERYUURORkRHQkRHUURHUkRwRkRoRkRtWERaWERiUkRNWURSZERUUkRyWFNBaFNCQ1NCclNHUVNFUVNIQlNWUlNoWVNoa1N5UVN1RlNpQlNkY1NvRVNvY1NsbVNNQlNGQlNGS1NGTlNGZFNGY0NCeUNhUkNLY0NTQkNTUkNDckNHYkNFSENZWENwQkNwUUNJQkNJSENlTkNnQkNnRkNWRUNWY0Nta0Ntd0NaWENaRkNkUkNsT0NsbUNsRkNqRENqZENuWEN3QkN3WENjUkNGUUNGakdYaEdOaEdERUdETUdDREdDSEdJRkdnQkdWWEdWRUdWUkdtWEdzWEdkWUdvU0diUkduWEd3WEd3REdXUkdGTkdGTEdGT0dGZEdGa0VBQkVCREVCRkVYT0VhQkVLU0VOQkVOREVZWEVJZ0VJa0VnQkVnUUVnSEVoRkV1ZEV1RkVpQkVpSEVpRkVaREV2QkVzWEVzRkVkWEVkUkVrRkViQkViUkVsRkVQQ0Vma0VGTllBRVlBaFlCTllRZFlEWFlTUllDRVlZb1lnUVlnUll1UlltQ1laVFlkQlliRVlsWFlqUVlSYllXUnBLWHBRb3BRbnBTRnBDWHBJQnBJU3BoTnBkQnBkUnBiUnBjWnBGQnBGTnBGRHBGb3BGckxBRExCdUxYUUxYY0xhRkxDWExFaExwQkxwRkxIWExlVkxoSUxkSExkUkxvRExiUkxyWElBQklCUUlCQ0lCc0lCb0lCTUlCUklYYUlhUklLWUlLUklOQklOdUlDRElHQklJRElJa0lnUkl4Rkl5UUlpSElkUkliWUliUklsSEl3UklNWUljUklSVklUUklGQklGTklGUU9BQk9BRk9CUU9hRk9OQk9OTU9RRk9TRk9DRE9HQk9FUU9wQk9MWE9JQk9JRk9nUU9nRk95UU95Y09tWE9zWE9kSU9rSE9NRU9Na09XV0hCTkhYTkhYV0hOWEhEdUhEUkhTdUhTUkhIb0hoa0htUkhkUkhrUUhsY0hsUkh3QkhXY2dBRWdBZ2dBa2dCTmdCUWdCRWdYT2dZY2dMWGdIamd5UWdpQmdzRmdkYWdNWWdXU2dGUWdGRVZCVFZYRVZLQlZLTlZLRFZLWVZLUlZOQlZOWVZEQlZEeFZTQlZTUlZDalZHTlZMWFZJRlZoQlZoY1ZzWFZkUlZiUlZsUmhCWWhLWWhEWWhHU2h4V2htTmhkYWhka2hiUmhqb2hNWGhUUnhBWHhYU3hLQnhOQnhFUXhlTnhlUXhoWHhzRnhkYnhsSHhqY3hGQnhGTnhGUXhGT3hGb3lOWXlZb3liY3lNWXVCUXVCUnVCcnVETXVDb3VIQnVkUXVra3VvQnVsVnVNWHVGRW1DWW1DUm1wUm1lRG1pTW1qZG1URm1GUWlBRGlCT2lhUmlLUmlOQmlOUmlTRmlHa2lHRmlFUmlwUmlMRmlJRmloWWliSGlqQmlqRWlNWGlXQmlGQmlGQ1VCUVVYRlVhUlVORFVOY1VOUlVORlVEQlVTSFVDRFVHQlVHRlVFcVVMTlVMb1VJUlVlRVVlWVVnQlVoRlV1UlVpRlVzWFVkRlVrSFViQlVqU1VqWVV3WFVNRFVjSFVSZFVUQlVyQlVyWFVyUVpBRlpYWlphUlpLRlpOQlpRRlpDWFpHQlpZZFpwQlpMRFpJRlpIWFpITlplUVpWUlpWRlptWFppQlp2RlpkRlprRlpiSFpiRlp3WFpjQ1pjUlpSQnZCUXZCR3ZCTHZCV3ZDb3ZNWXNBRnNCRHNhUnNLRnNORnNEcnNTSHNTRnNDWHNDUnNFQnNFSHNFZnNwQnNMQnNMRHNJZ3NJUnNlR3NiUnNGQnNGUXNGU2ROQmRTUmRDVmRHSGRZRGRIY2RWYmR5U2R1RGRzWGRsUmR3WGRXWWRXY2RXUmtCTWtYT2thUmtOSWtORmtTRmtDRmtZQmtwUmtlTmtnQmtoVmttWGtzRmtsVmtNQmtXRGtGTm9CTm9hUW9hRm9OQm9OWG9OYW9ORW9TUm9Fcm9ZWG9ZQ29ZYm9wUm9wRm9tWG9qa293WG9yRmJCRWJFSWJkQmJqWWxhUmxERWxNWGxGRGpLampTUmpHQmpZQmpZa2pwUmpMWGpJQmpPRmplVmpiUmp3Qm5YUW5TSG5wRm5MWG5JTm5NQm5UUndYQndYTndYWXdORndRRndTQndHRndMWHdMRHdlTndnQnd1SHdqRHduWE1CWE1wRk1JQk1lTk1USGNhUWNOQmNESGNTRmNDWGNwQmNMWGNMRGNnRmN1RmNuWGN3WGNjRGNUUWNyRlRRRXJYTnJDSHJwRnJnRnJiRnJUSHJGY1dOWVdOYldFSFdNWFdUUlwiLFxuICAgIC8vIDUta2FuYSB3b3Jkc1xuICAgIFwiQUJHSEFCSUpBRUFWQVlKUUFMWkpBSWFSQUhOWEFIZGNBSGJSQVpKTUFaSlJBWlRSQWRWSkFrbG1BYmNOQWpkUkFNblJBTVdZQVdwUkFXZ1JBRmdCQUZoQkFGZGNCTkpCQk5KREJRS0JCUWhjQlFsbUJERUpCWUprQllKVEJwTkJCcEpGQklKQkJJSkRCSWNBQk9LWEJPRUpCT1ZKQk9pSkJPWkpCZXBCQmVMWEJlSUZCZWdCQmdHSkJWSlhCdW9jQmlKUkJVSlFCbFhWQmxJVEJ3TkZCTVlWQmNxWEJUbG1CV05GQldpSkJXblJCRkdIQkZ3WFhLR0pYTkpCWE5aSlhEVFRYU0hTWFNWUlhTbEhYQ0pEWEdRSlhFaFhYWVFKWFliUlhPZlhYZU5jWFZKRlhoUUpYaEVKWGRUUlhqZFhYTWhCWGNRVFhSR0JYVEVCWFRuUVhGQ1hYRk9GWEZnRmFCYUZhQk5KYUJDSmFCcEJhQndYYU5KS2FOSkRhUUlCYURwUmFFUERhSE1GYW1ESmFsRUphTVpKYUZhRmFGTkJhRlFKYUZMRGFGVkhLQkNZS0JFQktCSERLWGFGS1hHZEtYRUpLWHBIS1hJQktYWkRLWHdYS0t3TEtOYWNLTllKS05Kb0tOV2NLREdkS0RUUktDaFhLR2FSS0doQktHYlJLRUJUS0VhUktFUFRLTE1ES0xXUktPSERLVkpjS2RCY0tsSUJLbE9QS0ZTQktGRVBLRnBGTkJOSk5KQlFOQkdITkJFUE5CSFhOQmdGTkJWWE5CWkROQnNYTkJ3WE5OYVJOTkpETk5KRU5OSmtORENKTkRWRE5HSlJOSmlETlpKTk5zQ0pOSkZOTkZTQk5GQ1hORkVQTkZMWE5GSUZRSkJGUUNhUlFKRVFRTEpEUUxKRlFJYVJRT3FYUUhhRlFISFFRVkpYUVZKRFFoTkpRbUVJUVpKRlFzSlhRSnJGUVdiUkRKQUJEQllKRFhORkRYQ1hEWExYRFhaRERYc0pEUXFYRFNKRkRKQ1hERVBrREVxWERZbVFEcFNKRE9Da0RPR1FESEVJRFZKRER1RHVEV0VCREpGZ1NCTkRTQlNGU0JHSFNCSUJTQlRRU0tWWVNKUU5TSlFpU0pDWFNFcVhTSllWU0lpSlNPTVlTSEFIU0hhUVNlQ0ZTZXBRU2VnQlNIZEhTSHJGU2hTSlNKdUhTSlVGU2tOUlNyU3JTV0VCU0ZhSFNKRlFTRkNYU0ZHRFNGWVhTRk9EU0ZnQlNGVlhTRmhCU0Z4RlNGa0ZTRmJCU0ZNRkNBRGRDSlhCQ1hhRkNYS0ZDWE5GQ1hDWENYR0JDWEVKQ1hZQkNYTERDWElCQ1hPUENYSFhDWGdCQ1hoQkNYaUJDWGxEQ1hjSENKTkJDSk5GQ0RDSkNER0JDRFZYQ0RoQkNEaURDREpkQ0NtTkNwSkZDSWFSQ09xWENIQ0hDSFpKQ1ZpSkN1Q3VDbWRkQ0ppRkNkTkJDZEhoQ2xFSkNuVUpDcmVTQ1dsZ0NXVFJDRkJGQ0ZOQkNGWUJDRlZGQ0ZoRkNGZFNDRlRCQ0ZXREdCTkJHQlFGR0pCQ0dCRXFHQnBCR0JnUUdOQkVHTkpZR05rT0dOSlJHRFVGR0pwUUdIYUJHSmVOR0plRUdWQmxHVktqR2lKREd2SkhHc1ZKR2tFQkdNSUpHV2pOR0ZCRkdGQ1hHRkdCR0ZZWEdGcEJHRk1GRUFTSkVBV3BFSk5GRUNKVkVJWFNFSVFKRU9xWEVPY0ZFZU5jRUhFSkVIbEZFSmdGRWhsbUVtREpFbVpKRWlNQkVVcVhFb1NSRVBCRkVQWEZFUEtGRVBTRkVQRUZFUHBGRVBMWEVQSUJFSlBkRVBjRkVQVEJFSm5YRXFsSEVNcFJFRkNYRUZPREVGY0ZZQVNKWUpBRllCYUJZQlZYWVhwRllEaEJZQ0pCWUpHRllZYlJZZU5jWUplVllpSUpZWkpjWXZKZ1l2SlJZSnNYWXNKRllNWU1ZcmVWcEJOSHBCRUpwQndYcFF4RnBZRUpwZU5EcEplRHBlU0ZwZUNIcEhVSnBIYkJwSGNIcG1VSnBpaUpwVUpycHNKdXBsSVRwRmFCcEZRcXBGR0JwRkVmcEZZQnBGcEJwRkxKcEZJRHBGZ0JwRlZYcEZ5UXBGdUZwRmxGcEZqRHBGblhwRndYcEpGTXBGVEJMWENKTFhFRkxYaEZMWFVKTFhiRkxhbG1MTkpCTFNKUUxDTENMR0pCTExESkxIYUZMZU5GTGVTSExlQ1hMZXBGTGhhUkxac0pMc0pETHNKckxvY2FMbExsTE1kYkxGTkJMRlNCTEZFSExGa0ZJQkJGSUJYRklCYVFJQktYSUJTRklCcEhJQkxYSUJnQklCaEJJQnVISUJtWElCaUZJQlpYSUJ2RklCYkZJQmpRSUJ3WElCV0ZJS1RSSVFVSklER0ZJQ2pRSVlTUklJTlhJSmVDSVZhUkltRWtJWkpGSXZKUklzSlhJZENKSUpvUkliQlFJallCSWNxWElURlZJcmVWSUZLRklGU0ZJRkNKSUZHRklGTERJRklCSUpGT0lGZ0JJRlZYSUpGaElGeEZJRm1YSUZkSElGYkJJSkZySUpGV09CR0JPUWZYT09Lak9VcVhPZlhCT3FYRU9jcVhPUlZKT0ZJQk9GbERIQklPSFhpRkhOVFJIQ0pYSElhUkhISkRISEVKSFZiUkhaSllIYklCSFJzSkhSa0RIV2xtZ0JLRmdCU0JnQkNEZ0JHSGdCcEJnQklCZ0JWSmdCdUJnQnZGZ0tEVGdRVlhnRFVKZ0dTSmdPcVhnbVVNZ1pJSmdUVUpnV0lFZ0ZCRmdGTkJnRkRKZ0ZTRmdGR0JnRllYZ0pGT2dGZ1FnRlZYZ0ZoQmdGYkhnSkZXVkpBQlZRS2NWRGdGVk9mWFZlREZWaGFSVm1HZFZpSllWTWFSVkZOSGhCTkRoQkNYaEJFcWhCcEZoQkxYaE5KQmhTSlJoZVZYaGhLRWh4bG1oWklKaGRCUWhrSUpoYk1OaE1VSmhNWkp4TkpneFFVSnhERWt4RGRGeFNKUnhwbG14ZVNCeGVDWHhlR0Z4ZVlYeGVwUXhlZ0J4V1ZjeEZFUXhGTFh4RklCeEZnQnhGeER4Rlp0eEZkY3hGYkJ4RndYeURKWHlEbGN1QVNKdURKcHVESUJ1Q3BKdUdTSnVJSkZ1ZUVGdVpJSnVzSlh1ZFdFdW9JQnVXR0p1RkJjdUZLRXVGTkZ1RlFGdUZESnVGR0p1RlZKdUZVdHVGZEh1RlRCbUJZSm1OSlltUWhrbUxKRG1MSm9tSWRYbWlKWW12SlJtc0pSbWtsbW1NQnltTXVDbWNsbW1jblFpSkFCaUpCTmlKQkRpQlNGaUJDSmlCRUZpQllCaUJwRmlCTFhpQlRIaUpOY2lERWZpQ1pKaUVDSmlKRXFpT2tIaUhLRmllTkRpSEpRaWVRY2llREhpZVNGaWVDWGllR0ZpZUVGaWVJSGllZ0ZpaFVKaXhOb2lvTlhpRmFCaUZLRmlGTkRpRkVQaUZZWGl0Rk9pdEZIaUZnQmlGVkVpRm1YaUZpdGlGYkJpRk1GaUZyRlVDWFFVSW9RVUlKY1VIUUpVZUNFVUh3WFVVSkRVVXFYVWRXY1VjcVhVcm5RVUZORFVGU0hVRkNGVUZFZlVGTFhVdEZPWkJYT1pYU0JaWHBGWlhWWFpFUUpaRUprWnBESlpPcVhaZU5IWmVDRFpVcVhaRkJRWkZFSFpGTFh2QkFGdkJLRnZCQ1h2QkVQdkJwSHZCSUR2QmdGdkJ1SHZRTkp2Rk5GdkZHQnZGSUJ2SkZjc1hDRHNYTFhzWHNYc1hsRnNYY0hzUXFYc0pRRnNFcVhzZUlGc0ZFSHNGakRkQnhPZE5wUmROSlJkRUpiZHBKUmRoWkpkblNKZHJqTmRGTkpkRlFIZEZoTmtOSkRrWWFSa0hOUmtIU1JrVmJSa3VNUmtqU0prY3FEb1NKRm9FaUpvWVpKb09mWG9oRUJvTUdRb2NxWGJCQUZiQlhGYkJhRmJCTkRiQkdCYkJMWGJCVEJiQldEYkdKWWJJSkhiRlFxYkZwUWxEZ1FsT3JGbFZKUmpHRUJqWkpSblh2Sm5YYkJuRWZIbk9QRG5nSlJueGZYblVKV3dYRUp3TnBKd0RwQndFZlh3ckVCTURDSk1ER0hNRElKTUxKRGNRR0RjUXBIY3FYY2NxTkZjcUNYY0ZDSlJCU0JSQkdCUkJFSlJCcFFUQk5GVEJRSlRCcEJUQlZYVEZBQlRGU0JURkNGVEZHQlRGTURyWENKclhMRHJETkpyRWZIckZRSnJGaXRXTmpkV05UUlwiLFxuICAgIC8vIDYta2FuYSB3b3Jkc1xuICAgIFwiQUtMSk1BTk9QRkFTTkpJQUVKV1hBWUpOUkFJSWJSQUljZGFBZUVmREFnaWRSQWRqTllBTVlFSkFNSWJSQUZOSkJBRnBKRkJCSUpZQkRaSkZCU2lKaEJHZEVCQkVKZlhCRUpxWEJFSldSQnBhVUpCTFhyWEJJWUpNQk9jZlhCZUVmRkJlc3RYQmpOSlJCY0RKT0JGRXFYWE52SlJYRE1CaFhDSk5ZWE9BV3BYT05KV1hIREVCWGVJYVJYaFlKRFhaSlNKWE1ESk9YY0FTSlhGVkpYYUJRcVhhQlpKRmFzWGRRYUZTSlFhRkVmWGFGcEpIYUZPcVhLQk5TUktYdkpCS1FKaFhLRUpRSktFSkdGS0lOSkJLSUpqTktnSk5TS1ZFbG1LVmhFQktpSkdGS2xCZ0pLam5VSkt3c0pZS01GSUpLRk5KREtGSUpGS0ZPZlhOSkJTRk5KQkNYTkJwSkZOSkJ2UU5KQk1CTkpMSlhOSk9xWE5KZUNYTkplR0ZOZHNKQ05iVEtGTndYVUpRTkZFUFFEaUpjUURNU0pRU0ZwQlFHTVFKUUplT2NReUNKRVFVSkVCUUpGQnJRRkVKcURYREpGREpYcEJESlhJTURHaUpoRElKR1JESmVZY0RIckRKRFZYZ0ZEa0FXcERrSWdSRGpERXFETXZKUkRKRk5GREpGSUJTS2NsbVNKUU9GU0pRVkhTSlFqRFNKR0pCU0pHSkZTRUNKb1NIRUpxU0pIVEJTSlZKRFNWaUpZU1pKTkJTSnNKRFNGU0pGU0ZFZlhTSkZMWENCVUpWQ0pYU0JDSlhwQkNYVkpYQ0pYc1hDSlhkRkNKTkpIQ0xJSmdDSGlKRkNWTkpNQ2hDSmhDVUhFSkNzSlRSQ0pkWWNDb1FKQ0NGRWZYQ0ZJSmdDRlVKeENGc3RGR0pCYVFHSkJJREdRSnFYR1lKTlJHSkhLRkdlUXFER0hFSkZHSmVMWEdISWlKR0hkQmxHVUpFQkdrSUpUR0ZRUERHSkZFcUVBR2VnRUpJSkJFSlZKWEVoUUpURWlKTmNFSlpKRkVKb0VxRWpERXFFUERzWEVQR0pCRVBPcVhFUGVRRkVmRGlERUpmRUZFZmVwUUVmTWlKRXFYTkJFcURJREVxZVNGRXFWSlhFTXZKUllYTkpEWVhFSkhZS1ZKY1lZSkVCWUplRWNZSlVxWFlGcEpGWUZzdFhwQVpKTXBCU0pGcE5CTkZwZVFQRHBITEpEcEhJSkZwSGdKRnBlaXRGcEhaSkZwSkZBRHBGU0pGcEpGQ0pwRk9xWHBGaXRCcEpGWkpMWElKRkxJSmdSTFZOSldMVkhKTUx3TnBKTEZHSkJMRkxKRExGT3FYTEpGVUpJQkRKWElCR0pCSUpCWVFJSkJJQklCT3FYSUJjcURJRUdKRklMTkpUSUlKRUJJT2lKaElKZU5CSUplSUJJaGlKSUlXb1RSSUpGQUhJSkZwQklKRnVISUZVdEZJSkZUSE9TQllKT0VjcVhPSEVKcU92QnBGT2tWSnJPYkJWSk9uY3FET2NOSmtIaE5KUkh1SEp1SGRNaEJnQlVxWGdCc0pYZ09OSkJnSE5KRGdISEpRZ0plaXRnSHNKWGdKeU5hZ3lESkJnWkpEcmdzVkpRZ2tFSk5na2pTSmdKRkFIZ0ZDSkRnRlp0TVZKWE5GVlhRZlhWSlhESlZYb1FKVlFWSlFWREVmWFZEdkpIVkVxTkZWZVFmWFZIcEpGVkh4ZlhWVkpTUlZWbWFSVmxJSk9oQ1hWSmhIallraHhDSlZoV1ZVSmhXaUpjeEJOSkl4ZUVxRHhmWEJGeGNGRVB4RlNKRnhGWUpYeUJEUUp5ZGFVSnlGT1BEdVlDSll1THZKUnVITEpYdVpKTER1Rk9QRHVGWkpIdUZjcVhtS0hKZG1DUUpjbU9zVkppSkFHRml0TENGaWVPZlhpZXN0WGlaSk1FaWtOSlFpclh6RmlGUXFYaUZJSkZpRlpKRmlGdnRGVUhwSkZVdGVJY1V0ZU9jVVZDSmtVaGRIY1ViRUpFVUpxWFFVTU5KaFVSallrVUZpdEZaREdKSFpKSXhEWkpWSlhaSkZESlpKRnBRdkJOSkJ2QlNKRnZKeEJyc2VRcURzVkZWSmRGTEpEa0VKTkJrbU5KWWtGTEpEb1FKT1BvR3NKUm9FQUhCb0VKZkZiQlFxRGJCWkpIYkZWSlhsRklKQmpZSXJYamVpdGNqakNFQmpXTU5Cd1hRZlh3WE9hRndEc0pYd0NKVFJ3ckNaSk1ETkpRY0RESkZjcURPUFJZaUpGVEJzSlhUUUlKQlRGRWZYVEZMSkRyWEVKRnJFSlhNckZaSkZXRUpkRVdZVGxtXCIsXG4gICAgLy8gNy1rYW5hIHdvcmRzXG4gICAgXCJBQkNERUZBQ05KVFJBTUJESmRBY05KVlhCTE5KRUJYU0lkV1JYRXJOSmtYWURKTUJYWkpDSmFYTU5KYVlLS1ZKS2NLREVKcVhLRGNOSmhLVkpyTllLYmdKVlhLRlZKU0JOQllCd0ROSmVRZlhOSmVFcVhOaEdKV0VOSkZpSlJRbElKYkVRSmZYeERRcVhjZlhRRk5ERUpRRndYVUpEWWNuVUpESklCZ1FESVVKVFJESkZFcURTSlFTSkZTSlFJSkZTT1BlWnRTSkZaSkhDSlhRZlhDVERFcUZHSkJTSkZHSkJPZlhHSkJjcVhHSkhOSkRHSlJMaUpFSmZYRXFFSkZFSlBFRnBCRUpZSkJaSkZZQndYVUpZaUpNRUJZSlpKeVRZVE9OSlhwUU1GWEZwZUdJRGRwSkZzdFhwSkZjUERMQlZTSlJMSFFKcVhMSkZaSkZJSkJOSkRJSkJVcVhJQmtGREpJSkVKUFRJWUpHV1JJSmVRUERJSmVFZkhJSkZzSlhPcUdEU0ZIWEVKcVhnSkNzSkNnR1FKcVhnZFFZSkVnRk1GTkJnSkZjcURWSndYVUpWSkZaSmNoSWdKQ0N4T0VKcVh4T3dYVUp5REpCVlJ1c2Npc2NpSkJpSkJpZVV0cVhpSkZESmtpRnNKWFFVR0VaSmNVSkZzSlhadFhJclhaRFpKRHJaSkZOSkRaSkZzdFh2SkZRcVh2SkZDSkVzSlhRSnFraGtOR0JiREpkVFJiWUpNRUJsRHdYVUpNRUZpSkZjZlhOSkRSY05KV01UQkxKWENcIixcbiAgICAvLyA4LWthbmEgd29yZHNcbiAgICBcIkJyYUZVdEhCRlNKRmRiTkJMSlhWSlFvWUpORUJTSkJFSmZIU0pId1hVSkNKZEFaSk1HamFGVkpYRUpQTkpCbEVKZkZpSkZwRmJGRUpxSUpCVkpDcklCZEhpSmhPUEZDaHZKVkpaSk5KV3hHRk5JRkx1ZUlCUUpxVUhFSmZVRnN0T1pKRHJsWEVBU0pSbFhWSlhTRndWSk5KV0RcIixcbiAgICAvLyA5LWthbmEgd29yZHNcbiAgICBcIlFKRUpOTkpEUUpFSklCU0ZRSkVKeGVnQlFKRUpmSEVQU0pCbVhFSkZTSkNERUpxWExYTkpGUXFYSWNRc0ZOSkZJRkVKcVhVSmdGc0pYSUpCVUpFSmZITkZ2SnhFcVhOSm5YVUpGUXFEXCIsXG4gICAgLy8gMTAta2FuYSB3b3Jkc1xuICAgIFwiSUpCRUpxWFpKXCJcbl07XG4vLyBNYXBzIGVhY2ggY2hhcmFjdGVyIGludG8gaXRzIGthbmEgdmFsdWUgKHRoZSBpbmRleClcbmNvbnN0IG1hcHBpbmcgPSBcIn5+QXpCflh+YX5LTn5RfkR+U35Dfkd+RX5ZfnB+TH5Jfk9+ZUh+Z35Wfmh4eXVtaX5+VX5+Wn5+dn5+c35+ZGtvYmxQamZucXdNY1JUcn5Xfn5+Rn5+fn5+SnRcIjtcbmxldCBfd29yZGxpc3QgPSBudWxsO1xuZnVuY3Rpb24gaGV4KHdvcmQpIHtcbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIuaGV4bGlmeSkoKDAsIGluZGV4X2pzXzIudG9VdGY4Qnl0ZXMpKHdvcmQpKTtcbn1cbmNvbnN0IEtpWW9LdSA9IFwiMHhlMzgxOGRlMzgyODRlMzgxOGZcIjtcbmNvbnN0IEt5b0t1ID0gXCIweGUzODE4ZGUzODI4M2UzODE4ZlwiO1xuZnVuY3Rpb24gdG9TdHJpbmcoZGF0YSkge1xuICAgIHJldHVybiAoMCwgaW5kZXhfanNfMi50b1V0ZjhTdHJpbmcpKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGxvYWRXb3JkcygpIHtcbiAgICBpZiAoX3dvcmRsaXN0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBfd29yZGxpc3Q7XG4gICAgfVxuICAgIGNvbnN0IHdvcmRsaXN0ID0gW107XG4gICAgLy8gVHJhbnNmb3JtcyBmb3Igbm9ybWFsaXppbmcgKHNvcnQgaXMgYSBub3QgcXVpdGUgVVRGLTgpXG4gICAgY29uc3QgdHJhbnNmb3JtID0ge307XG4gICAgLy8gRGVsZXRlIHRoZSBkaWFjcml0aWMgbWFya3NcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxNTRdKV0gPSBmYWxzZTtcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxNTNdKV0gPSBmYWxzZTtcbiAgICAvLyBTb21lIHNpbXBsZSB0cmFuc2Zvcm1zIHRoYXQgc29ydCBvdXQgbW9zdCBvZiB0aGUgb3JkZXJcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxMzNdKV0gPSB0b1N0cmluZyhbMjI3LCAxMzAsIDEzNF0pO1xuICAgIHRyYW5zZm9ybVt0b1N0cmluZyhbMjI3LCAxMjksIDE2M10pXSA9IHRvU3RyaW5nKFsyMjcsIDEyOSwgMTY0XSk7XG4gICAgdHJhbnNmb3JtW3RvU3RyaW5nKFsyMjcsIDEzMCwgMTMxXSldID0gdG9TdHJpbmcoWzIyNywgMTMwLCAxMzJdKTtcbiAgICB0cmFuc2Zvcm1bdG9TdHJpbmcoWzIyNywgMTMwLCAxMzVdKV0gPSB0b1N0cmluZyhbMjI3LCAxMzAsIDEzNl0pO1xuICAgIC8vIE5vcm1hbGl6ZSB3b3JkcyB1c2luZyB0aGUgdHJhbnNmb3JtXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGthbmEgPSB3b3JkW2ldO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdHJhbnNmb3JtW2thbmFdO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBrYW5hID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGthbmE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gU29ydCBob3cgdGhlIEphcGFuZXNlIGxpc3QgaXMgc29ydGVkXG4gICAgZnVuY3Rpb24gc29ydEphcGFuZXNlKGEsIGIpIHtcbiAgICAgICAgYSA9IG5vcm1hbGl6ZShhKTtcbiAgICAgICAgYiA9IG5vcm1hbGl6ZShiKTtcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gTG9hZCBhbGwgdGhlIHdvcmRzXG4gICAgZm9yIChsZXQgbGVuZ3RoID0gMzsgbGVuZ3RoIDw9IDk7IGxlbmd0aCsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkYXRhW2xlbmd0aCAtIDNdO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBkLmxlbmd0aDsgb2Zmc2V0ICs9IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBtYXBwaW5nLmluZGV4T2YoZFtvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgICAgICAgd29yZC5wdXNoKDIyNyk7XG4gICAgICAgICAgICAgICAgd29yZC5wdXNoKChrICYgMHg0MCkgPyAxMzAgOiAxMjkpO1xuICAgICAgICAgICAgICAgIHdvcmQucHVzaCgoayAmIDB4M2YpICsgMTI4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmRsaXN0LnB1c2godG9TdHJpbmcod29yZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdvcmRsaXN0LnNvcnQoc29ydEphcGFuZXNlKTtcbiAgICAvLyBGb3Igc29tZSByZWFzb24ga3lva3UgYW5kIGtpeW9rdSBhcmUgZmxpcHBlZCBpbiBub2RlICghISkuXG4gICAgLy8gVGhlIG9yZGVyIFNIT1VMRCBiZTpcbiAgICAvLyAgIC0ga3lva3VcbiAgICAvLyAgIC0ga2l5b2t1XG4gICAgLy8gVGhpcyBzaG91bGQgaWdub3JlIFwiaWZcIiwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIGhlcmU/P1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChoZXgod29yZGxpc3RbNDQyXSkgPT09IEtpWW9LdSAmJiBoZXgod29yZGxpc3RbNDQzXSkgPT09IEt5b0t1KSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHdvcmRsaXN0WzQ0Ml07XG4gICAgICAgIHdvcmRsaXN0WzQ0Ml0gPSB3b3JkbGlzdFs0NDNdO1xuICAgICAgICB3b3JkbGlzdFs0NDNdID0gdG1wO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIC8vIFZlcmlmeSB0aGUgY29tcHV0ZWQgbGlzdCBtYXRjaGVzIHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZGxpc3Quam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChjaGVja3N1bSAhPT0gXCIweGNiMzZiMDllNmJhYTkzNTc4N2ZkNzYyY2U2NWU4MGIwYzZhOGRhYmRmYmMzYTdmODZhYzBlMmM0ZmQxMTE2MDBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgamEgKEphcGFuZXNlKSBGQUlMRURcIik7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgX3dvcmRsaXN0ID0gd29yZGxpc3Q7XG4gICAgcmV0dXJuIHdvcmRsaXN0O1xufVxubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzktamFdXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0phIGV4dGVuZHMgd29yZGxpc3RfanNfMS5Xb3JkbGlzdCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEphcGFuZXNlIGxhbmd1YWdlIFdvcmRsaXN0LlxuICAgICAqXG4gICAgICogIFRoaXMgc2hvdWxkIGJlIHVubmVjZXNzYXJ5IG1vc3Qgb2YgdGhlIHRpbWUgYXMgdGhlIGV4cG9ydGVkXG4gICAgICogIFtbbGFuZ0phXV0gc2hvdWxkIHN1ZmZpY2UuXG4gICAgICpcbiAgICAgKiAgQF9pZ25vcmU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IHN1cGVyKFwiamFcIik7IH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gbG9hZFdvcmRzKCk7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwICYmIGluZGV4IDwgd29yZHMubGVuZ3RoLCBgaW52YWxpZCB3b3JkIGluZGV4OiAke2luZGV4fWAsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICByZXR1cm4gbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIC8vbG9nZ2VyLmFzc2VydE5vcm1hbGl6ZSgpO1xuICAgICAgICByZXR1cm4gcGhyYXNlLnNwbGl0KC8oPzpcXHUzMDAwfCApKy9nKTtcbiAgICB9XG4gICAgam9pbih3b3Jkcykge1xuICAgICAgICByZXR1cm4gd29yZHMuam9pbihcIlxcdTMwMDBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIGEgYGBMYW5nSmFgYCwgY3JlYXRpbmcgaXRcbiAgICAgKiAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICovXG4gICAgc3RhdGljIHdvcmRsaXN0KCkge1xuICAgICAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgd29yZGxpc3QgPSBuZXcgTGFuZ0phKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuTGFuZ0phID0gTGFuZ0phO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZy1qYS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMYW5nSmEiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsImluZGV4X2pzXzIiLCJ3b3JkbGlzdF9qc18xIiwiZGF0YSIsIm1hcHBpbmciLCJfd29yZGxpc3QiLCJoZXgiLCJ3b3JkIiwiaGV4bGlmeSIsInRvVXRmOEJ5dGVzIiwiS2lZb0t1IiwiS3lvS3UiLCJ0b1N0cmluZyIsInRvVXRmOFN0cmluZyIsIlVpbnQ4QXJyYXkiLCJsb2FkV29yZHMiLCJ3b3JkbGlzdCIsInRyYW5zZm9ybSIsIm5vcm1hbGl6ZSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJrYW5hIiwidGFyZ2V0Iiwic29ydEphcGFuZXNlIiwiYSIsImIiLCJkIiwib2Zmc2V0IiwiayIsImluZGV4T2YiLCJwdXNoIiwic29ydCIsInRtcCIsImNoZWNrc3VtIiwiaWQiLCJqb2luIiwiRXJyb3IiLCJXb3JkbGlzdCIsImNvbnN0cnVjdG9yIiwiZ2V0V29yZCIsImluZGV4Iiwid29yZHMiLCJhc3NlcnRBcmd1bWVudCIsImdldFdvcmRJbmRleCIsInNwbGl0IiwicGhyYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangKo = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = [\n    \"OYAa\",\n    \"ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@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!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6\",\n    \"ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv\",\n    \"AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo\",\n    \"AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg\",\n    \"HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb\",\n    \"AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl\"\n];\nconst codes = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*\";\nfunction getHangul(code) {\n    if (code >= 40) {\n        code = code + 168 - 40;\n    } else if (code >= 19) {\n        code = code + 97 - 19;\n    }\n    return (0, index_js_2.toUtf8String)(new Uint8Array([\n        225,\n        (code >> 6) + 132,\n        (code & 0x3f) + 128\n    ]));\n}\nlet _wordlist = null;\nfunction loadWords() {\n    if (_wordlist != null) {\n        return _wordlist;\n    }\n    const wordlist = [];\n    data.forEach((data, length)=>{\n        length += 4;\n        for(let i = 0; i < data.length; i += length){\n            let word = \"\";\n            for(let j = 0; j < length; j++){\n                word += getHangul(codes.indexOf(data[i + j]));\n            }\n            wordlist.push(word);\n        }\n    });\n    wordlist.sort();\n    // Verify the computed list matches the official list\n    /* istanbul ignore if */ const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */ if (checksum !== \"0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a\") {\n        throw new Error(\"BIP39 Wordlist for ko (Korean) FAILED\");\n    }\n    /* c8 ignore stop */ _wordlist = wordlist;\n    return wordlist;\n}\nlet wordlist = null;\n/**\n *  The [[link-bip39-ko]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangKo extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Korean language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langKo]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"ko\");\n    }\n    getWord(index) {\n        const words = loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords().indexOf(word);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangKo``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangKo();\n        }\n        return wordlist;\n    }\n}\nexports.LangKo = LangKo; //# sourceMappingURL=lang-ko.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1rby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQWtCO0FBQzdDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDLE1BQU1HLE9BQU87SUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxRQUFRO0FBQ2QsU0FBU0MsVUFBVUMsSUFBSTtJQUNuQixJQUFJQSxRQUFRLElBQUk7UUFDWkEsT0FBT0EsT0FBTyxNQUFNO0lBQ3hCLE9BQ0ssSUFBSUEsUUFBUSxJQUFJO1FBQ2pCQSxPQUFPQSxPQUFPLEtBQUs7SUFDdkI7SUFDQSxPQUFPLENBQUMsR0FBR0wsV0FBV00sWUFBWSxFQUFFLElBQUlDLFdBQVc7UUFBQztRQUFNRixDQUFBQSxRQUFRLEtBQUs7UUFBTUEsQ0FBQUEsT0FBTyxJQUFHLElBQUs7S0FBSTtBQUNwRztBQUNBLElBQUlHLFlBQVk7QUFDaEIsU0FBU0M7SUFDTCxJQUFJRCxhQUFhLE1BQU07UUFDbkIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFdBQVcsRUFBRTtJQUNuQlIsS0FBS1MsT0FBTyxDQUFDLENBQUNULE1BQU1VO1FBQ2hCQSxVQUFVO1FBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlYLEtBQUtVLE1BQU0sRUFBRUMsS0FBS0QsT0FBUTtZQUMxQyxJQUFJRSxPQUFPO1lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFHLElBQUs7Z0JBQzdCRCxRQUFRVixVQUFVRCxNQUFNYSxPQUFPLENBQUNkLElBQUksQ0FBQ1csSUFBSUUsRUFBRTtZQUMvQztZQUNBTCxTQUFTTyxJQUFJLENBQUNIO1FBQ2xCO0lBQ0o7SUFDQUosU0FBU1EsSUFBSTtJQUNiLHFEQUFxRDtJQUNyRCxzQkFBc0IsR0FDdEIsTUFBTUMsV0FBVyxDQUFDLEdBQUdyQixXQUFXc0IsRUFBRSxFQUFFVixTQUFTVyxJQUFJLENBQUMsUUFBUTtJQUMxRCxtQkFBbUIsR0FDbkIsSUFBSUYsYUFBYSxzRUFBc0U7UUFDbkYsTUFBTSxJQUFJRyxNQUFNO0lBQ3BCO0lBQ0Esa0JBQWtCLEdBQ2xCZCxZQUFZRTtJQUNaLE9BQU9BO0FBQ1g7QUFDQSxJQUFJQSxXQUFXO0FBQ2Y7Ozs7Q0FJQyxHQUNELE1BQU1iLGVBQWVJLGNBQWNzQixRQUFRO0lBQ3ZDOzs7Ozs7O0tBT0MsR0FDREMsYUFBYztRQUNWLEtBQUssQ0FBQztJQUNWO0lBQ0FDLFFBQVFDLEtBQUssRUFBRTtRQUNYLE1BQU1DLFFBQVFsQjtRQUNiLElBQUdULFdBQVc0QixjQUFjLEVBQUVGLFNBQVMsS0FBS0EsUUFBUUMsTUFBTWYsTUFBTSxFQUFFLENBQUMsb0JBQW9CLEVBQUVjLE1BQU0sQ0FBQyxFQUFFLFNBQVNBO1FBQzVHLE9BQU9DLEtBQUssQ0FBQ0QsTUFBTTtJQUN2QjtJQUNBRyxhQUFhZixJQUFJLEVBQUU7UUFDZixPQUFPTCxZQUFZTyxPQUFPLENBQUNGO0lBQy9CO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0osV0FBVztRQUNkLElBQUlBLFlBQVksTUFBTTtZQUNsQkEsV0FBVyxJQUFJYjtRQUNuQjtRQUNBLE9BQU9hO0lBQ1g7QUFDSjtBQUNBZixjQUFjLEdBQUdFLFFBQ2pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLWtvLmpzP2ZhNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdLbyA9IHZvaWQgMDtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaGFzaC9pbmRleC5qc1wiKTtcbmNvbnN0IGluZGV4X2pzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5kZXguanNcIik7XG5jb25zdCB3b3JkbGlzdF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3QuanNcIik7XG5jb25zdCBkYXRhID0gW1xuICAgIFwiT1lBYVwiLFxuICAgIFwiQVRBWm9BVEJsM0FUQ1RyQVRDbDhBVERsb0FUR2czQVRIVDhBVEpUOEFUSmwzQVRMbHZBVExuNEFUTVQ4QVRNWDhBVE1ib0FUTWdvQVRvTGJBVG9NVEFUckhnQVR2SG5BVDNBbkFUM0piQVQzTVRBVDhEYkFUOEpUQVQ4TG1BVDhNWUFUOE1iQVQjTG5BVUhUOEFVSFp2QVVKWHJBVUpYOEFVTG5yQVhKbnZBWExVb0FYTGd2QVhNbjZBWFJnM0FYck1iQVgzSlRBWDNRYkFZTG4zQVpMZ3ZBWnJTVUFadkFjQVo4QWFBWjhBYkFaOEFuQVo4SG5BWjhMZ0FaOE1ZQVo4TWdBWjhPbkFhQWJvQWFEVHJBYUZUckFhSlRyQWFKYm9BYUxWb0FhTVh2QWFPbDhBYVNlb0FiQVVvQWJBZzhBYkFsNEFiR25yQWJNVDhBYk1YckFiTW40QWJRYjhBYlNWOEFidlJsQWI4QVVBYjhBbkFiOEhnQWI4SlRBYjhOVEFiOFJiQWNHYm9BY0xudkFjTVQ4QWNNWDhBY1NUb0FjckFhQWNyRm5BYzhBYkFjOE1nQWZHZ3JBZkhib0FmSm52QWZMVjhBZkxrb0FmTVQ4QWZNbm9BZlFiOEFmU2NyQWZTZ3JBZ0FaOEFnRmwzQWdHWDhBZ0hadkFnSGdyQWdKWG9BZ0pYOEFnSmJvQWdMWm9BZ0xuNEFnT1g4QWdvQVRBZ29BbkFnb0NVQWdvSmdBZ29MWEFnb01ZQWdvU2VBZ3JEVUFnckpUQWhyRm5BaHJMakFoclFnQWpBZ29BakpuckFrTVg4QWtPbm9BbENUdkFsQ1Y4QWxDbHZBbEZnNEFsRmw2QWxGbjNBbG9TbkFsckFYQWxyQWZBbHJGVUFsckZiQWxyR2dBbHJPWEFsdktuQWx2TVRBbDNBYkFsM01uQW5BVHJBbkFjckFuQ1ozQW5DbDhBbkRnOEFuRmJvQW5GbDNBbkhYNEFuSGJyQW5IZ3JBbklsM0FuSmd2QW5MWG9BbkxYNEFuTGJyQW5MZ3JBbkxockFuTVhvQW5NZ3JBbk9uM0FuU2JyQW5TZW9BbnZMbkFuM09uQ1RHZ3ZDVFNsdkNUdkFVQ1R2S25DVHZOVENUM0NaQ1QzR1VDVDNNVENUOEhuQ1VDWnJDVUxmOENVTG52Q1UzSG5DVTNKVUNZNk5VQ2JEYjhDYkZab0NiTG5yQ2JvT1RDYm9TY0NickZuQ2J2TG5DYjhBZ0NiOEhnQ2IkTG5Da0xmb0NsQm4zQ2xvRFVEVEhUOERUTGwzRFRTVThEVHJBYURUckxYRFRyTGpEVHJPWURUck9nRFR2RlhEVHZGbkRUM0hVRFQzTGZEVUNUOURVRFQ0RFVGVm9EVUZWOERVRmtvRFVHZ3JEVUpuckRVTGw4RFVNVDhEVU1YckRVTVg0RFVNZzhEVU9Vb0RVT2d2RFVPZzhEVVNUb0RVU1o4RGJEWG9EYkRnb0RiR1Q4RGJKbjNEYkxnM0RiTG40RGJNWHJEYk1nOERiT1RvRGJvSlhHVENsdkdURFQ4R1RGWnJHVExWb0dUTGx2R1RMbDNHVE1nOEdUT1R2R1RTbHJHVG9DVUdUckRnR1RySllHVHJTY0dUdExuR1R2QW5HVHZRZ0dVQ1pyR1VEVHZHVUZab0dVSFhyR1VMbnZHVU1UOEdVb01nR1hvTG5HWHJNWEdYck1uR1h2Rm5HWUxudkdaT252R1p2T25HWjhMYUdaOExtR2JBbDNHYkRZdkdiRGxyR2JIWDNHYkpsNEdiTFY4R2JMbjNHYk1uNEdib0pUR2JvUmZHYnZGVUdiM0dVR2I0Sm5HZ0RYM0dnRmwkR2dKbHJHZ0xYNkdnTFpvR2dMZjhHZ09Yb0dnckFnR2dySlhHZ3JNWUdnclNjR2d2QVRHZ3ZPWUduQWdvR25KZ3ZHbkxab0duTGczR25MbnJHblFuOEduU2JyR25yTWdIVENsdkhURFRvSFRGVDNIVFFUOEhUb0pUSFRvSmdIVHJEVUhUck1uSFR2RllIVHZSZkhUOE1uSFQ4U1VIVUFaOEhVQmI0SFVEVHZIVW9NWUhYRmw2SFhKWDZIWFFsckhYckFVSFhyTW5IWHJTYkhYdkZZSFh2S1hIWDNMakhYM01lSFl2UWxIWnJTY0hadkRiSGJBY3JIYkZUM0hiRmwzSGJKVDhIYkxUckhiTVQ4SGJNWHJIYk1ickhiUWI4SGJTWDNIYm9EYkhib0pUSGJyRlVIYnJIZ0hickpUSGI4SlRIYjhNbkhiOFFnSGdBbHJIZ0RUM0hnR2dySGdIZ3JIZ0pUckhnSlQ4SGdMWEBIZ0xuckhnTVQ4SGdNWDhIZ01ib0hnT25ySGdRVG9IZ1JnM0hnb0hnSGdyQ2JIZ3JGbkhnckxWSGd2QWNIZ3ZBZkhuQWxvSG5DVHJIbkNudkhuR1RySG5HWjhIbkdudkhuSlQ4SG5MZjhIbkxrdkhuTWc4SG5SVHJJVHZGVUlUdkZuSlRBWHJKVENWOEpURlQzSlRGVDhKVEZuNEpUR2d2SlRIVDhKVEpUOEpUSlh2SlRKbDNKVEpudkpUTFg0SlRMZjhKVExodkpUTVQ4SlRNWHJKVE1uckpUT2JySlRRVDhKVFNsdkpUOERVSlQ4RmtKVDhNVEpUOE9YSlQ4T2dKVDhRVUpUOFJmSlVIWm9KWEZUNEpYRmxySlhHWjhKWEduckpYTFY4SlhMZ3ZKWE1Yb0pYTVgzSlhOYm9KWFBsdkpYb0pUSlhvTGtKWHJBWEpYckhVSlhySmdKWHZKVEpYdk9uSlg0S25KWUFsM0pZSlQ4SllMaHZKWVFUb0pZclFYSlk2TlVKYkFsM0piQ1pySmJEbG9KYkdUOEpiR2dySmJKWHZKYkpib0piTGY4SmJMaHJKYkxsM0piTW52SmJSZzhKYlNaOEpib0RiSmJyQ1pKYnJTVUpiM0tuSmI4TG5KZlJuOEpnQVhySmdDWnJKZ0RUckpnR1pySmdHWjhKZ0hUb0pnSlQ4SmdKWG9KZ0pndkpnTFg0SmdMWjNKZ0xaOEpnTG40SmdNZ3JKZ01uNEpnT2d2SmdQWDZKZ1JudkpnU1RvSmdvQ1pKZ29KYkpnb01ZSmdySlhKZ3JKZ0pnckxqSmc2TVRKbENuM0psR2d2SmxKbDhKbDRBbkpsOEZuSmw4SGdKbkFUb0puQVRySm5BYnZKbkRVb0puR25ySm5KWHJKbkpYdkpuTGh2Sm5MbnJKbkxudkpuTVRvSm5NVDhKbk1YdkpuTVgzSm5NZzhKbk1sckpuTW40Sm5PWDhKblNUNEpuU1gzSm5vQWdKbm9Bbkpub0pUSm5vT2JKbnJBYkpuckFrSm5ySG5KbnJKVEpuckpZSm5yT1lKbnJTY0pudkNVSm52RmFKbnZKZ0pudkpuSm52T1lKbnZRVUpudlJVSm4zRm5KbjNKVEtuRmwzS25MVDZMVERsdkxUTW5vTFRPbjNMVFJsM0xUU2I0TFRTbHJMVG9BbkxUb0pnTFRyQVVMVHJBY0xUckNVTFRySGdMVHJNZ0xUM0puTFVMbnJMVU1YOExVb0pnTFZBVHJMVkRUckxWTGI4TFZvSmdMVjhNZ0xWOFJUTFhEZzNMWEZsckxYckNuTFhyTFhMWDNHVExYNEdnTFg0T1lMWkFYckxaQWNyTFpBZ3JMWkFockxaRFh5TFpEbHJMWkZickxaRmwzTFpKWDZMWkpYOExaTGM4TFpMbnJMWlNVOExab0pUTFpvSm5MWnJBZ0xackFuTFpySllMWnJMVUxack1nTFpyU2tMWnZBbkxadkdVTFp2SmVMWnZPVExaM0ZaTFo0SlhMWjhTVExaOFNjTGFBVDNMYUFsM0xhSFQ4TGFKVHJMYUpUOExhSlhyTGFKZ3ZMYUpsNExhTFZvTGFNWHJMYU1YdkxhTVg4TGJDbHZMYkZUb0xiSGxyTGJKbjRMYkxaM0xiTGh2TGJNWHJMYk1ub0xidlNVTGNMbnJMYzhIbkxjOE1UTGRyTW5MZUFnb0xlT2d2TGVPbjNMZkFsM0xmTG52TGZNbDNMZk9YOExmOEFuTGY4SlhMZjhMWExnSlRyTGdKWHJMZ0psOExnTVg4TGdSWnJMaENUb0xockFiTGhyRlVMaHJKWExodkpZTGpIVHJMakhYNExqSlg4TGpMaHJMalNYM0xqU1o0TGtGWDRMa0daOExrR2d2TGtKVHJMa01Yb0xrU1RvTGtTVThMa1NaOExrb09ZTGwzRmZMbDNNZ0xtQVpyTG1DYnJMbUdnckxtSGJvTG1Kbm9MbUpuM0xtTGZvTG1MaHJMbVNUb0xuQVg2TG5BYjZMbkNaM0xuQ2IzTG5EVHZMbkRiOExuRmwzTG5HbnJMbkhadkxuSGd2TG5JVHZMbkpUOExuSlg4TG5KbHZMbkxmOExuTGc2TG5MaHZMbkxub0xuTVhyTG5NZzhMblFsdkxuU2JyTG5yQWdMbnJBbkxuckRiTG5yRmtMbnJKZExuck1VTG5yT1lMbnJTVExudkFuTG52RFVMbnZIZ0xudk9ZTG52T25MbjNHZ0xuNERVTG40SlRMbjRKbk1UQVpvTVRBbG9NVERiOE1URlQ4TVRKbm9NVEpuck1UTFpyTVRMaHJNVExrdk1UTVg4TVRSVHJNVG9BVE1UckRuTVRyT25NVDNKbk1UNE1uTVQ4RlVNVDhGYU1UOEZsTVQ4R1RNVDhHYk1UOEduTVQ4SG5NVDhKVE1UOEpiTVQ4T1RNVUNsOE1VSlRyTVVKVThNVU1YOE1VUlRyTVVTVG9NWEFYNk1YQWI2TVhDWm9NWEZYck1YSFhyTVhMZ3ZNWE9nb01YckFVTVhyQW5NWHJIZ01YckpZTVhySm5NWHJNVE1Yck1nTVhyT1lNWHJTWk1YclNnTVh2RFVNWHZPVE1YM0pnTVgzT1RNWDRKbk1YOERiTVg4Rm5NWDhIYk1YOEhnTVg4SG5NWDhMYk1YOE1uTVg4T25NWUFiOE1ZR2JvTVlIVHZNWUhYNE1ZTFRyTVlMbnZNWU1Ub01ZT2d2TVlSZzNNWVNUck1iQVRvTWJBWHJNYkFsM01iQW44TWJHWjhNYkpUOE1iSlhyTWJNWHZNYk1YOE1iTW5vTWJyTVVNYjhBZk1iOEZiTWI4RmtNY0pYb01lTG5yTWdGbDNNZ0dUdk1nR1hvTWdHZ3JNZ0duck1nSFQ4TWdIWnJNZ0pub01nTG5yTWdMbnZNZ01UOE1nUVVvTWdySG5NZ3ZBbk1nOEhnTWc4SllNZzhMZk1sb0puTWw4QVRNbDhBWE1sOEpZTW5BVG9NbkFUNE1uQVo4TW5BbDNNbkFsNE1uQ2w4TW5IVDhNbkhnOE1uSm5vTW5MWm9Nbkxock1uTVhvTW5NWDNNbk1uck1uT2d2TW5yRmJNbnJGZk1uckZuTW5yTlRNbnZKWE5UTWw4T1RDVDNPVEZWOE9URm4zT1RIWnZPVEpYck9UT2wzT1QzQVRPVDNKVU9UM0xaT1QzTGVPVDNNYk9UOEFUT1Q4QWJPVDhBZ09UOE1iT1VDWHZPVU1YM09YSFh2T1hMbDNPWHJNVU9YdkRiT1g2TlVPWDhKYk9ZRlpvT1lMYnJPWUxrb09ZTWc4T1lTWDNPYkhUck9iSFQ0T2JKZ3JPYkxock9iTVgzT2JPWDhPYjhGbk9lQWxyT2VKVDhPZUpYck9lSm5yT2VMVG9PZU1iOE9nSlhvT2dMWG9PZ01uck9nT1hyT2dPbG9PZ29BZ09nb0piT2dvTVlPZ29TVE9nOEFiT2pMWDRPak1ub09qU1Y4T25MVm9PbnJBZ09uM0RVUFhRbHJQWHZGWFBidkZUUGRBVDNQbEZuM1BudkZiUVRMbjRRVG9BZ1FUb01UUVVMVjhRVVJnOFFVb0puUVhDWHZRYkZiclFiOEFhUWI4QWNRYjhGYlFiOE1ZUWI4U2NRZUFsclFlTGhyUWpBbjNRbEZYb1Fsb0pnUWxvU25SVExudlJUckdVUlRySlRSVUpaclJVb0psUlVyUW5SWnJMbVJack1uUlpyU25SWjhBVFJaOEpiUlo4U2NSYk1UOFJiU1QzUmZHWnJSZk1YOFJmTWdyUmZTWnJSbkFiclJuR1Q4Um52SmdSbnZMZlJudk1UUm44QWFTVENsdlNUSmdyU1RPWHJTVFJnM1NUUm52U1RvQWNTVG9BZlNUb0FuU1RvSG5TVG9MalNUb01UU1RyQWFTVHJFVVNUM0JZU1Q4QWdTVDhMbVNVQVp2U1VBZ3JTVURUNFNVRFQ4U1VHZ3ZTVUpYb1NVSlh2U1VMVHJTVThKVFNVOExqU1Y4QW5TVjhKZ1NYRlRvU1hMZjhTWXZBblNackRVU1pyTVVTWnJNblNaOEhnU1o4SlRTWjhKZ1NaOE1ZU1o4UVVTYVFVb1NiQ1QzU2JIVG9TYlFZdlNiU2w0U2JvSm5TYnZGYlNiOEhiU2I4SmdTYjhPVFNjR1pyU2NIZ3JTY0pUdlNjTVQ4U2NTVG9TY29IYlNjck1UU2N2QW5TZUFaclNlQWNyU2VIYm9TZUpVb1NlTGhyU2VNVDhTZU1YclNlNkpnU2dIVHJTa0pub1NrTG52U2s4Q1VTbEZsM1NsclNuU2w4R25TbUFib1NtR1Q4U21KVThcIixcbiAgICBcIkFUTG5EbEFUckFab0FUckpYNEFUck1UOEFUck1YNEFUclJUckFUdkRsOEFUdkpVb0FUdk1sOEFUM0FUb0FUM01YOEFUOENUM0FUOERUOEFUOEhackFUOEhnb0FVQWdGbkFVQ1RGbkFYb01YOEFYckFUOEFYckdndkFYckpYdkFYck9nb0FYdkxsM0FadkFnb0FadkZickFadkpYb0FadkpsOEFadkpuM0Fadk1YOEFadlNickFaOEZab0FaOExaOEFaOE1VOEFaOE9UdkFaOFNWOEFaOFNYM0FiQWdGWkFib0pub0Fidkdib0FiOEFUckFiOEFab0FiOEFnckFiOEFsNEFiOERiOEFiOEpub0FiOExYNEFiOExackFiOExockFiOE1UOEFiOE9Vb0FiOFFiOEFiOFNUOEFjckFVb0FjckFjOEFjckNaM0FjckZUM0FjckZackFjckpsNEFjckpuM0Fjck1YM0Fjck9UdkFjOEFaOEFjOE1UOEFmQWNKWEFnb0ZuNEFnb0dndkFnb0duckFnb0xjOEFnb01Yb0FnckxuckFrclNaOEFsRlhDVEFsb0hib0FsckhickFsckxockFsckxrb0FsM0NackFsM0xVb0FsM0xackFuckFsNEFuck1UOEFuM0hUNEJUM0lUb0JYNE1udkJiIUxuJENUR1hNbkNUb0xaNENUckhUOENUM0pUckNUM1JackNUI0dUdkNVNkdndkNVOERiOENVOEdackNVOEhUOENib0xsM0NickdnckNick1VOENiOERUM0NiOEduckNiOExYNENiOE1UOENiOE9ickNnckdndkNncktYNENsOEZab0RUckFidkRUckRib0RUckdUNkRUckpnckRUck1YM0RUclJackRUclJnOERUdkFWdkRUdkZab0RUM0RUOERUM0xuM0RUNEhackRUNE1UOERUOEFsckRUOE1UOERVQWtHYkRVRGJKbkRZTG5RbERiRFVPWURiTVRBbkRiTVhTbkRib0FUM0Rib0ZuNERib0xudkRqNkpUckdUQ2dGVEdUR2dGbkdUSlRNbkdUTG5QbEdUb0pUOEdUckNUM0dUckxWb0dUckxudkdUck1YM0dUck1ib0dUdktsM0daQ2xGbkdackRUM0daOERUckdaOEZaOEdaOE1YdkdaOE9uOEdaOFNUM0diQ25RWEdiTWJGbkdib0Zib0dib0pnM0dib01Yb0diM0pUdkdiM0pib0diM01uNkdiM1FiOEdnRFhMakdnTW5BVUdnckRsb0dnckhYNEdnclNUb0dndkFYckdndkFadkdndkZickdndkxsM0dndk1udkduRG5MWEduckFUckduck1ib0dudUxsM0hUQVRNbkhUQWdDbkhUQ1RDVEhUckdUdkhUckhUdkhUckpYOEhUckxsOEhUck1UOEhUck1nb0hUck9UckhUdU9uM0hUdkFackhUdkRUdkhUdkdib0hUdkpVOEhUdkxsM0hUdk1YckhUdlFiNEhUNEdUNkhUNEpUOEhUNEpiI0hUOEFsM0hUOEdackhUOEdnckhUOEhYNEhUOEpiOEhUOEpub0hUOExUckhUOExndkhUOFNUb0hUOFNWOEhVb0pVb0hVb0pYOEhVb0xuckhYckxab0hYdkFsM0hYM0xuckhYNEZrdkhYNExockhYNE1Yb0hYNE9ub0hackFaOEhackRiOEhackdaOEhackpuckhadkdaOEhadkxudkhaOEpudkhaOExockhiQ1hKbEhiTVRBbkhib0psNEhicExsM0hickpYOEhickxuckhick1udkhidlJZckhnb1NUckhnckZWOEhnckdaOEhnckpYb0hnclJudkhndkJiIUhndkdUckhndkhYNEhndkhuIUhndkxUckhndlNVOEhuRG5MYkhuRmJKYkhudkRuOEhuNkdndkhuIUJUdkpUQ1RMbkpUUWdGbkpUckFudkpUckxYNEpUck9Vb0pUdkZuM0pUdkxuckpUdk5Ub0pUM0Fnb0pUM0puNEpUM0xodkpUM09ickpUOEFjckpUOEFsM0pUOEpUOEpUOEpub0pUOExYNEpUOExuckpUOE1YM0pUOFJnM0pUOFNjOEpVb0JUdkpVOEFUb0pVOEdaOEpVOEdndkpVOEpUckpVOEpYckpVOEpuckpVOExudkpVOFNjdkpYSG5KbEpYckdndkpYckpVOEpYckxockpYck1UOEpYck1YckpYclFVb0pYdkNUdkpYdkdaOEpYdkdnckpYdlFUOEpYOEFiOEpYOERUOEpYOEdaOEpYOEhadkpYOExuckpYOE1UOEpYOE1Yb0pYOE1udkpYOFNUM0pZR25DVEpiQWtHYkpiQ1RBbkpiTFRBY0pib0RUM0pib0xiNkpickFudkpickNuM0pickRsOEpickdib0picklab0pickpudkpick1udkpiclFiNEpiOFJackplQWJBbkpnSm5GYkpnU2NBbkpnckFUckpndkhaOEpndk1uNEpsSmxGYkpsTGlRWEpsTGpPbkpsUmJPbEpsdk5Yb0psdlJsM0psNEFjckpsOEFVb0psOE1uckpuRm5NbEpuSGdHYkpub0RUOEpub0ZWOEpub0dndkpub0lUOEpub1FUb0pub1JnM0puckNaM0puckdnckpuckhUdkpuckxmOEpuck9YOEpudkFUM0pudkZab0pudkdUOEpudkpsNEpudk1UOEpudk1YOEpudk9YckpudlBYNkpudlNYM0pudlNackpuM01UOEpuM01YOEpuM1JUckxUQVRLbkxUSm5MVExUTVhLbkxUUlRRbExUb0diOExUckFaOExUckNaOExUckRiOExUckhUOExUM1BYNkxUNEZab0xUJENUdkxUJEdnckxVdkhYM0xWb0FUckxWb0Fnb0xWb0pib0xWb01YM0xWb1JnM0xWOENaM0xWOEZab0xWOEdUdkxYckRYb0xYckZickxYdkFndkxYdkZsckxYdkxsM0xYdlJuNkxYNE1iOExYOEdUOExZQ1hNbkxZck1uckxab1NUdkxackFadkxackFsb0xackZUb0xackpYdkxackpib0xackpsNExackxuckxack1UOExack9ndkxaclJudkxaclNUNExadk1YOExadlNsdkxaOEFnb0xaOENUM0xaOEpUOExaOExWOExaOExab0xaOExnOExaOFNWOExaOFNickxaJEhUOExaJE1uNExhNkNUdkxiRmJNbkxiUllGVExiU25GWkxib0pUOExickFUOUxickdiM0xiclFiOExjckpYOExjck1YckxlckhUdkxlckpickxlck5ib0xnckRiOExnckdaOExnckhUckxnck1YckxnclNVOExndkpUckxndkxsM0xnNkxsM0xockxuckxock1UOExodkFsNExpTG5RWExrb0Fnckxrb0pUOExrb0puNExsclNVOExsM0Zab0xsM0hUckxsM0pYOExsM0pub0xsM0xUb0xtTGVGYkxuRFVGYkxuTFZBbkxuckFUckxuckFab0xuckFiOExuckFsckxuckdndkxuckpVOExuckxackxuckxockxuck1iOExuck9YckxuclNaOExudkFiNExudkRUckxudkRsOExudkhUckxudkhickxudkpUOExudkpVOExudkpickxudkxodkxudk1YOExudk1iOExudk5ub0xudlNVOExuM0FsM0xuNEZab0xuNEdUNkxuNEpndkxuNExockxuNE1UOExuNFNUb01Ub0Nack1Ub0pYOE1Ub0xYNE1Ub0xmOE1Ub1JnM01UckVsb01UdkdiNk1UM0JUck1UM0xiNk1UOEFjck1UOEFnck1UOEdack1UOEpub01UOExuck1UOE1YM01VT1VBbk1YQWJGbk1Yb0Fsb01Yb0pYOE1Yb0xmOE1Yb0xsOE1YckFiOE1YckRUdk1YckdUOE1Yckdnck1YckhUck1YckxmOE1Yck1VOE1Yck9Ydk1YclFiOE1YdkdUOE1YdkhUck1YdkxWb01YM0FYM01YM0puM01YM0xock1YM01YM01YNEFsck1YNE9ib01YOEdUdk1YOEdack1YOEdnck1YOEpUOE1YOEpYOE1YOExock1YOE1UOE1ZRFVGYk1ZTWdEYk1iR25GZk1idkxYNE1idkxsM01iOE1iOE1iOFNUNE1nR1hDbk1nOEFUck1nOEFnb01nOENack1nOERUck1nOERib01nOEhUck1nOEpnck1nOExUOE1sb0pYb01sOEFock1sOEpUOE1uTGdBVU1ub0pYck1ub0xYNE1ub0xock1ub01UOE1uckFsNE1uckRiOE1uck9Udk1uck9ndk1uclFiOE1uclNVOE1udkdnck1udkhaOE1uM01Ub01uNERUck1uNExUck1uNE1nOE5uQlhBbk9URlRGbk9Ub0FUb09Uckdndk9UckpYOE9UM0pYb09UNk1Uck9UOEdnck9UOEhUcE9UOE1Ub09Vb0hUOE9Vb0pUOE9Vb0xuM09YckFnb09YckRnOE9Yck1UOE9YdlNUb09YNkNUdk9YOENack9YOE9nck9iNkhndk9iOEFUb09iOE1UOE9jdkxaOE9ndkFsck9ndkhUdk9ndkpUck9ndkpuck9ndkxack9ndkxuNE9ndk1UOE9ndlJUck9nOEFab09nOERidk9uck9Yb09udkpuNE9udkxodk9udlJUck9uM0dnb09uM0pudk9uNkpidk9uOE9UclBUR1lGVFBiQm5GblBiR25EblBnRFlRVFBsckFudlBsckVUdlBsckxudlBsck1YdlBsdkZYNFFUTVRBblFUckpVOFFZQ25KbFFZSmxRbFFiR1RRYlFiOEpuclFiOExab1FiOExudlFiOE1UOFFiOE1sOFFiOFNUNFFsb0FsNFFsb0hadlFsb0pYOFFsb01uOFFuSlpPbFJUckFadlJUckRUclJUdkpuNFJUdkxodlJUNEpiOFJackFaclJaOEFrclJaOEpVOFJaOExWOFJaOExudlJiSmxRWFJnM0dib1JnM01udlJnOEFaOFJnOEpib1JnOEpsNFJuTFRDYlJudkZsM1JudlFiOFNUb0FsNFNUb0NaclNUb0Zab1NUb0hYclNUb0pVOFNUb0pndlNUb0psNFNUb0xoclNUb01YM1NUckFsdlNUckNUOVNUckNnclNUckdnclNUckhYclNUckhib1NUckpub1NUck5ib1NUdkxuclNUNEFab1NUOEFiOFNUOEpUOFNVb0puM1NVNkhaI1NVNkpUdlNVOERiOFNVOEhib1NVOExnclNWOEpUOFNackFjclNackFsM1NackpUOFNackpudlNack1UOFNadkxVb1NaNEZab1NaOEpub1NaOFJaclNjb0xuclNjb01UOFNjb01YOFNjckFUNFNjckFaOFNjckxaOFNjckxrdlNjdkRiOFNjdkxmOFNjdk5Ub1NnckZaclNodktuclNsb0hVb1Nsb0xuclNsck1Yb1NsOEhnclNtckpVb1NuM0JYNlwiLFxuICAgIFwiQVRGbE9uM0FUTGdyRFlBVDRNVEFuQVQ4TFRNbkFZSm5SVHJBYkdnSm5yQWJMVjhMbkFidk5UQW5BZUZiTGczQWdPWU1Yb0FsUWJGYm9BbkRib0FmQW5KZ29KVEJUb0RnQW5CVUpiQWwzQmJvRFVBbkNURGx2TG5DVEZUclNuQ1lvUVRMbkRUd0FiQW5EVURUclNuRFVIZ0hnckRYOExYRm5EYkpYQWNyRVR2TFRMbkdURlRRYnJHVE1uR1RvR1QzRFVGYkdVSmxQWDNHYlFnOExuR2JvSmJGbkdiM0dnQVlHZ0FnOFNjR2dNYkFYckdndkFiQW5HbkpUTG52R252QVRGZ0hURFQ2QVRIVHJEbEpuSFlMbk1uOEhaclNiSlRIWjhMVEZuSGJGVEpVb0hnU2VNVDhIZ3JMakFuSGd2QWJBbkhsRlVyRGxIbkRndkFuSG5IVEZUM0huUVRHbnJKVEFhTVh2SlRHYkNuM0pUT2dyQW5KWHZBWE1uSmJNZzhTbkpiTW5SZzNKYjhMVE1uSm5BbDNPbkpuR1lyUWxKbkpsUVkzTFREbENuM0xUSmpMZzNMVExndkZYTFRNZzNHVExWOEhVT2dMWEZaTGczTFhOWHJNbkxYOFFYRm5MWDlBbE1ZTFlMWFBYckxaQWJKVThMWkRVSlU4TFpNWHJTbkxaJEFnRm5MYVBYckRVTGJGWXJNbkxiTW44TFhMYm9KZ0pnTGVGYkxnM0xnTFpyU25MZ09ZQWdvTGhyUm5KbExrQ1RyU25Ma09uTGhyTG5GWCVBWUxuRlpvSlhMbkhUdkpiTG5MbG9BYk1UQVRMZjhNVEhnSm4zTVRNWHJBWE1UM01URm5NVUlUdkZuTVhGWCVBWU1YTVh2RmJNWHJGVERiTVlBY01YM01iTGY4U25NYjhKYkZuTWdNWHJNVE1ndkFYRm5NZ3ZHZ0NtTW5BbG9Tbk1uRm5KVHJPWHZNWFNuT1g4SFRNbk9iSlQ4U2NPYkxaRmwzT2JNWENab1BUTGdyUVhQVUZub1FYUFUzUlhKbFBYM1JrUVhQYnJKWFFsUGxySmJGblFVQWhyRGJRWEduQ1h2UVlMbkhsdlFiTGZMbnZSVE9ndkpiUlhKWXJRbFJZTG5yUWxSYkxuclFsUmxGVDhKbFJsRm5yUVhTVENsQ24zU1RIVHJBblNUTFpRbHJTVE1uR1RyU1RvSGdHYlNUckdURG5TVHZHWENuU1QzSGdGYlNVM0hYQVhTYkFuSm4zU2JGVDhMblNjTGZMbnZcIixcbiAgICBcIkFUM0pnSlg4QVQ4RlpvU25BVDhKZ0ZWOEFUOExockRiQVo4SlQ4RGJBYjhHZ0xockFiOFNrTG52QWU4TVQ4U25BbE1ZSlhMVkFsM0dZRFR2QWwzTGZMbnZCVURUdkxsM0NUT24zSFRyQ1QzRFVHZ3JDVThNVDhBYkNiRlRySlVvQ2dyRGI4TVREVExWOEpYOERUTG5MWFFsRFQ4TFpyU25EVVFiOEZaOERVU1Q0Sm52RGI4U2NPVW9EajZHYkpsNEdUTGZDWU1sR1RvQVh2Rm5HYm9BWHZMbkdnQWNySm4zR2d2Rm5TVG9HbkxmOEpudkduI0hURFRvSFRMbkZYSmxIVHZBVEZUb0hUdkhURFRvSFR2TVRBZ29IVDNTVENsdkhUNEFsRmw2SFQ4SFREVG9IVW9EZ0pUckhVb1NjTVgzSGJSWnJNWG9IYm9KZzhMVEhnRGI4SlRySGdNVG9MZjhIZ3ZMbkxub0huSG4zSFQ0SG42TWd2QW5KVEpVOFNjdkpUM0FhUVQ4SlQ4SFRyQW5KWHJSZzhBbkpiQWxvTVhvSmJyQVRGVG9KYnZNbm9TbkpnRGI2R2d2SmdEYjhNWG9KZ1NYM0pVOEpndUFURlRvSmxQWUxuUWxKbFFrRG5MYkpsUWxGWUpsSmw4TGY4T1RKbkNURm5MYkpuTFRIWE1uSm5MWEdYQ25Kbm9GZlJnM0puck1ZUmczSm4zSGdGbDNLVDhEZzhMbkxUUmxGblBUTFR2UGJMYnZMVm9TYnJDWkxYTVk2SFQzTFhOVTdEbHJMWE5YRFRBVExYOERYOExuTFpEYjhKVThMWk1ub0xockxaU1RvSlU4TFpyTGFMbnJMWnZKbjNTbkxaOExoclNuTGFKbm9NVDhMYkZsckhUdkxickZUTG5yTGJ2QVRMbHZMYjZPVEZuM0xjTG5KWk9sTGVBVDZNbjRMZUpUM09ickxnNkxYRmxyTGhySmc4TG5MaHZEbFBYNExodkxmTG52TGo2SlRGVDNMbkZick1Yb0xuUWx1Q1R2TG5yUVhDWTZMbnZMZkxudkxudk1nTG52TG52U2VMZjhNVE1ickpuM01UM0pnU1QzTVQ4QW5BVHJNVDhMVUxuck1VTVRvQ1pyTVVTY3ZMZjhNWG9EVDhTbk1YNkFURlRvTVg4QVhNVDhNWDhGa01UOE1YOEhUckRVTVg4U2NvU25NWUpUNkNUdk1nQWNyTVhvTWc4U1RvQWZNbHZBWExnM01uRmwzQW52T1QzQW5GbDNPVW9BVEhUOE9VM1JuTFhyT1hyT1hyU25PYlBidkZuNk9nOEhnclNuT2c4T1g4RGJQVHZBZ29KZ1BVM1JZTG5yUFhyRG5KWnJQYjhDVEdndlBsckxURGx2UGx2RlVKbm9RVXZGWHJRbFFlTW5vQWwzUWxyUWxyU25SVEZUckpVb1NURGxMaUxYU1RGZzZIVDNTVEpnb01uNFNUckZUSlRyU1RyTFpGbDNTVDRGbk1Yb1NVckRsSFVvU2N2SFR2U25TZkxrdk1Yb1wiLFxuICAgIFwiQVVvQWNyTVhvQVo4SGJvQWc4QWJPZzZBVEZnQWc4QWxvTVhvQWwzQVQ4SlRyQWw4TVg4TVhvQ1QzU1RvSlU4Q2w4RGI4TVhvRFQ4SGdyQVRyRGJvT1Q4TVhvR1RPVHJBVE1uR1Q4TGhyQVo4R252Rm5HblFYSFRvR2d2QWNySFR2QVh2TGwzSGJyQVpvTVhvSGdCbEZYTGczSGdNbkZYclNuSGdyU2I4SlVvSG42SFQ4TGd2SVR2QVRySlVvSlVvTFpyUm52SlU4SFQ4SmI4Slh2Rlg4UVQ4Slh2TFRvSlRySllyUW5HblFYSmdySm5vQVRySm5vSlU4U2N2Sm52TW52TVhvTFRDVExnckpYTFRKbFJUdlFsTGJSbkpsUVl2TGJyTWI4TG52TGJ2Rm4zUm5vTGRDVlNUR1pyTGVTVHZHWENuTGczTW5vTG4zTVRvTGxyRVR2TVQ4U1RvQWwzTWJyRFU2R1R2TWI4TFg0TGhyUGxyTFhHWENuU1RvTGY4UmczU1RyRGI4TFRyU1R2TFRIWE1uU2IzUllMbk1uU2dPZzZBVEZnXCIsXG4gICAgXCJIVURsR25yUVhySlRySGdMbnJBY0pZTWI4RFVMYzhMVHZGZ0duQ2szTWc4SmJBbkxYNFFZdkZZSG5NWHJSVW9KbkdudkZuUmx2RlRKbFFub1NUckJYSFhyTFlTVUpnTGZvTVQ4U2U4RFRySGJEYlwiLFxuICAgIFwiQWJEbDhTVG9KVThBbjNSYkFiOFNUOERVU1RyR25yQWdvTGJGVTZEYjhMVHJNZzhBYUhUOEpiOE9iRGw4U1RvSlU4UGIzUmx2RllvSmxcIlxuXTtcbmNvbnN0IGNvZGVzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSFAIyQlXiYqXCI7XG5mdW5jdGlvbiBnZXRIYW5ndWwoY29kZSkge1xuICAgIGlmIChjb2RlID49IDQwKSB7XG4gICAgICAgIGNvZGUgPSBjb2RlICsgMTY4IC0gNDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gMTkpIHtcbiAgICAgICAgY29kZSA9IGNvZGUgKyA5NyAtIDE5O1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGluZGV4X2pzXzIudG9VdGY4U3RyaW5nKShuZXcgVWludDhBcnJheShbMjI1LCAoY29kZSA+PiA2KSArIDEzMiwgKGNvZGUgJiAweDNmKSArIDEyOF0pKTtcbn1cbmxldCBfd29yZGxpc3QgPSBudWxsO1xuZnVuY3Rpb24gbG9hZFdvcmRzKCkge1xuICAgIGlmIChfd29yZGxpc3QgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3dvcmRsaXN0O1xuICAgIH1cbiAgICBjb25zdCB3b3JkbGlzdCA9IFtdO1xuICAgIGRhdGEuZm9yRWFjaCgoZGF0YSwgbGVuZ3RoKSA9PiB7XG4gICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHdvcmQgKz0gZ2V0SGFuZ3VsKGNvZGVzLmluZGV4T2YoZGF0YVtpICsgal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmRsaXN0LnB1c2god29yZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3b3JkbGlzdC5zb3J0KCk7XG4gICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18xLmlkKSh3b3JkbGlzdC5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGNoZWNrc3VtICE9PSBcIjB4ZjllZGRlYWNlOWM1ZDNkYTljOTNjZjdkM2NkMzhmNmExM2VkM2FmZmI5MzMyNTlhZTg2NTcxNGU4YTNhZTcxYVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJJUDM5IFdvcmRsaXN0IGZvciBrbyAoS29yZWFuKSBGQUlMRURcIik7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgX3dvcmRsaXN0ID0gd29yZGxpc3Q7XG4gICAgcmV0dXJuIHdvcmRsaXN0O1xufVxubGV0IHdvcmRsaXN0ID0gbnVsbDtcbi8qKlxuICogIFRoZSBbW2xpbmstYmlwMzkta29dXSBmb3IgW21uZW1vbmljIHBocmFzZXNdKGxpbmstYmlwLTM5KS5cbiAqXG4gKiAgQF9kb2Nsb2M6IGFwaS93b3JkbGlzdHNcbiAqL1xuY2xhc3MgTGFuZ0tvIGV4dGVuZHMgd29yZGxpc3RfanNfMS5Xb3JkbGlzdCB7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIEtvcmVhbiBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdLb11dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImtvXCIpO1xuICAgIH1cbiAgICBnZXRXb3JkKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gbG9hZFdvcmRzKCk7XG4gICAgICAgICgwLCBpbmRleF9qc18yLmFzc2VydEFyZ3VtZW50KShpbmRleCA+PSAwICYmIGluZGV4IDwgd29yZHMubGVuZ3RoLCBgaW52YWxpZCB3b3JkIGluZGV4OiAke2luZGV4fWAsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gd29yZHNbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICByZXR1cm4gbG9hZFdvcmRzKCkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdLb2BgLCBjcmVhdGluZyBpdFxuICAgICAqICBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoKSB7XG4gICAgICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3b3JkbGlzdCA9IG5ldyBMYW5nS28oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZGxpc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5MYW5nS28gPSBMYW5nS287XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nLWtvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxhbmdLbyIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsIndvcmRsaXN0X2pzXzEiLCJkYXRhIiwiY29kZXMiLCJnZXRIYW5ndWwiLCJjb2RlIiwidG9VdGY4U3RyaW5nIiwiVWludDhBcnJheSIsIl93b3JkbGlzdCIsImxvYWRXb3JkcyIsIndvcmRsaXN0IiwiZm9yRWFjaCIsImxlbmd0aCIsImkiLCJ3b3JkIiwiaiIsImluZGV4T2YiLCJwdXNoIiwic29ydCIsImNoZWNrc3VtIiwiaWQiLCJqb2luIiwiRXJyb3IiLCJXb3JkbGlzdCIsImNvbnN0cnVjdG9yIiwiZ2V0V29yZCIsImluZGV4Iiwid29yZHMiLCJhc3NlcnRBcmd1bWVudCIsImdldFdvcmRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangPt = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst words = \"0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=\";\nconst checksum = \"0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac\";\nlet wordlist = null;\n/**\n *  The [[link-bip39-pt]] for [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangPt extends wordlist_owl_js_1.WordlistOwl {\n    /**\n     *  Creates a new instance of the Portuguese language Wordlist.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langPt]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(){\n        super(\"pt\", words, checksum);\n    }\n    /**\n     *  Returns a singleton instance of a ``LangPt``, creating it\n     *  if this is the first time being called.\n     */ static wordlist() {\n        if (wordlist == null) {\n            wordlist = new LangPt();\n        }\n        return wordlist;\n    }\n}\nexports.LangPt = LangPt; //# sourceMappingURL=lang-pt.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy1wdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsb0JBQW9CQyxtQkFBT0EsQ0FBQyw2RkFBbUI7QUFDckQsTUFBTUMsUUFBUTtBQUNkLE1BQU1DLFdBQVc7QUFDakIsSUFBSUMsV0FBVztBQUNmOzs7O0NBSUMsR0FDRCxNQUFNTCxlQUFlQyxrQkFBa0JLLFdBQVc7SUFDOUM7Ozs7Ozs7S0FPQyxHQUNEQyxhQUFjO1FBQUUsS0FBSyxDQUFDLE1BQU1KLE9BQU9DO0lBQVc7SUFDOUM7OztLQUdDLEdBQ0QsT0FBT0MsV0FBVztRQUNkLElBQUlBLFlBQVksTUFBTTtZQUNsQkEsV0FBVyxJQUFJTDtRQUNuQjtRQUNBLE9BQU9LO0lBQ1g7QUFDSjtBQUNBUCxjQUFjLEdBQUdFLFFBQ2pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy9sYW5nLXB0LmpzPzU4ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxhbmdQdCA9IHZvaWQgMDtcbmNvbnN0IHdvcmRsaXN0X293bF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3Qtb3dsLmpzXCIpO1xuY29uc3Qgd29yZHMgPSBcIjBhcmFkIW90b3RlYWxpcmVydGFpbnJhc29lbnQgaG9hbmRvYVIjcmlhcmVoYSFhcm9lbGUnb3JvbnVsMEFjYSVBaXhvQWwgQSVyRHV6J0VsXUVyJElzbW9PJCBSPGcoUmV2aSBSaWcgUnVwJFMqJFNvbHUkU3VyPVV0WzBBYiNBbG0gQW1wIEFuaCBBLEVpLkVsKCBFbiBFcnZvRXNzIEUkbmFIYS5JZGV6SW1hSX0jSXJyIExhbSBMaXZlT2xoaWRhT21vZCBPcGwgT3JkIFVtfiBVcz8wQXAuRWdhRW50X0VwJEVxdSBFci0lRXNpdm9FdXNJPCVJdGl2b0pldGl2b0p1biRNJyBPciBRdScnVWJvVigsVm9nIzBSfWF2ZTBBcy5FcidFdGl2b0luP0l2YCBMaSRMdS0lUn0uMEFjaCBBcnIgQXMmL0VuY2kgSWxpeiBJbylJdCNPK1IhIFJlcyVSdXAgVSBkIFVsXTJPYGggVWQgVXMuMUFtZWRhQXJtZUFzdHIgQXY8Y2FCKGd1ZUIqb0NhdCtEZUBFY3JpbUVnckBFci5GYWNlRiplJUd1bUhlaW9JIEljYSVJLSBJbmggSXZpIE1vZl5PYyBQaXMlVCggVGl0dWRlVWMqIFVnIFVub1VzaXZvVm8wQWNpIEE9ckFbbG9Bc3MgQmFzQmktJUVpeGFFbml6IEk9SXMkLEl6IWVPbD9PbiQgT18sT3N0K1AgIFBsaSBQb2xhMEFnK21hQWxpcyBBcnF1QEEkbUBEYWltZUVsRXhvR34gSW0gSm9PbSZAT3QjU2lvLFQoaXxVaWQhZVVuY2kgWm9sMUFnP0FscCBBbmgjRWdvRWxpPUVydF5FcyBFdGklSSRMYXUsTGljXk9pb09uLk9zKVItZGl6Um92IDBVZWMoMEFtZUFuXUErQ15ELSVFQEVqIEVuaSRFcylHaWxvLEdvbGFNYVF1aXZvUmFpJlJlYmElUmlzYyBSb2I+dW0gUy0mVChpJlRpZ29Wb1s9MEYmLklsI1AnIFM/UyogU28mL1N1biRUciYwQWMjQWR1K0FsL0FbZiBFIEVuZChFcl9FdUluZydJcj9Jdm9PbHtvUmFjIFJldmk9Uml6VSZVbTBEaSRyTS0uUj5vK1Rpc21vVHxAVHUgMEFsaSBBbiVBckBFbnQmRXMsST9JcyBVbCwxSWxhMUFyIEU9RWklVWxlam86QiBCb3NhQyZddUNoIGBDQEdhZ2VtSTxvSWwgSX1lKUlyX0l4aXMpSn4gTGVATGl6YUxzYU4mTmR7YU4vTidOcXVlJVJhJFJiI1J9ZXM+K2M+fi9TZSNTKW4lVGEpVGU9clRpZGFUb21UdWMgVW5pbF0zQihJam9Jcl5Jc2Vib2xMZCFlTGV6YUxnYUxpc2MgTmRpJE5nJmFOeihSaW1iYXVSbCpkPl9Tb3VfWGlnYVooXzNDb0N1PUVuJkZvYyZGdXJjIEd8bmFMaGUlTWVzdFtNbyRyT2xvZ0BPbWJvT3NmKGFQb2wgUnItJFNjb2kkU25lJFNwb1NzZXgkVG9sYVogXzJJbmQjT2NvT3F1ZSAyQSRCYWdlbUMjQ2Vqb0NoZWNdSWNvLkxeTGV0aW1MXUxvTWJ7b05kZU5lY29OaSlSYn5oPmQ+ZSZSK2NdVipvWGU/MkFuY29Bc2FBdmV6YUV1SWdhSWwvSW5jIE9hT2NodStPbnplIE8kVXhvMkNdRGlzbW9GIExlUmFjb1NjYVMkWiphOkI8YUJgb0JpZGVCb0JyaSRDYXVDZXReQy9yX0NpcXVlRGFzdF9EZSNGZXomSWFxdWVJcCdhSXhvJUojSnVMYWZyaW9MY34gTGR7YUxpYnIgTG08JUxvKU1eTWJpcylNaXNhTW9taWxhTXA8XU11ZmwgTmF2aSZOY2AgTmUpTmd1cnVOLyROaXZlJU5vYU5zI04uTnU9UGFjL1BgYVAqIFBvLlByaWMvUHQ/UHV6UmFjb2xSYn1vUmRlJlJlYz5pbWIgUm57b1JwZSVSWyc+KXpSdiYvU2Fjb1NjYVNlYltTJWxvU35vVCBhKVRpdiBVbGVVcz9VJWwgViZvVihuYTNCb2xhRGlsXUd9XUxlYnIgTH4gTm91K04sTiVpb1JjIFJyI1IlJ29SdmVqYVRpbVZeMkFjbylBbHthQW0jQXBeQXJtZUF0aWNlQXZlRWZlRWdeRSdvRXF1ZUljbyVJZltJbmBvT2MmL092KFVtYm9VLlV2YTBDYXRyaXpDbH1lRCFlRFsnYUVuJUc8YU0tJE4kTno+PGQ+Y3VpJFJ1cmdAVCAyQVt6YUVfSWMgT25lVWJlMkE9QWcnQmFAQigkckJyIENeRWwvRW50X0UsR3VtYG9JYidJZmFJbyVMIEx7YUxoKExpZCdMbWVATH1vTHVuYU08PU1iKiBNLS5NaXRpdmFNb3YoTXBsZXhvTXVtTmNdTj1yTmVjLk5mdSxOZ2AgTmhlYyhOanVnIE5zdW0nTnQrJE52aSVPcCggUHtvUGk/UG9RdWUlbFJhZ2VtUmRpJlJuZSlSfWg+cHwmUltpb1Ilam9SdWo+dm9Tcy1vUyVsYVR9ZSVVX1V2ZVZpbFoqXTJBJStBdm9FY2hlRT1yRW1lRXJFc3BvSV5JbSomSW9+b0lzZUl0aWMgT3MpVWFVentvMkI8b0VjYUlkI0pvTGF0K0xtKiBMcCBMdHUrTXByJ05oI1BpPVJhdGl2b1JyJlJzIFIkU3AnUyUgVGBvOk1hc2NvVCAzQmElckJpLkJvY2hlQn5oIEMmcXVlQ2ltJkNsaXZlQ28lQ1suRCZEaWMjRHV6J0Zlc2FGdW0gR2BvRyt1R3VzLkl0I0l4IExhJHJMZWcjTCplIEx9Z2FNPGRhTWl0J01vbGk9TnRpcylQLSNQaWwgUG9pc1Bbc3NhUHVyIFJpdj4rbSBTYWZpb1Niby5TYzwsUy0vU2ZpI1NnYXMlU2lndSZTbGl6ZVNtYW0gU292YVNwZXNhUylxdWVTdmkgVCZoIFQtJHJUfSBUcmkkVXNhVihWaT1Wb3QjWi1hM0FnK21hQWxlJERhKUZ1LEdpLkxhdCNMdS0lTSp1J05hc3RATmh7b09jZXNlUmUkU2NbKVNmIGNlU3Agb1NxdWUlU3NpcCBTKW4lVD9Vcm5vVigsVmksclZ+ZyBaKDVCcj9MfGk9TT9NKiNOYXRpdm9OemA+bS0lUnMmU2FnZW1VciNVJHIyRW5hZ2VtSWJsZU9nIEAyRWwgRW5kZUUkUGxvUXVlcz48JVZpPSw6MUxvZCdPIE9sb2dAMElmaWMgSXQmVWMjMUVpJEV0aXYgM0UuMUFifCBFZyhFaSRyRW5jb0V2P0ltKiBPZ2kgMEIgZ29Cb2wjQnJ+L0J1dGk9RW5kYUVyZydJcyxyUGF0QFAtL1AqI1BvbGcgUFtnb1B1cnIgVWw/MENhaXhlQy0jQ2gtJUN9dF9EZXVzIERvc3MgRmFpeCBGZWklRmltR2FqI0ctL0dsb2IgR29tI0creCBHdUBKbyBMYS5RdTwkUmFpeiBSb2wjUnVnIFNhaW9TZV5TKm9Tb3AjVDwkVGUjVGlkIWVUfC5Ucl5Ufi9WKGcgVmkjVm9sdihYYW1lWCgkWG9mW1h1JDFJZChtZTBVaXAgMEUkR3VpPVJhKVZhVmlsXTBCPGogQmAkQ2FtYUNvbGFDcmkpQ3UpRipnZUZvbCBGW2cgRnVtI0dyaW1hTSYlUDwkUGAvUGlnYVB9amFQW2kpUHVtIFF1KGRhVGFjYVR7YVRpYyBUb2YjVFtsYVR1PVZhemkgMEFub2xJcXVlKTBGfGk+b3BldTBBY3UgQXB8IEFzaXZvRW50dSZJZC0lT2x1JzFBZyhvQWwgQW0qIEEkQXVzJENlcyxDaS5DbGFtIEVjdS5FbXBsb0liJ0lnLSVPbiggUDxkJ1BgJ1AnIFBsPCBQb3MkUFtzLFB+cyBUKG5vVCokVCskOkJyaWMgQn5vLENlKUNpJkRhRGlnYUl4YUwgTClNaWxpIE5kPGdvTmYgK04kY2hlUmQjUmBvUipoPm9mPnA+dHUrVEBUfFZ8aSlYKmFaLWRhM0NoI0lqb15JK24lTCpvTSoqb05kYU5vUj5pI1JydWdlbVJ2KFMlaiBUJlVkJjNBcG9CX3NlQyBDaHtvR3VyI0x7YUwvTG1lTHRyIFJtZXphU2deU3N1K1RhVmBhWD9YbzJBY2lkZXpBbSpnb0FuYGFFY2heTytVdHUgVXhvMkMmQyovRm9jIEdvR3VlJUljZUxnI0xoZSRSaiBSbWlnPm5vUiVTY29Tc2EyQWdhKUFsZGFBbmdvQXNjb0Elcm5vRSdhRW4lRS5JZXphSSxJdHUrT25dVXN0ciBVJSdhMkcnTDxvTGlnZW1OZCBOZ29OaWxSP1JpbyxUZWJvbDpCIGkkQiplJURvSWEkSW9sYUl2bylMZWdhTC9MKl1Mb2NdTmggUmFnZW1SZm9SZyZvUmltcG9Sb3VwPitmYVNvZHUkUyRUYVRpbC9WZSlaYGEzTCNMZUBMb01eTShNaT1OKG8sTmdpdmFOaSZOb21hTl9PbG9naT4/Um0qIFMsUyRyM05hcylOYzxhTmcjUmFmPipvMkFjaSZJY29zZU9iJk9yaW8sMkVsYUlhYmFMZmVMcGUgUmR1K1JqZSlSX1MkLFR7YVYobiAyQWNlam9BZHUmQWZpJUFsXUFtcG9Bbl5BdHVpJEF2ZSRBeGFFZ29FbGggRXZlSWxvSXMmL0kuQE9zLE8lc2NvVWQjVW5oaT1VKTJBY2hlQStuaUF4KmltRXJbIEkgSW5jL0lzI0xhTG8sUnU6QmkuUm19QFMlVigzQy5lUmQgUmVzQFNpLjNBJEIobiBEKy5FbmFOb1Bpc21vUG5vc2VQbyVjYTVKZUxvZm8lTWVtTmVzJE5yI1JtfSZTcGVkIDVNfCM6VGUyRUBPLDJOfCNSZWphVTxhNEUsSGFVZGk9VW0qIFVzdHIgMEFnZW1FZEAkRW4sRXJzaXZvSW4tJUl0P09ydCZQYWMkUGVkJ1BsPCVQfFByLXNhUHVuZVVuaXogMEFsP0FwJEF0aXZvQy0sQ2ggQ2lkJ0NsdSdDb2x8RGVjaSxEJ2UkRHUkckVmaWNhekVyLSVGPHRpbEZlcy5GKmkkRmxhbSBGfG0mRiskckcoJ0liaT1JY2kmSW1pZ29KZS5PYy0lTz1fT3Y/T3hRdWllJFNjcmkkU2UkU2lzdCdTcGUkclN0JiBTfiRUYWMkVGVnciZUaW0gVG9jI1RyaWdhVmEsclYobm9WaWMkVm9jIDBHdXIlMkFuaTxvT25peiBSZSZSaXQjMENhRW4kT2wjUXV7bzBBbGk8bzpOe29OZ15OKVIgYWM+ZGltUl9TbWltVG9WJmlaaWRhM0p1bTlBbipdRWxoXkc/ST5uJlJyIFZlbTVCYURldURvY2FJekxnP0wvUiNSaXMpUm9TKTo6QiBlZGFCfCZDW0MpbiVEcmlsL0cgKUdvYUplTWIoTS0uTSogTXBlam9OY2hlUGlkIFAsUjxqPns+Z3UrUzxdU3RfVCgmVGk9VjxkYVZvdStWcj9YPCVaKDNBbGQhZUJbRyNHLWQgR2lzKUlnb0lsbyBJdHUrTWJbJU1lTmg/TnRpbF1PYVNtYVMlVGl2b1RbJ29WIFZlemFWaS4zQigmQmk9RCggRyBHe29NaS5Nb3tvTXA/TmRhTmUgTl1nZW1RdWlkZXpTKWdlbVN1K1R8JlZfWGFYe2E1Qz9DdSRySmlzKU1ib05hTmdlTnQrUmRlVCNUKEBVY3UrVXNhVXYgNUFyQ2lkZXpDX05lKVN0W1Q/VmE6Q2Fjb0NlJUNoI0Npb0R7YURyKl1HbmEpR1t6YUl8SXNMPGRfTF1MbyVMdWNvTWlsb01ve29NdSVOXk5jXU5kYSROZXF1aW1OLyxOaXZgYU5vYnIgTnNhTiVyTnVzZSBQZSNRdSogUmM/UmVzaT5maW1SZ2VtUiovUm1pKVJvJFJxdWlzZVJbY29SJWxvUnVqb1NjbyVTbXwrU3NhZ2VtU3RpZyBUYWcmVChub1QqJlR1LlhpbCAzRCZdRGlkYUR1c2FHYWZ9ZUlnYUw8Y0BML3JNYl9NfGkmTipvTm9zTnNhZ2VtTnQmUmVjKFJnfi9TXlNjbCBTbW9TcXVpKVN0W1QhZVRlb19UK2dlbVgoWGljPG8zQ19HJl1HciBMYWdbTC0gTGggTSNOKCBOL2NhTmlzdF9OfEBPbG9SPCVSdGlsb1N0dXIgNUNpZCFlRChub0R+IEVkYUVySW4vSSlMZHUrTGV6YUwvTCplJUx1c2NvTiluXVF1ZWM+PGdvUmNlZ29SPW1vUi1hU2FpY29TcXVlJVMuZGFUYFRpbVRvVHJpejVEYUkkTGEpTGgoTC5OZGkmTmk9UiZoPmMvU2N+IFNldVNpYyY6Q2l9JkQ/SmFNb19SKj5yI1NjKFRpdmFUdVt6YVYmXVZlZyBWaW8zQmwqYUJ+byxHYXRpdmFHb2NpIEdyaSRSdm8sVGFVciZWYXNjYVZve28zTiBOL1RpZGV6VmAgNUJbemFJJUl2YU1lIE0qJlJkZXMlUiUgVCBUaWNpIFR1cm5vVmBvVmlsL1ZvNUJsI0Rlek0oJlBjaSZUcidWZW06MENlYyNFZGVjKEpldGl2b1JpZyNTY3VfUyV0K1QoVHVyIDBJZC0lSW8sT3JyKFVsaXMpVXAjMkVnPCVFbnNpdmFFci1kYUljKmFVc2MjMEl2YTRBckBFbyxIIEl2e2EwQl9FbGUlSXMsSXQnMER+I0VfLFRlbTFDaX0mRXI/T24tJU9ydHVub09zJDFBckJpLkRlbUQqJkY8YSRHYXNtb0d+L0ktdCZJZ2VtSXVuPUxhVG89eG9WJi8wQ2lsIFNeU29ULS4wSW1pc21vMFMhQFR9b1R1Yl9WaT0wRWxdVWwgMUlkIElnLSA6Q2EkQ2ktJUNvJUN0dSBEIEBEciovRyBHb2RlSW5gSXIgSXNhZ2VtTGF2K0xlc3QrTGhlKUxpJExtXkxwaS5OY15OYGFOZmxlJE5xdWVjYU4pbiZQYWdhaW9QYF5QJ29SYWYqPmNpJlJkJlJlZGVSdGlkYVNtb1NzI1MlbFRhbSBULSVUKiBUX25vVWxeVXMgM0N+aSBEJiBEZXN0W0RAdCtEK0deSSRyJkl4ZUxlTGljPG9OY2FOZHVyIE57YU5dc2NvTnM/TiVSY2ViKFJmZWkkUmd1bilSaSRSbWl0J1JuPnBsZXhvUnNpPD4lbmNlUnVjYVNjI1NxdWlzYVMsYVRpc2MgM0FkYUMjRWQhZUdtLSRMYXN0K0xoI0xvLk0tKU5jYE5ndWltTl1ObyVOLk9ue29Qb2NhUXVlJVI8aD5lc1J1ZSlTYyBTJGxhVDxnYVZlJTJBbilBcXVlKUF0KmFFYmV1VW1hZ2VtVXZpJjFFdTBEYUUnYUV0aXNhTGVnXkxpY2kgTHUtJUx2aWwvTSBNYmFOZCggTi5AUH5vLFIpU3N1J1N0JlRlVXAgVSxWbyAyQUBBbmNdQSRBeGVFY2VFZD9FZmVpJEVtaSBFbnMgRXAgIEVzaWxdRSV4JEV2LSdFeiBJbWEpSW5jZXNhSXNtYUl2I09jZXMsT2R1JE9mZSlPaWJpPU9qZSRPbWUlck9wYWcgT3NhTyUkck92PzJCbGljIERpbUwgTG19IExze2FOaCZOJ1BpbG9SZXphWD86OTlBZCtBbnRAQXIkQXNlRWJyIEVkYUVpam9FbiVFcmk9SW19b0luYUlvc3F1ZTpCPF5CaXNjb0NoIENpfSBEaSZJIEluXUlvSXZhSl5MI00mTmcoTmh1K1AhdStQYFBpZGV6UG9zYVF1ZSVSaWQhZVM8JVNjdW4vU2cgU3A/UyUnYVN1ciBUYXo8YVRve2EzQWxlemFBbmltIEF2KEJhaXggQmBkZUJvbCBDI0MtJUNoZWlvQ2lib0N8ZCBDcnUuQ3UgRGVEaW0nRH1kYUR1emlkYUVudmlvRiogRmxldCdGb2cgRltzY29GdWdpIEcmQEdpbWVHK0luI0kkckplaS5MYXRpdm9NP00tPU18LE5vdiNQIG9QYCdQbGUkUG9sL1Bbc2FQdWRpIFF1KChTLV1TZnJpIFNnYS5TaWQnU29sdihTcGVpJFNzYWNhUyluJVN1bSdUJi9UKFQnIFRvbV5UKy5WYCBWaSxyVm9sKTNBYy9DYUdpZGV6R29fLE0gTmd1ZVNeU2NvU30vNUImb0NoZT1EXkRlaW9Eb3ZART1yTGUpTTxvTmMgUyNTe2FTJFRhVHtvVCphVH4gVWNvVXBhWG81Ql9HaT1HbyxJdm9Nb1Blc3RbUyw6QnxDaSBDb2xhQ3VkJ0Rpb0YnYUdhR3JeSWJfTF5Me29MZyNMaXZhTHBpYyBMc2ljXUwuTHY/TWIgTXUraU4gTmZ9YU5ndWVOaWQhZVBhJFJkPmctJFJqZSlUdXIgVWQhZVhvZn1lWn0mM0MgQ34gRGFELSREaSNEbyxEdSRyR20tJEdbPUd1bj1JdmFMZSRMdmFnZW1NPCZNLSVOP04vck5zdSZOdCNQICNSZWk+Kmc+K1J2b1RlbWJfVHwzR2lsb0xodWUpTGljfWVNZXRyQE1wYXRATX4gTiZOYyhvTmd+IE5vcHNlTiRuaT4tZVJpVHUjNUIoPG9CK0N8X0dfSmFMZGFMZXRyIEwlJ29NYnJpb05hKU5kIE5lZyBOaD9Ob1Arbm9RdWUlUnInUiVpb1NzZWdvVGFxdWVUKHIgViNaKi81QXZpeiBCaWRhQm0oLEIsbG9CdCsnQ2EpQ2VzLENvRGVzJUZpeG9HP0coJ0plaSRMZmEkTSdPclAoaXxQbGljIFBvcyRQcmltJ1JkKj5maXMpUnBbcz5bJlJ0J1NwJ29TJW4kOkJgYUJsZSVCdV5DL0cgYGFMaChMb0x2ZXpNPC9NYnxpbU1wYU5nLSVOJFAgUGlvYz5kaW9SZWY+aj4reGFUdWFnZW1VcipvWGF0aXZvWGlzKTNBdHImQyhDaT1DbCNEaW8sSWFJbSBMZWZ9ZUxoI01wKG9OLSVOLHJOLlJtJlJub1JyLW9TZVNvdStTdCNUb1h0dStYdWdvM0ErR2BhSm9sb01iciBNaWRlek5naT1OJSdvUmFnZW1UfiA1QWxdQ11MKCBMaWNlTV5NaWwvTmBOdHUrUGUlUj5jaT1SbmVpb1JxdWVSciE+JFMuVWNhVXB7YVgqYTJBYiYvQWNlaiBBZHUkckFmZWcgQWplJEFtYUFuYyBBcG9Bc3tvQXQ/QXYgRSpvRW0oRXBpZCBFdm9JYWdlbUlib0ljaWNsb0lkLSVJbG9nQEluZCFlSXBsb0l0dXIgSXVuZiZPYyBPbWJlKU92YVVuZm9VcXVlMkJ+IEM8b0RvTGlwYVBpUmJvUm0+cXVlc2FUYCBUfGkmOjdWIDNCaWdvMEhhSWQhZUlmfG1lM09sb2dAU29UaWdhVWJ1MEE9SW5hVWZydSc6QyphRGkgRyBvLEk9LExhTC0lTGlkIWVMb1tzTilnZW1RdXtvUjxkPmUpUnIoU2N+IFNpbF1TLHUrWiBaaW8zQT1EIEdlLkljfiBMe29MaGljZUx1PU5jZT1yTmRhdiZOKCBOdFtSYiZSZCFlUmU/Umd9aD5tYC9Sbml6UnMgUiVuJVNwYVN0aT1UfGkmM0FkdSRBZ2VtQWogQXR1K0JyP0R7YURyIEBFbGFHYUctJUdpIEd8IEwgZWpvTmNvTmhlKU5pbE9sZSlSIT50dWRlU2kuUyRUciZWe29aKi81QT1yQXJHJkw8JUxlaWJvbEwpZ2VtTHVtbyxOdCFlNUwkVnV6YGE6OkRbelJvcGUzUXVlUmUuUmlmZTNOZyA6Ok5nI1JwIDNCdUw/OU1iIE9sb2dANU1iaT1cIjtcbmNvbnN0IGNoZWNrc3VtID0gXCIweDIyMTkwMDA5MjZkZjdiNTBkOGFhMGEzZDQ5NTgyNmI5ODgyODdkZjQ2NTdmYmQxMDBlNmZlNTk2YzhmNzM3YWNcIjtcbmxldCB3b3JkbGlzdCA9IG51bGw7XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LXB0XV0gZm9yIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdQdCBleHRlbmRzIHdvcmRsaXN0X293bF9qc18xLldvcmRsaXN0T3dsIHtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgUG9ydHVndWVzZSBsYW5ndWFnZSBXb3JkbGlzdC5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdQdF1dIHNob3VsZCBzdWZmaWNlLlxuICAgICAqXG4gICAgICogIEBfaWdub3JlOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyBzdXBlcihcInB0XCIsIHdvcmRzLCBjaGVja3N1bSk7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBhIGBgTGFuZ1B0YGAsIGNyZWF0aW5nIGl0XG4gICAgICogIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB3b3JkbGlzdCgpIHtcbiAgICAgICAgaWYgKHdvcmRsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0ID0gbmV3IExhbmdQdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdQdCA9IExhbmdQdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctcHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGFuZ1B0Iiwid29yZGxpc3Rfb3dsX2pzXzEiLCJyZXF1aXJlIiwid29yZHMiLCJjaGVja3N1bSIsIndvcmRsaXN0IiwiV29yZGxpc3RPd2wiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js":
/*!***************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LangZh = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\nconst data = \"}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH\";\nconst deltaData = \"FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL\";\nconst _wordlist = {\n    zh_cn: null,\n    zh_tw: null\n};\nconst Checks = {\n    zh_cn: \"0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1\",\n    zh_tw: \"0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d\"\n};\nconst codes = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst style = \"~!@#$%^&*_-=[]{}|;:,.()<>?\";\nfunction loadWords(locale) {\n    if (_wordlist[locale] != null) {\n        return _wordlist[locale];\n    }\n    const wordlist = [];\n    let deltaOffset = 0;\n    for(let i = 0; i < 2048; i++){\n        const s = style.indexOf(data[i * 3]);\n        const bytes = [\n            228 + (s >> 2),\n            128 + codes.indexOf(data[i * 3 + 1]),\n            128 + codes.indexOf(data[i * 3 + 2])\n        ];\n        if (locale === \"zh_tw\") {\n            const common = s % 4;\n            for(let i = common; i < 3; i++){\n                bytes[i] = codes.indexOf(deltaData[deltaOffset++]) + (i == 0 ? 228 : 128);\n            }\n        }\n        wordlist.push((0, index_js_2.toUtf8String)(new Uint8Array(bytes)));\n    }\n    // Verify the computed list matches the official list\n    const checksum = (0, index_js_1.id)(wordlist.join(\"\\n\") + \"\\n\");\n    /* c8 ignore start */ if (checksum !== Checks[locale]) {\n        throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);\n    }\n    /* c8 ignore stop */ _wordlist[locale] = wordlist;\n    return wordlist;\n}\nconst wordlists = {};\n/**\n *  The [[link-bip39-zh_cn]] and [[link-bip39-zh_tw]] for\n *  [mnemonic phrases](link-bip-39).\n *\n *  @_docloc: api/wordlists\n */ class LangZh extends wordlist_js_1.Wordlist {\n    /**\n     *  Creates a new instance of the Chinese language Wordlist for\n     *  the %%dialect%%, either ``\"cn\"`` or ``\"tw\"`` for simplified\n     *  or traditional, respectively.\n     *\n     *  This should be unnecessary most of the time as the exported\n     *  [[langZhCn]] and [[langZhTw]] should suffice.\n     *\n     *  @_ignore:\n     */ constructor(dialect){\n        super(\"zh_\" + dialect);\n    }\n    getWord(index) {\n        const words = loadWords(this.locale);\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return loadWords(this.locale).indexOf(word);\n    }\n    split(phrase) {\n        phrase = phrase.replace(/(?:\\u3000| )+/g, \"\");\n        return phrase.split(\"\");\n    }\n    /**\n     *  Returns a singleton instance of a ``LangZh`` for %%dialect%%,\n     *  creating it if this is the first time being called.\n     *\n     *  Use the %%dialect%% ``\"cn\"`` or ``\"tw\"`` for simplified or\n     *  traditional, respectively.\n     */ static wordlist(dialect) {\n        if (wordlists[dialect] == null) {\n            wordlists[dialect] = new LangZh(dialect);\n        }\n        return wordlists[dialect];\n    }\n}\nexports.LangZh = LangZh; //# sourceMappingURL=lang-zh.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy16aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQWtCO0FBQzdDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDLE1BQU1HLE9BQU87QUFDYixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLFlBQVk7SUFDZEMsT0FBTztJQUNQQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyxTQUFTO0lBQ1hGLE9BQU87SUFDUEMsT0FBTztBQUNYO0FBQ0EsTUFBTUUsUUFBUTtBQUNkLE1BQU1DLFFBQVE7QUFDZCxTQUFTQyxVQUFVQyxNQUFNO0lBQ3JCLElBQUlQLFNBQVMsQ0FBQ08sT0FBTyxJQUFJLE1BQU07UUFDM0IsT0FBT1AsU0FBUyxDQUFDTyxPQUFPO0lBQzVCO0lBQ0EsTUFBTUMsV0FBVyxFQUFFO0lBQ25CLElBQUlDLGNBQWM7SUFDbEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksTUFBTUEsSUFBSztRQUMzQixNQUFNQyxJQUFJTixNQUFNTyxPQUFPLENBQUNkLElBQUksQ0FBQ1ksSUFBSSxFQUFFO1FBQ25DLE1BQU1HLFFBQVE7WUFDVixNQUFPRixDQUFBQSxLQUFLO1lBQ1osTUFBTVAsTUFBTVEsT0FBTyxDQUFDZCxJQUFJLENBQUNZLElBQUksSUFBSSxFQUFFO1lBQ25DLE1BQU1OLE1BQU1RLE9BQU8sQ0FBQ2QsSUFBSSxDQUFDWSxJQUFJLElBQUksRUFBRTtTQUN0QztRQUNELElBQUlILFdBQVcsU0FBUztZQUNwQixNQUFNTyxTQUFTSCxJQUFJO1lBQ25CLElBQUssSUFBSUQsSUFBSUksUUFBUUosSUFBSSxHQUFHQSxJQUFLO2dCQUM3QkcsS0FBSyxDQUFDSCxFQUFFLEdBQUdOLE1BQU1RLE9BQU8sQ0FBQ2IsU0FBUyxDQUFDVSxjQUFjLElBQUssTUFBTSxJQUFLLE1BQU0sR0FBRTtZQUM3RTtRQUNKO1FBQ0FELFNBQVNPLElBQUksQ0FBQyxDQUFDLEdBQUduQixXQUFXb0IsWUFBWSxFQUFFLElBQUlDLFdBQVdKO0lBQzlEO0lBQ0EscURBQXFEO0lBQ3JELE1BQU1LLFdBQVcsQ0FBQyxHQUFHeEIsV0FBV3lCLEVBQUUsRUFBRVgsU0FBU1ksSUFBSSxDQUFDLFFBQVE7SUFDMUQsbUJBQW1CLEdBQ25CLElBQUlGLGFBQWFmLE1BQU0sQ0FBQ0ksT0FBTyxFQUFFO1FBQzdCLE1BQU0sSUFBSWMsTUFBTSxDQUFDLG1CQUFtQixFQUFFZCxPQUFPLGlCQUFpQixDQUFDO0lBQ25FO0lBQ0Esa0JBQWtCLEdBQ2xCUCxTQUFTLENBQUNPLE9BQU8sR0FBR0M7SUFDcEIsT0FBT0E7QUFDWDtBQUNBLE1BQU1jLFlBQVksQ0FBQztBQUNuQjs7Ozs7Q0FLQyxHQUNELE1BQU03QixlQUFlSSxjQUFjMEIsUUFBUTtJQUN2Qzs7Ozs7Ozs7O0tBU0MsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQUUsS0FBSyxDQUFDLFFBQVFBO0lBQVU7SUFDL0NDLFFBQVFDLEtBQUssRUFBRTtRQUNYLE1BQU1DLFFBQVF0QixVQUFVLElBQUksQ0FBQ0MsTUFBTTtRQUNsQyxJQUFHWCxXQUFXaUMsY0FBYyxFQUFFRixTQUFTLEtBQUtBLFFBQVFDLE1BQU1FLE1BQU0sRUFBRSxDQUFDLG9CQUFvQixFQUFFSCxNQUFNLENBQUMsRUFBRSxTQUFTQTtRQUM1RyxPQUFPQyxLQUFLLENBQUNELE1BQU07SUFDdkI7SUFDQUksYUFBYUMsSUFBSSxFQUFFO1FBQ2YsT0FBTzFCLFVBQVUsSUFBSSxDQUFDQyxNQUFNLEVBQUVLLE9BQU8sQ0FBQ29CO0lBQzFDO0lBQ0FDLE1BQU1DLE1BQU0sRUFBRTtRQUNWQSxTQUFTQSxPQUFPQyxPQUFPLENBQUMsa0JBQWtCO1FBQzFDLE9BQU9ELE9BQU9ELEtBQUssQ0FBQztJQUN4QjtJQUNBOzs7Ozs7S0FNQyxHQUNELE9BQU96QixTQUFTaUIsT0FBTyxFQUFFO1FBQ3JCLElBQUlILFNBQVMsQ0FBQ0csUUFBUSxJQUFJLE1BQU07WUFDNUJILFNBQVMsQ0FBQ0csUUFBUSxHQUFHLElBQUloQyxPQUFPZ0M7UUFDcEM7UUFDQSxPQUFPSCxTQUFTLENBQUNHLFFBQVE7SUFDN0I7QUFDSjtBQUNBbEMsY0FBYyxHQUFHRSxRQUNqQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvbGFuZy16aC5qcz80OTY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nWmggPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2hhc2gvaW5kZXguanNcIik7XG5jb25zdCBpbmRleF9qc18yID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuY29uc3Qgd29yZGxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LmpzXCIpO1xuY29uc3QgZGF0YSA9IFwifWFFIzRBPVl2JmNvIzROIzZHPWNKJlNNIzY2fC9aIzR0JmtufjQ2IzRLfjRxJWI5PUlSIzdsLG1CIzdXX1gyKmRsfVVvfjdzfVVmJkl3IzljJmN3fjZPJkg2Jnd4JklHJXY1PUlRfjhhJlB2IzQ3JFBSJjUwJUtvJlFNJjNsIzVmLEQ5IzRMfC9IJnRRO3YwfjZuXW5OPGRpLEFNPVc1JVFPJmthJnVhLGhNXnRtPXpWPUpBPXdSJitYXTdQJk5CIzRKIzVMfC9iW2RBfXRKPERvJjZtJnUyW1UxJktiLkhNJm1DPXcwJk1XPHJZLEhxIzZNfVFHLDEzJndQfUpwXU93JXVlJktnPEhQPEQ5fjRrfjlUJkkyX2M2JDlUIzkvW0M1fjdPfjRhPWNzJk83PUtLPUFuJmw5JDZVJDhBJnVEJlFJfC9ZJmJnfVV4JkYyIzZifUUyJkpOJmtXJmtwPVUvJmJiPVhsPENqfWsrfjVKIzZMJjV6JjlpfWI0JkZvLGhvKFgwX2czfjRPJEZ6JlFFPEhOPVd3XTYvJUdGLVZ3PXRqJi9EJlBOIzlnPVlPfWNMJk9mJlBJfjVJJklwPXZVPUlXIzlHOzBvLXdVfXNzJlFSPEJUJlI5PXRrJFBZX2RoJlBxLXloXTdULG5qLlh1PUVQJjc2PWNJJkZzKlhnfXo3JEdiJitJPURGLEFGPWNBfXJMIzdqPUR6JjN5PEFhJDUyPVBRfWIwKGlZJEZhfW9MJnhWIzZVPWVjPVdaLHhoJVJZPGRwIzlOJkZsJjQ0PVdIKkE3PXNoJlRCJjhQPTA3O3UrJlBLfXVofUo1IzcyKVYvPXhDLEFCJGswJmY2OzFFfCs1PTFCLDN2XTZuJndSJWIrJnh4XTdmPU9sfWZsOytEXndHXTdFO25CO3VoXklyJmw1PUpMLG5TPWNmPWc1O3U2fC9RJEdjPU1IJUhnIzVkJU02Xjg2PVUrJEd6LGwvLGlyXjV5JkJhJi9GLUlZJkZJJmJlJUlaIzc3JlBXX051JGtFKFlmJk5YXTdaLEp5JkZKKFhvJk56Iy9kPXk3Jk1YPEFnfVorO25FXUR0KGlHIzREPTEzJlBqfjRjJXY4JlpvJU9MJi9YIzRXPEhSJmllfjZKXzFPKFkyPXk1PUFkKmN2X2VCIzZrJlBYOkJVIzdBO3VrJkZ0JkZ4X2REPVUyO3ZCPVU1PTRGfStPJkdOLkhIOjlzPWIwJU5WKGpPJklIPUpUfVo5PVZaPEFmLEt4XjRtJnVKJWM2LDZyOzltIytMfWNmJUtoJkYzfjRIPXZQfWJ1LEh6fCsrLDF3XW52fWs2O3V1JGp3KktsKldYJnVNW3g3JkZyW203JE5PJlFOXWh1PUpOfW5SXjhnIy9oKHBzfEtDO3ZkfXh6PVYwfXA2JkZEJEcxIzdLPGJHXzRwfjhnJmNmO3U0PXRsfStrJTUvfWZ6O3V3PGNBPXUxfWdVfVZNPUxKPWVYJitMJlByIzRVfXAyOm5DLDJLXTdIOmpGJjl4fXVYIzlPPU1CPGZ6fjhYfjVtJjREJmtOJnU1JUUvKGg3KFpGJlZHPGRlKHFNfC9lLVd0PTN4KGErLC9SXWYvJk5EJFJvJm5VfTBnPUtBJWtIJk5LJEtlPGRTfWNCJklYfjVnJFROXTZtPVV2LElzJlB5PUVmJUt6IysvJWJpJitBPEY0JE9HJjRDJkZMIzlWPFprPTJJX2VFJjZjXW53JmtxJEhHfXkrJkE4JFAzfU9IPVhQXTcwJUlTKEFKX2dIJUdaJnRZJkFaPXZifjZ5Ji9yPVZJPVd2PFppPWZsPXhmJmVMfWM4fU9MPU1KPWc4JEY3PVlUfTl1PTArXnhDfUpIJm5MXk4wfjRUXUsyLEN5JU9DIzZzO3ZHKEFDXnhlXmNHJk1GfUJyIzlQO3dELTdoJE8vJnhBfUZuXlBDXTZpXTdHJjhWJFFzO3ZsKFRCfjczfjRsPG1XJjZWPTJ5JnVZJiszKWFQfVhGO0xQJmt4JHdVPXQ3O3V5PEZOJmx6KTdFPU9vKlkrO3dJfTlxfWxlO0o2JlJpJjR0JlFyIzhCPWNiJnZHPUo1fFFsKGg1PFl5fjQrfVFELEx4PXduJUsvJlJLPWRPJlB3LFE5PWNvJTR1Ozl1fWcwQDZhXjRJJWIwPXpvfC9jJnRYPWRRPU9TIytiPXl6X0FCJndCJlBtPVc5JEhQX2dSPTYyPUFPPXRpPWhJLG9BJmpyJmRIPXRtJmI2JFAyKHg4PXppO25HfjdGOzA1XTBuW0l4JjNtfXJnPVhwPWNkJnV6XTd0Ozk3PWNOO3ZWPGpmJkZGJkYxPTZRJklrKktrJlA0LDJ6PWZRXTdEJjN1LEgwPWQvfVV3PFpOPDdSfUt2OzBmJEg3LE1EXTduJEYwIzg4fjlaJWRhPWJ5OytUIy91PVZGJmZPJmtyXmtmPEFCXXNVLEk1JE5nJlB6OzBpJlFEJnZNPVlsOkJNO25KX3hKXVU3JktmJjMwLDNmfFo5KmRDKWplX2pBJlE0JktwJE5IKFl6IzZTJklkJUliPUtYLEFEPUtWJWRQfXRXJlBrXitFX05pPWNxLDNSfVZaKFNpPWIrfXJ2OzBqfXJaXXVBLC93KFN4Jkp2JHc5JjRkJndFLE5KJEd5PUovXUxzIzdrPFpRPFkvJnVqXU92JFBNO3YzLDJGJit1OnVwPU9uJjNlLEp2OzkwPUorJlFtXTZxfWJLIytkfjhZKGgyXWhBOzk5JkFTPUkvfXFCJmRRfXlKLVZNfVZsJnVpLGlCJkczfERjXTdkPWVRJWRYJUpDXzFMfjRkXk5QO3ZKJi8xKVpJIzdOXTlYW2JRJlBMPTBMKFVaLExtJmtjJklSfW43KGlSPEFRPGRnPTMzPXZOfWZ0fWF1XTdJLEJhPXg5PWRSfjZSJlRxPVhpLDNkJE5yJkJjfURJJmt1JnZmXURuLC9GJmlELExsJk53PTB5Jkk3PUxzPS9BJnRVPVFlfVVhJnVrJitGPWc0PWdoPVZqIysxJlFufVV5KjQ0IzVGLFBjJlJ6KlhuPW9oPTVXOzBuX05mKGlFPFk3PXZyPVp1XW96IzVaJW1JPWtOPUJ2X0pwKFQyO3Z0X01sPEZTJnVJPUwvJjZQXTY0JE03fTg2PGJvJVFYKFNJJUlZJlZLPUFsJlV4O3Z2O3V0KkUvJXVoPFpFfE8zLE0yKHljXXl1PVdrJnRwOkV4fWhyLENsJldFKStaPThVfUkyXzRRLGhBX3NpPWl3PU9NPXRNPXlaJUlhPVU3O3dUfWIrO3VvPVphfXlTITV4fUhEfWZiIzVPX2RBO052JXVCKHlCOzAxKFNmfUZrO3Y3fVB0Izh2PG1aIzdMLC9yJlBsfjR3JmY1PVBoJEZ3X0xGJjhtLGJMPXlKJkJIfXAvKkpufXRVfjVRO3dCKGg2XURmXThwXitCO0U0JldjPWQrO0VhJmJ3JDhDJkZOLERNPVlmfW1QfjV3PWZUIzZWPW1DPUZpPUFWfWpCJkFOfWxXfWFIIy9EKWRaO2hsO3ZFfS83LENKOzMxJnc4LGhqJXU5X0pzPWpKJjRNfjhrPVROJmVDfW5MJnVjLXdpJmxYfWRqPU12PWUyIzZ1PWNyJHVxJDZHXThXfUpiOm5tPVlnPGIzKFVBO3ZYJjZuJnhGPUtULGpDLERlJlI4Jm9ZPVp2Jm9CXTcvPVoyJk9hfWJmLGhoKDRoXnRaJjcyJk54O0QyJnhMfjVofjQwKVpHKWgrPU9KJlJBXUJ2JHlCPU9xPWRmLEFRJUpufU9KOzExLDN6JlRsJnRqO3YrXkh2LERoKGlkPXMrXTdOJk4zKTlRfjhmLFM0PXVXPXc0JnVYLExYJjNkXUNKJnlwJjh4PGIyX2RvJmxQPXkvPGN5X2RHPU9pPTdSKFZIKGx0XzFULElxX0FBOzEyXjZUJWs2IzhLW0Ixe29PPEFVW0J0OzFiJDlTJlBzPDhUPVN0e2JZLGpCKFpwJjYzJlV2JDlWLFBNXTZ2JkFmfXpXW2JXX29xfXNtfW5CJktxJmdDJmZmX2VxXzJtJjVGJlRJfXJmfUdmO1pyX3o5O0VSJmprfWl6X3NuPEJOfituJnZvPVZpJTk3fFpSPVdjLFdFJjZ0XTZ6JTg1KGx5Izg0PUtZKTZtXzUvPWFYLE4zfVRtJmhlJjZLXXRSX0IyLUkzO3UvJmhVJmxIPEFQPWlCJklBPVhMOy81Jk5oPXd2PEJIIzc5PXZTPXpsPEFBPTBYX1JHfUJ3JjlwJE5XLEFYJmtQX0xwJi9aKFRjXU11fWhzIzZJfTVCJmNJPGJxJkg5IzZtPUs5fXZIKFkxKFkwIzRCJnc2LC85JmdHPGJFLC9PPXpifUk0X2w4PEIvO3dMJVFvPEhPW01xPVhYfTB2JkJQJkY0KG1HfTBpfW5tLEVDPTl1e0kzLHhHJi85PUpZKkRLJmhSKUJYPUVJPWN4PWIvezZrfXlYJUErJndhfVhiPWxhO3dpXmxMOzB0fWpvJlFiPXhnPVhCfWlPPHFve2JSPU5WJjhmPWEwJkp5OzB2PXVLKUhLO3ZOIzZoJmpCKGgvJXVkJk5JJXdZLlg3PVB0fUN1LXVMJkdzX2hsJW1ILHRtXTc4PUxiXlEwIzdZPTF1PEJ0JitRPUNvX1JILHczOzFlfXV4PGFVO3VpfVUzJlE1JWJ0XTYzJlVRfDBsJnVMfU83JjNvLEFWJmRtfE5qKFh0KjUrKFV1JkhoKHA3KFVGPVZSPUJwXkpsJkhkW2l4KTkvPUlxXUM4PDY3XTY2fW1CJTZmfWJifUpJXThUJEhBfWRiPVlNJnBhPTJKfXRTJlkwPVBTJnk0PWNYJDZFLGhYLFhQJm5SOzA0LEZRJmwwJlZtX0R2IzVZfjhaPUJpJU1BXTZ4PUpPOitwLEF6JjlxLEhqfjYvfVNEPUsxOkVKfW5BO1FvIy9FXTlSLEllJjZYJVczXTYxJnY0PXhYX01DPTBxOzA2KFhxPWZzfUlHfUR2PTBsfW83JGlaOzl2JkxIJkRQLTdhJk9ZLFNaLEt6LEN2JmRoPWZ4fE5oLEYvfjdxPVhGJncrOzluJkd3OzBofVo3PDdPJkpLKFM3JkxTPEFEPGFjPXdvPER0Jnp3JTRCPTR2IzhQOzlvfjZwKnZWPVRtLE9yJkk2PTFxfW5ZPVAwPWdxJkJsJlV1LENoJXlifVVZPXpofWRofXJsKFQ0X3hrKFlBIzhSKnhILElOfUpuXTdWfUM0JlR5fWozXTdwPWNMPTNoJndXJVF2PFozPWYwJlJJJitTKGljX3pxfW9OJi9ZPXoxO1RkPUxXPTBlPU9JKFZjLCtiXmp1KFVMOzByOlphJTh2PVJwPXp3JjU4JjczJndLfXFYXTZ5JjhFKWEyfVdSPXdQXnVyJm5RPGNIfVJlPUFxJndrfVEwJitxPVBQLEdjfC9kXms1LEZ3XThZfVBnXXAzPWp1PWVkfXI1X3lmJkNzXTd6JC9HPENtJkpwJjU0XzFHX2dQX0xsfUpaOzB1XWs4XzdrKFNnXTY1ezlpPUxOJlN4JldLLGlXJmZEJkxrezlhfUVtLTljIzhOJmlvPXN5XThkJm5UJklLKGx4IzcvJGxXKFRkPHM4fjQ5LDNvPDdZPU1XKFQrX0pyJldkLGlMfUN0PXhoJjVWO3Y0JjhuJUt4PWlGJmwyXzBCe0IrLElmKEowLEx2O3U4PUt4LXZCPUhDJnZTPVo2JmZVJnZFXnhLOzNEPTRoPU1SIzQ1Okp3OzBkfWl3PUxVfUk1PUkwXWdCKmltLEs5fUdVLDFrXzRVJlR0PVZzKGlYJmxVKFRGIzd5LFpPfW9BJm01IzVQfVBOfVV6PWhNPEIxJkZCPGFHLGU2fjdUPHRQKFVRX1pUPXd1JkY4KWFRXWlOLDFyX0xvJi9nOkNEfTg0e0oxX0tpJk5hJjNuJGp6JkZFPWRjO3V2O3ZhfWlufWxsPWZ2KGgxJjNofWZwPUN5fUJNKCtFfjhtfWxvJXY3PWhDKFQ2JGNqPUJRPUJ3KERSLDJqPUtzLE5TfEYrOzAwPWZVPTcwfU1iKFlVOytHJm03JmhyPVNrJUNvXXQrKFg1X0p3fTByfWdDKEFTLUlQJlFLPFoyIzhRJFdDXVdYfVQyJnBHX0thLEhDPVI0Ji9OO1orO2NoKEM3LEQ0JDNwX01rJkIyJDhEPW45JUt5IzV6KENUJlFKIzdCXURDXWdXfW5mfjVNO0l3IzgwfVRjXzFGIzRaLWFDfUhsPXBoPWZ6LC8zPWFXfUpNfW5uO0RHO3ZtfXduLDRQfVQzO3d4JlJHJHUrfXpLPTBiOytKX0Vre3JlPGFaPUFTfXlZIzVEXTdxLENwfXhOPVZQKjJDfUdafWFHfittX0NzPU9ZIzZyXTZnPEdTfUxDKFVCPTNBPUJvfUp5PGM0fUlzOzFQPEFHfU9wPFoxfWxkfW5TPTFaLHlNJjk1Jjk4PUNKKDR0OjJMJEhrPVpvfVZjOytJfW5wJk4xfTl5PWl2fUNPKjdwPWpMKXB4XXRiXnpoJkdTJlZsJXYvO3ZSPTE0PXpKJjQ5fC9mXWhGfVdHOzAzPThQfW8vJkdnJnJwO0RCLEt2fUppJlBiO2FBXmxsKDRqJXl0fStLJEh0IzR5JmhZXTdZPEYxLGVOfWJHKFVoJTZaXXQ1JUc3OytGX1JFO2l0fXRMPUxTJkRhPVh4KFMrKDRmPThHPXlJfWNKfVdQPTM3PWpTfXBYfWhkKWZwPEE4PUp0fitvJEhKPU02fWlYPWc5fUNTPWR2PUNqKG1QJUtkLHhxfCs5JkxEKDQvPVhtJlFQPUxjfUxYJmZMOytLPU9wKGx1PVFzLnFDOitlJkwrPUpqIzh3O1NMXTdTKGIrIzRJPWMxJm5HX0xmJnVIOytSKVpWPGJWJUIvLFRFJjBIJkpxJkFoJU9GJlNzKHAyLFd2JkkzPVdsfVZxOzFMJmxKIzliXzFIPThyPWI4PUpIKFNaPWhEPUoyIzdVLC9VIy9YfjZQLEZVPGVMPWp4LG1HPWhHPUNFJlBVPVNlKHFYJkxZPVg2PXk0JnRrJlFRJnRmPTRnJnhJfVcrJm1aPURjIzd3fUxnO0RBO3dRX0tiKGNKPWhSJXlYJlliLGh3e2JYXzRYO0VQOzFXXzJNfVVjPWI1KFlGLENNJlRwXk9Ke0REXTZzPXZGPVlvfjhxfVhIfUZ1JVA1KFNKPVF0O01PXXM4PEYzJkIzJjhUKFVsLUJTKmR3JmRSPDg3fS84XTYyJFBaXUx4PEF1fTlRXTdjPWphPUtSLEdvLFVzJnY2KHFrfXBHJkcyPWV2XkdNJXc0Jkg0XTdGJmR2XUo2fUV3Ojl3PXNqLVpMfVltJCtoKFV0KFVtfjRuPVhzKFU3JWVFPVFjX0pSPENBIzZ0PEZ2fC9JLElTLEVHPEYyKFh5JC9uPEZhKGg5fSs5XzJvJk40IzdYPFpxfCtmX0RwPWR0Jm5hLENhPU5KKWpZPThDPVlHPXM2JlErPERPfUQzPXhCJlIxKGx3O1FuPGJGKEN1fC9CfUhWPVNTJm43LDEwJnUwXURtJUE2XjRRPVdSKFREPVhvPEdILFJqKGw4KWJQJm4vPUxNJkNGLEY1Jm1sPVBKOzBrPUxHPXRxLFJoLEQ2QDRpPTFwJis5PVlDJWVyX01oO25JOzBxPUZ3XTgwPXhxPUZNJEd2O3Y2Jm5jO3dLJUgyJktqO3ZzLEFBPVlQLDY2fWJJKHFSfjVVPTZxfjRiJE5pPUs1LlgzJFNvJkl1KHArXThHPUNmPVJZKFRTX08zKGlIJjU3PWZFPURnX0RvIzl6IzdIO0ZLe3FkXzJrJUpSfWVuJmdoX3o4O1J4fTlwPGNOX05lLERPO0xOXzdvfi9wPU5GPTVZfWdOPGNlPEMxLFFFXVd2PTN1PEJDfUdLXXlxfURZJnUvX2hqPUlJKHB6JnJDLGpWJitafXV0PU5RO0NnLVNSX1pTLCtvPXUvO095X1JLX1FGKEZ4JnhQfVdyJlRBLFVoJmcxPXlye2F4W1ZGJFBnKFlCO094PVZ5OytXKFNwfVhWJWRkJjMzKGwvXWw0IzRZfU9FPTZjPWJ3KEE3Jjl0JXdkJk4vJm1vLEpIJlFlKWZtPUFvfWZ1PXRIXCI7XG5jb25zdCBkZWx0YURhdGEgPSBcIkZBWkRDNkJBTGNMWkNBK0dCQVJDVzh3TkNjRERaOExWRkJPcXFEVWlvdStNNDJURkF5RVJYRmI3RWpoUCt2bUJGcEZyVXBmRFYyRjdlQitlQ2x0Q0hKRldMRkNFRCtwV1RvakVJSEZYYzNhRm40RjY4enFqRXVLaWRTMVFCVlBERWhFN05BNG1oTUY3b1RoRDQ5b3QzRmd0ekhGQ0swYWNXMXg4REgxRW1Mb0lscldGQkxFK3k1K05BM0N4NjV3SkhUYUVaVmFLMW1XQW1QR3hnWUNkeHdPalRESXQvZmFPRWhUbDF2cU5zS3RKQ09oSld1aW8yZzA3S0xaRVFzRkJVcE50d0VCeUJneEZzbEZoZUZiaUVQdmk2MW1zRHZBcHhDekI2ckJDem94N2pvWUE1VWREYytDYjRGU2dJYWJwWEZBajNiamttRkF4Q1pFK21EL1NGZi8wRUxlY1lDdDNuTG94QzZXRVpmMnRLREI0b1p2ckVtcUZrS2s3QndJTEE3Z3RZQnBzVHEvL0Q0akQwRjB3RUI5cHlRMUJENUJhMG9ZSERJK3NiREZodnJIWGRESGZnRkVJSkxpNXI4cWVyY05GQmdGTEM0Ym81RVJKdGFtV0JERnk3M0tDRWI2TThWcG1FdDMzMHlnQ1RLNThFSUlGa1lnRjg0Z3RHQTlVeWgzbTY4aVZyRmJXRmJjYnFpQ1lIWjlKMWplUlBiTDh5c3doTWlEYmhFaGROb1N3RmJackxUNzQwQUJFcWdDa084SjFCTGQxVmhLS1I0c0QxeVVvMHorRkY1OU12ZzcxQ0ZieUVoYkhTRkJLRUlLeW9RTmdRcHBxOVQwS0FxZVB1MFpGR3JYT0hkS0pxa29URmhZdnBETnl1dXpuck44NHRoSmJzQ29PNkN1Nlhsdm50dnkwUVl1QUV4UUVZdFRVQmYzQ29DcXdnR0ZaNHUxSEpGekRWd0V5M2NqY3BWNFF2c1BhQkMzckNHeUNGMjNvNEszcHAyZ2JlckdnRkVKRUhvNG5ISUN0eUtIMlpxeXhoTjA1S0JCSklRbEtoL091anYvREgzMlZybHFGZElGQzdGejlDdDRrYXFGTUUwVUVUTHBybk45a2Z5K2tGbXRRQkIwKzVDRnUwTjlJajhsL1Z2SkRoMm9xM2hUNkV6alRIS0ZON1pqWndvVHNBWjRFeHNrbzZGcGE2V0Mrc2R1ejhqeXJMcGVnVHYyaDFFQmVZcExwbTJjelFXMEtvQ2NTMGJDVlhDbXVXSkRCak4xblFOTGRGNThTRkowaDdpM3BDM29FT0t5L0ZqQmtsTDcwWHZCRUVJV3AyeVowNHhPYnpBV0RESkc3ZitEYnFCRUE3THlpUjk1ajdNRFZkRFZpejJSRTV2V2xCTXY1ZTQrVmZoUDNhWE5QaHZMU3luYjlPMng0dUZCViszanF1NmQ1cENHMjgvc0VUQnl2bXUvK0lKMEwzd2I0cmo5RE5PTEJGNlhQSU9EcjRMMTlVOVJSb2ZBRzZOeHlkaThCa2k4QmhHSmJCQUpLemJKeGtaU2xGOVEyQ3U4b0txZ2dCOWhCQXJ3TExxRUJXRXRGb3d5OFhLOGJFeXc5c25UK0JleUZrMVpDU3JkbWdmRXdGZVBUZ0NqRUxCRW5JYmphRERQSm0zNnJHOXB6dGNFelQ4ZEdrMjNTQmhYQkIxSDR6K09XemUwb29Geno4cERCWUZ2cDlqOXR2RkJ5Zjl5NEVGZFZuejAyNkNHUjVxTXI3ZnhNSE44VVVkbHlKQXpsVEJEUkMyOGsrTDRGQjgwNzhsanlEOTF0VWoxb2NuVHM4dmRFZjd6bmJ6bStHSWpFWm5vWkU1cm5MTDcwMFhjN3lIZnowNW5XeHkwM3ZCQjlZR0hZT1d4Z01RR0JDUjI0Q1ZZTkUxaHBmS3hOMHpLbmZKRG1tTWdNbUJXcU5iamZTeUZDQldTQ0dDZ1I4eUZYaUh5RWorVnREMUZCM0ZwQzF6STBrRmJ6aWZpS1RMbTl5cTV6Rm11citxOEZIcWpvT0JXc0JQaURibkNDMkVydW5WNmNKNlR5Z1hGWUhZcDdNS045UlVsU0lTOC94QkFHWUx6ZXFVbkJGNFFic1R1VWtVcUdzNkNhaURXS1dqUUs5RUpranBrVG1OQ1BZWExcIjtcbmNvbnN0IF93b3JkbGlzdCA9IHtcbiAgICB6aF9jbjogbnVsbCxcbiAgICB6aF90dzogbnVsbFxufTtcbmNvbnN0IENoZWNrcyA9IHtcbiAgICB6aF9jbjogXCIweDE3YmNjNGQ4NTQ3ZTVhNzEzNWUzNjVkMWFiNDQzYWFhZTk1ZTc2ZDgyMzBjMjc4MmM2NzMwNWQ0ZjIxNDk3YTFcIixcbiAgICB6aF90dzogXCIweDUxZTcyMGU5MGM3Yjg3YmVjMWQ3MGViNmU3NGEyMWE0NDliZDNlYzljMDIwYjAxZDNhNDBlZDk5MWI2MGNlNWRcIlxufTtcbmNvbnN0IGNvZGVzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5jb25zdCBzdHlsZSA9IFwifiFAIyQlXiYqXy09W117fXw7OiwuKCk8Pj9cIjtcbmZ1bmN0aW9uIGxvYWRXb3Jkcyhsb2NhbGUpIHtcbiAgICBpZiAoX3dvcmRsaXN0W2xvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3dvcmRsaXN0W2xvY2FsZV07XG4gICAgfVxuICAgIGNvbnN0IHdvcmRsaXN0ID0gW107XG4gICAgbGV0IGRlbHRhT2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwNDg7IGkrKykge1xuICAgICAgICBjb25zdCBzID0gc3R5bGUuaW5kZXhPZihkYXRhW2kgKiAzXSk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gW1xuICAgICAgICAgICAgMjI4ICsgKHMgPj4gMiksXG4gICAgICAgICAgICAxMjggKyBjb2Rlcy5pbmRleE9mKGRhdGFbaSAqIDMgKyAxXSksXG4gICAgICAgICAgICAxMjggKyBjb2Rlcy5pbmRleE9mKGRhdGFbaSAqIDMgKyAyXSksXG4gICAgICAgIF07XG4gICAgICAgIGlmIChsb2NhbGUgPT09IFwiemhfdHdcIikge1xuICAgICAgICAgICAgY29uc3QgY29tbW9uID0gcyAlIDQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29tbW9uOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXNbaV0gPSBjb2Rlcy5pbmRleE9mKGRlbHRhRGF0YVtkZWx0YU9mZnNldCsrXSkgKyAoKGkgPT0gMCkgPyAyMjggOiAxMjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdvcmRsaXN0LnB1c2goKDAsIGluZGV4X2pzXzIudG9VdGY4U3RyaW5nKShuZXcgVWludDhBcnJheShieXRlcykpKTtcbiAgICB9XG4gICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBpbmRleF9qc18xLmlkKSh3b3JkbGlzdC5qb2luKFwiXFxuXCIpICsgXCJcXG5cIik7XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGNoZWNrc3VtICE9PSBDaGVja3NbbG9jYWxlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJJUDM5IFdvcmRsaXN0IGZvciAke2xvY2FsZX0gKENoaW5lc2UpIEZBSUxFRGApO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIF93b3JkbGlzdFtsb2NhbGVdID0gd29yZGxpc3Q7XG4gICAgcmV0dXJuIHdvcmRsaXN0O1xufVxuY29uc3Qgd29yZGxpc3RzID0ge307XG4vKipcbiAqICBUaGUgW1tsaW5rLWJpcDM5LXpoX2NuXV0gYW5kIFtbbGluay1iaXAzOS16aF90d11dIGZvclxuICogIFttbmVtb25pYyBwaHJhc2VzXShsaW5rLWJpcC0zOSkuXG4gKlxuICogIEBfZG9jbG9jOiBhcGkvd29yZGxpc3RzXG4gKi9cbmNsYXNzIExhbmdaaCBleHRlbmRzIHdvcmRsaXN0X2pzXzEuV29yZGxpc3Qge1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDaGluZXNlIGxhbmd1YWdlIFdvcmRsaXN0IGZvclxuICAgICAqICB0aGUgJSVkaWFsZWN0JSUsIGVpdGhlciBgYFwiY25cImBgIG9yIGBgXCJ0d1wiYGAgZm9yIHNpbXBsaWZpZWRcbiAgICAgKiAgb3IgdHJhZGl0aW9uYWwsIHJlc3BlY3RpdmVseS5cbiAgICAgKlxuICAgICAqICBUaGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBtb3N0IG9mIHRoZSB0aW1lIGFzIHRoZSBleHBvcnRlZFxuICAgICAqICBbW2xhbmdaaENuXV0gYW5kIFtbbGFuZ1poVHddXSBzaG91bGQgc3VmZmljZS5cbiAgICAgKlxuICAgICAqICBAX2lnbm9yZTpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkaWFsZWN0KSB7IHN1cGVyKFwiemhfXCIgKyBkaWFsZWN0KTsgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBsb2FkV29yZHModGhpcy5sb2NhbGUpO1xuICAgICAgICAoMCwgaW5kZXhfanNfMi5hc3NlcnRBcmd1bWVudCkoaW5kZXggPj0gMCAmJiBpbmRleCA8IHdvcmRzLmxlbmd0aCwgYGludmFsaWQgd29yZCBpbmRleDogJHtpbmRleH1gLCBcImluZGV4XCIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHdvcmRzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0V29yZEluZGV4KHdvcmQpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRXb3Jkcyh0aGlzLmxvY2FsZSkuaW5kZXhPZih3b3JkKTtcbiAgICB9XG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC8oPzpcXHUzMDAwfCApKy9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHBocmFzZS5zcGxpdChcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYSBgYExhbmdaaGBgIGZvciAlJWRpYWxlY3QlJSxcbiAgICAgKiAgY3JlYXRpbmcgaXQgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAgVXNlIHRoZSAlJWRpYWxlY3QlJSBgYFwiY25cImBgIG9yIGBgXCJ0d1wiYGAgZm9yIHNpbXBsaWZpZWQgb3JcbiAgICAgKiAgdHJhZGl0aW9uYWwsIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZGxpc3QoZGlhbGVjdCkge1xuICAgICAgICBpZiAod29yZGxpc3RzW2RpYWxlY3RdID09IG51bGwpIHtcbiAgICAgICAgICAgIHdvcmRsaXN0c1tkaWFsZWN0XSA9IG5ldyBMYW5nWmgoZGlhbGVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0c1tkaWFsZWN0XTtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdaaCA9IExhbmdaaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctemguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTGFuZ1poIiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJpbmRleF9qc18yIiwid29yZGxpc3RfanNfMSIsImRhdGEiLCJkZWx0YURhdGEiLCJfd29yZGxpc3QiLCJ6aF9jbiIsInpoX3R3IiwiQ2hlY2tzIiwiY29kZXMiLCJzdHlsZSIsImxvYWRXb3JkcyIsImxvY2FsZSIsIndvcmRsaXN0IiwiZGVsdGFPZmZzZXQiLCJpIiwicyIsImluZGV4T2YiLCJieXRlcyIsImNvbW1vbiIsInB1c2giLCJ0b1V0ZjhTdHJpbmciLCJVaW50OEFycmF5IiwiY2hlY2tzdW0iLCJpZCIsImpvaW4iLCJFcnJvciIsIndvcmRsaXN0cyIsIldvcmRsaXN0IiwiY29uc3RydWN0b3IiLCJkaWFsZWN0IiwiZ2V0V29yZCIsImluZGV4Iiwid29yZHMiLCJhc3NlcnRBcmd1bWVudCIsImxlbmd0aCIsImdldFdvcmRJbmRleCIsIndvcmQiLCJzcGxpdCIsInBocmFzZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js":
/*!********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Use the encode-latin.js script to create the necessary\n// data files to be consumed by this class\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WordlistOwl = void 0;\nconst index_js_1 = __webpack_require__(/*! ../hash/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/hash/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\nconst decode_owl_js_1 = __webpack_require__(/*! ./decode-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owl.js\");\nconst wordlist_js_1 = __webpack_require__(/*! ./wordlist.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\");\n/**\n *  An OWL format Wordlist is an encoding method that exploits\n *  the general locality of alphabetically sorted words to\n *  achieve a simple but effective means of compression.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on ASCII-7 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */ class WordlistOwl extends wordlist_js_1.Wordlist {\n    #data;\n    #checksum;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWL %%data%%\n     *  and validated against the %%checksum%%.\n     */ constructor(locale, data, checksum){\n        super(locale);\n        this.#data = data;\n        this.#checksum = checksum;\n        this.#words = null;\n    }\n    /**\n     *  The OWL-encoded data.\n     */ get _data() {\n        return this.#data;\n    }\n    /**\n     *  Decode all the words for the wordlist.\n     */ _decodeWords() {\n        return (0, decode_owl_js_1.decodeOwl)(this.#data);\n    }\n    #words;\n    #loadWords() {\n        if (this.#words == null) {\n            const words = this._decodeWords();\n            // Verify the computed list matches the official list\n            const checksum = (0, index_js_1.id)(words.join(\"\\n\") + \"\\n\");\n            /* c8 ignore start */ if (checksum !== this.#checksum) {\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);\n            }\n            /* c8 ignore stop */ this.#words = words;\n        }\n        return this.#words;\n    }\n    getWord(index) {\n        const words = this.#loadWords();\n        (0, index_js_2.assertArgument)(index >= 0 && index < words.length, `invalid word index: ${index}`, \"index\", index);\n        return words[index];\n    }\n    getWordIndex(word) {\n        return this.#loadWords().indexOf(word);\n    }\n}\nexports.WordlistOwl = WordlistOwl; //# sourceMappingURL=wordlist-owl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IseURBQXlEO0FBQ3pELDBDQUEwQztBQUMxQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQWtCO0FBQzdDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLGtGQUFtQjtBQUM5QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLHlGQUFpQjtBQUNqRCxNQUFNRyxnQkFBZ0JILG1CQUFPQSxDQUFDLHFGQUFlO0FBQzdDOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsTUFBTUYsb0JBQW9CSyxjQUFjQyxRQUFRO0lBQzVDLENBQUNDLElBQUksQ0FBQztJQUNOLENBQUNDLFFBQVEsQ0FBQztJQUNWOzs7S0FHQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVILElBQUksRUFBRUMsUUFBUSxDQUFFO1FBQ2hDLEtBQUssQ0FBQ0U7UUFDTixJQUFJLENBQUMsQ0FBQ0gsSUFBSSxHQUFHQTtRQUNiLElBQUksQ0FBQyxDQUFDQyxRQUFRLEdBQUdBO1FBQ2pCLElBQUksQ0FBQyxDQUFDRyxLQUFLLEdBQUc7SUFDbEI7SUFDQTs7S0FFQyxHQUNELElBQUlDLFFBQVE7UUFBRSxPQUFPLElBQUksQ0FBQyxDQUFDTCxJQUFJO0lBQUU7SUFDakM7O0tBRUMsR0FDRE0sZUFBZTtRQUNYLE9BQU8sQ0FBQyxHQUFHVCxnQkFBZ0JVLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQ1AsSUFBSTtJQUNwRDtJQUNBLENBQUNJLEtBQUssQ0FBQztJQUNQLENBQUNJLFNBQVM7UUFDTixJQUFJLElBQUksQ0FBQyxDQUFDSixLQUFLLElBQUksTUFBTTtZQUNyQixNQUFNQSxRQUFRLElBQUksQ0FBQ0UsWUFBWTtZQUMvQixxREFBcUQ7WUFDckQsTUFBTUwsV0FBVyxDQUFDLEdBQUdQLFdBQVdlLEVBQUUsRUFBRUwsTUFBTU0sSUFBSSxDQUFDLFFBQVE7WUFDdkQsbUJBQW1CLEdBQ25CLElBQUlULGFBQWEsSUFBSSxDQUFDLENBQUNBLFFBQVEsRUFBRTtnQkFDN0IsTUFBTSxJQUFJVSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDUixNQUFNLENBQUMsT0FBTyxDQUFDO1lBQzlEO1lBQ0Esa0JBQWtCLEdBQ2xCLElBQUksQ0FBQyxDQUFDQyxLQUFLLEdBQUdBO1FBQ2xCO1FBQ0EsT0FBTyxJQUFJLENBQUMsQ0FBQ0EsS0FBSztJQUN0QjtJQUNBUSxRQUFRQyxLQUFLLEVBQUU7UUFDWCxNQUFNVCxRQUFRLElBQUksQ0FBQyxDQUFDSSxTQUFTO1FBQzVCLElBQUdaLFdBQVdrQixjQUFjLEVBQUVELFNBQVMsS0FBS0EsUUFBUVQsTUFBTVcsTUFBTSxFQUFFLENBQUMsb0JBQW9CLEVBQUVGLE1BQU0sQ0FBQyxFQUFFLFNBQVNBO1FBQzVHLE9BQU9ULEtBQUssQ0FBQ1MsTUFBTTtJQUN2QjtJQUNBRyxhQUFhQyxJQUFJLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQyxDQUFDVCxTQUFTLEdBQUdVLE9BQU8sQ0FBQ0Q7SUFDckM7QUFDSjtBQUNBMUIsbUJBQW1CLEdBQUdFLGFBQ3RCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmNvbW1vbmpzL3dvcmRsaXN0cy93b3JkbGlzdC1vd2wuanM/NGZhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFVzZSB0aGUgZW5jb2RlLWxhdGluLmpzIHNjcmlwdCB0byBjcmVhdGUgdGhlIG5lY2Vzc2FyeVxuLy8gZGF0YSBmaWxlcyB0byBiZSBjb25zdW1lZCBieSB0aGlzIGNsYXNzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldvcmRsaXN0T3dsID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9oYXNoL2luZGV4LmpzXCIpO1xuY29uc3QgaW5kZXhfanNfMiA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmRleC5qc1wiKTtcbmNvbnN0IGRlY29kZV9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZS1vd2wuanNcIik7XG5jb25zdCB3b3JkbGlzdF9qc18xID0gcmVxdWlyZShcIi4vd29yZGxpc3QuanNcIik7XG4vKipcbiAqICBBbiBPV0wgZm9ybWF0IFdvcmRsaXN0IGlzIGFuIGVuY29kaW5nIG1ldGhvZCB0aGF0IGV4cGxvaXRzXG4gKiAgdGhlIGdlbmVyYWwgbG9jYWxpdHkgb2YgYWxwaGFiZXRpY2FsbHkgc29ydGVkIHdvcmRzIHRvXG4gKiAgYWNoaWV2ZSBhIHNpbXBsZSBidXQgZWZmZWN0aXZlIG1lYW5zIG9mIGNvbXByZXNzaW9uLlxuICpcbiAqICBUaGlzIGNsYXNzIGlzIGdlbmVyYWxseSBub3QgdXNlZnVsIHRvIG1vc3QgZGV2ZWxvcGVycyBhc1xuICogIGl0IGlzIHVzZWQgbWFpbmx5IGludGVybmFsbHkgdG8ga2VlcCBXb3JkbGlzdHMgZm9yIGxhbmd1YWdlc1xuICogIGJhc2VkIG9uIEFTQ0lJLTcgc21hbGwuXG4gKlxuICogIElmIG5lY2Vzc2FyeSwgdGhlcmUgYXJlIHRvb2xzIHdpdGhpbiB0aGUgYGBnZW5lcmF0aW9uL2BgIGZvbGRlclxuICogIHRvIGNyZWF0ZSB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKi9cbmNsYXNzIFdvcmRsaXN0T3dsIGV4dGVuZHMgd29yZGxpc3RfanNfMS5Xb3JkbGlzdCB7XG4gICAgI2RhdGE7XG4gICAgI2NoZWNrc3VtO1xuICAgIC8qKlxuICAgICAqICBDcmVhdGVzIGEgbmV3IFdvcmRsaXN0IGZvciAlJWxvY2FsZSUlIHVzaW5nIHRoZSBPV0wgJSVkYXRhJSVcbiAgICAgKiAgYW5kIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSAlJWNoZWNrc3VtJSUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlLCBkYXRhLCBjaGVja3N1bSkge1xuICAgICAgICBzdXBlcihsb2NhbGUpO1xuICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy4jY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICAgICAgdGhpcy4jd29yZHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVGhlIE9XTC1lbmNvZGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IF9kYXRhKCkgeyByZXR1cm4gdGhpcy4jZGF0YTsgfVxuICAgIC8qKlxuICAgICAqICBEZWNvZGUgYWxsIHRoZSB3b3JkcyBmb3IgdGhlIHdvcmRsaXN0LlxuICAgICAqL1xuICAgIF9kZWNvZGVXb3JkcygpIHtcbiAgICAgICAgcmV0dXJuICgwLCBkZWNvZGVfb3dsX2pzXzEuZGVjb2RlT3dsKSh0aGlzLiNkYXRhKTtcbiAgICB9XG4gICAgI3dvcmRzO1xuICAgICNsb2FkV29yZHMoKSB7XG4gICAgICAgIGlmICh0aGlzLiN3b3JkcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRoaXMuX2RlY29kZVdvcmRzKCk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGNvbXB1dGVkIGxpc3QgbWF0Y2hlcyB0aGUgb2ZmaWNpYWwgbGlzdFxuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgaW5kZXhfanNfMS5pZCkod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoY2hlY2tzdW0gIT09IHRoaXMuI2NoZWNrc3VtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCSVAzOSBXb3JkbGlzdCBmb3IgJHt0aGlzLmxvY2FsZX0gRkFJTEVEYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jd29yZHMgPSB3b3JkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jd29yZHM7XG4gICAgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLiNsb2FkV29yZHMoKTtcbiAgICAgICAgKDAsIGluZGV4X2pzXzIuYXNzZXJ0QXJndW1lbnQpKGluZGV4ID49IDAgJiYgaW5kZXggPCB3b3Jkcy5sZW5ndGgsIGBpbnZhbGlkIHdvcmQgaW5kZXg6ICR7aW5kZXh9YCwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgICAgIHJldHVybiB3b3Jkc1tpbmRleF07XG4gICAgfVxuICAgIGdldFdvcmRJbmRleCh3b3JkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsb2FkV29yZHMoKS5pbmRleE9mKHdvcmQpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3RPd2wgPSBXb3JkbGlzdE93bDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LW93bC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXb3JkbGlzdE93bCIsImluZGV4X2pzXzEiLCJyZXF1aXJlIiwiaW5kZXhfanNfMiIsImRlY29kZV9vd2xfanNfMSIsIndvcmRsaXN0X2pzXzEiLCJXb3JkbGlzdCIsImRhdGEiLCJjaGVja3N1bSIsImNvbnN0cnVjdG9yIiwibG9jYWxlIiwid29yZHMiLCJfZGF0YSIsIl9kZWNvZGVXb3JkcyIsImRlY29kZU93bCIsImxvYWRXb3JkcyIsImlkIiwiam9pbiIsIkVycm9yIiwiZ2V0V29yZCIsImluZGV4IiwiYXNzZXJ0QXJndW1lbnQiLCJsZW5ndGgiLCJnZXRXb3JkSW5kZXgiLCJ3b3JkIiwiaW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.WordlistOwlA = void 0;\nconst wordlist_owl_js_1 = __webpack_require__(/*! ./wordlist-owl.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js\");\nconst decode_owla_js_1 = __webpack_require__(/*! ./decode-owla.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/decode-owla.js\");\n/**\n *  An OWL-A format Wordlist extends the OWL format to add an\n *  overlay onto an OWL format Wordlist to support diacritic\n *  marks.\n *\n *  This class is generally not useful to most developers as\n *  it is used mainly internally to keep Wordlists for languages\n *  based on latin-1 small.\n *\n *  If necessary, there are tools within the ``generation/`` folder\n *  to create the necessary data.\n */ class WordlistOwlA extends wordlist_owl_js_1.WordlistOwl {\n    #accent;\n    /**\n     *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%\n     *  and %%accent%% data and validated against the %%checksum%%.\n     */ constructor(locale, data, accent, checksum){\n        super(locale, data, checksum);\n        this.#accent = accent;\n    }\n    /**\n     *  The OWLA-encoded accent data.\n     */ get _accent() {\n        return this.#accent;\n    }\n    /**\n     *  Decode all the words for the wordlist.\n     */ _decodeWords() {\n        return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);\n    }\n}\nexports.WordlistOwlA = WordlistOwlA; //# sourceMappingURL=wordlist-owla.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixNQUFNRyxvQkFBb0JDLG1CQUFPQSxDQUFDLDZGQUFtQjtBQUNyRCxNQUFNQyxtQkFBbUJELG1CQUFPQSxDQUFDLDJGQUFrQjtBQUNuRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELE1BQU1GLHFCQUFxQkMsa0JBQWtCRyxXQUFXO0lBQ3BELENBQUNDLE1BQU0sQ0FBQztJQUNSOzs7S0FHQyxHQUNEQyxZQUFZQyxNQUFNLEVBQUVDLElBQUksRUFBRUgsTUFBTSxFQUFFSSxRQUFRLENBQUU7UUFDeEMsS0FBSyxDQUFDRixRQUFRQyxNQUFNQztRQUNwQixJQUFJLENBQUMsQ0FBQ0osTUFBTSxHQUFHQTtJQUNuQjtJQUNBOztLQUVDLEdBQ0QsSUFBSUssVUFBVTtRQUFFLE9BQU8sSUFBSSxDQUFDLENBQUNMLE1BQU07SUFBRTtJQUNyQzs7S0FFQyxHQUNETSxlQUFlO1FBQ1gsT0FBTyxDQUFDLEdBQUdSLGlCQUFpQlMsVUFBVSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0gsT0FBTztJQUNwRTtBQUNKO0FBQ0FaLG9CQUFvQixHQUFHRSxjQUN2Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3Qtb3dsYS5qcz82MDhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JkbGlzdE93bEEgPSB2b2lkIDA7XG5jb25zdCB3b3JkbGlzdF9vd2xfanNfMSA9IHJlcXVpcmUoXCIuL3dvcmRsaXN0LW93bC5qc1wiKTtcbmNvbnN0IGRlY29kZV9vd2xhX2pzXzEgPSByZXF1aXJlKFwiLi9kZWNvZGUtb3dsYS5qc1wiKTtcbi8qKlxuICogIEFuIE9XTC1BIGZvcm1hdCBXb3JkbGlzdCBleHRlbmRzIHRoZSBPV0wgZm9ybWF0IHRvIGFkZCBhblxuICogIG92ZXJsYXkgb250byBhbiBPV0wgZm9ybWF0IFdvcmRsaXN0IHRvIHN1cHBvcnQgZGlhY3JpdGljXG4gKiAgbWFya3MuXG4gKlxuICogIFRoaXMgY2xhc3MgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwgdG8gbW9zdCBkZXZlbG9wZXJzIGFzXG4gKiAgaXQgaXMgdXNlZCBtYWlubHkgaW50ZXJuYWxseSB0byBrZWVwIFdvcmRsaXN0cyBmb3IgbGFuZ3VhZ2VzXG4gKiAgYmFzZWQgb24gbGF0aW4tMSBzbWFsbC5cbiAqXG4gKiAgSWYgbmVjZXNzYXJ5LCB0aGVyZSBhcmUgdG9vbHMgd2l0aGluIHRoZSBgYGdlbmVyYXRpb24vYGAgZm9sZGVyXG4gKiAgdG8gY3JlYXRlIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqL1xuY2xhc3MgV29yZGxpc3RPd2xBIGV4dGVuZHMgd29yZGxpc3Rfb3dsX2pzXzEuV29yZGxpc3RPd2wge1xuICAgICNhY2NlbnQ7XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgV29yZGxpc3QgZm9yICUlbG9jYWxlJSUgdXNpbmcgdGhlIE9XTEEgJSVkYXRhJSVcbiAgICAgKiAgYW5kICUlYWNjZW50JSUgZGF0YSBhbmQgdmFsaWRhdGVkIGFnYWluc3QgdGhlICUlY2hlY2tzdW0lJS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRhdGEsIGFjY2VudCwgY2hlY2tzdW0pIHtcbiAgICAgICAgc3VwZXIobG9jYWxlLCBkYXRhLCBjaGVja3N1bSk7XG4gICAgICAgIHRoaXMuI2FjY2VudCA9IGFjY2VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRoZSBPV0xBLWVuY29kZWQgYWNjZW50IGRhdGEuXG4gICAgICovXG4gICAgZ2V0IF9hY2NlbnQoKSB7IHJldHVybiB0aGlzLiNhY2NlbnQ7IH1cbiAgICAvKipcbiAgICAgKiAgRGVjb2RlIGFsbCB0aGUgd29yZHMgZm9yIHRoZSB3b3JkbGlzdC5cbiAgICAgKi9cbiAgICBfZGVjb2RlV29yZHMoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZGVjb2RlX293bGFfanNfMS5kZWNvZGVPd2xBKSh0aGlzLl9kYXRhLCB0aGlzLl9hY2NlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3RPd2xBID0gV29yZGxpc3RPd2xBO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3Qtb3dsYS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJXb3JkbGlzdE93bEEiLCJ3b3JkbGlzdF9vd2xfanNfMSIsInJlcXVpcmUiLCJkZWNvZGVfb3dsYV9qc18xIiwiV29yZGxpc3RPd2wiLCJhY2NlbnQiLCJjb25zdHJ1Y3RvciIsImxvY2FsZSIsImRhdGEiLCJjaGVja3N1bSIsIl9hY2NlbnQiLCJfZGVjb2RlV29yZHMiLCJkZWNvZGVPd2xBIiwiX2RhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlist.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Wordlist = void 0;\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/utils/index.js\");\n/**\n *  A Wordlist represents a collection of language-specific\n *  words used to encode and devoce [[link-bip-39]] encoded data\n *  by mapping words to 11-bit values and vice versa.\n */ class Wordlist {\n    /**\n     *  Creates a new Wordlist instance.\n     *\n     *  Sub-classes MUST call this if they provide their own constructor,\n     *  passing in the locale string of the language.\n     *\n     *  Generally there is no need to create instances of a Wordlist,\n     *  since each language-specific Wordlist creates an instance and\n     *  there is no state kept internally, so they are safe to share.\n     */ constructor(locale){\n        (0, index_js_1.defineProperties)(this, {\n            locale\n        });\n    }\n    /**\n     *  Sub-classes may override this to provide a language-specific\n     *  method for spliting %%phrase%% into individual words.\n     *\n     *  By default, %%phrase%% is split using any sequences of\n     *  white-space as defined by regular expressions (i.e. ``/\\s+/``).\n     */ split(phrase) {\n        return phrase.toLowerCase().split(/\\s+/g);\n    }\n    /**\n     *  Sub-classes may override this to provider a language-specific\n     *  method for joining %%words%% into a phrase.\n     *\n     *  By default, %%words%% are joined by a single space.\n     */ join(words) {\n        return words.join(\" \");\n    }\n}\nexports.Wordlist = Wordlist; //# sourceMappingURL=wordlist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsYUFBYUMsbUJBQU9BLENBQUMsa0ZBQW1CO0FBQzlDOzs7O0NBSUMsR0FDRCxNQUFNRjtJQUVGOzs7Ozs7Ozs7S0FTQyxHQUNERyxZQUFZQyxNQUFNLENBQUU7UUFDZixJQUFHSCxXQUFXSSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUU7WUFBRUQ7UUFBTztJQUNwRDtJQUNBOzs7Ozs7S0FNQyxHQUNERSxNQUFNQyxNQUFNLEVBQUU7UUFDVixPQUFPQSxPQUFPQyxXQUFXLEdBQUdGLEtBQUssQ0FBQztJQUN0QztJQUNBOzs7OztLQUtDLEdBQ0RHLEtBQUtDLEtBQUssRUFBRTtRQUNSLE9BQU9BLE1BQU1ELElBQUksQ0FBQztJQUN0QjtBQUNKO0FBQ0FYLGdCQUFnQixHQUFHRSxVQUNuQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3QuanM/ZmJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV29yZGxpc3QgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL2luZGV4LmpzXCIpO1xuLyoqXG4gKiAgQSBXb3JkbGlzdCByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBsYW5ndWFnZS1zcGVjaWZpY1xuICogIHdvcmRzIHVzZWQgdG8gZW5jb2RlIGFuZCBkZXZvY2UgW1tsaW5rLWJpcC0zOV1dIGVuY29kZWQgZGF0YVxuICogIGJ5IG1hcHBpbmcgd29yZHMgdG8gMTEtYml0IHZhbHVlcyBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuY2xhc3MgV29yZGxpc3Qge1xuICAgIGxvY2FsZTtcbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBXb3JkbGlzdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyBNVVNUIGNhbGwgdGhpcyBpZiB0aGV5IHByb3ZpZGUgdGhlaXIgb3duIGNvbnN0cnVjdG9yLFxuICAgICAqICBwYXNzaW5nIGluIHRoZSBsb2NhbGUgc3RyaW5nIG9mIHRoZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqICBHZW5lcmFsbHkgdGhlcmUgaXMgbm8gbmVlZCB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgV29yZGxpc3QsXG4gICAgICogIHNpbmNlIGVhY2ggbGFuZ3VhZ2Utc3BlY2lmaWMgV29yZGxpc3QgY3JlYXRlcyBhbiBpbnN0YW5jZSBhbmRcbiAgICAgKiAgdGhlcmUgaXMgbm8gc3RhdGUga2VwdCBpbnRlcm5hbGx5LCBzbyB0aGV5IGFyZSBzYWZlIHRvIHNoYXJlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsZSkge1xuICAgICAgICAoMCwgaW5kZXhfanNfMS5kZWZpbmVQcm9wZXJ0aWVzKSh0aGlzLCB7IGxvY2FsZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGUgYSBsYW5ndWFnZS1zcGVjaWZpY1xuICAgICAqICBtZXRob2QgZm9yIHNwbGl0aW5nICUlcGhyYXNlJSUgaW50byBpbmRpdmlkdWFsIHdvcmRzLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUlcGhyYXNlJSUgaXMgc3BsaXQgdXNpbmcgYW55IHNlcXVlbmNlcyBvZlxuICAgICAqICB3aGl0ZS1zcGFjZSBhcyBkZWZpbmVkIGJ5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgKGkuZS4gYGAvXFxzKy9gYCkuXG4gICAgICovXG4gICAgc3BsaXQocGhyYXNlKSB7XG4gICAgICAgIHJldHVybiBwaHJhc2UudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFN1Yi1jbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIHRvIHByb3ZpZGVyIGEgbGFuZ3VhZ2Utc3BlY2lmaWNcbiAgICAgKiAgbWV0aG9kIGZvciBqb2luaW5nICUld29yZHMlJSBpbnRvIGEgcGhyYXNlLlxuICAgICAqXG4gICAgICogIEJ5IGRlZmF1bHQsICUld29yZHMlJSBhcmUgam9pbmVkIGJ5IGEgc2luZ2xlIHNwYWNlLlxuICAgICAqL1xuICAgIGpvaW4od29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuV29yZGxpc3QgPSBXb3JkbGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldvcmRsaXN0IiwiaW5kZXhfanNfMSIsInJlcXVpcmUiLCJjb25zdHJ1Y3RvciIsImxvY2FsZSIsImRlZmluZVByb3BlcnRpZXMiLCJzcGxpdCIsInBocmFzZSIsInRvTG93ZXJDYXNlIiwiam9pbiIsIndvcmRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlist.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ethers/lib.commonjs/wordlists/wordlists.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wordlists = void 0;\nconst lang_cz_js_1 = __webpack_require__(/*! ./lang-cz.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-cz.js\");\nconst lang_en_js_1 = __webpack_require__(/*! ./lang-en.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-en.js\");\nconst lang_es_js_1 = __webpack_require__(/*! ./lang-es.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-es.js\");\nconst lang_fr_js_1 = __webpack_require__(/*! ./lang-fr.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-fr.js\");\nconst lang_ja_js_1 = __webpack_require__(/*! ./lang-ja.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ja.js\");\nconst lang_ko_js_1 = __webpack_require__(/*! ./lang-ko.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-ko.js\");\nconst lang_it_js_1 = __webpack_require__(/*! ./lang-it.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-it.js\");\nconst lang_pt_js_1 = __webpack_require__(/*! ./lang-pt.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-pt.js\");\nconst lang_zh_js_1 = __webpack_require__(/*! ./lang-zh.js */ \"(rsc)/./node_modules/ethers/lib.commonjs/wordlists/lang-zh.js\");\n/**\n *  The available Wordlists by their\n *  [ISO 639-1 Language Code](link-wiki-iso639).\n *\n *  (**i.e.** [cz](LangCz), [en](LangEn), [es](LangEs), [fr](LangFr),\n *  [ja](LangJa), [ko](LangKo), [it](LangIt), [pt](LangPt),\n *  [zh_cn](LangZh), [zh_tw](LangZh))\n *\n *  The dist files (in the ``/dist`` folder) have had all languages\n *  except English stripped out, which reduces the library size by\n *  about 80kb. If required, they are available by importing the\n *  included ``wordlists-extra.min.js`` file.\n */ exports.wordlists = {\n    cz: lang_cz_js_1.LangCz.wordlist(),\n    en: lang_en_js_1.LangEn.wordlist(),\n    es: lang_es_js_1.LangEs.wordlist(),\n    fr: lang_fr_js_1.LangFr.wordlist(),\n    it: lang_it_js_1.LangIt.wordlist(),\n    pt: lang_pt_js_1.LangPt.wordlist(),\n    ja: lang_ja_js_1.LangJa.wordlist(),\n    ko: lang_ko_js_1.LangKo.wordlist(),\n    zh_cn: lang_zh_js_1.LangZh.wordlist(\"cn\"),\n    zh_tw: lang_zh_js_1.LangZh.wordlist(\"tw\")\n}; //# sourceMappingURL=wordlists.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5jb21tb25qcy93b3JkbGlzdHMvd29yZGxpc3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGVBQWVDLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1JLGVBQWVKLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1LLGVBQWVMLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1NLGVBQWVOLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDLE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLG1GQUFjO0FBQzNDOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNESixpQkFBaUIsR0FBRztJQUNoQmEsSUFBSVYsYUFBYVcsTUFBTSxDQUFDQyxRQUFRO0lBQ2hDQyxJQUFJWCxhQUFhWSxNQUFNLENBQUNGLFFBQVE7SUFDaENHLElBQUlaLGFBQWFhLE1BQU0sQ0FBQ0osUUFBUTtJQUNoQ0ssSUFBSWIsYUFBYWMsTUFBTSxDQUFDTixRQUFRO0lBQ2hDTyxJQUFJWixhQUFhYSxNQUFNLENBQUNSLFFBQVE7SUFDaENTLElBQUliLGFBQWFjLE1BQU0sQ0FBQ1YsUUFBUTtJQUNoQ1csSUFBSWxCLGFBQWFtQixNQUFNLENBQUNaLFFBQVE7SUFDaENhLElBQUluQixhQUFhb0IsTUFBTSxDQUFDZCxRQUFRO0lBQ2hDZSxPQUFPbEIsYUFBYW1CLE1BQU0sQ0FBQ2hCLFFBQVEsQ0FBQztJQUNwQ2lCLE9BQU9wQixhQUFhbUIsTUFBTSxDQUFDaEIsUUFBUSxDQUFDO0FBQ3hDLEdBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuY29tbW9uanMvd29yZGxpc3RzL3dvcmRsaXN0cy5qcz9lOTE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53b3JkbGlzdHMgPSB2b2lkIDA7XG5jb25zdCBsYW5nX2N6X2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWN6LmpzXCIpO1xuY29uc3QgbGFuZ19lbl9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1lbi5qc1wiKTtcbmNvbnN0IGxhbmdfZXNfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctZXMuanNcIik7XG5jb25zdCBsYW5nX2ZyX2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWZyLmpzXCIpO1xuY29uc3QgbGFuZ19qYV9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1qYS5qc1wiKTtcbmNvbnN0IGxhbmdfa29fanNfMSA9IHJlcXVpcmUoXCIuL2xhbmcta28uanNcIik7XG5jb25zdCBsYW5nX2l0X2pzXzEgPSByZXF1aXJlKFwiLi9sYW5nLWl0LmpzXCIpO1xuY29uc3QgbGFuZ19wdF9qc18xID0gcmVxdWlyZShcIi4vbGFuZy1wdC5qc1wiKTtcbmNvbnN0IGxhbmdfemhfanNfMSA9IHJlcXVpcmUoXCIuL2xhbmctemguanNcIik7XG4vKipcbiAqICBUaGUgYXZhaWxhYmxlIFdvcmRsaXN0cyBieSB0aGVpclxuICogIFtJU08gNjM5LTEgTGFuZ3VhZ2UgQ29kZV0obGluay13aWtpLWlzbzYzOSkuXG4gKlxuICogICgqKmkuZS4qKiBbY3pdKExhbmdDeiksIFtlbl0oTGFuZ0VuKSwgW2VzXShMYW5nRXMpLCBbZnJdKExhbmdGciksXG4gKiAgW2phXShMYW5nSmEpLCBba29dKExhbmdLbyksIFtpdF0oTGFuZ0l0KSwgW3B0XShMYW5nUHQpLFxuICogIFt6aF9jbl0oTGFuZ1poKSwgW3poX3R3XShMYW5nWmgpKVxuICpcbiAqICBUaGUgZGlzdCBmaWxlcyAoaW4gdGhlIGBgL2Rpc3RgYCBmb2xkZXIpIGhhdmUgaGFkIGFsbCBsYW5ndWFnZXNcbiAqICBleGNlcHQgRW5nbGlzaCBzdHJpcHBlZCBvdXQsIHdoaWNoIHJlZHVjZXMgdGhlIGxpYnJhcnkgc2l6ZSBieVxuICogIGFib3V0IDgwa2IuIElmIHJlcXVpcmVkLCB0aGV5IGFyZSBhdmFpbGFibGUgYnkgaW1wb3J0aW5nIHRoZVxuICogIGluY2x1ZGVkIGBgd29yZGxpc3RzLWV4dHJhLm1pbi5qc2BgIGZpbGUuXG4gKi9cbmV4cG9ydHMud29yZGxpc3RzID0ge1xuICAgIGN6OiBsYW5nX2N6X2pzXzEuTGFuZ0N6LndvcmRsaXN0KCksXG4gICAgZW46IGxhbmdfZW5fanNfMS5MYW5nRW4ud29yZGxpc3QoKSxcbiAgICBlczogbGFuZ19lc19qc18xLkxhbmdFcy53b3JkbGlzdCgpLFxuICAgIGZyOiBsYW5nX2ZyX2pzXzEuTGFuZ0ZyLndvcmRsaXN0KCksXG4gICAgaXQ6IGxhbmdfaXRfanNfMS5MYW5nSXQud29yZGxpc3QoKSxcbiAgICBwdDogbGFuZ19wdF9qc18xLkxhbmdQdC53b3JkbGlzdCgpLFxuICAgIGphOiBsYW5nX2phX2pzXzEuTGFuZ0phLndvcmRsaXN0KCksXG4gICAga286IGxhbmdfa29fanNfMS5MYW5nS28ud29yZGxpc3QoKSxcbiAgICB6aF9jbjogbGFuZ196aF9qc18xLkxhbmdaaC53b3JkbGlzdChcImNuXCIpLFxuICAgIHpoX3R3OiBsYW5nX3poX2pzXzEuTGFuZ1poLndvcmRsaXN0KFwidHdcIiksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29yZGxpc3RzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndvcmRsaXN0cyIsImxhbmdfY3pfanNfMSIsInJlcXVpcmUiLCJsYW5nX2VuX2pzXzEiLCJsYW5nX2VzX2pzXzEiLCJsYW5nX2ZyX2pzXzEiLCJsYW5nX2phX2pzXzEiLCJsYW5nX2tvX2pzXzEiLCJsYW5nX2l0X2pzXzEiLCJsYW5nX3B0X2pzXzEiLCJsYW5nX3poX2pzXzEiLCJjeiIsIkxhbmdDeiIsIndvcmRsaXN0IiwiZW4iLCJMYW5nRW4iLCJlcyIsIkxhbmdFcyIsImZyIiwiTGFuZ0ZyIiwiaXQiLCJMYW5nSXQiLCJwdCIsIkxhbmdQdCIsImphIiwiTGFuZ0phIiwia28iLCJMYW5nS28iLCJ6aF9jbiIsIkxhbmdaaCIsInpoX3R3Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/lib.commonjs/wordlists/wordlists.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs":
/*!********************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = \"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\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand({ S, B }, cps, saved) {\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = \"AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    const read_chunked = ()=>new Set(read_sorted_array().flatMap((i)=>chunks[i]).concat(read_sorted_array()));\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // first arent restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = `Restricted[${N}]`;\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            gs.forEach((g)=>rec.G.add(g));\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G));\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g)));\n            for (let cp of V){\n                M.set(cp, complement);\n            }\n        }\n    }\n    // compute valid set\n    let union = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>union.has(cp) ? multi.add(cp) : union.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of union){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    VALID = new Set(Array_from(union).concat(Array_from(nfd(union)))); // possibly valid\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`);\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"◌\");\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp) {\n    init();\n    return CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        // ξ => Ξ if not greek\n        if (type !== \"Greek\") {\n            let prev = 0;\n            while(true){\n                let next = output.indexOf(0x3BE, prev);\n                if (next < 0) break;\n                output[next] = 0x39E;\n                prev = next + 1;\n            }\n        }\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(`empty label`);\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                cps[0]\n                            ])}\"`);\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\nexports.ens_beautify = ens_beautify;\nexports.ens_emoji = ens_emoji;\nexports.ens_normalize = ens_normalize;\nexports.ens_normalize_fragment = ens_normalize_fragment;\nexports.ens_split = ens_split;\nexports.ens_tokenize = ens_tokenize;\nexports.is_combining_mark = is_combining_mark;\nexports.nfc = nfc;\nexports.nfd = nfd;\nexports.safe_str_from_cps = safe_str_from_cps;\nexports.should_escape = should_escape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsbUNBQW1DO0FBQ25DLHNEQUFzRDtBQUN0RCw0RUFBNEU7QUFDNUUsNERBQTREO0FBQzVELDRFQUE0RTtBQUM1RSxJQUFJQSxlQUFlO0FBQ25CLE1BQU1DLFNBQVMsSUFBSUMsSUFBSTtJQUFDO1FBQUM7UUFBSztLQUFhO0lBQUM7UUFBQztRQUFLO0tBQWlCO0lBQUM7UUFBQztRQUFNO0tBQWE7Q0FBQztBQUN6RixNQUFNQyxVQUFVO0FBRWhCLFNBQVNDLGtCQUFrQkMsS0FBSztJQUMvQixJQUFJQyxNQUFNO0lBQ1YsU0FBU0M7UUFBUSxPQUFPLEtBQU0sQ0FBQ0QsTUFBTSxJQUFJLElBQUtELEtBQUssQ0FBQ0MsTUFBTTtJQUFFO0lBRTVELDZCQUE2QjtJQUM3QixJQUFJRSxlQUFlRDtJQUNuQixJQUFJRSxRQUFRO0lBQ1osSUFBSUMsTUFBTTtRQUFDO1FBQUc7S0FBRSxFQUFFLCtCQUErQjtJQUNqRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsY0FBY0csSUFBSztRQUN0Q0QsSUFBSUUsSUFBSSxDQUFDSCxTQUFTRjtJQUNuQjtJQUVBLDREQUE0RDtJQUM1RCxJQUFJTSxPQUFPTjtJQUNYLElBQUlPLGNBQWNSO0lBQ2xCQSxPQUFPTztJQUVQLElBQUlFLGFBQWE7SUFDakIsSUFBSUMsY0FBYztJQUNsQixTQUFTQztRQUNSLElBQUlGLGNBQWMsR0FBRztZQUNwQixzQ0FBc0M7WUFDdEMsZ0NBQWdDO1lBQ2hDQyxjQUFjLGVBQWdCLElBQUtYLEtBQUssQ0FBQ0MsTUFBTTtZQUMvQ1MsYUFBYTtRQUNkO1FBQ0EsT0FBTyxlQUFnQixFQUFFQSxhQUFjO0lBQ3hDO0lBRUEsTUFBTUcsSUFBSTtJQUNWLE1BQU1DLE9BQU8sS0FBR0Q7SUFDaEIsTUFBTUUsT0FBT0QsU0FBUztJQUN0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QU8wRCxJQUFJK0ssT0FBT3BNLE1BQU0sSUFBSW9NLE1BQU0sQ0FBQy9LLEVBQUUsQ0FBQ3NLLElBQUksSUFBSW9DLFNBQVUxTTtZQUN4RCtLLE9BQU91QyxNQUFNLENBQUNoUixHQUFHMEQsSUFBSTFELEdBQUc7Z0JBQUNnTyxNQUFNb0M7Z0JBQVV6TCxLQUFLOEosT0FBT3RLLEtBQUssQ0FBQ25FLEdBQUcwRCxHQUFHSSxPQUFPLENBQUNwQyxDQUFBQSxJQUFLQSxFQUFFaUQsR0FBRztZQUFDO1FBQ3JGO0lBQ0Q7SUFDQSxPQUFPOEo7QUFDUjtBQUVBMEMsb0JBQW9CLEdBQUdyRDtBQUN2QnFELGlCQUFpQixHQUFHakU7QUFDcEJpRSxxQkFBcUIsR0FBR3hEO0FBQ3hCd0QsOEJBQThCLEdBQUdoRTtBQUNqQ2dFLGlCQUFpQixHQUFHL0M7QUFDcEIrQyxvQkFBb0IsR0FBR1I7QUFDdkJRLHlCQUF5QixHQUFHbEU7QUFDNUJrRSxXQUFXLEdBQUdwSTtBQUNkb0ksV0FBVyxHQUFHckk7QUFDZHFJLHlCQUF5QixHQUFHN0U7QUFDNUI2RSxxQkFBcUIsR0FBRy9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmNqcz8wMTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gY3JlYXRlZCAyMDIzLTA5LTEyVDIyOjA1OjE0LjIxMVpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1lbnMgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiAwNTY1ZWQwNDliOWNmMTYxNGJiOWUxMWJhN2Q4YWM2YTZmYjk2Yzg5MzI1M2Q4OTBmN2UyYjI4ODRiOWRlZDMyXG52YXIgQ09NUFJFU1NFRCQxID0gJ0FFRVVkd21nRFM4QnhRS0tBUDRCT2dEakFUQUFuZ0RVQUlNQW9BQm9BT0FBYWdDT0FFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F1QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdnQWVBQk1BR0FVaEJlOEJGeFJFTjhzRjJ3QzVBSzVIQVc4QXJRa0R6UUN1aHpjM056Y0JQNjhORWZNQUJRZEhCdXc1QlY4RllBQTlNemtJOXI0WkJnN1F5UUFXQTlDZU93TE5DamNDanFrQ2h1QS9sbStSQXNYVEFvUDZBU2ZuRVFEeXRRRkpBaldWQ2tlWEFPc0E2Z29kQUIvY3dkQVVFMFdsQkNOL0FRVUNRUmpGRC9NUkJqSHhEUVNKYncwakJ6VUFzd0J4bWUrdG5JY0FZd2FiQXlzRzhRQWpBRU1NbXhjRHFnUEtReURYQ01NeEE3a1VRd0QzTlhPckFLbUZJQUFmQkMwRDN4NEJKUURCR2RVRkFoRWdWRDhKbndtUUppTldZVXpyZzBvQUd3QVVBQjBBRm5OY0FDa0FGZ0JQOWgzZ1Bmc0RPV0RLbmVZMkNoZ2xYMVVEWUQzMEFCc0FGQUFkQUJaeklHUkFud0REOHdBakFFRU16UmJEcWdNQjJzQUZZd1hxQXRDbkFzUzRBd3BVSktSdEZIc2FkVXo5QU1NVmJ3THBBQk0xTkpFWDBaa0NnWU1CRXlNQXhSVnZBdWtBRXpVQlVGQXRtVXdTQXk0REJURVIzM0VmdFFIZlN3QjVNeEovQWprV0tRTHpMOEUvY3dCQjZRSDlMUURQRHRPOUFTTnJpUUM1RFFBTkF3Q0syMUVGSTkxekh3Q29MOWtCcVFjSEJ3Y0hLelVEb3dCdkFRb2hQdlUzZkFRZ0h3Q3lBYzhDS1FNQTV6TVNlenI3VUxnRm1EcC9MelZRQmdFR0FpOEZZUVZndDhBRmNUdGxRaHBDV0VtZmU1dG1aNklBRXhzRHpROHQrWDhyQkt0VEFsdGJBbjBqc3k4Qmw2dXRQV01EVFI4RWkya1JBTmtEQnJOSE55c0RCekVDUVdVQWN3RnBKM2tBaXlVaEFKMEJVYjhBTDNFZkFiZk5BejgxS1VzRld3RjNZUVp0QW0wQStWRWZBekVKRFFCUlNRQ3pBUUJsQUhzQU03MEdEL3YzSVpXSEJ3QVJLUUF4QUxzalR3SFpBZU1QRXptWGdJSHdBQklBR1FBOEFFVUFRRHQzZ2R2SUVHY1FaQWtHVFJGTWRFSVZFd0swRDY0TDdSRWRETmtxMDlQZ0FEU3hCL01EV3dmekExc0RXd2Z6Qi9NRFd3ZnpBMXNEV3dOYkExc2NFdkFpMjhnUVp3OVFCSFVGbGdXVEJONElpeVpSRVlrSE1BamFWQlYwSmh4UEEwMEJCQ010U1NRN216TVRKVXBNRkUwTENBUTJTbXl2ZlVBRFR6R3pWUDJRcWdQVE1sYzVkQWtHSG5rU3FBQXlEM3NrTmIxT2hucFBjYWdLVTArMnRZZEphazV2QXNZNnNFQUFDaWtKbTIvRGQxWUdSUkFmSjZrUSt3dzNBYmtCUHczeFM5d0U5UVkvQk0wZmdSa2REOUdWb0FpcExlRU04U2JuTHFXQVhpUDVLb2NGOFV2NFBPRUxVVkZzRDEwTGFRbm5PbWVCVWdNbEFSRWlqd3JoRFQwSWNSRDNDczF2RGVrUlNRYzlBOWxKbmdDcEJ3VUxGUjA1RmJrbUZHS3dDdzA1ZXdiL0d2b0xreWF6RXkxN0FBWFhHaVVHVVFFdEd3TUEweTdyaGJSYU5Wd2dUMk1HQndzcEk4c1VyRkFrRFNsQXUzaE1HaDhIR1NXdEFwVkRkRXFMVVRvZWx5SDZQRUVOYWk0WFVZQUgrVHdKR1ZNTGhUeWlScTlGRWhIV1BwRTlUQ0pOVERBRU9ZTXNNeWVQQ2RNUGlReTlmSFlCWFFrbENiVU1kUk0xRVJzM3lRZzlCeDB4bHlnbkdRZ2xScGxnbmdUN293UDNFOVVERHdWRENVVUhGd081SERFVE1oVXRCUkdCS05zQzl6YlpMcmNDazFhRUFSc0Z6dzhwSCtNUVZFZmtEdTBJbndKcEE0Y2w3d0F4RlNVQUd5S2ZDRWRuQUdPUDNGTUpMczhJeTJwd0kzZ0RheFRyWlJGM0I1VU9Xd2VySERjVnd4emxjTXhlRDRZTUtLZXpDVjhCZVFtZEFXTUU1d2dOTlYrTXBDQkZaMWVMWEJpZklHVkJRMTRBQWpVTWFSV2pSTUdIZkFLUEQyOFNId0U1QVhjSFBRMEZBbnNSOFJGdkVKa0k3NFlJTmJrei9Eb3BCRk1oaHlBVkNpc0RVMnpTQ3lzbS9RejhiUUduRW1ZREVEUkJkL0pucjJDNktCZ0JCeDB5eVVGa0lmVUxsay9SREtBYXhSaEdWRElaNkFmREEvY2E5eWZ1UVZzR0F3T25CeGM2VVRQeUJNRUxiUWlQQ1VNQVRRNm5Hd2ZiR0c0S2RZelVBVFdQQWJ1ZEExdVZod0p6a3dZN0J3OEFhdytMQlgzcEFDRUNxd2luQUFrQTB3TmJBRDBDc1FlaEFCMEFpVVVCUVFNck13RWw2UUtUQTVjSU5jOEJtVE1COXkwRUg4Y01HUUQ3TzI1T0FzTzFBb0J1WnFZRjRWd0NrZ0pOT1FGUktRUUpVa3RWQTdOMTVRRGZBRThHRitOTEFSbXZUczhlNTBjQjQzTXZBTXNBL3dBSk9RY0pSUUhSQWZkeEFMc0JZd3MxQ2FhM3VRRlI3UzBBaHdBWmJ3SGJBbzBBNFFBNUFJUDFBVmNBVVFWZC9RWFhBbE5OQVJVMUhDOWJaUUcvQXlNQk53RVJBSDBHejVHcHpRc2pCSEVIMXdJUUh4WGxBdTh5QjdrRkF5TGpFOUZDeVFLOTRsa0FNaG9LUEFxckNxcGdYMlEzQ2pWMlBWUUFFaCtzUHNzL1VnVlZPMWM3WER0WE8xdzdWenRjTzFjN1hEdFhPMXdEbThQbXcrWUtjRjlKWWU4TXFnM1lSTXc2VFJQZllGVmdOaFBNTGJzVXhSWFNKVm9aUVJyQUp3a2w2RlVORHdndDEyWTBDREEwZVJmQUFFTXBiSU5GWTRvZU5BcFBIT3RUbFZUOExSOEF0VXVtTTdNTnNCc1pSRVFGUzNYeFlpNFdFZ29tQW1TRkFtSkdYMUd6QVY4M0pBS2grd0pvbkFKbURRS2ZpRGdmRHdKbVB3Sm1LZ1J5QklNRGZ4Y0RmcFk1Q2psN0d6bUdPaWNuQW13aEFqSTZPQTRDYmNzQ2JiTHpqZ00zYTBrdkFXc0E0Z0RsQUU0SkI1d01rUUVDRDhZQUVia0Nkek1DZHFaREFubFBSd0o0dmlGZzMwV3lSdmNDZkVNQ2Vzd0NmUTBDZlBSSUJFaUJaeWdBTHhsSlhFcGZHUnRLMEFMUkJRTFEwRXNyQTRoVEE0ZnFSTW1STmdMeXBWMEhBd095UzlKTU1Ta0gwMDFRVGJNQ2kwTUNpdHpGSHdzaFIyc0p1d0tPT3dLT1lFU2JoUUtPM1FLT1lIeFJ1Rk01QVE1UzJGU0pBcFAvQXBNUUFPMEFJRlVpVmJOVjFBb3NIeW1aaWpMbGVHcEZQejBDbDZNQzc3WllKYXdBWFNrQ2xwTUNsb0NnQUsxWnNGb05oVkVBUHdLV3VRS1dVbHhJWE5VQ21jOENtV2hjemwwTEhRS2Nuem5HT3FFQ25Cb0NuNThDbnJ5T0FDRVROUzRUQXAzMUFwNldBTGxCWVRoaDh3S2Uxd0tnY2dHdEFwNmpJd0tlVXFsanpHUXJLUzhDSjdNQ0pvSUNvUDhDb0ZEYkFxWXpBcVhTQXFnREFJRUNwL1pvZ0dpMUFBZE5haUJxMVFLczV3S3NzZ0t0YXdLdEJnSlhJUUpWNEFLeDVkc0RIMUpzbXdLeXdSRUNzdXdiYk9SdFoyMU1Zd01sMFFLMllEOURicFFES1VrQ3VHSUN1VXNaQXJrdWUzQTZjT1VDdlIwRExiWURNaFVDdm94eUJnTXpkUUsrSG5NbWMxTUN3ODhDd3doemhuUlBPVWwwNUFNOHF3RURQSjREUGNNQ3hZQUN4a3NDeGhTTkFzaHRWUUxJU0FMSlV3TEpNZ0prb1FMZDFuaDlaWGl5ZVNsTDFBTVlwMmNHQW1INEdmZVZLSHNQWHBaZXZ4VUN6MjhDejNBelQxZlc5eGVqQU1xeEFzOTNBUzN1QTA0V2ZrOEpBdHdyQXR1T0F0SlRBMUpnQTFOakFRVURWWkNBalVNRXp4cnhaRWw1QTRMU2c1RUMyc3NDMmVLRUZJUk5wMEFEaHFrQU13TmtFb1oxWGYwQVdRTGZhUUxldkhkN0F1SXo3UmdCOHpRckFmU2ZBZkxXaXdMcjl3THBkSDBEQXVyOUF1cm9BUDFMQWIwQzdvMEM2NkNXcnBjSEF1NURBNFhrbUgxdzVIR2xBdk1IQUcwRGpocVpsd0wzRndPUmNnT1Npd0wzbkFMNTNRTDRhcG9nbXErL081c2lBNTJIQXY3K0FSOEFQWjhnQVorM0F3V1JBNlp1QTZiZEFOWEpBd1p1b1l5aUNRMERERTBCRXdFakIzRUdaYjFyQ1FDL0JHL0RGWThldHhFQUczazlBQ2NETnhKUkE0MkRBV2NySlFDTTh3QWxBT2FuQzZPVkNMc0dJNmZKQmdDdkJSbkRCdkVsUlVZRkZvQUZjRDlHU0ROQ0tVSzhYM2taWDhRQWxzMEZPZ0NRVkNHYndUc3VZRG9adXRjT054ak9HSkhKL2dWZkJXQUZYd1ZnQldzRllBVmZCV0FGWHdWZ0JWOEZZQVZmQldCT0hRamZqVzhLQ2dvS2JGN3hNd1RSQTdrR044UERBTU1FcjhNQTcwZ3hGcm9GVGo1eFBuaENSMEsrWDMwL1gvQUFXQmt6c3dDTkJzeHp6QVNtNzBhQ1JTNHJERE1lTHo0OWZuWGZjc0g1R2Nvc2NRRnoxM1k0SHdWbkJYTEp5Y25BQ05kUll3Z0lDQXFFWG9XVHhnQTdQNGtBQ3hiWkJ1MjFLdzBBak1zVEF3a1ZBT1Z0SlVVc0oxSkN1VUxFU1VBclh5OWdQaTlBS3duSlJRWUtURDlMUG9BK2lUNTRQbmtDa1VMRVVVcERYOU5XVjNKVkVqUUFjMXczQTNJQkUzWW5YK2c3UWlNSmI2TUthaXN6UkNVdVFyTkN4RFBNQ2N3RVg5RVdKellSRUJFRUJ3SUhLbjZsMzNKQ05WSWZ5YlBKdEFsdHlkUFVDbWhCWncvdEVLc1pBSk9WSlUxQ0xSdXhiVUhPUUFvN1AwcytlRUpISEE4U0pWUlBkR00wTlZycHZCb0toZlVsTTBKSEhHVVFVaEVXTzF4TFNqOE1PMHVjTkFxSkl6VkNSeHY5RUZzcUt5QTRPUWdOajJud1pncDVaTkZnRTJBMUszWUhTMkFoUVFvakptQzdEZ3B6R0cxV1lGVVpDUVlIWk85Z0hXQ2RZSVZndTJCVFlKbHdGaDhHdlJiY1hiRzhZZ3RESHJNQnd6UFZ5UW9uSFFna0N5WUJnUUowQWpjNG5WcUlBd0dTQ3NCUElnRHNLM1NXRXRJVkJhNU44Z0dqQW8ra1Z3Vklad0QvQUVVU0NEd2VYNElUclJRc0o4SzNUd0JYRkR3RUFCMFR2elZjQXRvVFMyMFJJd0RnVmdaOUJCSW1ZZ0E1QUw0Q29pOExGbmV6T2tDbklRRmpBWTRLQkFQaDlSY0dzZ1pTQnNFQUpjdGRzV0lSdTJrVGtRc3RSdzdEQWNNQktncFBCR0lHTURBd0tDWW5LVFFhTGc0QUtSU1ZBRndDZGwrWVVaMEpkaWNGRDNsUEFkdDFGOVpaS0NHeHVFM3lCeGtGVkdjQS93QkZFZ2lDQndBT0xIUVNqeE90UURnMXo3ZGVGUk1BWjhRVEFHdEtiMUFwSWlQSEFEa0F2Z0tpTHkxREZ0WUNtQmlEQWxERFdOQjBlbzdmcGFNTy9hRVZSUnYwQVRFUVpCSU9EeU1FQWM4SlFoQ2JEUmd6RkQ0VEFFTUF1OVlCQ2dDc0FPa0FtNUkzQUJ3QVl4dk9OblIrTWhYSkF4Z0tReXhMMitra0poTWJoUUtEQk1rU3N2RjBBRDlCTlE2dVFDN1dxU1FId3hFQUVFSXUxaGtoQUgyejRpUVB3eUpQSE5XcGR5WUJSU3BuSkFMem9CQUVWUFBzSDIwTXhBMENDRVFLUmdBRnlBdEZBbE1Od3dqRURVUUpSQXJFTHRhcE1nN0REWmdKSXcrVEd1a0VJd3ZERmtNQXFBdERFTU1NQmhpb2UrUUFPM01NUkFBQ3JnbkVCU1BZOVEwRkRuYlNCb01BQjhNU1l4a1N4QUVKQVBJSkFBQjhGV01PRnRNYy9IY1h3eGhEQUM3REF2T293d0Fld3dKZEtES0hBQUhEQUFMckZVUVZ3d0Fid3l2enBXTVd2OHdBL0FCcEF5KytiY1lEVUtQRDBLaERDd0ttSjFNQUFtTUE1K1Vad3hBYWd3aXBCUkwvZUFEZnc2ZkRHT01DR3NPamszbDZCd09wbzRzQUVzTU9HeE1BQTVzQWJjTU9BQXZEcDBNSkdrTUR3Z2lwbk5JUEF3ZklxVU1HQU9HREFBUHpBQlhEQUFjREFBbkRBR21UQUJyREFBN0RDaGpEam5FV0F3QUJZd0FPY3dBdVV5WUFCc01BRjhNSUtRQU5VZ0M2d3k0QUE4TUFEcU1xOHdDeVlnQWNJd0FCOHdxcEFBWE9DeDBWNHdBSG93QkN3d0VLQUduREFBdURBQjNEQUFqRENha0FCZElBYnFjWjNRQ1pDQ2tBQmRJQUFBRkRBQWZqQUIyakNDa0FCcUlBQ1lNQUd6TUFiU01BNXNPSUFBaGpBQWhEQUJUREJBa3BBQWJTQU9PVEFBbERDNmtPelB0bkFBZERBRzZrUUZBQVR3QUt3d3dBQTBNQUNiVURQd0FISXdBWmd3QUNFNmNEQUFvakFBcERBQW9EcC9NR3d3QUpJd0FERXdBUVF3Z0FGRU1BRVhNQUQ1TUFEZk1BRGNNQUdSTU9GaU1BRlVNQWJxTVd1d0hEQU1JQUUwTUxBR2t6RWdEaFV3QUNRd0FFV2dBWGd3VWpBQWJZQUJqREJTWUJnekJhQUVGTkFMY1FCeFVNZWdBd01uZ0JyQTBJWmdKMEt4UUhCUkVQZDFOMFp6S1JKd2FJSEFacU5UNERxUXE4QnduZ0FCNERBd3QyQVg1NlQxb2NLUU5YQWgxR0FUUUdDM3RPeFlOYWdrZ0FNUUE1Q1FBREFRRUFXeExqQUlPWU5BRXpBSDd0RlJrNlRnbFNBRjhOQUFsWUFRK1MxQUNBUXdRb3JRQmlBTjRkQUoxd1B5ZVRBTlZ6dVFEWDNBSWVFTXA5ZXlNZ1hpVUFFZGtCa0ppektsdGJWVkFhUk1xUkFBRUFoeVEvU0RFejZCbWZWd0I2QVRFc09DbEtJUmNET0YwRS84MzJBRk50NUFCeUFua0NSeEdDT3M5NE5qWGRBd0lOR0JvbkRCd1BBTFcyQXdJQ0FnQUFBQUFBQUFZREJRTURBUnJVQXdBdEFBQUFBZ0VHQmdZR0JnWUZCUVVGQlFVRUJRWUhDQWtFQlFVRkJRUUFBQUlDQUFBQUlnQ05BSkFBbFQwQTZnQzdBTndBcEVRQXdnQ3lBSzBBcUFEdUFLWUEyZ0NqQU9jQkNBRURBTWNBZ1FCaUFOSUExQUVEQU40QThnQ1FBS2tCTVFEcUFOOEEzQXNCQ1E4eU85cmEydHE4eHVMVDF0UkpPQjBCVWdGY05VMEJXZ0ZwQVdnQld3Rk1VVWxMYmhNQlV4c05FQXM2UGhNT0FDY1VLeTB2TWo1QVFFTkRRMFJGRkVZR0pGZFhWMWRaV1ZoWkwxcGJYVnhjSTJObloyWm9aeXBzYm5aMWVIaDRlSGg0ZW5wNmVucDZlbnA2ZW5wOGZIMThlMklBUlBJQVNRQ2FBSGdBTWdCbStBQ09BRmNBVndBM0FuYnZBSXNBQmZqNEFHUUFrL0lBbndCUEFHSUFaUC8vc0FDRkFJVUFhUUJXQUxFQUpBQzJBSU1DUUFKREFQd0E1d0QrQVA0QTZBRC9BT2tBNlFEb0FPWUFMd0o3QVZFQlFBRStBVlFCUGdFK0FUNEJPUUU0QVRnQk9BRWNBVmdYQURFUUNBRUFVeDhTSGdzZEhoWUFqZ0NXQUtZQVVRQnFJQUl4QUhZQWJ3Q1hBeFVESnpJRElVbEdUekVBa1FKUEFNY0NWd0trQU1BQ2xnS1dBcFlDbGdLV0FwWUNpd0tXQXBZQ2xnS1dBcFlDbGdLVkFwVUNtQUtnQXBjQ2xnS1dBcFFDbEFLVUFwUUNrZ0tWQW5VQjFBS1hBcDhDbGdLV0FwVWVBSUVUQlFEK0RRT2ZBbUVDT2g4QlZCZzlBdUlaRWpNYkFVNC9HMVdaQVh1c1JBRnBZUUVGQTBGUEFRWUFtVEVlSUpkeUFERm9BSEVBTmdDUkE1ek1rL0MyakdJTndqTVd5Z0laQ2FYZGZESUxCQ3M1ZEFFN1luUUJ1Z0RsaG9pSGhvaUdpWXFLaG91T2pJYU5rSTZJajRxUWlwR0drb2FUaHBTU2xZYVdocGVLbUlhWmhwcUdtNGFjaTUyUW5vcWZodUlDNFhUcEF0OTBBSXAwTEhTb0FJc0FkSFFFUXdSQUJFSUVSUVJEQkVrRVJnUkJCRWNFU1FSSUJFUUVSZ1JKQUo1dWRBQ3JBNDkwQUx4dUFRMTBBTkZaZEhRQTEzUUNGSFFBL21KMEFQNEJJUUQrQVB3QS9BRDlBUHdEaEdaMDNBU01LMjNIQVA0QS9BRDhBUDBBL0NSMGRBQ1JZblFBL2dDUkFTRUEvZ0NSQXZRQS9nQ1JBNFJtZE53RWpDdHR4eVIwQVA5aWRBRWhBUDRBL2dEOEFQd0EvUUQ4QVA4QS9BRDhBUDBBL0FPRVpuVGNCSXdyYmNja2RIUUFrV0owQVNFQS9nQ1JBUDRBa1FMMEFQNEFrUU9FWm5UY0JJd3JiY2NrZEFKTEFUNTBBbElCUVhRQ1U4bDBkQUpmZEhRRHBnTDBBNllEcGdPbkE2Y0Rwd09uQTRSbWROd0VqQ3R0eHlSMGRBQ1JZblFCSVFPbUFKRURwZ0NSQXZRRHBnQ1JBNFJtZE53RWpDdHR4eVIwQkRoMEFKRUVPUUNSRHBVNWRTZ0NBRFIwM2dWMkN3QXJkQUVGQU01aUNuUjBBRjFpQUFZY09ncDBkQUNSQ25RQVhBRUl3V1owQ25SbWRIUUFrV1owQ25SbWRFWGdBRkYwM2dwMGRFWTB0bFQydTNTT0FRVHdzY3doalpaS3JoWWNCU2ZGcDlYTmJLaVZET0QyYitjcGU0L1oxN21RbmJ0enpoYWVRdEUyR0dqMElETlRqUlVTeVR4eHcvUlBIVy8rdlM3ZDFOZlJ0OXo5UVBaZzRYN1FGZmhDbmt2Z05QSUl0T3NDMmVWNmhQYW5uWk5IbFo5eHJ3WlhJTU9sdTNqU29RU3E3OFdFandMancxRUxTbEYxYUJ2Znp3azVaWDdBVXZRempQUUtiRHVRK3NtNHdOT3A0QTZBZFZ1UlMwdDF5L0RacGc0UjZtN0ZOak05SGd2VzdCaTg4emFNak9vNmxNOHd0QkJkajhMUDR5bHYzekNYUGhlYk1LSmMwNjZvOXNGNzFvRlcvOEpYdTg2SEpid0RJRDVsenc1R1dMUi9MaFQwUXFucDJKUXhOWk5mY2JMSXpQeStZeXBxUm0vbEJtR21leCs4MitQaXN4VXVtU2VKa0FMSVQ2ckplenhNSCtDVEptUXR0NXV3VFZiTDNwdG1qRFVRemxTSXZXaThUbDduZzFOcHVSbjFOZzRuMTRRYyszSWlsN093a3ZOV29nTFNQa24zcGloSUZ5dHlJR21NaE9lM24xdFdzdU15OUJkS3lxRjRaM3YyU2dnZ1RMOUtWdk1YUG5DYlJlK29PdUZGUDNIZWpCRy93OWd2bWZOWXZnNkp1V2lhMmxjU1NOMXVJakJrdHpvSWF6T0hQSlo3a0tIUHo4bVJXVmRXM2xBOFdHRjlkUUY2Qm02NzNib292M0JVV0RVMkpOY2FoUjIzR3RmSEtMT3ovdmlaK3JZblpGYUl6blhPNjdDWUVKMWZYdVRScFpoWVprS2U1NHhlb2Fna05HTHMrTlRaSEUwclg0NS9YdlEyUkdBRFg2dmNBdmR4SVVCVjI3d3hHbTJ6alpvNFgzSUxnQWxyT0ZoZXVaNnd0c3ZhSWo0eUxZN3FxYXdsbGlhSWNyejJHK2MzdnNjQW5Da0N1TXpNbVp2TWZ1OWxMd1R2ZlgrM2NWU3lQZE45WndnRFpoZmpSZ05KY0xpSjY3Yjl4eDhKSHN3cHJiaUUzdjlVcGhvdEFQSWduWFZJTjVLbU1jMHBpWGhjNmNDaFBuTitNUmhHOWFkdGR0dFFUVHdTSXBsOEk0L2ovL2Qzc3oxMzI2cVRCVHBQUk0vSGdoM2t6cUVYczhaQWs0RXJRaE5POGh6clEwRExrV01BL04rOTF0bjJNZE9KbldDMkZDWmVoa1Fyd3p3YktPamh2WnNiTTk1UW9lTDlza1l5TWY0c3JWUFZKU2dnN3BPTFV0ci9uOWVUOTlvZTluTHRGUnBqQTlva1YyS2o4aDlrNUhhQzBvaXZSRDhWeVhrSjgxdGNkNGZITlhQQ2Zsb0lRYXN4c3VPMTgvNDZkUjJqZ3VsL1VJZXQyRzBrUnZueU9OTUtoSHM2SjI2RkVvcVNxZCtyZllqZUVHd0hXVkRwWDFmaDFqQkJjS0dNcVJlcGp1OVkwMG1EVkhDK1hkaWovajQ0cktmdmZqR2luTnMxak8vMEYzakI4M1hDRElOTi9IQjg0YXhsUCszRS9rbGt0Um8rdmwzVS9haXlNSmJJb2RFMVhTc0RuNlVBeklvTXRVT2JZMitrLzRnWS9sK0FrWko1U2oydlFya3lMbTNGb3hqaERYKzMxVVhCRmY5WHJBSDMxZkZxb0JtREVadmh2dnBuWjg3TitvWkV1N1U5Ty9ubmsrUVdqM3g4dXlvUmJFbmYrTzVVTXI5aTBuSFAzOElGNUF2enJCVzhZV0JVUjBtSUF6SXZuZFFxOU4zdi9KdG8zYVBqUFhVUGw4QVNkUFB5QXA3akVOZjhiazdWTU05b2w5WEdtbEJtZURNdUdxdCtXenVMNkNYQXhYakloQ1BNNXZBQ2NoZ01KLzhYQkdMTy9EMWlzVnZHaHd3SEhyMURMYUk1bW4ySnIvYjFwVUQ5MHVjaURhUzhjWE5EekNXdk5tVC9QaFFlNWU4blRubm5rdDhEcy9TSWppYmN1bS9mcURoS29weEFZOEFrU3JQbitJR0RFS09PK1UzWE9QNmRqRnMySDVOOStvcmhPYWhpUWs1S25FVVdhK0N6a1Z6aHA4Yk1IUmJnODFxaGpqWHVJS2JIalNMU0lCS1dxb2NrR3RLaW5ZK3o0L1JkQlVGNnBjYzNKbW5seFZjTmdySTRTRXpLVVpTd2NEMlFDeXh6S3ZlK2dBbWc2WnVTUmtwUEZhNm1mVGh1N0xKTnUzSDVLNDJ1Q3BOdlBBc29lZG9sS1YvTEhlL2VKK0JiYUc1TUcwTmFTR1ZQUlVtTkZNRkZTU3BYRWNYd2JWaDdVRVRPWlp0b1ZOUkdPSWJia2lnM01jRXRSNjhjRzBSWkFvSmV2V1lvN0RnL2xaMUNRemJsV2VVdlZIbXI4Zlk0TnFkOUpKaUgvekVYMjRtSnZpSDYwZkF5RnIwQTNjNGJDMWozeVpVNjBWZ0p4WG44SmdKWExVSXNpQm5tS21NWXorN3lCUUZCdnFiMmVZbnVXNTlqb1pCZjU2L3dYdldJUjRSOHdUbVY4MGkxbVp5K1M0K0JVRVMraHpqazB1WHBDLy8vei9JbHFIWjFtb256bFhwOGFDZmhHS010aTczRkkxS2JMMXE2SUtPNGZ1QnVaNTlnYWdqbjV4VTc5bXVNcEhYZzZTK2UrZ0RNL1U5QktMSGJsOWw2bzhjelFLbDRSVWtKSmlxZnRRRzJpM0JNZy9UUWxVWUZrSkRZQk9PdkF1Z1l1ellTRG5aYkREZC9hU2Q5eDBPZTZGK2JKY0hmbDkrZ3A2TDUvVGdBK0JkRkZvdmJmQ3JRNDBzNXZNUHc4ODY2cE5YOHp5RkdlRldkeElwUFZwOVJnMVVQT1ZGYkZacnZhRnEvWUF6SFFncU1XcGFoTVlmcUhwbXdYZkhMMS9rcFltR3VIRndUNTVtUXUwZHlsZk51cTJPcTBoVE1DUHdxZnhudUJJUExYZmNpNFkxQU55KzFDVWlwUXhsZC9pelZoMTZXeUcyUTBDUVE5TnF0QW54MUhDSHdEajdzWXhPU0Iwd29wWlNuT3p4UU9jRXhteHJWVEYyQmtPdGhWcEdmdWhhR0VDZkNKcEpLcGpuaWhZK3hPVDJRSnhONjErOUs2UVNxdHYyU2hyODJJM2pnSnJxQmcwd0VMRlpQanZIcHZ6VHRhSm5MSzZWYjk3WW45MzNrb08vc2FON2ZzandOS3pwNGwybEpWeDJvcmpDR3pDLzRaTDR6Q3ZlcjZhUVl0QzVzZG95Y2h1RkU2dWZPaW9nK1ZXaTVVRGtibXZtdGFoLzNhQXJFQklpMzlzNUlMVW5sRkxnaWxjR3V6OUNRc2hFWTdmdzJvdW9JTEFZUFZUL2d5QUlxM1RGQUl3VnNsK2t0a1J6L3FHZm5DREdybTVnc2wvbDlRZHZDV0dzalB6M2RVN1h1cUtmZFVyci82WElnanA0cmV5NkFKQm1DbVVKTWpJVEhWZEZiNW0xcCtkTE1DTDh0NTV6RDQyY21mdG1MRUpDMERhMDRZaVJDVlVCTExhOEQwNzEvTjVVQk5CWERoMExGc21oVi81QjVFeE9CNGozV1ZHL1MzbGZLNW8rVjZFTEh2eTZSUjluNGFjK1ZzSzRWRTR5cGhQdlYra0c5RmVnVEJINFpSWEwySHl0VUhDZHVKYXpCL0t5a2pmZXRZeE9YVEx3czI2N2FHT2QrSStKaEtQLy8rVm5YbVM5ME9EL2p2TGNWdTBhc3lxY3VZTjFtU2I2WFRsQ2txdjF2aWdaUElZd05GL3pwV2NUMUdSLzZhRUlSamtoMHloZzRMWEpmYUdvYllKVFk0Skk1OEtpQUtnbW1nQUtXZGw1bllDZUxxYXZSSkdRTnVZdVp0WkZHeCtJa0k0dzROUzJ4d2JldE5NdW5PakJ1L2htS0NJL3c3dGZpaXlVZC8vNHJiVGVXdDRpekJZOFl2R0lONnZ5S1ltUC84WDh3SEtDZU4rV1JjS003MCt0WEtOR3lldlU5SDJEZzVCc2xqblRmOFlic0oxVG1Nczc0Q2UyWGxIaXNsZWd1aHllZzQ0clFPSFp1dy82SFRraG5udXJLMmQ2MnE2eVM3MjEwU3NBSWFSK2pYTVFBK3N2a3JMcHNVWStGMzBVdzg5dU9kR0FSNnZvNEZJTUUwRWZWVmVIVHU2ZUtpY2ZoU3FPZVhKaGJmdGNkMDhzV0VuTlVMMUM5Zm5wclRnZDgzSU11dDhvblZVRjBodnF6WmZIZHVQamJqd0VYSWNvWW15K1A2dGNKWkhtZU92NlZydkVka0hESmVjakh1SGVXQU5lNzlWRzY2MnFUakEvSEN2dW1WdjNxTCtMck9jcHFHcHMyWkd3UWRGSjdQVTRpdXlSbEJyd2ZPK3huUHlyNDdzMmNYVmJXekF5em5EaUJHakNNM2tzeGpqcU02MkdFOUM4ZjVVMzhrQjNWanRhYktwL25SZHZNRVNQR0RHOTBiV1JMQXQxUWs1RHlMdWF6UlIxWXpkQzFjK2haWHZBV1Y4eEE3MlM0QThCNjd2alZoYmJhM01Nb3AyOTNGZUVYcGU3ekl0TVdySkcvTE9IOUJ5T1htWW5OSmZqbWZ1WDlLYnJwZ0xPYmE0blorZmw4R2Jkdi9paHYrNndGR0tIQ1lyVndtaEZDMEozVjJibjJ0SUIxd0NjMUNTVDNkM1gyT3l4aGd1WGNzNHNtNjc5VW5nem9mdVNlQmV3TUZKYm9JUUhiVWgvbTJKaFcyaEc5REl2RzJ0N3laSXpLQlR6OXdCdG5OQysycENSWWhTSXVRMWo4eHN6NVZ2cW55VUl0aHZ1b3l5dTdmTklyZy9LUVVWbUdRYXFrcVprL1Z4NWIzMy9nc0VzOHlYN1NDMUorTlY0aWN6NmJ2SUU3QzVHNk1jQmFJOHJWZzU2cTVRQkpXeG4vODdRMXNQSzQrc1FhOGZMVTVnWG80cGFhcTRjT2NRNHdSMFZCSFBHaktoK1VsUENiQTFuTFh5RVVYNDVxWjhKNy9MbjRGUEpFMlRkekQwWjhNTFNOUWl5a01NbVN5T0NpRmZ5ODRScTYwZW1ZQjJ2RDA5S2pZd3NvSXBlRGNCRFRFbEJiWHhORDcyeWhkOXBDLzFDTWlkLzVIVU12QUwyN090Y0lKRHpOS3BSUE5xUE9weXQyYVBHejlRV0lzOWhROUxpWDVzOG05aGpUVXUvZjdNeUlhdGpqZCt0U2ZRM3VmWnhQcG1KaFRhQnRadEtMVWNmT0NVcUFEdU8rUW9IOEI5djZVK1AwSFYxR0xRbXRvTkZUYjNzNzRpdlpnakVTMHFmSys4UmRHZ0JiY0NNU3k4ZUJ2aDk4K2V0MUtJRnFTZTFLUVB5WFVMQk1Uc0lZbnlzSXdpWkJKWWRJMjB2c2VWK3d1SmtjcUdlbWVoS2phQWI5TDU3eFptM2cyelgwYloyeGsvZlUrYkNvN1RsbmJXN0p1RjFZZFVSby8yR3c3VmNsREcxVzdMT3RhczJMWDR1cGlmWi8yM3J6cHNuWS9BTGZSZ3JjV1A1aFltVjlWeFZPUUExZlp2cDlGMlVOVSs3ZDd4UnlWbTV3aUxwMy8wZGxWN3ZkdzFQTWlacmJEQVl6SVZxRWpSWTJZVTAzc0poUG5sd0lQY1pVRzVsdEw2UzhYQ3hVMWVZUzVjanIzNHZlQm1YQXZ5N3lONFpqQXJJRzBkZkQvNVVwQk5sWDFaUG94Sk93eXFSaTN3UVd0T3pkNG9OS2gwTGtvVG04Y3dxZ0lmS2hxcUdPaHdvNzFJK3pYbk1lbVR2MkIyQVV6QUJXeUZ6dEdnR1VMakREeldZd0pVVkJUaktDbjVLMlFHTUsxQ1FUN1N6emlPam8rQmhBbXFCanp1YzN4WXltMmVlZEdlT0lSSlZ5VHdEdzM3aUNNZTRnNVZibnNiNVpCZHhPQW5NVDdIVTRESHB4V0d1UTdHZWlZMzBDcGJ2enNzNTUrNUttMVlzYkQ1ZWEzTkk5UU5ZSVhvbDVhcGdTdTlkWjhmOHhTNWR0SHBpZG81QmNsRHVMV1k0bGhpazB0YkphMDd5SmhIMEJPeUV1dC9HUmJZVFM2UmZpVFlXR01Da05wZlNIaTdIdmRpVGdsRVZIS1pYYVZoZXpINGtrWGlJdktvcFlBbFB1c2Z0cEU0YTVJWnd2dzF4L2VMdm9ESWgvenBvOUZpUUluc1RiMlNBa0tIVjQyWFlCanBKRGc0Mzc0WGlWYjN3czRxTTBzOWVTUTVIenNNVTRPWkpLdW9wRmpCTStkQVpFbDhSVU14NXVVMk40ODZLcjE0MXRWc0dRZkdqT1JZTUNKQU1zeEVMZU5UNFJtV2pSY3BkVEdCd2N4NlhOOWRyV3FQbUp6Y3JHckg0K0RSYzcrbjF3M2tQWnd1MEJrTnI2aFFycWdvN0pUQjlBNWtkSi9IN1A0Y1dCTXdzbXVpeEF6SkIzeXJRcG5HSXE5MGx4QVhMekRDZG4xTFBpYnNSdDdySE5qZ1FCa2xSZ1BaOHZUYmpYZGdYclRXUXNLNU1kclhYUVZQcDBSaW5xM2ZyelpLSjBxRDZRaGM0MFZ6QXJhVVhsb2IxZ3ZraEszdnBtSGdJNkZSbFFaTng2ZVJxa3Awenk0QVFsWDgxM2ZBUHRMM2pNUmFpdEdGRmpvMHptRXJsb0MraCtZWWRWUTZrNEYvZXB4QW9GMEJtcUVvS05UdDZqNHZRWk5RMkJvcUY5Vmo1M1RPSW9ObURpdTlYcDE1UmtJZ1FJR2NvTHBmb0liZW56cEdVQXRxRkpwNVcrTExueDM4akhlRUNUSi9uYXZLWTFOV2ZOMHNZMVQ4L3BCOGtJSDNEVTNEWCt1NlczWXdweXBCTVlPaGJTeEdqcTg0Ulo4NGZXSm93OHB5SHFuNFMvOUoxNUVjQ01zWHFyZnd5ZDltaGl1MytyRW85cFBwb0prZFpxSGpyYTROdnpGd3VUaE5LeTZoYW8vU2xMdzNaQURVY1VwM3czU1JWZlcycmhsODB6T2dUWW5LRTBIczJxcDFKNkgzeHFQcUlrdlVEUk1GRFl5UmJzRkkzTTlNRXlvdlBrOHJsdzcvMGE4MWNEVkxtQnNSMnplMnBCdUtiMjNmYmVaQzB1WG9JdkRwcGZUd0lEeGsxT3EyZEdlc0djK29KWFdKTEdrT2hhM0NYK0RVbnpnQXA5SEdIOVJzUFpONjNIbjRSTUE1ZVNWaFBITys5UmNSYi9JT2d0VzMxVjFRNUlQR3RveFBqQytNRUpiVmxJTVlBRGQ5YUhZV1VJUUtvcHVQT0htb3FTa3VibkFLbnpnS0hxZ0lPZlc1UmRBZ290TjZCTitPMlpZSGt1ZW1MbnZROFU5VEhWclMxUnRMbUtiY0M3UGVlRHNZem52cXplZzZWQ053bXIwWXl4MXduTGp5VDg0Qlp6M0VKeUNwdEQzeWV1ZUF5RFdJczBMMnFzL1ZRM0hVeXFmcmphMFYxTGREenFBaWtlV3VWNHNjN1JMSUI2OWpFSUJqQ2t5WmVkb1VIcUNyT3ZTaFZ6eWQ3M09kckpXMGhQT3VRdjJxT29IRGM5eFZiNll1NnVxM1hxcDJaYUg0NkE3bHpldmJ4UUVtZnJ6dkFZU0p1WjRXRGsxSHozUVgxTFZkaVVLMEV2bEFHQVlsRzNNZDMwcjdkY1BONjN5cUJDSWoyNXBycHZaUDBuSTQrRWdXb0ZHOTVWNTk2Q3VyWHBLUkJHUmpRbEhDdnk1SWIvaVc4blpKV3dyRVQzbWdkNm1FaGZQNEtDdWFMam9wV3M3aCtNZFhGZEl2OGRIUUpnZzF4aTFlWXFCMHVEWWp4d1ZtcmkwU3Y1WEt1dC9vbnFhcEMrRlFpQzJDMWx2WUo5TVZjbzZ5RFlzUzNBQU5VZk10dnRiWUkyaGZ3WmF0aVNzbm9VZU1aZDM0R1Zqa01NS0ErWG5qSnBYZ1JXMlNIVFpwbFZvd1BtSnN2WHk2dzNjZk8xQUsyZHZ0WkVLVGtDL1RZOUxGaUtIQ0cwRG5yTVFkR20ybHpsQkhNOWlFWXluSDJVY1ZNaFVFanNjMG9EQlRnbzJaU1ExZ3prQUhlV2VCWFlGallMdXVmOHl6VEN5Ny9SRlI4MVdEalhNYnEyQk9INWRVUm54bzZvaXZteEwzY0t6S0lubFprRDMxbnZwSEI5S2s3R2ZjZkUxdCsxVjY0YjlMdGdlSkdscFJGeFFDQXFXSjVEb1k3N3NraThnc09FT3IydXl3WmFvTy9OR2EwWDB5MXBOUUhCaTNiMlNVR05wY1p4RFQ3ckxiQmYxRlNuUThndXhHVzNXKzM2QlcwZ0JqZTRET3o2QmE2U1ZrMHhpS2d0K3EySk9GeXI0U1lmbnUrSWMxUVpZSXV3SEJyZ3pyNlV2T2NTQ3pQVE9vN0Q2SUM0SVNlUzd6a2w0aCsyVm9lSHBuRy91V1IzK3lzTmdQY09JWFFidjBuNG1yM0J3UWNkS0p4Z1BTZXl1UC96MUpqZzRlOW5Vdm9YZWdxUVZJRTMwRUh4NUdIditGQVZVTlRvd1lESmd5RmhmNUl2bFltRXFSaWY2K1dOMU1rRUptRGNRSVR4OUZYMjNhNG14eTFBUVJzT0hPLytlSW1YOWw4RU1KSTNvUFd6Vlh4U09lSFUxZFVXWXIydUFBN0FNYit2QUVaU2JVM3FvYjlpYkN5WGV5cEVNcFo2ODYzbzZRUHFscUdIWmt1V0FCU1RWTmQ0Y09oOWh2M3FFcFN4Mlp5L0RKTVA2Y0l0RW1pQko1UEZxUW5ERUl0M05yQTNDT2xPU2d6NDNEN2dwTkZOSjVNQmg0b0Z6aERQaWdsQzJ5cHNOVTRJU3l3WTJlcmt5YjFOQzNRaC9JZldqMGVEZ1pJNC9sbjhXUGZCc1QzbWVUanExVXF0MUU3WmwvcWZ0cWt4NmFNOUt1ZU1DZWtTbk1yY0hqMUNxVFdXekV6UHNaR2NEZTNVZTRXcytYRllWeE5iT0ZGOGV6a3ZRR1I2Wk90T0xVMmxRRW5NQlN0eDQ3dkU2UGI3QVlNQlJqMk9PZlpYZmlzakpucFRmU05qbzZzWjZxU3ZOeFpObURlUzdHazN5WXlDazFIdEtOMlVuaE1Jak9YVXpBcUR2OTBseDlPL3EvQVQxWk1uaXQ1WFFlOXdtUXhuRS9XU0gwQ3FaOS8ySHkrU2ZtcGVnOFJ3c0hJNVo4a0M4SDI5M20vTEhWVk0vQkE3SGFUSllnNUVuazdNL3hXcHEwMTkyQUNmQmFpMkxBL3FyQ2pDcjZEaDFCSU16TVhJTkJtWDk2TUo1SG4ybnhsbi9SWFBGaHdIeFVtU1YwRVYyVjBqbTg2L2R4eHVZU1UxVzdzVmtFYk45RXprRzBRRndQaHlIS3liM3QrRmo1V29VVVRFcmNhekUvTjZFVzZMdnAwZC8vU0RQajdFVjlVZEpOK0FtbmYzV3drM0EwU2xKOVowMHl2WFo3bjN6NzBHNDdIZnNvdzhXcTFKWGNmd25BK1l4YTVtRnNnVjQ2NEtLUDRUMzF3cUlnekZQZDNlQ2UzajVvcnk1ZkJGMmhnQ0Z5VkZyTHpJOWVldE5Ydk03b1FxeUZnRG80Q1RwL2hEVjlOTVg5SkRIUS9ueUhUTHZaTE5MRjZmdG4yT3hqR204K1BxT3doeG5QSFdpcGtFLzh3YnR5cmk4MFNyN3BNTmtRR01mbzRaWUs5T2NDQzRFU1ZGRmJMTUl2bHhTb1JxV2llMHd4cW5MZmNMU1hNU3BNTVFFSllEVk9iWXNYSVFOdjRUR053anExa3ZUMVVPa2ljVHJHM0lhQlozWGRTY1MzdThzZ2VaUFZwT0xrYmlGOTQwRmpiQ2VOUklOTnZEYmQwMUVQQnJUQ1BwbTEybTQzemUxYkJCNTlJYTZPdmhudXIvTnZ4M0l4d1NXb2wrM0gycWZDSlI4ZGY2YVFmNHY2V2lPTnhrSytJcVQ0cEtRclpLL0xwbGdESS9QSlpiT2VwOGR0YlY3b0NyNkNnZnBXYThOY3pPa1B4ODFpU0hic05oVlNKQk90ckxJTXJMMzFMSzlUcUhxQWJBSGUwUkxtbVY4MDZrUkxETE5FaFVFSmZtOXUwc3hwa0w5M1pnZDZydyt0cUJmVE1pNTl4cVhITFhTSHdTYlNCbDBFSzArbG9FQ09QdHJsKy9uc2FGZTE5N2RpNHlVZ29lNGpLb0FKRFhjNkRHRGpyUU9vRkRXWko5SFh3dDh4RHJRUCs3YVJ3V0tXSTFHRjhzOE80S3p4V0JCY3dubDN2bmwxT2V6M29oNkVhMXZqUjcvejdERFRyRnRxVTJXL0tBRXpBdVhETlo3TVk3M01GMjE2ZHpkU2JXbVVwNGxjbTdrZUpmV2FNSGd1dDl4NUM5bWo2NlowbEoreWhzalZ2eWlXcmZrMWx6UE9UZGhHMTVZN2dRbFh0YWN2STdxdi9YTlNzY0R3cWtnd0hUL2dVc0Q1eUI3TGRSUnZKeFFHWUlObjloVHBvZEtGVlNUUHJ0R3Z5UXcrSGxSRlhJa29kRXJBR3U5SXkxWXBmU1BjM2prRmg1Q1gzbFB4djdhcWpFL0pBZlRJcEVqR2IvSDdNTzBlMnZzVmlTVzFxYS9MbWk0L240REVJM2c3bFlyY2Fuc3BEZkVwS2tkVjFPalNMT3kwQkNVcVZvRUNhQjU1dnMwNnJYbDRqcW1Mc1BzRk0vN3ZZSjB2ckJoRENtLzAwQS9IODFsMXVla0ovNkxtbDNIYjkrTktpTHFBVEptRHB5emZZWkZIdW1FakM2NjJMMEJ3a3hpN0U5VTRjUUEwWE1WRHVNWUFJZUxNUGdRYU1WT2Q4Zm10NVNmbEZJZnVCb3N6ZUF3N293NWdYUEUyWS95QmMvN2pFeEFSVWYvQnhJSFFCRjVTbjNpNjF3NHo1eEpkQ3lPMUYxWDMrM2F4K0pTdk1lWjdTNlFTS3AxRnAvc2pZejZaK1ZnQ1p6aWJHZUVvdWpyeWZNdWxIN1JhaTVrQWZ0OWViY1c1MER5SnIydW8yejk3bVRXSXU0NVlzU25OU01yck5VdUcxWHNZQnREOVREWXpRZmZLQjg3dldia000RWJQQUZnb0JWNEdRUyt2dEZEVXFPRkFvaTFuVHRtSU92ZzM4TjRoVDJTbjhyOGNsbUJDWHNwQmxNQllUbnJxRkpHQlQzd1pPekF5SkRyZTlkSEg3K3g3cWFhS0RPQjRVUUFMRDVlY1MwREU0b2J1YlFFaXVKWjBFcEJWcEx1WWNjZThBYTRQWWQvVjRETERBSkJZS1FQQ1dUY3JFYVo1SFliSmkxMUdkNmhqR29tMWlpMThWSFluRzI4Tktwa3oyVUtWUHhsaFlTcDh1WnIzNjdpT21veTd6c3hlaFc5d3pjeTJ6RzBhODBQQk1DUlFNYjMyaG5hSGVPUjhmbk5EelpoYU5ZaGtPZERzQlVaM2xvRE1hMVlQMHVTMGNqVVAzYi82REJscW1aT2VOQUJEc0xsNUJJNVFKdXBzOHV4QXVXSmRrVUIvcE82WmF4NnRzZzdmTjVtampEZ01HbmdPK0RQY0txaUhJRGJGSUd1ZHh0UFRJeURpOVNGTUtCRGNmZEdRUnY0MXExQXFteGdrVmZKTW5QOHcvQmM3TjkvVFI2QzdtR09iRnFGa0lFb204c0tpMnhZcUpMVENISzdjeHphWnZxT0RvMjJjM3dpc0JDUDRIZUFnY1JiTlBBc0JrTlJoU21ENDhkSHVwZEJSdzRtSXZ0UzVvZUY2emVUMUtNQ3loTW5taHBrRkFHV25Hc2NvTmt3dlE4Wk01bEUvdmdUSEZZTDk5T3VOeGRGQnhURURkNXYycUxSOHk5V2tYc1dnRzZrWk5uZEZHK3BPL1VBa09DaXBxSWhMM2hxN2NSU2RyQ3E3WWhVc1RvY0VjbmFGYTZuVmtoblNlUllVQTFZTzB6NWl0RjlTbHkzVmx4WUR3MjM5VEpKSDZmM0VVZllPNWxiN2JjRmN6OEJwN09vOFFtbnNVSE96L2ZhZ1ZVQnRLRXcxaVQ4OGorYUtrdjhjc2NLTmtNeGpZcjgzNDREMWtGb1o3L3RkMVc2TENOWU41OTQzMDF0VUdSbUZqQXplUmc1dnlvTTFGNitiSlovUTU0ak4vazhTRmQzRHhQVFlhQVVzaXZzQmZnVG43TXg4SDJTcFB0NEdPZFlSbkVKT0g2akhNMnA2U2dCMGd6SVJxNmZIeEdNbVNtcWFQQ21sZnd4aXVsb2FWSWl0TEdOOHdpZTJDRFdoa3pMb0NKY09EaDdLSU9BcWJIRXZYZFV4YVM0VFRUczA3Q2x6ai82R21WczlraVpEZXJNeEVuaFVCNlFRUGxjZnFrRzk4ODJScUhvTGlIR0JvSGZRdVhJc0FHOEdUQXRhbzJLVndSbnZ2YW04am8xZTMxMkdRQUtXRWE0c1VWRUFNRzRHNmNrY09ORHdSY2cxZTJEMytvaFhnWTRVQVdGOHdIS1FNclNuekNnZkZwc3hoK2FIWE1HdFBRcm9RYXNSWTRVNlVkRzByejFWamJrYTBNZWtPR1JaUUV2cVFGbHhzZUZvcjh6V0ZnSGVrM3YyOStXcU42Z2FLNWdaT1RPTVp6cFFJQzEyMDFMa01DWGlsZDN2V1hTYzVVWDl4Y0ZZZmJSUHpHRmExRkRjUGZQQi9qVUVxL0ZlR3Q0MTlDSTNZbUJsVm9Ic2E0S2Rjd1FQNVpTd0hIaEZKNy9QaC9SYXAvNHZtRzkxZUR3UFAwbERmQ0RSQ0xzelRxZnpNNzF4cG1pS2kySHdTNFdscXZHTnd0dndGNURxcG42S1RxOGF4MDBVTVBreERjWnJFRUVzSXZIaVVYWEVwaGRiNEdCNEZ5bWxQd0J6NEdwZXJxcTVwVzdUUTYveU5SaFc4VlQ1Tmh1UDB1ZGx4bzRnSUxxNVp4QVprOFpHaDNnNENxeEpsUEtZN0FReHVwZlVjVnBXVDVWSXRwMSszMFVxb3lQNHdXc1JvM29sUlJna1daWjJaTjZWQzNPWkZlWEI4TmJuVXJTZGlrTnB0RDFRaUd1S2tyOEVtU1IvQUs5UncrRkYzczV1d3VQYnZIR2lQZUZPVmlsdE1LN0FVYU9zcTkreDljbmRrM2lKRUU1TEtaUmxXSmJLT1p3ZVJPem1QTlZQa2pFM0svVHlBNTdSczY4VGtaM01SOGFrS3BtN2NGam5qUGQvRGRrV2pnWW9LSFNyNVd1NXNzb0JZVTRhY1JzNWcyREh4VW1kcThWWE9YUmJ1bkQ4UU4wTGhna3NzZ2FoY2RvWXNOdnVYR1VLL0tYRC83b0ZiK1ZHZGhxSW4wMnZldU01Ykx1ZEpPYzJLeTBHTWFHNFcveFdCeElKY0w3eWxpSk9YT3B4MEFrQnFVZ3psRGN6bUxUNGlJTFhEeHh0UlIxb1phMkpXRmdpQWI0M29ickpuRy9UWkMyS1NLMndxT3pSWlRYYXZaWkZNYjFmM2JYdlZhTmFLODI4dzlUTzYxMGdrOEpOZjNnTWZFVHpYWHNiY3ZSR0NHOUpXUVo2K2NEUHFjNDQ2NllvMlJjS0grUElMZUtPcXRubGJJblIzTW1CZUdHM0ZIMTB5emt5YnVxRUMySFNRd3BBMEFuN2Q5KzczQmtEVVRtMzBiWm1vUC9SR2JnRk4rR3JDT2ZBRGdxcjBXYkkxYTFva3BGbXM4aUhZdzlobTB6VXZsRU1pdkJSeE1vZHJiSkorOS9wM2pVZFFROUJDdFFkeG5PR3JUNWR6UlVtdzA1OTMvbWJSU2RCZzBuUnZSWk01L0UxNm03WkhtREV0V2h3dmZkWkNaOEo4TTEyVzB5Uk1zelhhbVdmUVR3SVo0YXlZa3RybnNjUXVXcjhpZHAzUGpUMmVGL2ptdGRoSWZjcE1uYitJZlpZMkZlYlc2VVkvQUszalA0dTNUdTR6RTRxbG5RZ0xGYk0xOUVCSXNOZjdLaGpkYnFRL0Q2eWlEYitObEVpMlNLRCtpdlhWVUs4aWIwb0JvMzY2Z1hrUjhaeEdqcEpJRGNFZ1pQYTlUY1llMFRJYmlQbC9yUFVRRHUzWEJKOVgvR05xM0ZBVXNLc2xsNTdEemFHTXJqY1QrZ2N0cCs5TUxZWENxK3NxUDgxZVZRMHI5bHQrZ2NRZlpiQUNSYkVqdmxNc2t6dFpHOGdiQzhRbjl0dDI2UTd5N25EcmJacS9MRXo3a1I2SmM2cGczTjlyVlg4WTVNSnJHbE1MOXA5bFU0amJUa0txQ3ZlZVpVSmpIQjAzbTJLUktSMlR5dG9Ga1RYT0xnN2tlVTFzMWxyUE1RSnBvT0tMdUFBQyt5MUhsSnVjVTZ5c0I1aHNYaHZTUFBMcTVKN0p0bnFIS1o0dllqQzRWeTgxNTNRWSs2NzgweER1R0FSc0diT3MxV3F6SDBRUzc2NXJuU0tFYmJLbGtPOG9JL1ZEd1VkMGlzMTN0S3BxSUx1MW1ESkZOeS9pSkFXY3ZEZ2p4dnVzSVQrUEd6M1NUL0o5cjlNdGZkMGpwYUdlaUxZSXFYYzdEaUhTUzhUY2pGVmtzaTY2UEVreFcxejZ1amJMTFVHTk5ZbnpPV3BIOEJaR0s0YkNLN2lSK01iSXY4bmNEQXoxdTRTdE4zdlRUemV3cjlJUWprOXd4RnhuKzZOMWRkS3MwdmZmSmlTMDhOM2E0RzFTVnJsWjk3US9NKzhHOWZlNUFQNmQ5L1FxNFdSbk9SVmhvZlBJS0VkQ3IzbGxzcFVmRTBvS0lJWW9CeUJSUGgrYlgxSExTM0pXR0pSaEl2RTFhVzROVGQ4ZVBpNFora1hiK1o4c25ZZlNOY3FpamhBZ1ZzeDRSQ001NGNYVWlZa2plQm1tQzRhak9IckNob0VMc2NKSkM3Kzlqak1qdzVCYWdaS2xnUk1pU05ZejdoN3Z2WklvUXFidFFtc3BjMGNVazFHLzczaVh0U3BST2w1d3RMZ1FpMG1XMkV4OGkzV1VMaGNnZ3g2RTFMTVZIVXNkYzlHSEkxUEgzVTJLbzBQeUdkbjlLZFZPTG03RlBCdWkwaTlhMEhwQTYwTXNld1ZFNHo4Q0F0NWQ0MDFHdjZ6WGxJVDVZYml0MVZJQTBGQ3M3d3R2WXJlcnUxZlV5VzNvTEFaLythVG5ack9jWVJOVkE4c3BvUnRsUm9XZmxzUkNsRmNnemtxaUhPcmYwL1NWdytFcFZhRmxKMGc0S3hxMU1NT21pUWRwTU5wdGU4bE1NUXFtNmNJRlhsbkdiZkpsbHlzS0RpKzBKSk1vdGtxZ0l4T1NRZ1U5ZG4vbFdrZVZmOG5VbTNpd1gyTmwzV0R3OWk2QVVLM3ZCQWJaWnJjSnBEUS9ONjRBVndqVDA3SmVmMzBHU1NtdE51MldsVzdZb3lXMkZsV2ZaRlFVd2s4NjdFZExZS2s5Vkc2SmdFbkJpQnhrWTdMTW80WUxRSkpsQW85bC9vVHZKa1NBUkRGL1h0eUF6TThPMnQzZVQvaVhhNndETjNXZXdObVFIZFBmc3hDaFUvS3RMRzJNbjhpNFpxS2RTbElhQlphZHhKbVJ6VlMvbzR5QTY1UlRTVmlxNjBvYTM5NUxxdzBwelk0U2lwd0UwU1hYc0tWK0dacmFHU2tyL1JXMDh3UFJ2cXZTVWtZQk1BOWxQeDRtMjRheitJSG1DYlhBKzBmYXhUUkU5d3VHZU8wNkRJWGE2UWxLSjNwdUl5aXVBVmZQcjczNnZ6bzJwQmlyUytWeGVsM1RNbTNKS2h6OW8yWm9SdmFGVnBJa3lrYjBIY200b0hGQk1jTlNOajcvNEdKdDQzb2dvblkyVmc0bnNEUUlXeEFjb3JwWEFDemdCcVFQallzRS9WVXBYcHdOTWFuRXJ1NE53TUNGUGtYdk1vcXZvZUxOM3F5dS9OMWVXRUh0dE1ENjV2MTlsLzBrSDJtUjM1aXYvRkkreWpvSEo5Z1BNejY3YWYzTXEvQm9XWHF1M3JwaGlXTVhWa21uUFNFa3BHcFVJMmgxTVRoaWRlR0ZFT0s2WVpIUHdZek1CdnBOQzcrWkh4UGI3ZXBmZWZHeUlCNEp6TzlEVE5FWW5ETFZWSGRReXZPRVZlZnJrNlV2NWtUUVlWWVdXZHFyZGNJbDd5bGp3d0lXZGZRL3krMlFCM2VSL3F4WU9idVl5QjRnVGJvMmluNFB6YXJVMXNPOW5FVGttajkvQW94REErSk0zR01xUXRKUjRqdGR1SHRub0NMeGQxZ1FVc2NIUkIvTW9SWUlFc1AycERaOUt2SGd0bGsxaVRiV1diSGhvaHdGRVlYN3k1MWZVVjJudVVtbm9VY3FuV0lRQUFnbDlMVFZYK0JjMFFHTkVoQ2h4SFI0WWpmRTUxUFVkR2ZzU0ZFNmNrN0JMMy9oVGY5akxxNEcxSWFmSU54T0xLZUF0TzdxdXVsWXZINVlPQmMrelg3Q3JNZ1duVzQ3L2pmUnNXbkpqWVlvRTd4TWZXVjJITjJpeUlxTEknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XG5cbi8vIGNyZWF0ZWQgMjAyMy0wOS0xMlQyMjowNToxNC4yMTFaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtbmYgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiBhOTc0YjZmODU0MWZjMjlkOTE5YmM4NTExOGFmMGE0NDAxNTg1MWZhYjUzNDNmODY3OWNiMzFiZTJiZGIyMDllXG52YXIgQ09NUFJFU1NFRCA9ICdBRVVEVEFIQkNGUUFUUURSQURBQWNnQWdBRFFBRkFBc0FCUUFId0FPQUNRQURRQVJBQW9BRndBSEFCSUFDQUFQQUFVQUN3QUZBQXdBQkFBUUFBTUFCd0FFQUFvQUJRQUlBQUlBQ2dBQkFBUUFGQUFMQUFJQUN3QUJBQUlBQVFBSEFBTUFBd0FFQUFzQURBQU1BQXdBQ2dBTkFBMEFBd0FLQUFrQUJBQWRBQVlBWndEU0Fkc0RKZ0MwQ2tNQjh4aFpBcWZvQzE5MFVHY1RoZ0J1cndmN1BUMDlQYjA5QWpnSnVtOE9qRGxseEhZVUtYQVB4enE2dEFCQXhnSzh5c1V2V0FnTVBUMDlQVDA5UFNzNkxUMkhjZ1dYV3dGTG9TTUVFRWw1UkZWTUt2TzBYUThFeERkSk1uSWdzajI2UFRReXk4RmZFUThBWThJUEFHY0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkY4QUpwSUJwb2I1QUVSU01BS05vQVhxYVFMVUJNQ3pFaUFDbndSWkVra1ZzUzd0QU5Bc0JHMFJ1QVFMRVBBQnY5SElDVFVCWGlnUFp3UkJBcE1ET3dBYW1odGFBQnFFQVk4S3ZLeDNMUTRBckFCOFVod0VCQVZTYWdEOEFFRlpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzlBeElCMUJsYkVQTUFzMzBDR3hsWEFod1pLUUlFQ0JjNkVic0NveG5nenY3VXpSUUE4TTBCYXdMNlp3a043d0FCQUQzM09RUmNzZ0xKQ2pNQ2pxVUNodHcva20rTkFzWFBBb1AyQlQ4NFB3VVJBSzBSQXZwdGI2Y0FwUVMvT01NZXk1SEpTODRVZHhweFRQa0NvZ1ZGSVRhVE93RVJBSzVwQXZrTkJPVnlBN3EzQktsT0pTQUxBZ1VJQlJjRWRBU3BCWHF6QUJYRlNXWk9hd0xDT3F3Ly9Bb2xDWmR2djNkU0JrRVFHeWVsRVBjTU13RzFBVHNON1V2WUJQRUdPd1RKSDMwWkdRL05sWndJcFMzZERPMG00eTZoZ0ZvajlTcURCZTFMOUR6ZEMwMVJhQTlaQzJVSjR6cGpnVTRESVFFTklvc0szUTA1Q0cwUTh3ckphdzNsRVVVSE9RUFZTWm9BcFFjQkN4RWROUlcxSmhCaXJBc0pPWGNHK3hyMkM0OG1yeE1wZXZ3RjB4b2hCazBCS1JyL0FNOHU1NFd3V2pGY0hFOWZCZ01MSlNQSEZLaFFJQTBsUUxkNFNCb2JCeFVscVFLUlEzQktoMUUySHBNaDlqdzlEV1l1RTFGOEIvVThCUmxQQzRFOG5rYXJSUTRSMGo2TlBVZ2lTVXdzQkRWL0xDOG5pd25QRDRVTXVYeHlBVmtKSVFteERIRVRNUkVYTjhVSU9RY1pMWmNrSnhVSUlVYVZZSm9FOTU4RDh4UFJBd3NGUHdsQkJ4TUR0Und0RXk0VktRVU5nU1RYQXZNMjFTNnpBbzlXZ0FFWEJjc1BKUi9mRUZCSDRBN3BDSnNDWlFPREplc0FMUlVoQUJjaW13aERZd0JmajloVEJTN0xDTWRxYkNOMEEyY1U1MkVSY3dlUkRsY0hweHd6RmI4YzRYRElYZ3VHQ0NpanJ3bGJBWFVKbVFGZkJPTUlDVFZiaktBZ1FXZFRpMWdZbXlCaFFUOWQvQUl4REdVVm4wUzloM2dDaXc5ckVoc0JOUUZ6QnprTkFRSjNFZTBSYXhDVkNPdUdCRFcxTS9nNkpRUlBJWU1nRVFvbkEwOXN6Z3NuSnZrTStHa0JveEppQXd3MFBYZnVaNnRndGlRWC9RY1pNc1ZCWUNIeEM1SlB6UXljR3NFWVFsUXVHZVFIdndQekd2TW42a0ZYQmY4RG93TVRPazB6N2dTOUMya0lpd2svQUVrT294Y0gxeGhxQ25HTTBBRXhpd0czbVFOWGtZTUNiNDhHTndjTEFHY0xod1Y1NVFBZEFxY0lvd0FGQU04RFZ3QTVBcTBIblFBWkFJVkJBVDBESnk4QkllVUNqd09UQ0RITEFaVXZBZk1wQkJ2RERCVUE5emR1U2dMRHNRS0FhbWFpQmQxWUFvNENTVFVCVFNVRUJVNUhVUU92Y2VFQTJ3QkxCaFBmUndFVnEwckxHdU5EQWQ5dkt3REhBUHNBQlRVSEJVRUJ6UUh6YlFDM0FWOExNUW1pczdVQlRla3BBSU1BRldzQjF3S0pBTjBBTlFCLzhRRlRBRTBGV2ZrRjB3SlBTUUVSTVJnclYyRUJ1d01mQVRNQkRRQjVCc3VOcGNrSEh3UnRCOU1DRUJzVjRRTHZMZ2UxQVFNaTN4UE5Rc1VDdmQ1Vm9XQUNaSUVDWWtKYlRhOWJOeUFDb2ZjQ2FKZ0NaZ2tDbjRRNEd3c0NaanNDWmlZRWJnUi9BMzhUQTM2U09RWTVkeGM1Z2pvakl3SnNIUUl5TmpnS0FtM0hBbTJ1NzRvelowVXJBV2NBM2dEaEFFb0ZCNWdNalFEK0M4SUFEYlVDZHk4Q2RxSS9BbmxMUXdKNHVoMWMyMFd1UnRjQ2ZEOENlc2dDZlFrQ2ZQQUZXUVVnU0FCSWZXTWtBb0Z0QW9BQUFvQUZBbit1U1ZoS1d4VVhTc3dDMFFFQzBNeExKd09JVHdPSDVrVEZrVElDOHFGZEF3TURya3ZPVEMwbEE4OU5URTJ2QW9zL0Fvcll3UnNISFVObkJiY0NqamNDamx4QWw0RUNqdGtDamx4NFViUlROUXBTMUZTRkFwUDdBcE1NQU9rQUhGVWVWYTlWMEFZc0d5bVZoakxoZUdaRk96a0NsNThDNzdKWUlhZ0FXU1VDbG84Q2xueWNBS2xackZvSmdVMEFPd0tXdFFLV1RseEVYTkVDbWNzQ21XUmN5bDBIR1FLY216bkNPcDBDbkJZQ241c0NucmlLQUIwUE1Tb1BBcDN4QXA2U0FMVTlZVFJoN3dLZTB3S2diZ0dwQXA2Zkh3S2VUcVZqeUdRbkpTc0NKNjhDSm40Q29Qc0NvRXdDb3QwQ29jUUNwaThDcGM0Q3AvOEFmUUtuOG1oOGFMRUFBMGxxSEdyUkFxempBcXl1QXExbkFxMENBbGNkQWxYY0FySGgxd01mVG15WEFySzlEUUt5NkJkczRHMWpiVWhmQXlYTkFyWmNPejl1a0FNcFJRSzRYZ0s1UnhVQ3VTcDNjRFp3NFFLOUdRSzcybkNXQXpJUkFyNkljZ0lETTNFQ3ZocHpJbk5QQXNQTEFzTUVjNEowU3pWRmRPQURQS2NEUEpvRFBiOEN4WHdDeGtjQ3hoQ0pBc2hwVVFMSVJBTEpUd0xKTGdKa25RTGQwbmg1WVhpdWVTVkwwQU1ZbzJjQ0FtSDBHZk9WSkhzTFhwSmV1eEVDejJzQ3oyd3ZTMVBTOHhPZkFNYXRBczl6QVNucUEwNFNma3NGQXR3bkF0dUtBdEpQQTFKY0ExTmZBUUVEVll5QWlUOEF5eGJ0WUVXQ0hJTFRnczZEalFMYXh3TFozb1FRaEVtblBBT0dwUUF2QTJRT2huRlorUUJWQXQ5bEF0NjRjM2NDNGkvdEZBSHpNQ2NCOUpzQjh0S0hBdXZ6QXVsd2VRTHErUUxxNUFENVJ3RzVBdTZKQXV1Y2xxcVhBd0x1UHdPRjRKaDVjT0J4b1FMekF3QnBBNDRXbVpNQzl4TURrVzREa29jQzk1Z0MrZGtDK0dhYUhKcXJ1emViSGdPZGd3TCsrZ0ViQURtZkhKK3pBd1dOQTZacUE2YlpBTkhGQXdacW9ZaWlCUWtEREVrQ3dBQS9Bd0RoUVJkVEFSSHpBMnNIbDJjRkFKTXRLN2V2dmRzQmlaa1VmeEVFT1FIN0tRVWhEcDBKbndDUy9TbFh4UUwzQVowQXR3VzVBRzhMYlVFdUZDYU5MZ0ZEQVlEOEFiVW1BSFVERGdSdEFDd0NGZ3loQUFBS0FqMENhZ1BkQTM0RWtRRWdSUVVoZkFvQUJRQkVBQk1BTmhJQ2R3RUFCZFVEYSs4S3hRSUE5d3FmSjcreHQrVUJrU0ZCUWdIcEZIOFJOTUNKQUFRQUd3QmFBa1VDaElzQUJqcFRPcFNOYlFDNE9vODYwQUNOT01FNjNBQ2xBT2dBeXdFNmdUbzdPZnc1K1R0MmlUcGJPNTZKT204NUdBRldBVE1CYkFVdk5WMDFuald0TldZMWRUVzJOY1UxZ2pXUk5kSTE0VFdlTmEwMTdqWDlOYkkxd1RZQ05oRTF4alhWTmhZMkp6WGVOZTAyTGpZOU5pNDFMU0UyT2pZOU5qdzJ5VGNJQkpBOFZ6WTROdDAzSURjUE5zb2dONGszTUFvRXNEeG5OaVEzR1Rkc09vMDNJVUxVUXdkQzRFTUxIQThQQ1pzb2JTaFJWUVlBNlg4QTZiQUJGQ25YQXVrQm93QzlCYmNBYndOekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0JGTFdaQXUwQmhRQ2pCY0VBYnlrQnZ3R0pBYVFjRVowZVBDa2xNQUFoTXZBSU1BTDU0Z0M3Qm04RWVzY2p6UU1wQVJRcEtnRFVBQmF2QWo2MjZ4UUFKUDBBM2V0enVmNE5OUkE3ZWZ5Mlo5TlFyQ25DME9TeUFOejVCQkliSjVJRkRSNm1pSWF2WVM2dHByamptdUtlYnhtNUM3NFEyMjVYMXBrYVlZUGI2ZjFESzRrM3hNRUJiOVMyV01qRWliVE5XaHNSSklBK3Z3TlZFaVhURTVpWHMvd2V6VjY2b0ZMZnA5TlpHWVcrR2sxOUoyK2JDVDZZZTJ3NkxEWWRnektNVWFiazU5NWVMQkNYQU56OUhVcFdiQVRxOXZxWFZ4OVhEZytQYzlYcDQrYnNTMDA1U1ZNL0JKQk00Njg3V1V1ZitVajlkRWk4YUROYVB4dHBiRHhjRzFUSFRJbVVNWnE0VUNhYU5ZcHNWcXJhTnlLTEpYRFlzRlovNWpsN2JMUnRPODh0N1AzeFphQXhoYjVPZFBNWHFzU2twMVdDaWVHOGpYbTFVOTkrYmx2TGxYelBDUytNOTNWbkpDaUsrMDlMZmFTYUJBVkJvbXlEZ0p1YThkZlV6UjdnYTM0SXZSMk52aitBOWhlSjZsc2wxS0c0TmtJMTAzMkNuZmYxbTF3b2YyQjlvSEpLNGJpNkprRWRTcWVOZWl1bzZRb1paaW5jb2M3My9USDlTWEY4c0NFN1h5dVl5VzhXU2diR0ZDalBWMGloTEtoZFBzMDhUeDgyZllBa0xMYzRJMndkbDRhcFk3R1U1bEhSRnpSV0plcDdXdzN3YmVBM3FtZDU5Lzg2UDR4dU5hcURweWdYdDZNODVnbFNCSE9DR2dKRG50K3BOOWJLN0hBcE1ndVg2KzA2UlpOanpWbWNaSit3Y1VySjkvL2JwUk54TnVLcE5sOXVGZHMrUzl0ZHg3TGFNNVprSXJQajZuSVU5bW5iRnRWYnM5cy91TGdsOE1WY3pBd2V0K2lPRXp6QmxZVzdSQ01nRTZneU5MZXE2KzF0SXg0ZHBnWm5kMERrc0pTNWYrSk5EcHd3Y1BOWGFhVnNwcTFmYlFhak9ySmdLMG9mS3RKMU5lOTBMNlZPNE1PbDVTODg2cDd1NnhvN09Makc4VEdMK0hVMUpYR0pncHBnNG5OYk5KNW5selNwdVBZeTIxSlVFY1VBOTRQb0ZpWmZqWnVlK1FueVE4MGVrT3VaVmt4eDRnK2N2aEpmSGdObDRoeTEvYTYrUktjS2xhci9KMjl5Ly9FenRsYlZQSFZVZVExelg4NmVRVkFqUi9NM2RBOXc0VzhMZmFYcDRFZ004NXdPV2FzbGk4MzdQelZNT25zTHpSK2szbzc1L2xSUEFKU0UxeEFLUXpFaTV2MTBrZStWQnZSdDFjd1FSTWQrVTVtTENUR1ZkNlhpWnRnQkc1Y0RpMHcyMkdLY1ZOdkhpdTVMUWJaRURWdHowb25uN2s1K2hldUtYVnNadFN6aWxrTFJBVW1qTVhFTUIzSjlZQzUwWEJ4UGl6NTNTQytFaG5QbDlXc0tDdjkyU00vT0ZGSU1KWllmbDBXVzh0SU8zVXhZY3dkTUFqN0ZTbWdyc1oyYUFaTzAzQk9oUDFiTk5aSXR5WFlRRlRwQzNTRzFWdVBEcUg5R2tpQ0RtRStKd3h5SVZTTzVzaURFckFPcEVYRmdqeTZQUXRPVkRqK3M2ZTFyOGhlV1Z2bVpuVGNpdWY0RWlOWnpDQWQ3U09NaFhFUklPbHNISU1HMzk5aTlhTFR5M20yaFJMWmpKVkROTFM1M2lHSUsxMWRQcVF0MHpCRHlnNnFjN1lxa0RtMk01VmU2ZENXQ2FDYlRYWDJyVG9hSWd6Nit6aDRsWVVpLys2bnFjRk1Ba1FKS0hZTEswd1lrNU45c3pWNnhpaERiRERGcjQ1bE4xSzRhQ1hCcS9GaXRQU3VkOWdMdDVaVm4rWnFHWDdjd20yejVFR01nZkZwSUZ5aEdHdURQbXNvNlRJdFRNd255Kzd1UG5MQ2Y0VzZnb0ZRRlYwb1FTc2M5VmZNbVZMY0xyNlpldERaYmFTRlRMcW5TTy9iSVBqQTMvekFVb3FnR0ZBRVFTNElodU16RXAySTNqSnpiemtrL0lFbXlheCtyaFpUd2Q2ZitDR3R3UGl4dThJdnpBQ3F1UFdQUkV1OVp2R2tVenBSd3ZSUnVhTk42Y3IwVzF3V2l0czlJQ2RZSjdsdGJnTWlTTDNzVFBldWZnTmNWcU1WV0ZrQ1BESDRqRzJqQTBYY1ZnUWo2MkNiMjl2OWYvei8rMktiWXZJdi96empwUUFQa2xpYVZEek5yVzU3VFovWk95WkQwbmxmTW1BSUJJQUdBSTBEM2svbWRONHhyOXY4NVpiWmJicWZIMmpHZDVoVXFOWld3bDVTUGZvR21mRWxtYXpVSWVOTDFqL21rRjdWTkF6VHE0ak50OEpvUTExTlFPY21ocHJYb3hTeGZSR0o5TERFT0FRK2RteEFRSDkwaXRpOWUydS9Nb2V1YUdjRFRIb0MreHNtRWVXbXhFS2VmUXVJekhicHc1VGM1Y0VvY2JvQUQwOW9pcFdRaHRUTzF3aXZmL08rRFJlMnJwbC9FOXdscnpCb3JqSnNPZUcxQi9YUFc0RWFKRUZkTmxFQ0VaZ2E1Wm9HUkhYZ1lvdUdSdVZrbTh0REVTaUV5Rk5vKzNzNU01cHVTZFR5VUwybGxuSU5WSEV0OTFYVU5XNGV3ZE1nSjRib0pmRXl0L2lZNVdYcWJBK0EyRmt0NVowbHV0aVdoZTluWkl5SVVqeVhEQzNVc2FHMXQrZU54Nno0Vy9PWW9UQjdBNngrZE5TVE9pOUFJbmN0YkVTcW01Z3ZPTHd3N09XWFBybUh3Vlphc3JsNGVEMTEzcG0rSnRUN0pWT3ZuQ1hxZHp6ZFRSSGdKMFBpR1RGWVc1R3Z0OVI5TEQ2THpmczB2L1RaWkhTbXlWTnE3dmlJSEU2REJLN1FwMDdJejU1RU04U1l0UXZaZi9vYkJuaVRXaTVDMi9vdkhmdzRWbmRrRTVYWWRqT2hDTVJqRGVPRWZYZU4vQ3dmR2R1aVVJZnNvRmVVeFhlUVhiYTdjNzk3MlhOdjh3K2RUampVTTBRZU5BUmVXK0owMTRkS0FEL01jUVlYVDdjMEdRUElrbjNMbDZSN2dHanVpUW9aRDBURWVFcVFwS29aMTVnLzBPUFFJMTdRaVN2OUFVUk9hL1YvVFFOM2R2TEFyZWMzUnJzWWx2Qm0xYjhMV3psdGR1Z3NDNTBsTktZTEVwMmErWlpZcVBlalVMUmxPSmg1emovTFZNeVREdndLaE14eHd1RGt4SjFRcG9OSTBPVFdMb200WjcxU056STlUVjFpWEpySXU5V2NuZCtNQ2FBdzhvMWpTWGQ5NFlVLzFnbmtyQzlCVUVPdFF2RUlRN2cwaTZoK0tMMkpLazhZZGw3SHJ1dmdXTVNBbU5lK0xzaEdoVjRxbldIaE85L1JJUFF6WTF0SFJqMlZxT3lOc0RwSzBjd3crNTZBZERDNGdzV3dZMFh4b3VjSVdJcXMvR2N3bldxbGFUMEtQcjhtYks1VTk0LzMwMWkxV0x0NFlJTlRWdkNGQnJGWmJJYlk4ZXljT2RlSjJ0ZUQ1SWZQTENSZzdqamNGVHdsTUZObDl6ZGgvbzNFL2hIUHdqN0JXZzBNVTA5cFByQkxickNnbTU0QTZIK0k2djI3K2pMNWdraldnL2lZZGtzOWpiZlZQNXkvbjBkbGdXRU1sS2FzbDdKdkZaZDU2TGZ5YlcxZWVhVk8wZ3hUZlhad0Q4RzRTSTExNnl4N1VLVlJndWk2WWExWXBpeHFYZU5MYzhJeHRBd0NVNUlod1FnbitOcUhuUmFEdjYxQ3hLaE9xNHBPWDdNNnBrQStQbXBkNGoxdm42QUNVQUxvTExjNHZwWGNpOFZpZEx4em03cUZCZTdzK3F1dUpzNkVUWW1ucGdTM0x3U1p4UElsdGdCRFh6OE0xay9XMnlTTnYyZjkvTlBoeExHSzJEMjFka0hlU0dtZW5SVDNZcWNkbDBtL2gzT1lyOFYrbFhOWUdmOGFDQ3BkNGJXakU0UUlQajd2VUtONE5yZnM3TUw2WTJPeVM4MzBKQ25vZmcvazdscEZwdDRTcVpjNUhHZzFIQ09ySHZPZEM4YlA2RkdEYkUvVlYwbVg0SWFremJkUy9vcCtLdDNHMjQvOFFiQlY3eTg2c0dTUS92WnpVOEZYczd1NmpJdndjaHNFUDJCcEloVzNHOHVXTndhM0htamZIL1pqaGhDV3ZsdUFjRituTWYxNENsS2c1aEdndFBMSjk4dWVOQWtjNUhzMldabGsyUUh2ZnJlQ0sxQ0NHTzZuTVpWU2I5OVZNL2FqcjhXSFR0ZTlKU21rWHEvaS9VOTQzSEViZHpXNlJlL1M4OGRLZ2c4cEdPTGxBZU5pcXJjTGtVUjMvYUNsRnBNWGNPVVAzcm1FVGNXU2ZNWFpFM1RVT2k4aStmcVJuVFlMZmxWeC9WYi82R0o3ZUlSWlVBNmszUllSM2lGU0s5YzRpRGROd0p1WkwyRkt6L0lLNVZpbWNOV0VxZFhqU294U2dtRjBVUGxEb1VsTnJQY003ZnRtQThZOWdLaXFLRUh1V04rQVpSSXd0VlN4eWUyS2Y4ck0zbGhKNVhjQlhVOW40djBPeTFSVTJNKzRxTThBUVBWd3NlOEVyTlNvYjVvRlBXeHVxWm5Wem8xcUIvSUJ4a00zRVZVS0ZVVWxPM2U1MTI1OUdnTmNKYkNtbHZyZGp0b1RXN3JDaG0xd3lDS3pwQ1R3b3pVVUVPSWNXTG5lUkxnTVhoK1NqR1NGa0FsbHpiR1M1SEs3TGxmQ01STlJEU3ZiUVBqY1hhZW5OWXhDdnUyUXl6bno2U3R1eFZqNjZTZ0kwVDhCNi9zZkhBSllaYVo3OHRoak9TSUZ1bU5XTFFiZVppeERDQ0MrdjBZQnRreGlCQjNqZWZIcVovZEZIVStjcmJqNk92UzF4L0pERDd2bG03ek9WUHdwVUMwMW5oeFp1WS82M0U3Zyc7XG5cbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG4vLyBmb3IgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXHJcbi8vIHNlZTogL2Rlcml2ZS9uZi5qc1xyXG5cclxuXHJcbi8vIGFsZ29yaXRobWljIGhhbmd1bFxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTUuMC4wL2NoMDMucGRmIChwYWdlIDE0NClcclxuY29uc3QgUzAgPSAweEFDMDA7XHJcbmNvbnN0IEwwID0gMHgxMTAwO1xyXG5jb25zdCBWMCA9IDB4MTE2MTtcclxuY29uc3QgVDAgPSAweDExQTc7XHJcbmNvbnN0IExfQ09VTlQgPSAxOTtcclxuY29uc3QgVl9DT1VOVCA9IDIxO1xyXG5jb25zdCBUX0NPVU5UID0gMjg7XHJcbmNvbnN0IE5fQ09VTlQgPSBWX0NPVU5UICogVF9DT1VOVDtcclxuY29uc3QgU19DT1VOVCA9IExfQ09VTlQgKiBOX0NPVU5UO1xyXG5jb25zdCBTMSA9IFMwICsgU19DT1VOVDtcclxuY29uc3QgTDEgPSBMMCArIExfQ09VTlQ7XHJcbmNvbnN0IFYxID0gVjAgKyBWX0NPVU5UO1xyXG5jb25zdCBUMSA9IFQwICsgVF9DT1VOVDtcclxuXHJcbmZ1bmN0aW9uIHVucGFja19jYyhwYWNrZWQpIHtcclxuXHRyZXR1cm4gKHBhY2tlZCA+PiAyNCkgJiAweEZGO1xyXG59XHJcbmZ1bmN0aW9uIHVucGFja19jcChwYWNrZWQpIHtcclxuXHRyZXR1cm4gcGFja2VkICYgMHhGRkZGRkY7XHJcbn1cclxuXHJcbmxldCBTSElGVEVEX1JBTkssIEVYQ0xVU0lPTlMsIERFQ09NUCwgUkVDT01QO1xyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyBmaXJzdCBhcmVudCByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0Z3MuZm9yRWFjaChnID0+IHJlYy5HLmFkZChnKSk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7XHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0bGV0IHVuaW9uID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMSsgZ3JvdXBzXHJcblx0bGV0IG11bHRpID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMisgZ3JvdXBzXHJcblx0Y29uc3QgYWRkX3RvX3VuaW9uID0gY3AgPT4gdW5pb24uaGFzKGNwKSA/IG11bHRpLmFkZChjcCkgOiB1bmlvbi5hZGQoY3ApO1xyXG5cdGZvciAobGV0IGcgb2YgR1JPVVBTKSB7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlApIGFkZF90b191bmlvbihjcCk7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlEpIGFkZF90b191bmlvbihjcCk7XHJcblx0fVxyXG5cdC8vIGR1YWwgcHVycG9zZSBXSE9MRV9NQVA6IHJldHVybiBwbGFjZWhvbGRlciBpZiB1bmlxdWUgbm9uLWNvbmZ1c2FibGVcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlvbikge1xyXG5cdFx0aWYgKCFXSE9MRV9NQVAuaGFzKGNwKSAmJiAhbXVsdGkuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCBVTklRVUVfUEgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRWQUxJRCA9IG5ldyBTZXQoQXJyYXlfZnJvbSh1bmlvbikuY29uY2F0KEFycmF5X2Zyb20obmZkKHVuaW9uKSkpKTsgLy8gcG9zc2libHkgdmFsaWRcclxuXHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBxdW90ZXIoY3ApID0+IHN0cmluZywgZWcuIDMwMDAgPT4gXCJ7MzAwMH1cIlxyXG4vLyBub3RlOiBpbiBodG1sLCB5b3UnZCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiByZXBsYWNlIFs8PiZdIHdpdGggZW50aXRpZXNcclxuZnVuY3Rpb24gc2FmZV9zdHJfZnJvbV9jcHMoY3BzLCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpXTtcclxuXHRcdGlmIChzaG91bGRfZXNjYXBlKGNwKSkge1xyXG5cdFx0XHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIGkpKSk7XHJcblx0XHRcdGJ1Zi5wdXNoKHF1b3RlcihjcCkpO1xyXG5cdFx0XHRwcmV2ID0gaSArIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgbikpKTtcclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG4vLyBub3RlOiBzZXQocykgY2Fubm90IGJlIGV4cG9zZWQgYmVjYXVzZSB0aGV5IGNhbiBiZSBtb2RpZmllZFxyXG4vLyBub3RlOiBPYmplY3QuZnJlZXplKCkgZG9lc24ndCB3b3JrXHJcbmZ1bmN0aW9uIGlzX2NvbWJpbmluZ19tYXJrKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIHsgXHJcblx0XHRcdGxldCBwcmV2ID0gMDtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgbmV4dCA9IG91dHB1dC5pbmRleE9mKDB4M0JFLCBwcmV2KTtcclxuXHRcdFx0XHRpZiAobmV4dCA8IDApIGJyZWFrO1xyXG5cdFx0XHRcdG91dHB1dFtuZXh0XSA9IDB4MzlFOyBcclxuXHRcdFx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyAyMDIyMTIxMzogZml4ZXMgYmlkaSBzdWJkb21haW4gaXNzdWUsIGJ1dCBicmVha3MgaW52YXJpYW50ICgyMDBFIGlzIGRpc2FsbG93ZWQpXHJcblx0XHQvLyBjb3VsZCBiZSBmaXhlZCB3aXRoIHNwZWNpYWwgY2FzZSBmb3I6IDJEICguKSArIDIwMEUgKExUUilcclxuXHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2JpZGktbGFiZWwtb3JkZXJpbmctc3Bvb2YvMTU4MjRcclxuXHRcdC8vb3V0cHV0LnNwbGljZSgwLCAwLCAweDIwMEUpO1xyXG5cdH1cclxuXHRyZXR1cm4gZmxhdHRlbihsYWJlbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0KSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0cy5lbnNfYmVhdXRpZnkgPSBlbnNfYmVhdXRpZnk7XG5leHBvcnRzLmVuc19lbW9qaSA9IGVuc19lbW9qaTtcbmV4cG9ydHMuZW5zX25vcm1hbGl6ZSA9IGVuc19ub3JtYWxpemU7XG5leHBvcnRzLmVuc19ub3JtYWxpemVfZnJhZ21lbnQgPSBlbnNfbm9ybWFsaXplX2ZyYWdtZW50O1xuZXhwb3J0cy5lbnNfc3BsaXQgPSBlbnNfc3BsaXQ7XG5leHBvcnRzLmVuc190b2tlbml6ZSA9IGVuc190b2tlbml6ZTtcbmV4cG9ydHMuaXNfY29tYmluaW5nX21hcmsgPSBpc19jb21iaW5pbmdfbWFyaztcbmV4cG9ydHMubmZjID0gbmZjO1xuZXhwb3J0cy5uZmQgPSBuZmQ7XG5leHBvcnRzLnNhZmVfc3RyX2Zyb21fY3BzID0gc2FmZV9zdHJfZnJvbV9jcHM7XG5leHBvcnRzLnNob3VsZF9lc2NhcGUgPSBzaG91bGRfZXNjYXBlO1xuIl0sIm5hbWVzIjpbIkNPTVBSRVNTRUQkMSIsIkZFTkNFRCIsIk1hcCIsIk5TTV9NQVgiLCJkZWNvZGVfYXJpdGhtZXRpYyIsImJ5dGVzIiwicG9zIiwidTE2Iiwic3ltYm9sX2NvdW50IiwidG90YWwiLCJhY2MiLCJpIiwicHVzaCIsInNraXAiLCJwb3NfcGF5bG9hZCIsInJlYWRfd2lkdGgiLCJyZWFkX2J1ZmZlciIsInJlYWRfYml0IiwiTiIsIkZVTEwiLCJIQUxGIiwiUVJUUiIsIk1BU0siLCJyZWdpc3RlciIsInN5bWJvbHMiLCJsb3ciLCJyYW5nZSIsInZhbHVlIiwiTWF0aCIsImZsb29yIiwic3RhcnQiLCJlbmQiLCJtaWQiLCJhIiwiYiIsIm9mZnNldCIsIm1hcCIsIngiLCJyZWFkX3BheWxvYWQiLCJ2IiwicmVhZF9jb21wcmVzc2VkX3BheWxvYWQiLCJzIiwidW5zYWZlX2F0b2IiLCJsb29rdXAiLCJmb3JFYWNoIiwiYyIsImNoYXJDb2RlQXQiLCJuIiwibGVuZ3RoIiwicmV0IiwiVWludDhBcnJheSIsIndpZHRoIiwiY2FycnkiLCJzaWduZWQiLCJyZWFkX2RlbHRhcyIsIm5leHQiLCJBcnJheSIsInJlYWRfc29ydGVkIiwicHJldiIsInJlYWRfc29ydGVkX2FycmF5cyIsInJlYWRfYXJyYXlfd2hpbGUiLCJyZWFkX21hcHBlZCIsInciLCJyZWFkX2xpbmVhcl90YWJsZSIsInJlYWRfcmVwbGFjZW1lbnRfdGFibGUiLCJmbGF0IiwicmVhZF90cmFuc3Bvc2VkIiwibSIsImZpbGwiLCJqIiwiZHgiLCJkeSIsInZOIiwiZmxhdE1hcCIsInlzIiwiXyIsImpfZHkiLCJ5Iiwic2xpY2UiLCJyZWFkX3RyaWUiLCJzb3J0ZWQiLCJleHBhbmQiLCJkZWNvZGUiLCJRIiwiUyIsIkIiLCJjcHMiLCJzYXZlZCIsImJyIiwiY3AiLCJoZXhfY3AiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwicGFkU3RhcnQiLCJxdW90ZV9jcCIsImV4cGxvZGVfY3AiLCJsZW4iLCJjb2RlUG9pbnRBdCIsInN0cl9mcm9tX2NwcyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsImJ1ZiIsImpvaW4iLCJjb21wYXJlX2FycmF5cyIsIkNPTVBSRVNTRUQiLCJTMCIsIkwwIiwiVjAiLCJUMCIsIkxfQ09VTlQiLCJWX0NPVU5UIiwiVF9DT1VOVCIsIk5fQ09VTlQiLCJTX0NPVU5UIiwiUzEiLCJMMSIsIlYxIiwiVDEiLCJ1bnBhY2tfY2MiLCJwYWNrZWQiLCJ1bnBhY2tfY3AiLCJTSElGVEVEX1JBTksiLCJFWENMVVNJT05TIiwiREVDT01QIiwiUkVDT01QIiwiaW5pdCQxIiwiciIsIlNldCIsImhhcyIsImJ1Y2tldCIsImdldCIsInNldCIsInJldmVyc2UiLCJpc19oYW5ndWwiLCJjb21wb3NlX3BhaXIiLCJyZWNvbXAiLCJkZWNvbXBvc2VkIiwiY2hlY2tfb3JkZXIiLCJhZGQiLCJjYyIsInNfaW5kZXgiLCJsX2luZGV4Iiwidl9pbmRleCIsInRfaW5kZXgiLCJtYXBwZWQiLCJwb3AiLCJwcmV2X2NjIiwidG1wIiwiY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkIiwic3RhY2siLCJwcmV2X2NwIiwiY29tcG9zZWQiLCJuZmQiLCJuZmMiLCJIWVBIRU4iLCJTVE9QIiwiU1RPUF9DSCIsIkZFMEYiLCJVTklRVUVfUEgiLCJBcnJheV9mcm9tIiwiZnJvbSIsImdyb3VwX2hhc19jcCIsImciLCJQIiwiRW1vamkiLCJpc19lbW9qaSIsIk1BUFBFRCIsIklHTk9SRUQiLCJDTSIsIk5TTSIsIkVTQ0FQRSIsIk5GQ19DSEVDSyIsIkdST1VQUyIsIldIT0xFX1ZBTElEIiwiV0hPTEVfTUFQIiwiVkFMSUQiLCJFTU9KSV9MSVNUIiwiRU1PSklfUk9PVCIsImluaXQiLCJyZWFkX3NvcnRlZF9hcnJheSIsInJlYWRfc29ydGVkX3NldCIsImNodW5rcyIsInVucmVzdHJpY3RlZCIsInJlYWRfY2h1bmtlZCIsImNvbmNhdCIsIlIiLCJNIiwid2hvbGVzIiwic29ydCIsImQiLCJWIiwidmFsdWVzIiwicmVjcyIsImdzIiwiZmlsdGVyIiwicmVjIiwiZmluZCIsIkciLCJzb21lIiwidW5pb24iLCJjb21wbGVtZW50IiwibXVsdGkiLCJhZGRfdG9fdW5pb24iLCJub2RlIiwiY2hpbGQiLCJxdW90ZWRfY3AiLCJzaG91bGRfZXNjYXBlIiwiYmlkaV9xcSIsInNhZmVfc3RyX2Zyb21fY3BzIiwiY2hlY2tfbGFiZWxfZXh0ZW5zaW9uIiwiRXJyb3IiLCJjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUiLCJVTkRFUlNDT1JFIiwibGFzdEluZGV4T2YiLCJjaGVja19mZW5jZWQiLCJlcnJvcl9wbGFjZW1lbnQiLCJsYXN0IiwibWF0Y2giLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsImVuc19lbW9qaSIsImVuc19ub3JtYWxpemVfZnJhZ21lbnQiLCJmcmFnIiwiZGVjb21wb3NlIiwibmYiLCJzcGxpdCIsImxhYmVsIiwidG9rZW5zX2Zyb21fc3RyIiwiZmlsdGVyX2ZlMGYiLCJlbnNfbm9ybWFsaXplIiwibmFtZSIsImZsYXR0ZW4iLCJlbnNfYmVhdXRpZnkiLCJsYWJlbHMiLCJ0eXBlIiwib3V0cHV0IiwiZXJyb3IiLCJpbmRleE9mIiwiZW5zX3NwbGl0IiwicHJlc2VydmVfZW1vamkiLCJlZiIsImlucHV0IiwiaW5mbyIsInRva2VucyIsInRva2VuX2NvdW50Iiwibm9ybSIsImVtb2ppIiwiZXZlcnkiLCJjaGFycyIsInVuaXF1ZSIsImRldGVybWluZV9ncm91cCIsImNoZWNrX2dyb3VwIiwiY2hlY2tfd2hvbGUiLCJlcnIiLCJncm91cCIsIm1ha2VyIiwic2hhcmVkIiwid2hvbGUiLCJncm91cHMiLCJlcnJvcl9kaXNhbGxvd2VkIiwiZXJyb3JfZ3JvdXBfbWVtYmVyIiwibXNnIiwibWVzc2FnZSIsInF1b3RlZCIsImdnIiwid2hlcmUiLCJlIiwiayIsImNvbnN1bWVfZW1vamlfcmV2ZXJzZWQiLCJlYXRlbiIsIlRZX1ZBTElEIiwiVFlfTUFQUEVEIiwiVFlfSUdOT1JFRCIsIlRZX0RJU0FMTE9XRUQiLCJUWV9FTU9KSSIsIlRZX05GQyIsIlRZX1NUT1AiLCJlbnNfdG9rZW5pemUiLCJ0b2tlbiIsImlzX3ZhbGlkX29yX21hcHBlZCIsInJlcXVpcmVzX2NoZWNrIiwiY3BzMCIsInNwbGljZSIsInRva2VuczAiLCJjb2xsYXBzZV92YWxpZF90b2tlbnMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */ var __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _AES_key, _AES_Kd, _AES_Ke;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AES = void 0;\n// Number of rounds by keysize\nconst numberOfRounds = {\n    16: 10,\n    24: 12,\n    32: 14\n};\n// Round constant words\nconst rcon = [\n    0x01,\n    0x02,\n    0x04,\n    0x08,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x1b,\n    0x36,\n    0x6c,\n    0xd8,\n    0xab,\n    0x4d,\n    0x9a,\n    0x2f,\n    0x5e,\n    0xbc,\n    0x63,\n    0xc6,\n    0x97,\n    0x35,\n    0x6a,\n    0xd4,\n    0xb3,\n    0x7d,\n    0xfa,\n    0xef,\n    0xc5,\n    0x91\n];\n// S-box and Inverse S-box (S is for Substitution)\nconst S = [\n    0x63,\n    0x7c,\n    0x77,\n    0x7b,\n    0xf2,\n    0x6b,\n    0x6f,\n    0xc5,\n    0x30,\n    0x01,\n    0x67,\n    0x2b,\n    0xfe,\n    0xd7,\n    0xab,\n    0x76,\n    0xca,\n    0x82,\n    0xc9,\n    0x7d,\n    0xfa,\n    0x59,\n    0x47,\n    0xf0,\n    0xad,\n    0xd4,\n    0xa2,\n    0xaf,\n    0x9c,\n    0xa4,\n    0x72,\n    0xc0,\n    0xb7,\n    0xfd,\n    0x93,\n    0x26,\n    0x36,\n    0x3f,\n    0xf7,\n    0xcc,\n    0x34,\n    0xa5,\n    0xe5,\n    0xf1,\n    0x71,\n    0xd8,\n    0x31,\n    0x15,\n    0x04,\n    0xc7,\n    0x23,\n    0xc3,\n    0x18,\n    0x96,\n    0x05,\n    0x9a,\n    0x07,\n    0x12,\n    0x80,\n    0xe2,\n    0xeb,\n    0x27,\n    0xb2,\n    0x75,\n    0x09,\n    0x83,\n    0x2c,\n    0x1a,\n    0x1b,\n    0x6e,\n    0x5a,\n    0xa0,\n    0x52,\n    0x3b,\n    0xd6,\n    0xb3,\n    0x29,\n    0xe3,\n    0x2f,\n    0x84,\n    0x53,\n    0xd1,\n    0x00,\n    0xed,\n    0x20,\n    0xfc,\n    0xb1,\n    0x5b,\n    0x6a,\n    0xcb,\n    0xbe,\n    0x39,\n    0x4a,\n    0x4c,\n    0x58,\n    0xcf,\n    0xd0,\n    0xef,\n    0xaa,\n    0xfb,\n    0x43,\n    0x4d,\n    0x33,\n    0x85,\n    0x45,\n    0xf9,\n    0x02,\n    0x7f,\n    0x50,\n    0x3c,\n    0x9f,\n    0xa8,\n    0x51,\n    0xa3,\n    0x40,\n    0x8f,\n    0x92,\n    0x9d,\n    0x38,\n    0xf5,\n    0xbc,\n    0xb6,\n    0xda,\n    0x21,\n    0x10,\n    0xff,\n    0xf3,\n    0xd2,\n    0xcd,\n    0x0c,\n    0x13,\n    0xec,\n    0x5f,\n    0x97,\n    0x44,\n    0x17,\n    0xc4,\n    0xa7,\n    0x7e,\n    0x3d,\n    0x64,\n    0x5d,\n    0x19,\n    0x73,\n    0x60,\n    0x81,\n    0x4f,\n    0xdc,\n    0x22,\n    0x2a,\n    0x90,\n    0x88,\n    0x46,\n    0xee,\n    0xb8,\n    0x14,\n    0xde,\n    0x5e,\n    0x0b,\n    0xdb,\n    0xe0,\n    0x32,\n    0x3a,\n    0x0a,\n    0x49,\n    0x06,\n    0x24,\n    0x5c,\n    0xc2,\n    0xd3,\n    0xac,\n    0x62,\n    0x91,\n    0x95,\n    0xe4,\n    0x79,\n    0xe7,\n    0xc8,\n    0x37,\n    0x6d,\n    0x8d,\n    0xd5,\n    0x4e,\n    0xa9,\n    0x6c,\n    0x56,\n    0xf4,\n    0xea,\n    0x65,\n    0x7a,\n    0xae,\n    0x08,\n    0xba,\n    0x78,\n    0x25,\n    0x2e,\n    0x1c,\n    0xa6,\n    0xb4,\n    0xc6,\n    0xe8,\n    0xdd,\n    0x74,\n    0x1f,\n    0x4b,\n    0xbd,\n    0x8b,\n    0x8a,\n    0x70,\n    0x3e,\n    0xb5,\n    0x66,\n    0x48,\n    0x03,\n    0xf6,\n    0x0e,\n    0x61,\n    0x35,\n    0x57,\n    0xb9,\n    0x86,\n    0xc1,\n    0x1d,\n    0x9e,\n    0xe1,\n    0xf8,\n    0x98,\n    0x11,\n    0x69,\n    0xd9,\n    0x8e,\n    0x94,\n    0x9b,\n    0x1e,\n    0x87,\n    0xe9,\n    0xce,\n    0x55,\n    0x28,\n    0xdf,\n    0x8c,\n    0xa1,\n    0x89,\n    0x0d,\n    0xbf,\n    0xe6,\n    0x42,\n    0x68,\n    0x41,\n    0x99,\n    0x2d,\n    0x0f,\n    0xb0,\n    0x54,\n    0xbb,\n    0x16\n];\nconst Si = [\n    0x52,\n    0x09,\n    0x6a,\n    0xd5,\n    0x30,\n    0x36,\n    0xa5,\n    0x38,\n    0xbf,\n    0x40,\n    0xa3,\n    0x9e,\n    0x81,\n    0xf3,\n    0xd7,\n    0xfb,\n    0x7c,\n    0xe3,\n    0x39,\n    0x82,\n    0x9b,\n    0x2f,\n    0xff,\n    0x87,\n    0x34,\n    0x8e,\n    0x43,\n    0x44,\n    0xc4,\n    0xde,\n    0xe9,\n    0xcb,\n    0x54,\n    0x7b,\n    0x94,\n    0x32,\n    0xa6,\n    0xc2,\n    0x23,\n    0x3d,\n    0xee,\n    0x4c,\n    0x95,\n    0x0b,\n    0x42,\n    0xfa,\n    0xc3,\n    0x4e,\n    0x08,\n    0x2e,\n    0xa1,\n    0x66,\n    0x28,\n    0xd9,\n    0x24,\n    0xb2,\n    0x76,\n    0x5b,\n    0xa2,\n    0x49,\n    0x6d,\n    0x8b,\n    0xd1,\n    0x25,\n    0x72,\n    0xf8,\n    0xf6,\n    0x64,\n    0x86,\n    0x68,\n    0x98,\n    0x16,\n    0xd4,\n    0xa4,\n    0x5c,\n    0xcc,\n    0x5d,\n    0x65,\n    0xb6,\n    0x92,\n    0x6c,\n    0x70,\n    0x48,\n    0x50,\n    0xfd,\n    0xed,\n    0xb9,\n    0xda,\n    0x5e,\n    0x15,\n    0x46,\n    0x57,\n    0xa7,\n    0x8d,\n    0x9d,\n    0x84,\n    0x90,\n    0xd8,\n    0xab,\n    0x00,\n    0x8c,\n    0xbc,\n    0xd3,\n    0x0a,\n    0xf7,\n    0xe4,\n    0x58,\n    0x05,\n    0xb8,\n    0xb3,\n    0x45,\n    0x06,\n    0xd0,\n    0x2c,\n    0x1e,\n    0x8f,\n    0xca,\n    0x3f,\n    0x0f,\n    0x02,\n    0xc1,\n    0xaf,\n    0xbd,\n    0x03,\n    0x01,\n    0x13,\n    0x8a,\n    0x6b,\n    0x3a,\n    0x91,\n    0x11,\n    0x41,\n    0x4f,\n    0x67,\n    0xdc,\n    0xea,\n    0x97,\n    0xf2,\n    0xcf,\n    0xce,\n    0xf0,\n    0xb4,\n    0xe6,\n    0x73,\n    0x96,\n    0xac,\n    0x74,\n    0x22,\n    0xe7,\n    0xad,\n    0x35,\n    0x85,\n    0xe2,\n    0xf9,\n    0x37,\n    0xe8,\n    0x1c,\n    0x75,\n    0xdf,\n    0x6e,\n    0x47,\n    0xf1,\n    0x1a,\n    0x71,\n    0x1d,\n    0x29,\n    0xc5,\n    0x89,\n    0x6f,\n    0xb7,\n    0x62,\n    0x0e,\n    0xaa,\n    0x18,\n    0xbe,\n    0x1b,\n    0xfc,\n    0x56,\n    0x3e,\n    0x4b,\n    0xc6,\n    0xd2,\n    0x79,\n    0x20,\n    0x9a,\n    0xdb,\n    0xc0,\n    0xfe,\n    0x78,\n    0xcd,\n    0x5a,\n    0xf4,\n    0x1f,\n    0xdd,\n    0xa8,\n    0x33,\n    0x88,\n    0x07,\n    0xc7,\n    0x31,\n    0xb1,\n    0x12,\n    0x10,\n    0x59,\n    0x27,\n    0x80,\n    0xec,\n    0x5f,\n    0x60,\n    0x51,\n    0x7f,\n    0xa9,\n    0x19,\n    0xb5,\n    0x4a,\n    0x0d,\n    0x2d,\n    0xe5,\n    0x7a,\n    0x9f,\n    0x93,\n    0xc9,\n    0x9c,\n    0xef,\n    0xa0,\n    0xe0,\n    0x3b,\n    0x4d,\n    0xae,\n    0x2a,\n    0xf5,\n    0xb0,\n    0xc8,\n    0xeb,\n    0xbb,\n    0x3c,\n    0x83,\n    0x53,\n    0x99,\n    0x61,\n    0x17,\n    0x2b,\n    0x04,\n    0x7e,\n    0xba,\n    0x77,\n    0xd6,\n    0x26,\n    0xe1,\n    0x69,\n    0x14,\n    0x63,\n    0x55,\n    0x21,\n    0x0c,\n    0x7d\n];\n// Transformations for encryption\nconst T1 = [\n    0xc66363a5,\n    0xf87c7c84,\n    0xee777799,\n    0xf67b7b8d,\n    0xfff2f20d,\n    0xd66b6bbd,\n    0xde6f6fb1,\n    0x91c5c554,\n    0x60303050,\n    0x02010103,\n    0xce6767a9,\n    0x562b2b7d,\n    0xe7fefe19,\n    0xb5d7d762,\n    0x4dababe6,\n    0xec76769a,\n    0x8fcaca45,\n    0x1f82829d,\n    0x89c9c940,\n    0xfa7d7d87,\n    0xeffafa15,\n    0xb25959eb,\n    0x8e4747c9,\n    0xfbf0f00b,\n    0x41adadec,\n    0xb3d4d467,\n    0x5fa2a2fd,\n    0x45afafea,\n    0x239c9cbf,\n    0x53a4a4f7,\n    0xe4727296,\n    0x9bc0c05b,\n    0x75b7b7c2,\n    0xe1fdfd1c,\n    0x3d9393ae,\n    0x4c26266a,\n    0x6c36365a,\n    0x7e3f3f41,\n    0xf5f7f702,\n    0x83cccc4f,\n    0x6834345c,\n    0x51a5a5f4,\n    0xd1e5e534,\n    0xf9f1f108,\n    0xe2717193,\n    0xabd8d873,\n    0x62313153,\n    0x2a15153f,\n    0x0804040c,\n    0x95c7c752,\n    0x46232365,\n    0x9dc3c35e,\n    0x30181828,\n    0x379696a1,\n    0x0a05050f,\n    0x2f9a9ab5,\n    0x0e070709,\n    0x24121236,\n    0x1b80809b,\n    0xdfe2e23d,\n    0xcdebeb26,\n    0x4e272769,\n    0x7fb2b2cd,\n    0xea75759f,\n    0x1209091b,\n    0x1d83839e,\n    0x582c2c74,\n    0x341a1a2e,\n    0x361b1b2d,\n    0xdc6e6eb2,\n    0xb45a5aee,\n    0x5ba0a0fb,\n    0xa45252f6,\n    0x763b3b4d,\n    0xb7d6d661,\n    0x7db3b3ce,\n    0x5229297b,\n    0xdde3e33e,\n    0x5e2f2f71,\n    0x13848497,\n    0xa65353f5,\n    0xb9d1d168,\n    0x00000000,\n    0xc1eded2c,\n    0x40202060,\n    0xe3fcfc1f,\n    0x79b1b1c8,\n    0xb65b5bed,\n    0xd46a6abe,\n    0x8dcbcb46,\n    0x67bebed9,\n    0x7239394b,\n    0x944a4ade,\n    0x984c4cd4,\n    0xb05858e8,\n    0x85cfcf4a,\n    0xbbd0d06b,\n    0xc5efef2a,\n    0x4faaaae5,\n    0xedfbfb16,\n    0x864343c5,\n    0x9a4d4dd7,\n    0x66333355,\n    0x11858594,\n    0x8a4545cf,\n    0xe9f9f910,\n    0x04020206,\n    0xfe7f7f81,\n    0xa05050f0,\n    0x783c3c44,\n    0x259f9fba,\n    0x4ba8a8e3,\n    0xa25151f3,\n    0x5da3a3fe,\n    0x804040c0,\n    0x058f8f8a,\n    0x3f9292ad,\n    0x219d9dbc,\n    0x70383848,\n    0xf1f5f504,\n    0x63bcbcdf,\n    0x77b6b6c1,\n    0xafdada75,\n    0x42212163,\n    0x20101030,\n    0xe5ffff1a,\n    0xfdf3f30e,\n    0xbfd2d26d,\n    0x81cdcd4c,\n    0x180c0c14,\n    0x26131335,\n    0xc3ecec2f,\n    0xbe5f5fe1,\n    0x359797a2,\n    0x884444cc,\n    0x2e171739,\n    0x93c4c457,\n    0x55a7a7f2,\n    0xfc7e7e82,\n    0x7a3d3d47,\n    0xc86464ac,\n    0xba5d5de7,\n    0x3219192b,\n    0xe6737395,\n    0xc06060a0,\n    0x19818198,\n    0x9e4f4fd1,\n    0xa3dcdc7f,\n    0x44222266,\n    0x542a2a7e,\n    0x3b9090ab,\n    0x0b888883,\n    0x8c4646ca,\n    0xc7eeee29,\n    0x6bb8b8d3,\n    0x2814143c,\n    0xa7dede79,\n    0xbc5e5ee2,\n    0x160b0b1d,\n    0xaddbdb76,\n    0xdbe0e03b,\n    0x64323256,\n    0x743a3a4e,\n    0x140a0a1e,\n    0x924949db,\n    0x0c06060a,\n    0x4824246c,\n    0xb85c5ce4,\n    0x9fc2c25d,\n    0xbdd3d36e,\n    0x43acacef,\n    0xc46262a6,\n    0x399191a8,\n    0x319595a4,\n    0xd3e4e437,\n    0xf279798b,\n    0xd5e7e732,\n    0x8bc8c843,\n    0x6e373759,\n    0xda6d6db7,\n    0x018d8d8c,\n    0xb1d5d564,\n    0x9c4e4ed2,\n    0x49a9a9e0,\n    0xd86c6cb4,\n    0xac5656fa,\n    0xf3f4f407,\n    0xcfeaea25,\n    0xca6565af,\n    0xf47a7a8e,\n    0x47aeaee9,\n    0x10080818,\n    0x6fbabad5,\n    0xf0787888,\n    0x4a25256f,\n    0x5c2e2e72,\n    0x381c1c24,\n    0x57a6a6f1,\n    0x73b4b4c7,\n    0x97c6c651,\n    0xcbe8e823,\n    0xa1dddd7c,\n    0xe874749c,\n    0x3e1f1f21,\n    0x964b4bdd,\n    0x61bdbddc,\n    0x0d8b8b86,\n    0x0f8a8a85,\n    0xe0707090,\n    0x7c3e3e42,\n    0x71b5b5c4,\n    0xcc6666aa,\n    0x904848d8,\n    0x06030305,\n    0xf7f6f601,\n    0x1c0e0e12,\n    0xc26161a3,\n    0x6a35355f,\n    0xae5757f9,\n    0x69b9b9d0,\n    0x17868691,\n    0x99c1c158,\n    0x3a1d1d27,\n    0x279e9eb9,\n    0xd9e1e138,\n    0xebf8f813,\n    0x2b9898b3,\n    0x22111133,\n    0xd26969bb,\n    0xa9d9d970,\n    0x078e8e89,\n    0x339494a7,\n    0x2d9b9bb6,\n    0x3c1e1e22,\n    0x15878792,\n    0xc9e9e920,\n    0x87cece49,\n    0xaa5555ff,\n    0x50282878,\n    0xa5dfdf7a,\n    0x038c8c8f,\n    0x59a1a1f8,\n    0x09898980,\n    0x1a0d0d17,\n    0x65bfbfda,\n    0xd7e6e631,\n    0x844242c6,\n    0xd06868b8,\n    0x824141c3,\n    0x299999b0,\n    0x5a2d2d77,\n    0x1e0f0f11,\n    0x7bb0b0cb,\n    0xa85454fc,\n    0x6dbbbbd6,\n    0x2c16163a\n];\nconst T2 = [\n    0xa5c66363,\n    0x84f87c7c,\n    0x99ee7777,\n    0x8df67b7b,\n    0x0dfff2f2,\n    0xbdd66b6b,\n    0xb1de6f6f,\n    0x5491c5c5,\n    0x50603030,\n    0x03020101,\n    0xa9ce6767,\n    0x7d562b2b,\n    0x19e7fefe,\n    0x62b5d7d7,\n    0xe64dabab,\n    0x9aec7676,\n    0x458fcaca,\n    0x9d1f8282,\n    0x4089c9c9,\n    0x87fa7d7d,\n    0x15effafa,\n    0xebb25959,\n    0xc98e4747,\n    0x0bfbf0f0,\n    0xec41adad,\n    0x67b3d4d4,\n    0xfd5fa2a2,\n    0xea45afaf,\n    0xbf239c9c,\n    0xf753a4a4,\n    0x96e47272,\n    0x5b9bc0c0,\n    0xc275b7b7,\n    0x1ce1fdfd,\n    0xae3d9393,\n    0x6a4c2626,\n    0x5a6c3636,\n    0x417e3f3f,\n    0x02f5f7f7,\n    0x4f83cccc,\n    0x5c683434,\n    0xf451a5a5,\n    0x34d1e5e5,\n    0x08f9f1f1,\n    0x93e27171,\n    0x73abd8d8,\n    0x53623131,\n    0x3f2a1515,\n    0x0c080404,\n    0x5295c7c7,\n    0x65462323,\n    0x5e9dc3c3,\n    0x28301818,\n    0xa1379696,\n    0x0f0a0505,\n    0xb52f9a9a,\n    0x090e0707,\n    0x36241212,\n    0x9b1b8080,\n    0x3ddfe2e2,\n    0x26cdebeb,\n    0x694e2727,\n    0xcd7fb2b2,\n    0x9fea7575,\n    0x1b120909,\n    0x9e1d8383,\n    0x74582c2c,\n    0x2e341a1a,\n    0x2d361b1b,\n    0xb2dc6e6e,\n    0xeeb45a5a,\n    0xfb5ba0a0,\n    0xf6a45252,\n    0x4d763b3b,\n    0x61b7d6d6,\n    0xce7db3b3,\n    0x7b522929,\n    0x3edde3e3,\n    0x715e2f2f,\n    0x97138484,\n    0xf5a65353,\n    0x68b9d1d1,\n    0x00000000,\n    0x2cc1eded,\n    0x60402020,\n    0x1fe3fcfc,\n    0xc879b1b1,\n    0xedb65b5b,\n    0xbed46a6a,\n    0x468dcbcb,\n    0xd967bebe,\n    0x4b723939,\n    0xde944a4a,\n    0xd4984c4c,\n    0xe8b05858,\n    0x4a85cfcf,\n    0x6bbbd0d0,\n    0x2ac5efef,\n    0xe54faaaa,\n    0x16edfbfb,\n    0xc5864343,\n    0xd79a4d4d,\n    0x55663333,\n    0x94118585,\n    0xcf8a4545,\n    0x10e9f9f9,\n    0x06040202,\n    0x81fe7f7f,\n    0xf0a05050,\n    0x44783c3c,\n    0xba259f9f,\n    0xe34ba8a8,\n    0xf3a25151,\n    0xfe5da3a3,\n    0xc0804040,\n    0x8a058f8f,\n    0xad3f9292,\n    0xbc219d9d,\n    0x48703838,\n    0x04f1f5f5,\n    0xdf63bcbc,\n    0xc177b6b6,\n    0x75afdada,\n    0x63422121,\n    0x30201010,\n    0x1ae5ffff,\n    0x0efdf3f3,\n    0x6dbfd2d2,\n    0x4c81cdcd,\n    0x14180c0c,\n    0x35261313,\n    0x2fc3ecec,\n    0xe1be5f5f,\n    0xa2359797,\n    0xcc884444,\n    0x392e1717,\n    0x5793c4c4,\n    0xf255a7a7,\n    0x82fc7e7e,\n    0x477a3d3d,\n    0xacc86464,\n    0xe7ba5d5d,\n    0x2b321919,\n    0x95e67373,\n    0xa0c06060,\n    0x98198181,\n    0xd19e4f4f,\n    0x7fa3dcdc,\n    0x66442222,\n    0x7e542a2a,\n    0xab3b9090,\n    0x830b8888,\n    0xca8c4646,\n    0x29c7eeee,\n    0xd36bb8b8,\n    0x3c281414,\n    0x79a7dede,\n    0xe2bc5e5e,\n    0x1d160b0b,\n    0x76addbdb,\n    0x3bdbe0e0,\n    0x56643232,\n    0x4e743a3a,\n    0x1e140a0a,\n    0xdb924949,\n    0x0a0c0606,\n    0x6c482424,\n    0xe4b85c5c,\n    0x5d9fc2c2,\n    0x6ebdd3d3,\n    0xef43acac,\n    0xa6c46262,\n    0xa8399191,\n    0xa4319595,\n    0x37d3e4e4,\n    0x8bf27979,\n    0x32d5e7e7,\n    0x438bc8c8,\n    0x596e3737,\n    0xb7da6d6d,\n    0x8c018d8d,\n    0x64b1d5d5,\n    0xd29c4e4e,\n    0xe049a9a9,\n    0xb4d86c6c,\n    0xfaac5656,\n    0x07f3f4f4,\n    0x25cfeaea,\n    0xafca6565,\n    0x8ef47a7a,\n    0xe947aeae,\n    0x18100808,\n    0xd56fbaba,\n    0x88f07878,\n    0x6f4a2525,\n    0x725c2e2e,\n    0x24381c1c,\n    0xf157a6a6,\n    0xc773b4b4,\n    0x5197c6c6,\n    0x23cbe8e8,\n    0x7ca1dddd,\n    0x9ce87474,\n    0x213e1f1f,\n    0xdd964b4b,\n    0xdc61bdbd,\n    0x860d8b8b,\n    0x850f8a8a,\n    0x90e07070,\n    0x427c3e3e,\n    0xc471b5b5,\n    0xaacc6666,\n    0xd8904848,\n    0x05060303,\n    0x01f7f6f6,\n    0x121c0e0e,\n    0xa3c26161,\n    0x5f6a3535,\n    0xf9ae5757,\n    0xd069b9b9,\n    0x91178686,\n    0x5899c1c1,\n    0x273a1d1d,\n    0xb9279e9e,\n    0x38d9e1e1,\n    0x13ebf8f8,\n    0xb32b9898,\n    0x33221111,\n    0xbbd26969,\n    0x70a9d9d9,\n    0x89078e8e,\n    0xa7339494,\n    0xb62d9b9b,\n    0x223c1e1e,\n    0x92158787,\n    0x20c9e9e9,\n    0x4987cece,\n    0xffaa5555,\n    0x78502828,\n    0x7aa5dfdf,\n    0x8f038c8c,\n    0xf859a1a1,\n    0x80098989,\n    0x171a0d0d,\n    0xda65bfbf,\n    0x31d7e6e6,\n    0xc6844242,\n    0xb8d06868,\n    0xc3824141,\n    0xb0299999,\n    0x775a2d2d,\n    0x111e0f0f,\n    0xcb7bb0b0,\n    0xfca85454,\n    0xd66dbbbb,\n    0x3a2c1616\n];\nconst T3 = [\n    0x63a5c663,\n    0x7c84f87c,\n    0x7799ee77,\n    0x7b8df67b,\n    0xf20dfff2,\n    0x6bbdd66b,\n    0x6fb1de6f,\n    0xc55491c5,\n    0x30506030,\n    0x01030201,\n    0x67a9ce67,\n    0x2b7d562b,\n    0xfe19e7fe,\n    0xd762b5d7,\n    0xabe64dab,\n    0x769aec76,\n    0xca458fca,\n    0x829d1f82,\n    0xc94089c9,\n    0x7d87fa7d,\n    0xfa15effa,\n    0x59ebb259,\n    0x47c98e47,\n    0xf00bfbf0,\n    0xadec41ad,\n    0xd467b3d4,\n    0xa2fd5fa2,\n    0xafea45af,\n    0x9cbf239c,\n    0xa4f753a4,\n    0x7296e472,\n    0xc05b9bc0,\n    0xb7c275b7,\n    0xfd1ce1fd,\n    0x93ae3d93,\n    0x266a4c26,\n    0x365a6c36,\n    0x3f417e3f,\n    0xf702f5f7,\n    0xcc4f83cc,\n    0x345c6834,\n    0xa5f451a5,\n    0xe534d1e5,\n    0xf108f9f1,\n    0x7193e271,\n    0xd873abd8,\n    0x31536231,\n    0x153f2a15,\n    0x040c0804,\n    0xc75295c7,\n    0x23654623,\n    0xc35e9dc3,\n    0x18283018,\n    0x96a13796,\n    0x050f0a05,\n    0x9ab52f9a,\n    0x07090e07,\n    0x12362412,\n    0x809b1b80,\n    0xe23ddfe2,\n    0xeb26cdeb,\n    0x27694e27,\n    0xb2cd7fb2,\n    0x759fea75,\n    0x091b1209,\n    0x839e1d83,\n    0x2c74582c,\n    0x1a2e341a,\n    0x1b2d361b,\n    0x6eb2dc6e,\n    0x5aeeb45a,\n    0xa0fb5ba0,\n    0x52f6a452,\n    0x3b4d763b,\n    0xd661b7d6,\n    0xb3ce7db3,\n    0x297b5229,\n    0xe33edde3,\n    0x2f715e2f,\n    0x84971384,\n    0x53f5a653,\n    0xd168b9d1,\n    0x00000000,\n    0xed2cc1ed,\n    0x20604020,\n    0xfc1fe3fc,\n    0xb1c879b1,\n    0x5bedb65b,\n    0x6abed46a,\n    0xcb468dcb,\n    0xbed967be,\n    0x394b7239,\n    0x4ade944a,\n    0x4cd4984c,\n    0x58e8b058,\n    0xcf4a85cf,\n    0xd06bbbd0,\n    0xef2ac5ef,\n    0xaae54faa,\n    0xfb16edfb,\n    0x43c58643,\n    0x4dd79a4d,\n    0x33556633,\n    0x85941185,\n    0x45cf8a45,\n    0xf910e9f9,\n    0x02060402,\n    0x7f81fe7f,\n    0x50f0a050,\n    0x3c44783c,\n    0x9fba259f,\n    0xa8e34ba8,\n    0x51f3a251,\n    0xa3fe5da3,\n    0x40c08040,\n    0x8f8a058f,\n    0x92ad3f92,\n    0x9dbc219d,\n    0x38487038,\n    0xf504f1f5,\n    0xbcdf63bc,\n    0xb6c177b6,\n    0xda75afda,\n    0x21634221,\n    0x10302010,\n    0xff1ae5ff,\n    0xf30efdf3,\n    0xd26dbfd2,\n    0xcd4c81cd,\n    0x0c14180c,\n    0x13352613,\n    0xec2fc3ec,\n    0x5fe1be5f,\n    0x97a23597,\n    0x44cc8844,\n    0x17392e17,\n    0xc45793c4,\n    0xa7f255a7,\n    0x7e82fc7e,\n    0x3d477a3d,\n    0x64acc864,\n    0x5de7ba5d,\n    0x192b3219,\n    0x7395e673,\n    0x60a0c060,\n    0x81981981,\n    0x4fd19e4f,\n    0xdc7fa3dc,\n    0x22664422,\n    0x2a7e542a,\n    0x90ab3b90,\n    0x88830b88,\n    0x46ca8c46,\n    0xee29c7ee,\n    0xb8d36bb8,\n    0x143c2814,\n    0xde79a7de,\n    0x5ee2bc5e,\n    0x0b1d160b,\n    0xdb76addb,\n    0xe03bdbe0,\n    0x32566432,\n    0x3a4e743a,\n    0x0a1e140a,\n    0x49db9249,\n    0x060a0c06,\n    0x246c4824,\n    0x5ce4b85c,\n    0xc25d9fc2,\n    0xd36ebdd3,\n    0xacef43ac,\n    0x62a6c462,\n    0x91a83991,\n    0x95a43195,\n    0xe437d3e4,\n    0x798bf279,\n    0xe732d5e7,\n    0xc8438bc8,\n    0x37596e37,\n    0x6db7da6d,\n    0x8d8c018d,\n    0xd564b1d5,\n    0x4ed29c4e,\n    0xa9e049a9,\n    0x6cb4d86c,\n    0x56faac56,\n    0xf407f3f4,\n    0xea25cfea,\n    0x65afca65,\n    0x7a8ef47a,\n    0xaee947ae,\n    0x08181008,\n    0xbad56fba,\n    0x7888f078,\n    0x256f4a25,\n    0x2e725c2e,\n    0x1c24381c,\n    0xa6f157a6,\n    0xb4c773b4,\n    0xc65197c6,\n    0xe823cbe8,\n    0xdd7ca1dd,\n    0x749ce874,\n    0x1f213e1f,\n    0x4bdd964b,\n    0xbddc61bd,\n    0x8b860d8b,\n    0x8a850f8a,\n    0x7090e070,\n    0x3e427c3e,\n    0xb5c471b5,\n    0x66aacc66,\n    0x48d89048,\n    0x03050603,\n    0xf601f7f6,\n    0x0e121c0e,\n    0x61a3c261,\n    0x355f6a35,\n    0x57f9ae57,\n    0xb9d069b9,\n    0x86911786,\n    0xc15899c1,\n    0x1d273a1d,\n    0x9eb9279e,\n    0xe138d9e1,\n    0xf813ebf8,\n    0x98b32b98,\n    0x11332211,\n    0x69bbd269,\n    0xd970a9d9,\n    0x8e89078e,\n    0x94a73394,\n    0x9bb62d9b,\n    0x1e223c1e,\n    0x87921587,\n    0xe920c9e9,\n    0xce4987ce,\n    0x55ffaa55,\n    0x28785028,\n    0xdf7aa5df,\n    0x8c8f038c,\n    0xa1f859a1,\n    0x89800989,\n    0x0d171a0d,\n    0xbfda65bf,\n    0xe631d7e6,\n    0x42c68442,\n    0x68b8d068,\n    0x41c38241,\n    0x99b02999,\n    0x2d775a2d,\n    0x0f111e0f,\n    0xb0cb7bb0,\n    0x54fca854,\n    0xbbd66dbb,\n    0x163a2c16\n];\nconst T4 = [\n    0x6363a5c6,\n    0x7c7c84f8,\n    0x777799ee,\n    0x7b7b8df6,\n    0xf2f20dff,\n    0x6b6bbdd6,\n    0x6f6fb1de,\n    0xc5c55491,\n    0x30305060,\n    0x01010302,\n    0x6767a9ce,\n    0x2b2b7d56,\n    0xfefe19e7,\n    0xd7d762b5,\n    0xababe64d,\n    0x76769aec,\n    0xcaca458f,\n    0x82829d1f,\n    0xc9c94089,\n    0x7d7d87fa,\n    0xfafa15ef,\n    0x5959ebb2,\n    0x4747c98e,\n    0xf0f00bfb,\n    0xadadec41,\n    0xd4d467b3,\n    0xa2a2fd5f,\n    0xafafea45,\n    0x9c9cbf23,\n    0xa4a4f753,\n    0x727296e4,\n    0xc0c05b9b,\n    0xb7b7c275,\n    0xfdfd1ce1,\n    0x9393ae3d,\n    0x26266a4c,\n    0x36365a6c,\n    0x3f3f417e,\n    0xf7f702f5,\n    0xcccc4f83,\n    0x34345c68,\n    0xa5a5f451,\n    0xe5e534d1,\n    0xf1f108f9,\n    0x717193e2,\n    0xd8d873ab,\n    0x31315362,\n    0x15153f2a,\n    0x04040c08,\n    0xc7c75295,\n    0x23236546,\n    0xc3c35e9d,\n    0x18182830,\n    0x9696a137,\n    0x05050f0a,\n    0x9a9ab52f,\n    0x0707090e,\n    0x12123624,\n    0x80809b1b,\n    0xe2e23ddf,\n    0xebeb26cd,\n    0x2727694e,\n    0xb2b2cd7f,\n    0x75759fea,\n    0x09091b12,\n    0x83839e1d,\n    0x2c2c7458,\n    0x1a1a2e34,\n    0x1b1b2d36,\n    0x6e6eb2dc,\n    0x5a5aeeb4,\n    0xa0a0fb5b,\n    0x5252f6a4,\n    0x3b3b4d76,\n    0xd6d661b7,\n    0xb3b3ce7d,\n    0x29297b52,\n    0xe3e33edd,\n    0x2f2f715e,\n    0x84849713,\n    0x5353f5a6,\n    0xd1d168b9,\n    0x00000000,\n    0xeded2cc1,\n    0x20206040,\n    0xfcfc1fe3,\n    0xb1b1c879,\n    0x5b5bedb6,\n    0x6a6abed4,\n    0xcbcb468d,\n    0xbebed967,\n    0x39394b72,\n    0x4a4ade94,\n    0x4c4cd498,\n    0x5858e8b0,\n    0xcfcf4a85,\n    0xd0d06bbb,\n    0xefef2ac5,\n    0xaaaae54f,\n    0xfbfb16ed,\n    0x4343c586,\n    0x4d4dd79a,\n    0x33335566,\n    0x85859411,\n    0x4545cf8a,\n    0xf9f910e9,\n    0x02020604,\n    0x7f7f81fe,\n    0x5050f0a0,\n    0x3c3c4478,\n    0x9f9fba25,\n    0xa8a8e34b,\n    0x5151f3a2,\n    0xa3a3fe5d,\n    0x4040c080,\n    0x8f8f8a05,\n    0x9292ad3f,\n    0x9d9dbc21,\n    0x38384870,\n    0xf5f504f1,\n    0xbcbcdf63,\n    0xb6b6c177,\n    0xdada75af,\n    0x21216342,\n    0x10103020,\n    0xffff1ae5,\n    0xf3f30efd,\n    0xd2d26dbf,\n    0xcdcd4c81,\n    0x0c0c1418,\n    0x13133526,\n    0xecec2fc3,\n    0x5f5fe1be,\n    0x9797a235,\n    0x4444cc88,\n    0x1717392e,\n    0xc4c45793,\n    0xa7a7f255,\n    0x7e7e82fc,\n    0x3d3d477a,\n    0x6464acc8,\n    0x5d5de7ba,\n    0x19192b32,\n    0x737395e6,\n    0x6060a0c0,\n    0x81819819,\n    0x4f4fd19e,\n    0xdcdc7fa3,\n    0x22226644,\n    0x2a2a7e54,\n    0x9090ab3b,\n    0x8888830b,\n    0x4646ca8c,\n    0xeeee29c7,\n    0xb8b8d36b,\n    0x14143c28,\n    0xdede79a7,\n    0x5e5ee2bc,\n    0x0b0b1d16,\n    0xdbdb76ad,\n    0xe0e03bdb,\n    0x32325664,\n    0x3a3a4e74,\n    0x0a0a1e14,\n    0x4949db92,\n    0x06060a0c,\n    0x24246c48,\n    0x5c5ce4b8,\n    0xc2c25d9f,\n    0xd3d36ebd,\n    0xacacef43,\n    0x6262a6c4,\n    0x9191a839,\n    0x9595a431,\n    0xe4e437d3,\n    0x79798bf2,\n    0xe7e732d5,\n    0xc8c8438b,\n    0x3737596e,\n    0x6d6db7da,\n    0x8d8d8c01,\n    0xd5d564b1,\n    0x4e4ed29c,\n    0xa9a9e049,\n    0x6c6cb4d8,\n    0x5656faac,\n    0xf4f407f3,\n    0xeaea25cf,\n    0x6565afca,\n    0x7a7a8ef4,\n    0xaeaee947,\n    0x08081810,\n    0xbabad56f,\n    0x787888f0,\n    0x25256f4a,\n    0x2e2e725c,\n    0x1c1c2438,\n    0xa6a6f157,\n    0xb4b4c773,\n    0xc6c65197,\n    0xe8e823cb,\n    0xdddd7ca1,\n    0x74749ce8,\n    0x1f1f213e,\n    0x4b4bdd96,\n    0xbdbddc61,\n    0x8b8b860d,\n    0x8a8a850f,\n    0x707090e0,\n    0x3e3e427c,\n    0xb5b5c471,\n    0x6666aacc,\n    0x4848d890,\n    0x03030506,\n    0xf6f601f7,\n    0x0e0e121c,\n    0x6161a3c2,\n    0x35355f6a,\n    0x5757f9ae,\n    0xb9b9d069,\n    0x86869117,\n    0xc1c15899,\n    0x1d1d273a,\n    0x9e9eb927,\n    0xe1e138d9,\n    0xf8f813eb,\n    0x9898b32b,\n    0x11113322,\n    0x6969bbd2,\n    0xd9d970a9,\n    0x8e8e8907,\n    0x9494a733,\n    0x9b9bb62d,\n    0x1e1e223c,\n    0x87879215,\n    0xe9e920c9,\n    0xcece4987,\n    0x5555ffaa,\n    0x28287850,\n    0xdfdf7aa5,\n    0x8c8c8f03,\n    0xa1a1f859,\n    0x89898009,\n    0x0d0d171a,\n    0xbfbfda65,\n    0xe6e631d7,\n    0x4242c684,\n    0x6868b8d0,\n    0x4141c382,\n    0x9999b029,\n    0x2d2d775a,\n    0x0f0f111e,\n    0xb0b0cb7b,\n    0x5454fca8,\n    0xbbbbd66d,\n    0x16163a2c\n];\n// Transformations for decryption\nconst T5 = [\n    0x51f4a750,\n    0x7e416553,\n    0x1a17a4c3,\n    0x3a275e96,\n    0x3bab6bcb,\n    0x1f9d45f1,\n    0xacfa58ab,\n    0x4be30393,\n    0x2030fa55,\n    0xad766df6,\n    0x88cc7691,\n    0xf5024c25,\n    0x4fe5d7fc,\n    0xc52acbd7,\n    0x26354480,\n    0xb562a38f,\n    0xdeb15a49,\n    0x25ba1b67,\n    0x45ea0e98,\n    0x5dfec0e1,\n    0xc32f7502,\n    0x814cf012,\n    0x8d4697a3,\n    0x6bd3f9c6,\n    0x038f5fe7,\n    0x15929c95,\n    0xbf6d7aeb,\n    0x955259da,\n    0xd4be832d,\n    0x587421d3,\n    0x49e06929,\n    0x8ec9c844,\n    0x75c2896a,\n    0xf48e7978,\n    0x99583e6b,\n    0x27b971dd,\n    0xbee14fb6,\n    0xf088ad17,\n    0xc920ac66,\n    0x7dce3ab4,\n    0x63df4a18,\n    0xe51a3182,\n    0x97513360,\n    0x62537f45,\n    0xb16477e0,\n    0xbb6bae84,\n    0xfe81a01c,\n    0xf9082b94,\n    0x70486858,\n    0x8f45fd19,\n    0x94de6c87,\n    0x527bf8b7,\n    0xab73d323,\n    0x724b02e2,\n    0xe31f8f57,\n    0x6655ab2a,\n    0xb2eb2807,\n    0x2fb5c203,\n    0x86c57b9a,\n    0xd33708a5,\n    0x302887f2,\n    0x23bfa5b2,\n    0x02036aba,\n    0xed16825c,\n    0x8acf1c2b,\n    0xa779b492,\n    0xf307f2f0,\n    0x4e69e2a1,\n    0x65daf4cd,\n    0x0605bed5,\n    0xd134621f,\n    0xc4a6fe8a,\n    0x342e539d,\n    0xa2f355a0,\n    0x058ae132,\n    0xa4f6eb75,\n    0x0b83ec39,\n    0x4060efaa,\n    0x5e719f06,\n    0xbd6e1051,\n    0x3e218af9,\n    0x96dd063d,\n    0xdd3e05ae,\n    0x4de6bd46,\n    0x91548db5,\n    0x71c45d05,\n    0x0406d46f,\n    0x605015ff,\n    0x1998fb24,\n    0xd6bde997,\n    0x894043cc,\n    0x67d99e77,\n    0xb0e842bd,\n    0x07898b88,\n    0xe7195b38,\n    0x79c8eedb,\n    0xa17c0a47,\n    0x7c420fe9,\n    0xf8841ec9,\n    0x00000000,\n    0x09808683,\n    0x322bed48,\n    0x1e1170ac,\n    0x6c5a724e,\n    0xfd0efffb,\n    0x0f853856,\n    0x3daed51e,\n    0x362d3927,\n    0x0a0fd964,\n    0x685ca621,\n    0x9b5b54d1,\n    0x24362e3a,\n    0x0c0a67b1,\n    0x9357e70f,\n    0xb4ee96d2,\n    0x1b9b919e,\n    0x80c0c54f,\n    0x61dc20a2,\n    0x5a774b69,\n    0x1c121a16,\n    0xe293ba0a,\n    0xc0a02ae5,\n    0x3c22e043,\n    0x121b171d,\n    0x0e090d0b,\n    0xf28bc7ad,\n    0x2db6a8b9,\n    0x141ea9c8,\n    0x57f11985,\n    0xaf75074c,\n    0xee99ddbb,\n    0xa37f60fd,\n    0xf701269f,\n    0x5c72f5bc,\n    0x44663bc5,\n    0x5bfb7e34,\n    0x8b432976,\n    0xcb23c6dc,\n    0xb6edfc68,\n    0xb8e4f163,\n    0xd731dcca,\n    0x42638510,\n    0x13972240,\n    0x84c61120,\n    0x854a247d,\n    0xd2bb3df8,\n    0xaef93211,\n    0xc729a16d,\n    0x1d9e2f4b,\n    0xdcb230f3,\n    0x0d8652ec,\n    0x77c1e3d0,\n    0x2bb3166c,\n    0xa970b999,\n    0x119448fa,\n    0x47e96422,\n    0xa8fc8cc4,\n    0xa0f03f1a,\n    0x567d2cd8,\n    0x223390ef,\n    0x87494ec7,\n    0xd938d1c1,\n    0x8ccaa2fe,\n    0x98d40b36,\n    0xa6f581cf,\n    0xa57ade28,\n    0xdab78e26,\n    0x3fadbfa4,\n    0x2c3a9de4,\n    0x5078920d,\n    0x6a5fcc9b,\n    0x547e4662,\n    0xf68d13c2,\n    0x90d8b8e8,\n    0x2e39f75e,\n    0x82c3aff5,\n    0x9f5d80be,\n    0x69d0937c,\n    0x6fd52da9,\n    0xcf2512b3,\n    0xc8ac993b,\n    0x10187da7,\n    0xe89c636e,\n    0xdb3bbb7b,\n    0xcd267809,\n    0x6e5918f4,\n    0xec9ab701,\n    0x834f9aa8,\n    0xe6956e65,\n    0xaaffe67e,\n    0x21bccf08,\n    0xef15e8e6,\n    0xbae79bd9,\n    0x4a6f36ce,\n    0xea9f09d4,\n    0x29b07cd6,\n    0x31a4b2af,\n    0x2a3f2331,\n    0xc6a59430,\n    0x35a266c0,\n    0x744ebc37,\n    0xfc82caa6,\n    0xe090d0b0,\n    0x33a7d815,\n    0xf104984a,\n    0x41ecdaf7,\n    0x7fcd500e,\n    0x1791f62f,\n    0x764dd68d,\n    0x43efb04d,\n    0xccaa4d54,\n    0xe49604df,\n    0x9ed1b5e3,\n    0x4c6a881b,\n    0xc12c1fb8,\n    0x4665517f,\n    0x9d5eea04,\n    0x018c355d,\n    0xfa877473,\n    0xfb0b412e,\n    0xb3671d5a,\n    0x92dbd252,\n    0xe9105633,\n    0x6dd64713,\n    0x9ad7618c,\n    0x37a10c7a,\n    0x59f8148e,\n    0xeb133c89,\n    0xcea927ee,\n    0xb761c935,\n    0xe11ce5ed,\n    0x7a47b13c,\n    0x9cd2df59,\n    0x55f2733f,\n    0x1814ce79,\n    0x73c737bf,\n    0x53f7cdea,\n    0x5ffdaa5b,\n    0xdf3d6f14,\n    0x7844db86,\n    0xcaaff381,\n    0xb968c43e,\n    0x3824342c,\n    0xc2a3405f,\n    0x161dc372,\n    0xbce2250c,\n    0x283c498b,\n    0xff0d9541,\n    0x39a80171,\n    0x080cb3de,\n    0xd8b4e49c,\n    0x6456c190,\n    0x7bcb8461,\n    0xd532b670,\n    0x486c5c74,\n    0xd0b85742\n];\nconst T6 = [\n    0x5051f4a7,\n    0x537e4165,\n    0xc31a17a4,\n    0x963a275e,\n    0xcb3bab6b,\n    0xf11f9d45,\n    0xabacfa58,\n    0x934be303,\n    0x552030fa,\n    0xf6ad766d,\n    0x9188cc76,\n    0x25f5024c,\n    0xfc4fe5d7,\n    0xd7c52acb,\n    0x80263544,\n    0x8fb562a3,\n    0x49deb15a,\n    0x6725ba1b,\n    0x9845ea0e,\n    0xe15dfec0,\n    0x02c32f75,\n    0x12814cf0,\n    0xa38d4697,\n    0xc66bd3f9,\n    0xe7038f5f,\n    0x9515929c,\n    0xebbf6d7a,\n    0xda955259,\n    0x2dd4be83,\n    0xd3587421,\n    0x2949e069,\n    0x448ec9c8,\n    0x6a75c289,\n    0x78f48e79,\n    0x6b99583e,\n    0xdd27b971,\n    0xb6bee14f,\n    0x17f088ad,\n    0x66c920ac,\n    0xb47dce3a,\n    0x1863df4a,\n    0x82e51a31,\n    0x60975133,\n    0x4562537f,\n    0xe0b16477,\n    0x84bb6bae,\n    0x1cfe81a0,\n    0x94f9082b,\n    0x58704868,\n    0x198f45fd,\n    0x8794de6c,\n    0xb7527bf8,\n    0x23ab73d3,\n    0xe2724b02,\n    0x57e31f8f,\n    0x2a6655ab,\n    0x07b2eb28,\n    0x032fb5c2,\n    0x9a86c57b,\n    0xa5d33708,\n    0xf2302887,\n    0xb223bfa5,\n    0xba02036a,\n    0x5ced1682,\n    0x2b8acf1c,\n    0x92a779b4,\n    0xf0f307f2,\n    0xa14e69e2,\n    0xcd65daf4,\n    0xd50605be,\n    0x1fd13462,\n    0x8ac4a6fe,\n    0x9d342e53,\n    0xa0a2f355,\n    0x32058ae1,\n    0x75a4f6eb,\n    0x390b83ec,\n    0xaa4060ef,\n    0x065e719f,\n    0x51bd6e10,\n    0xf93e218a,\n    0x3d96dd06,\n    0xaedd3e05,\n    0x464de6bd,\n    0xb591548d,\n    0x0571c45d,\n    0x6f0406d4,\n    0xff605015,\n    0x241998fb,\n    0x97d6bde9,\n    0xcc894043,\n    0x7767d99e,\n    0xbdb0e842,\n    0x8807898b,\n    0x38e7195b,\n    0xdb79c8ee,\n    0x47a17c0a,\n    0xe97c420f,\n    0xc9f8841e,\n    0x00000000,\n    0x83098086,\n    0x48322bed,\n    0xac1e1170,\n    0x4e6c5a72,\n    0xfbfd0eff,\n    0x560f8538,\n    0x1e3daed5,\n    0x27362d39,\n    0x640a0fd9,\n    0x21685ca6,\n    0xd19b5b54,\n    0x3a24362e,\n    0xb10c0a67,\n    0x0f9357e7,\n    0xd2b4ee96,\n    0x9e1b9b91,\n    0x4f80c0c5,\n    0xa261dc20,\n    0x695a774b,\n    0x161c121a,\n    0x0ae293ba,\n    0xe5c0a02a,\n    0x433c22e0,\n    0x1d121b17,\n    0x0b0e090d,\n    0xadf28bc7,\n    0xb92db6a8,\n    0xc8141ea9,\n    0x8557f119,\n    0x4caf7507,\n    0xbbee99dd,\n    0xfda37f60,\n    0x9ff70126,\n    0xbc5c72f5,\n    0xc544663b,\n    0x345bfb7e,\n    0x768b4329,\n    0xdccb23c6,\n    0x68b6edfc,\n    0x63b8e4f1,\n    0xcad731dc,\n    0x10426385,\n    0x40139722,\n    0x2084c611,\n    0x7d854a24,\n    0xf8d2bb3d,\n    0x11aef932,\n    0x6dc729a1,\n    0x4b1d9e2f,\n    0xf3dcb230,\n    0xec0d8652,\n    0xd077c1e3,\n    0x6c2bb316,\n    0x99a970b9,\n    0xfa119448,\n    0x2247e964,\n    0xc4a8fc8c,\n    0x1aa0f03f,\n    0xd8567d2c,\n    0xef223390,\n    0xc787494e,\n    0xc1d938d1,\n    0xfe8ccaa2,\n    0x3698d40b,\n    0xcfa6f581,\n    0x28a57ade,\n    0x26dab78e,\n    0xa43fadbf,\n    0xe42c3a9d,\n    0x0d507892,\n    0x9b6a5fcc,\n    0x62547e46,\n    0xc2f68d13,\n    0xe890d8b8,\n    0x5e2e39f7,\n    0xf582c3af,\n    0xbe9f5d80,\n    0x7c69d093,\n    0xa96fd52d,\n    0xb3cf2512,\n    0x3bc8ac99,\n    0xa710187d,\n    0x6ee89c63,\n    0x7bdb3bbb,\n    0x09cd2678,\n    0xf46e5918,\n    0x01ec9ab7,\n    0xa8834f9a,\n    0x65e6956e,\n    0x7eaaffe6,\n    0x0821bccf,\n    0xe6ef15e8,\n    0xd9bae79b,\n    0xce4a6f36,\n    0xd4ea9f09,\n    0xd629b07c,\n    0xaf31a4b2,\n    0x312a3f23,\n    0x30c6a594,\n    0xc035a266,\n    0x37744ebc,\n    0xa6fc82ca,\n    0xb0e090d0,\n    0x1533a7d8,\n    0x4af10498,\n    0xf741ecda,\n    0x0e7fcd50,\n    0x2f1791f6,\n    0x8d764dd6,\n    0x4d43efb0,\n    0x54ccaa4d,\n    0xdfe49604,\n    0xe39ed1b5,\n    0x1b4c6a88,\n    0xb8c12c1f,\n    0x7f466551,\n    0x049d5eea,\n    0x5d018c35,\n    0x73fa8774,\n    0x2efb0b41,\n    0x5ab3671d,\n    0x5292dbd2,\n    0x33e91056,\n    0x136dd647,\n    0x8c9ad761,\n    0x7a37a10c,\n    0x8e59f814,\n    0x89eb133c,\n    0xeecea927,\n    0x35b761c9,\n    0xede11ce5,\n    0x3c7a47b1,\n    0x599cd2df,\n    0x3f55f273,\n    0x791814ce,\n    0xbf73c737,\n    0xea53f7cd,\n    0x5b5ffdaa,\n    0x14df3d6f,\n    0x867844db,\n    0x81caaff3,\n    0x3eb968c4,\n    0x2c382434,\n    0x5fc2a340,\n    0x72161dc3,\n    0x0cbce225,\n    0x8b283c49,\n    0x41ff0d95,\n    0x7139a801,\n    0xde080cb3,\n    0x9cd8b4e4,\n    0x906456c1,\n    0x617bcb84,\n    0x70d532b6,\n    0x74486c5c,\n    0x42d0b857\n];\nconst T7 = [\n    0xa75051f4,\n    0x65537e41,\n    0xa4c31a17,\n    0x5e963a27,\n    0x6bcb3bab,\n    0x45f11f9d,\n    0x58abacfa,\n    0x03934be3,\n    0xfa552030,\n    0x6df6ad76,\n    0x769188cc,\n    0x4c25f502,\n    0xd7fc4fe5,\n    0xcbd7c52a,\n    0x44802635,\n    0xa38fb562,\n    0x5a49deb1,\n    0x1b6725ba,\n    0x0e9845ea,\n    0xc0e15dfe,\n    0x7502c32f,\n    0xf012814c,\n    0x97a38d46,\n    0xf9c66bd3,\n    0x5fe7038f,\n    0x9c951592,\n    0x7aebbf6d,\n    0x59da9552,\n    0x832dd4be,\n    0x21d35874,\n    0x692949e0,\n    0xc8448ec9,\n    0x896a75c2,\n    0x7978f48e,\n    0x3e6b9958,\n    0x71dd27b9,\n    0x4fb6bee1,\n    0xad17f088,\n    0xac66c920,\n    0x3ab47dce,\n    0x4a1863df,\n    0x3182e51a,\n    0x33609751,\n    0x7f456253,\n    0x77e0b164,\n    0xae84bb6b,\n    0xa01cfe81,\n    0x2b94f908,\n    0x68587048,\n    0xfd198f45,\n    0x6c8794de,\n    0xf8b7527b,\n    0xd323ab73,\n    0x02e2724b,\n    0x8f57e31f,\n    0xab2a6655,\n    0x2807b2eb,\n    0xc2032fb5,\n    0x7b9a86c5,\n    0x08a5d337,\n    0x87f23028,\n    0xa5b223bf,\n    0x6aba0203,\n    0x825ced16,\n    0x1c2b8acf,\n    0xb492a779,\n    0xf2f0f307,\n    0xe2a14e69,\n    0xf4cd65da,\n    0xbed50605,\n    0x621fd134,\n    0xfe8ac4a6,\n    0x539d342e,\n    0x55a0a2f3,\n    0xe132058a,\n    0xeb75a4f6,\n    0xec390b83,\n    0xefaa4060,\n    0x9f065e71,\n    0x1051bd6e,\n    0x8af93e21,\n    0x063d96dd,\n    0x05aedd3e,\n    0xbd464de6,\n    0x8db59154,\n    0x5d0571c4,\n    0xd46f0406,\n    0x15ff6050,\n    0xfb241998,\n    0xe997d6bd,\n    0x43cc8940,\n    0x9e7767d9,\n    0x42bdb0e8,\n    0x8b880789,\n    0x5b38e719,\n    0xeedb79c8,\n    0x0a47a17c,\n    0x0fe97c42,\n    0x1ec9f884,\n    0x00000000,\n    0x86830980,\n    0xed48322b,\n    0x70ac1e11,\n    0x724e6c5a,\n    0xfffbfd0e,\n    0x38560f85,\n    0xd51e3dae,\n    0x3927362d,\n    0xd9640a0f,\n    0xa621685c,\n    0x54d19b5b,\n    0x2e3a2436,\n    0x67b10c0a,\n    0xe70f9357,\n    0x96d2b4ee,\n    0x919e1b9b,\n    0xc54f80c0,\n    0x20a261dc,\n    0x4b695a77,\n    0x1a161c12,\n    0xba0ae293,\n    0x2ae5c0a0,\n    0xe0433c22,\n    0x171d121b,\n    0x0d0b0e09,\n    0xc7adf28b,\n    0xa8b92db6,\n    0xa9c8141e,\n    0x198557f1,\n    0x074caf75,\n    0xddbbee99,\n    0x60fda37f,\n    0x269ff701,\n    0xf5bc5c72,\n    0x3bc54466,\n    0x7e345bfb,\n    0x29768b43,\n    0xc6dccb23,\n    0xfc68b6ed,\n    0xf163b8e4,\n    0xdccad731,\n    0x85104263,\n    0x22401397,\n    0x112084c6,\n    0x247d854a,\n    0x3df8d2bb,\n    0x3211aef9,\n    0xa16dc729,\n    0x2f4b1d9e,\n    0x30f3dcb2,\n    0x52ec0d86,\n    0xe3d077c1,\n    0x166c2bb3,\n    0xb999a970,\n    0x48fa1194,\n    0x642247e9,\n    0x8cc4a8fc,\n    0x3f1aa0f0,\n    0x2cd8567d,\n    0x90ef2233,\n    0x4ec78749,\n    0xd1c1d938,\n    0xa2fe8cca,\n    0x0b3698d4,\n    0x81cfa6f5,\n    0xde28a57a,\n    0x8e26dab7,\n    0xbfa43fad,\n    0x9de42c3a,\n    0x920d5078,\n    0xcc9b6a5f,\n    0x4662547e,\n    0x13c2f68d,\n    0xb8e890d8,\n    0xf75e2e39,\n    0xaff582c3,\n    0x80be9f5d,\n    0x937c69d0,\n    0x2da96fd5,\n    0x12b3cf25,\n    0x993bc8ac,\n    0x7da71018,\n    0x636ee89c,\n    0xbb7bdb3b,\n    0x7809cd26,\n    0x18f46e59,\n    0xb701ec9a,\n    0x9aa8834f,\n    0x6e65e695,\n    0xe67eaaff,\n    0xcf0821bc,\n    0xe8e6ef15,\n    0x9bd9bae7,\n    0x36ce4a6f,\n    0x09d4ea9f,\n    0x7cd629b0,\n    0xb2af31a4,\n    0x23312a3f,\n    0x9430c6a5,\n    0x66c035a2,\n    0xbc37744e,\n    0xcaa6fc82,\n    0xd0b0e090,\n    0xd81533a7,\n    0x984af104,\n    0xdaf741ec,\n    0x500e7fcd,\n    0xf62f1791,\n    0xd68d764d,\n    0xb04d43ef,\n    0x4d54ccaa,\n    0x04dfe496,\n    0xb5e39ed1,\n    0x881b4c6a,\n    0x1fb8c12c,\n    0x517f4665,\n    0xea049d5e,\n    0x355d018c,\n    0x7473fa87,\n    0x412efb0b,\n    0x1d5ab367,\n    0xd25292db,\n    0x5633e910,\n    0x47136dd6,\n    0x618c9ad7,\n    0x0c7a37a1,\n    0x148e59f8,\n    0x3c89eb13,\n    0x27eecea9,\n    0xc935b761,\n    0xe5ede11c,\n    0xb13c7a47,\n    0xdf599cd2,\n    0x733f55f2,\n    0xce791814,\n    0x37bf73c7,\n    0xcdea53f7,\n    0xaa5b5ffd,\n    0x6f14df3d,\n    0xdb867844,\n    0xf381caaf,\n    0xc43eb968,\n    0x342c3824,\n    0x405fc2a3,\n    0xc372161d,\n    0x250cbce2,\n    0x498b283c,\n    0x9541ff0d,\n    0x017139a8,\n    0xb3de080c,\n    0xe49cd8b4,\n    0xc1906456,\n    0x84617bcb,\n    0xb670d532,\n    0x5c74486c,\n    0x5742d0b8\n];\nconst T8 = [\n    0xf4a75051,\n    0x4165537e,\n    0x17a4c31a,\n    0x275e963a,\n    0xab6bcb3b,\n    0x9d45f11f,\n    0xfa58abac,\n    0xe303934b,\n    0x30fa5520,\n    0x766df6ad,\n    0xcc769188,\n    0x024c25f5,\n    0xe5d7fc4f,\n    0x2acbd7c5,\n    0x35448026,\n    0x62a38fb5,\n    0xb15a49de,\n    0xba1b6725,\n    0xea0e9845,\n    0xfec0e15d,\n    0x2f7502c3,\n    0x4cf01281,\n    0x4697a38d,\n    0xd3f9c66b,\n    0x8f5fe703,\n    0x929c9515,\n    0x6d7aebbf,\n    0x5259da95,\n    0xbe832dd4,\n    0x7421d358,\n    0xe0692949,\n    0xc9c8448e,\n    0xc2896a75,\n    0x8e7978f4,\n    0x583e6b99,\n    0xb971dd27,\n    0xe14fb6be,\n    0x88ad17f0,\n    0x20ac66c9,\n    0xce3ab47d,\n    0xdf4a1863,\n    0x1a3182e5,\n    0x51336097,\n    0x537f4562,\n    0x6477e0b1,\n    0x6bae84bb,\n    0x81a01cfe,\n    0x082b94f9,\n    0x48685870,\n    0x45fd198f,\n    0xde6c8794,\n    0x7bf8b752,\n    0x73d323ab,\n    0x4b02e272,\n    0x1f8f57e3,\n    0x55ab2a66,\n    0xeb2807b2,\n    0xb5c2032f,\n    0xc57b9a86,\n    0x3708a5d3,\n    0x2887f230,\n    0xbfa5b223,\n    0x036aba02,\n    0x16825ced,\n    0xcf1c2b8a,\n    0x79b492a7,\n    0x07f2f0f3,\n    0x69e2a14e,\n    0xdaf4cd65,\n    0x05bed506,\n    0x34621fd1,\n    0xa6fe8ac4,\n    0x2e539d34,\n    0xf355a0a2,\n    0x8ae13205,\n    0xf6eb75a4,\n    0x83ec390b,\n    0x60efaa40,\n    0x719f065e,\n    0x6e1051bd,\n    0x218af93e,\n    0xdd063d96,\n    0x3e05aedd,\n    0xe6bd464d,\n    0x548db591,\n    0xc45d0571,\n    0x06d46f04,\n    0x5015ff60,\n    0x98fb2419,\n    0xbde997d6,\n    0x4043cc89,\n    0xd99e7767,\n    0xe842bdb0,\n    0x898b8807,\n    0x195b38e7,\n    0xc8eedb79,\n    0x7c0a47a1,\n    0x420fe97c,\n    0x841ec9f8,\n    0x00000000,\n    0x80868309,\n    0x2bed4832,\n    0x1170ac1e,\n    0x5a724e6c,\n    0x0efffbfd,\n    0x8538560f,\n    0xaed51e3d,\n    0x2d392736,\n    0x0fd9640a,\n    0x5ca62168,\n    0x5b54d19b,\n    0x362e3a24,\n    0x0a67b10c,\n    0x57e70f93,\n    0xee96d2b4,\n    0x9b919e1b,\n    0xc0c54f80,\n    0xdc20a261,\n    0x774b695a,\n    0x121a161c,\n    0x93ba0ae2,\n    0xa02ae5c0,\n    0x22e0433c,\n    0x1b171d12,\n    0x090d0b0e,\n    0x8bc7adf2,\n    0xb6a8b92d,\n    0x1ea9c814,\n    0xf1198557,\n    0x75074caf,\n    0x99ddbbee,\n    0x7f60fda3,\n    0x01269ff7,\n    0x72f5bc5c,\n    0x663bc544,\n    0xfb7e345b,\n    0x4329768b,\n    0x23c6dccb,\n    0xedfc68b6,\n    0xe4f163b8,\n    0x31dccad7,\n    0x63851042,\n    0x97224013,\n    0xc6112084,\n    0x4a247d85,\n    0xbb3df8d2,\n    0xf93211ae,\n    0x29a16dc7,\n    0x9e2f4b1d,\n    0xb230f3dc,\n    0x8652ec0d,\n    0xc1e3d077,\n    0xb3166c2b,\n    0x70b999a9,\n    0x9448fa11,\n    0xe9642247,\n    0xfc8cc4a8,\n    0xf03f1aa0,\n    0x7d2cd856,\n    0x3390ef22,\n    0x494ec787,\n    0x38d1c1d9,\n    0xcaa2fe8c,\n    0xd40b3698,\n    0xf581cfa6,\n    0x7ade28a5,\n    0xb78e26da,\n    0xadbfa43f,\n    0x3a9de42c,\n    0x78920d50,\n    0x5fcc9b6a,\n    0x7e466254,\n    0x8d13c2f6,\n    0xd8b8e890,\n    0x39f75e2e,\n    0xc3aff582,\n    0x5d80be9f,\n    0xd0937c69,\n    0xd52da96f,\n    0x2512b3cf,\n    0xac993bc8,\n    0x187da710,\n    0x9c636ee8,\n    0x3bbb7bdb,\n    0x267809cd,\n    0x5918f46e,\n    0x9ab701ec,\n    0x4f9aa883,\n    0x956e65e6,\n    0xffe67eaa,\n    0xbccf0821,\n    0x15e8e6ef,\n    0xe79bd9ba,\n    0x6f36ce4a,\n    0x9f09d4ea,\n    0xb07cd629,\n    0xa4b2af31,\n    0x3f23312a,\n    0xa59430c6,\n    0xa266c035,\n    0x4ebc3774,\n    0x82caa6fc,\n    0x90d0b0e0,\n    0xa7d81533,\n    0x04984af1,\n    0xecdaf741,\n    0xcd500e7f,\n    0x91f62f17,\n    0x4dd68d76,\n    0xefb04d43,\n    0xaa4d54cc,\n    0x9604dfe4,\n    0xd1b5e39e,\n    0x6a881b4c,\n    0x2c1fb8c1,\n    0x65517f46,\n    0x5eea049d,\n    0x8c355d01,\n    0x877473fa,\n    0x0b412efb,\n    0x671d5ab3,\n    0xdbd25292,\n    0x105633e9,\n    0xd647136d,\n    0xd7618c9a,\n    0xa10c7a37,\n    0xf8148e59,\n    0x133c89eb,\n    0xa927eece,\n    0x61c935b7,\n    0x1ce5ede1,\n    0x47b13c7a,\n    0xd2df599c,\n    0xf2733f55,\n    0x14ce7918,\n    0xc737bf73,\n    0xf7cdea53,\n    0xfdaa5b5f,\n    0x3d6f14df,\n    0x44db8678,\n    0xaff381ca,\n    0x68c43eb9,\n    0x24342c38,\n    0xa3405fc2,\n    0x1dc37216,\n    0xe2250cbc,\n    0x3c498b28,\n    0x0d9541ff,\n    0xa8017139,\n    0x0cb3de08,\n    0xb4e49cd8,\n    0x56c19064,\n    0xcb84617b,\n    0x32b670d5,\n    0x6c5c7448,\n    0xb85742d0\n];\n// Transformations for decryption key expansion\nconst U1 = [\n    0x00000000,\n    0x0e090d0b,\n    0x1c121a16,\n    0x121b171d,\n    0x3824342c,\n    0x362d3927,\n    0x24362e3a,\n    0x2a3f2331,\n    0x70486858,\n    0x7e416553,\n    0x6c5a724e,\n    0x62537f45,\n    0x486c5c74,\n    0x4665517f,\n    0x547e4662,\n    0x5a774b69,\n    0xe090d0b0,\n    0xee99ddbb,\n    0xfc82caa6,\n    0xf28bc7ad,\n    0xd8b4e49c,\n    0xd6bde997,\n    0xc4a6fe8a,\n    0xcaaff381,\n    0x90d8b8e8,\n    0x9ed1b5e3,\n    0x8ccaa2fe,\n    0x82c3aff5,\n    0xa8fc8cc4,\n    0xa6f581cf,\n    0xb4ee96d2,\n    0xbae79bd9,\n    0xdb3bbb7b,\n    0xd532b670,\n    0xc729a16d,\n    0xc920ac66,\n    0xe31f8f57,\n    0xed16825c,\n    0xff0d9541,\n    0xf104984a,\n    0xab73d323,\n    0xa57ade28,\n    0xb761c935,\n    0xb968c43e,\n    0x9357e70f,\n    0x9d5eea04,\n    0x8f45fd19,\n    0x814cf012,\n    0x3bab6bcb,\n    0x35a266c0,\n    0x27b971dd,\n    0x29b07cd6,\n    0x038f5fe7,\n    0x0d8652ec,\n    0x1f9d45f1,\n    0x119448fa,\n    0x4be30393,\n    0x45ea0e98,\n    0x57f11985,\n    0x59f8148e,\n    0x73c737bf,\n    0x7dce3ab4,\n    0x6fd52da9,\n    0x61dc20a2,\n    0xad766df6,\n    0xa37f60fd,\n    0xb16477e0,\n    0xbf6d7aeb,\n    0x955259da,\n    0x9b5b54d1,\n    0x894043cc,\n    0x87494ec7,\n    0xdd3e05ae,\n    0xd33708a5,\n    0xc12c1fb8,\n    0xcf2512b3,\n    0xe51a3182,\n    0xeb133c89,\n    0xf9082b94,\n    0xf701269f,\n    0x4de6bd46,\n    0x43efb04d,\n    0x51f4a750,\n    0x5ffdaa5b,\n    0x75c2896a,\n    0x7bcb8461,\n    0x69d0937c,\n    0x67d99e77,\n    0x3daed51e,\n    0x33a7d815,\n    0x21bccf08,\n    0x2fb5c203,\n    0x058ae132,\n    0x0b83ec39,\n    0x1998fb24,\n    0x1791f62f,\n    0x764dd68d,\n    0x7844db86,\n    0x6a5fcc9b,\n    0x6456c190,\n    0x4e69e2a1,\n    0x4060efaa,\n    0x527bf8b7,\n    0x5c72f5bc,\n    0x0605bed5,\n    0x080cb3de,\n    0x1a17a4c3,\n    0x141ea9c8,\n    0x3e218af9,\n    0x302887f2,\n    0x223390ef,\n    0x2c3a9de4,\n    0x96dd063d,\n    0x98d40b36,\n    0x8acf1c2b,\n    0x84c61120,\n    0xaef93211,\n    0xa0f03f1a,\n    0xb2eb2807,\n    0xbce2250c,\n    0xe6956e65,\n    0xe89c636e,\n    0xfa877473,\n    0xf48e7978,\n    0xdeb15a49,\n    0xd0b85742,\n    0xc2a3405f,\n    0xccaa4d54,\n    0x41ecdaf7,\n    0x4fe5d7fc,\n    0x5dfec0e1,\n    0x53f7cdea,\n    0x79c8eedb,\n    0x77c1e3d0,\n    0x65daf4cd,\n    0x6bd3f9c6,\n    0x31a4b2af,\n    0x3fadbfa4,\n    0x2db6a8b9,\n    0x23bfa5b2,\n    0x09808683,\n    0x07898b88,\n    0x15929c95,\n    0x1b9b919e,\n    0xa17c0a47,\n    0xaf75074c,\n    0xbd6e1051,\n    0xb3671d5a,\n    0x99583e6b,\n    0x97513360,\n    0x854a247d,\n    0x8b432976,\n    0xd134621f,\n    0xdf3d6f14,\n    0xcd267809,\n    0xc32f7502,\n    0xe9105633,\n    0xe7195b38,\n    0xf5024c25,\n    0xfb0b412e,\n    0x9ad7618c,\n    0x94de6c87,\n    0x86c57b9a,\n    0x88cc7691,\n    0xa2f355a0,\n    0xacfa58ab,\n    0xbee14fb6,\n    0xb0e842bd,\n    0xea9f09d4,\n    0xe49604df,\n    0xf68d13c2,\n    0xf8841ec9,\n    0xd2bb3df8,\n    0xdcb230f3,\n    0xcea927ee,\n    0xc0a02ae5,\n    0x7a47b13c,\n    0x744ebc37,\n    0x6655ab2a,\n    0x685ca621,\n    0x42638510,\n    0x4c6a881b,\n    0x5e719f06,\n    0x5078920d,\n    0x0a0fd964,\n    0x0406d46f,\n    0x161dc372,\n    0x1814ce79,\n    0x322bed48,\n    0x3c22e043,\n    0x2e39f75e,\n    0x2030fa55,\n    0xec9ab701,\n    0xe293ba0a,\n    0xf088ad17,\n    0xfe81a01c,\n    0xd4be832d,\n    0xdab78e26,\n    0xc8ac993b,\n    0xc6a59430,\n    0x9cd2df59,\n    0x92dbd252,\n    0x80c0c54f,\n    0x8ec9c844,\n    0xa4f6eb75,\n    0xaaffe67e,\n    0xb8e4f163,\n    0xb6edfc68,\n    0x0c0a67b1,\n    0x02036aba,\n    0x10187da7,\n    0x1e1170ac,\n    0x342e539d,\n    0x3a275e96,\n    0x283c498b,\n    0x26354480,\n    0x7c420fe9,\n    0x724b02e2,\n    0x605015ff,\n    0x6e5918f4,\n    0x44663bc5,\n    0x4a6f36ce,\n    0x587421d3,\n    0x567d2cd8,\n    0x37a10c7a,\n    0x39a80171,\n    0x2bb3166c,\n    0x25ba1b67,\n    0x0f853856,\n    0x018c355d,\n    0x13972240,\n    0x1d9e2f4b,\n    0x47e96422,\n    0x49e06929,\n    0x5bfb7e34,\n    0x55f2733f,\n    0x7fcd500e,\n    0x71c45d05,\n    0x63df4a18,\n    0x6dd64713,\n    0xd731dcca,\n    0xd938d1c1,\n    0xcb23c6dc,\n    0xc52acbd7,\n    0xef15e8e6,\n    0xe11ce5ed,\n    0xf307f2f0,\n    0xfd0efffb,\n    0xa779b492,\n    0xa970b999,\n    0xbb6bae84,\n    0xb562a38f,\n    0x9f5d80be,\n    0x91548db5,\n    0x834f9aa8,\n    0x8d4697a3\n];\nconst U2 = [\n    0x00000000,\n    0x0b0e090d,\n    0x161c121a,\n    0x1d121b17,\n    0x2c382434,\n    0x27362d39,\n    0x3a24362e,\n    0x312a3f23,\n    0x58704868,\n    0x537e4165,\n    0x4e6c5a72,\n    0x4562537f,\n    0x74486c5c,\n    0x7f466551,\n    0x62547e46,\n    0x695a774b,\n    0xb0e090d0,\n    0xbbee99dd,\n    0xa6fc82ca,\n    0xadf28bc7,\n    0x9cd8b4e4,\n    0x97d6bde9,\n    0x8ac4a6fe,\n    0x81caaff3,\n    0xe890d8b8,\n    0xe39ed1b5,\n    0xfe8ccaa2,\n    0xf582c3af,\n    0xc4a8fc8c,\n    0xcfa6f581,\n    0xd2b4ee96,\n    0xd9bae79b,\n    0x7bdb3bbb,\n    0x70d532b6,\n    0x6dc729a1,\n    0x66c920ac,\n    0x57e31f8f,\n    0x5ced1682,\n    0x41ff0d95,\n    0x4af10498,\n    0x23ab73d3,\n    0x28a57ade,\n    0x35b761c9,\n    0x3eb968c4,\n    0x0f9357e7,\n    0x049d5eea,\n    0x198f45fd,\n    0x12814cf0,\n    0xcb3bab6b,\n    0xc035a266,\n    0xdd27b971,\n    0xd629b07c,\n    0xe7038f5f,\n    0xec0d8652,\n    0xf11f9d45,\n    0xfa119448,\n    0x934be303,\n    0x9845ea0e,\n    0x8557f119,\n    0x8e59f814,\n    0xbf73c737,\n    0xb47dce3a,\n    0xa96fd52d,\n    0xa261dc20,\n    0xf6ad766d,\n    0xfda37f60,\n    0xe0b16477,\n    0xebbf6d7a,\n    0xda955259,\n    0xd19b5b54,\n    0xcc894043,\n    0xc787494e,\n    0xaedd3e05,\n    0xa5d33708,\n    0xb8c12c1f,\n    0xb3cf2512,\n    0x82e51a31,\n    0x89eb133c,\n    0x94f9082b,\n    0x9ff70126,\n    0x464de6bd,\n    0x4d43efb0,\n    0x5051f4a7,\n    0x5b5ffdaa,\n    0x6a75c289,\n    0x617bcb84,\n    0x7c69d093,\n    0x7767d99e,\n    0x1e3daed5,\n    0x1533a7d8,\n    0x0821bccf,\n    0x032fb5c2,\n    0x32058ae1,\n    0x390b83ec,\n    0x241998fb,\n    0x2f1791f6,\n    0x8d764dd6,\n    0x867844db,\n    0x9b6a5fcc,\n    0x906456c1,\n    0xa14e69e2,\n    0xaa4060ef,\n    0xb7527bf8,\n    0xbc5c72f5,\n    0xd50605be,\n    0xde080cb3,\n    0xc31a17a4,\n    0xc8141ea9,\n    0xf93e218a,\n    0xf2302887,\n    0xef223390,\n    0xe42c3a9d,\n    0x3d96dd06,\n    0x3698d40b,\n    0x2b8acf1c,\n    0x2084c611,\n    0x11aef932,\n    0x1aa0f03f,\n    0x07b2eb28,\n    0x0cbce225,\n    0x65e6956e,\n    0x6ee89c63,\n    0x73fa8774,\n    0x78f48e79,\n    0x49deb15a,\n    0x42d0b857,\n    0x5fc2a340,\n    0x54ccaa4d,\n    0xf741ecda,\n    0xfc4fe5d7,\n    0xe15dfec0,\n    0xea53f7cd,\n    0xdb79c8ee,\n    0xd077c1e3,\n    0xcd65daf4,\n    0xc66bd3f9,\n    0xaf31a4b2,\n    0xa43fadbf,\n    0xb92db6a8,\n    0xb223bfa5,\n    0x83098086,\n    0x8807898b,\n    0x9515929c,\n    0x9e1b9b91,\n    0x47a17c0a,\n    0x4caf7507,\n    0x51bd6e10,\n    0x5ab3671d,\n    0x6b99583e,\n    0x60975133,\n    0x7d854a24,\n    0x768b4329,\n    0x1fd13462,\n    0x14df3d6f,\n    0x09cd2678,\n    0x02c32f75,\n    0x33e91056,\n    0x38e7195b,\n    0x25f5024c,\n    0x2efb0b41,\n    0x8c9ad761,\n    0x8794de6c,\n    0x9a86c57b,\n    0x9188cc76,\n    0xa0a2f355,\n    0xabacfa58,\n    0xb6bee14f,\n    0xbdb0e842,\n    0xd4ea9f09,\n    0xdfe49604,\n    0xc2f68d13,\n    0xc9f8841e,\n    0xf8d2bb3d,\n    0xf3dcb230,\n    0xeecea927,\n    0xe5c0a02a,\n    0x3c7a47b1,\n    0x37744ebc,\n    0x2a6655ab,\n    0x21685ca6,\n    0x10426385,\n    0x1b4c6a88,\n    0x065e719f,\n    0x0d507892,\n    0x640a0fd9,\n    0x6f0406d4,\n    0x72161dc3,\n    0x791814ce,\n    0x48322bed,\n    0x433c22e0,\n    0x5e2e39f7,\n    0x552030fa,\n    0x01ec9ab7,\n    0x0ae293ba,\n    0x17f088ad,\n    0x1cfe81a0,\n    0x2dd4be83,\n    0x26dab78e,\n    0x3bc8ac99,\n    0x30c6a594,\n    0x599cd2df,\n    0x5292dbd2,\n    0x4f80c0c5,\n    0x448ec9c8,\n    0x75a4f6eb,\n    0x7eaaffe6,\n    0x63b8e4f1,\n    0x68b6edfc,\n    0xb10c0a67,\n    0xba02036a,\n    0xa710187d,\n    0xac1e1170,\n    0x9d342e53,\n    0x963a275e,\n    0x8b283c49,\n    0x80263544,\n    0xe97c420f,\n    0xe2724b02,\n    0xff605015,\n    0xf46e5918,\n    0xc544663b,\n    0xce4a6f36,\n    0xd3587421,\n    0xd8567d2c,\n    0x7a37a10c,\n    0x7139a801,\n    0x6c2bb316,\n    0x6725ba1b,\n    0x560f8538,\n    0x5d018c35,\n    0x40139722,\n    0x4b1d9e2f,\n    0x2247e964,\n    0x2949e069,\n    0x345bfb7e,\n    0x3f55f273,\n    0x0e7fcd50,\n    0x0571c45d,\n    0x1863df4a,\n    0x136dd647,\n    0xcad731dc,\n    0xc1d938d1,\n    0xdccb23c6,\n    0xd7c52acb,\n    0xe6ef15e8,\n    0xede11ce5,\n    0xf0f307f2,\n    0xfbfd0eff,\n    0x92a779b4,\n    0x99a970b9,\n    0x84bb6bae,\n    0x8fb562a3,\n    0xbe9f5d80,\n    0xb591548d,\n    0xa8834f9a,\n    0xa38d4697\n];\nconst U3 = [\n    0x00000000,\n    0x0d0b0e09,\n    0x1a161c12,\n    0x171d121b,\n    0x342c3824,\n    0x3927362d,\n    0x2e3a2436,\n    0x23312a3f,\n    0x68587048,\n    0x65537e41,\n    0x724e6c5a,\n    0x7f456253,\n    0x5c74486c,\n    0x517f4665,\n    0x4662547e,\n    0x4b695a77,\n    0xd0b0e090,\n    0xddbbee99,\n    0xcaa6fc82,\n    0xc7adf28b,\n    0xe49cd8b4,\n    0xe997d6bd,\n    0xfe8ac4a6,\n    0xf381caaf,\n    0xb8e890d8,\n    0xb5e39ed1,\n    0xa2fe8cca,\n    0xaff582c3,\n    0x8cc4a8fc,\n    0x81cfa6f5,\n    0x96d2b4ee,\n    0x9bd9bae7,\n    0xbb7bdb3b,\n    0xb670d532,\n    0xa16dc729,\n    0xac66c920,\n    0x8f57e31f,\n    0x825ced16,\n    0x9541ff0d,\n    0x984af104,\n    0xd323ab73,\n    0xde28a57a,\n    0xc935b761,\n    0xc43eb968,\n    0xe70f9357,\n    0xea049d5e,\n    0xfd198f45,\n    0xf012814c,\n    0x6bcb3bab,\n    0x66c035a2,\n    0x71dd27b9,\n    0x7cd629b0,\n    0x5fe7038f,\n    0x52ec0d86,\n    0x45f11f9d,\n    0x48fa1194,\n    0x03934be3,\n    0x0e9845ea,\n    0x198557f1,\n    0x148e59f8,\n    0x37bf73c7,\n    0x3ab47dce,\n    0x2da96fd5,\n    0x20a261dc,\n    0x6df6ad76,\n    0x60fda37f,\n    0x77e0b164,\n    0x7aebbf6d,\n    0x59da9552,\n    0x54d19b5b,\n    0x43cc8940,\n    0x4ec78749,\n    0x05aedd3e,\n    0x08a5d337,\n    0x1fb8c12c,\n    0x12b3cf25,\n    0x3182e51a,\n    0x3c89eb13,\n    0x2b94f908,\n    0x269ff701,\n    0xbd464de6,\n    0xb04d43ef,\n    0xa75051f4,\n    0xaa5b5ffd,\n    0x896a75c2,\n    0x84617bcb,\n    0x937c69d0,\n    0x9e7767d9,\n    0xd51e3dae,\n    0xd81533a7,\n    0xcf0821bc,\n    0xc2032fb5,\n    0xe132058a,\n    0xec390b83,\n    0xfb241998,\n    0xf62f1791,\n    0xd68d764d,\n    0xdb867844,\n    0xcc9b6a5f,\n    0xc1906456,\n    0xe2a14e69,\n    0xefaa4060,\n    0xf8b7527b,\n    0xf5bc5c72,\n    0xbed50605,\n    0xb3de080c,\n    0xa4c31a17,\n    0xa9c8141e,\n    0x8af93e21,\n    0x87f23028,\n    0x90ef2233,\n    0x9de42c3a,\n    0x063d96dd,\n    0x0b3698d4,\n    0x1c2b8acf,\n    0x112084c6,\n    0x3211aef9,\n    0x3f1aa0f0,\n    0x2807b2eb,\n    0x250cbce2,\n    0x6e65e695,\n    0x636ee89c,\n    0x7473fa87,\n    0x7978f48e,\n    0x5a49deb1,\n    0x5742d0b8,\n    0x405fc2a3,\n    0x4d54ccaa,\n    0xdaf741ec,\n    0xd7fc4fe5,\n    0xc0e15dfe,\n    0xcdea53f7,\n    0xeedb79c8,\n    0xe3d077c1,\n    0xf4cd65da,\n    0xf9c66bd3,\n    0xb2af31a4,\n    0xbfa43fad,\n    0xa8b92db6,\n    0xa5b223bf,\n    0x86830980,\n    0x8b880789,\n    0x9c951592,\n    0x919e1b9b,\n    0x0a47a17c,\n    0x074caf75,\n    0x1051bd6e,\n    0x1d5ab367,\n    0x3e6b9958,\n    0x33609751,\n    0x247d854a,\n    0x29768b43,\n    0x621fd134,\n    0x6f14df3d,\n    0x7809cd26,\n    0x7502c32f,\n    0x5633e910,\n    0x5b38e719,\n    0x4c25f502,\n    0x412efb0b,\n    0x618c9ad7,\n    0x6c8794de,\n    0x7b9a86c5,\n    0x769188cc,\n    0x55a0a2f3,\n    0x58abacfa,\n    0x4fb6bee1,\n    0x42bdb0e8,\n    0x09d4ea9f,\n    0x04dfe496,\n    0x13c2f68d,\n    0x1ec9f884,\n    0x3df8d2bb,\n    0x30f3dcb2,\n    0x27eecea9,\n    0x2ae5c0a0,\n    0xb13c7a47,\n    0xbc37744e,\n    0xab2a6655,\n    0xa621685c,\n    0x85104263,\n    0x881b4c6a,\n    0x9f065e71,\n    0x920d5078,\n    0xd9640a0f,\n    0xd46f0406,\n    0xc372161d,\n    0xce791814,\n    0xed48322b,\n    0xe0433c22,\n    0xf75e2e39,\n    0xfa552030,\n    0xb701ec9a,\n    0xba0ae293,\n    0xad17f088,\n    0xa01cfe81,\n    0x832dd4be,\n    0x8e26dab7,\n    0x993bc8ac,\n    0x9430c6a5,\n    0xdf599cd2,\n    0xd25292db,\n    0xc54f80c0,\n    0xc8448ec9,\n    0xeb75a4f6,\n    0xe67eaaff,\n    0xf163b8e4,\n    0xfc68b6ed,\n    0x67b10c0a,\n    0x6aba0203,\n    0x7da71018,\n    0x70ac1e11,\n    0x539d342e,\n    0x5e963a27,\n    0x498b283c,\n    0x44802635,\n    0x0fe97c42,\n    0x02e2724b,\n    0x15ff6050,\n    0x18f46e59,\n    0x3bc54466,\n    0x36ce4a6f,\n    0x21d35874,\n    0x2cd8567d,\n    0x0c7a37a1,\n    0x017139a8,\n    0x166c2bb3,\n    0x1b6725ba,\n    0x38560f85,\n    0x355d018c,\n    0x22401397,\n    0x2f4b1d9e,\n    0x642247e9,\n    0x692949e0,\n    0x7e345bfb,\n    0x733f55f2,\n    0x500e7fcd,\n    0x5d0571c4,\n    0x4a1863df,\n    0x47136dd6,\n    0xdccad731,\n    0xd1c1d938,\n    0xc6dccb23,\n    0xcbd7c52a,\n    0xe8e6ef15,\n    0xe5ede11c,\n    0xf2f0f307,\n    0xfffbfd0e,\n    0xb492a779,\n    0xb999a970,\n    0xae84bb6b,\n    0xa38fb562,\n    0x80be9f5d,\n    0x8db59154,\n    0x9aa8834f,\n    0x97a38d46\n];\nconst U4 = [\n    0x00000000,\n    0x090d0b0e,\n    0x121a161c,\n    0x1b171d12,\n    0x24342c38,\n    0x2d392736,\n    0x362e3a24,\n    0x3f23312a,\n    0x48685870,\n    0x4165537e,\n    0x5a724e6c,\n    0x537f4562,\n    0x6c5c7448,\n    0x65517f46,\n    0x7e466254,\n    0x774b695a,\n    0x90d0b0e0,\n    0x99ddbbee,\n    0x82caa6fc,\n    0x8bc7adf2,\n    0xb4e49cd8,\n    0xbde997d6,\n    0xa6fe8ac4,\n    0xaff381ca,\n    0xd8b8e890,\n    0xd1b5e39e,\n    0xcaa2fe8c,\n    0xc3aff582,\n    0xfc8cc4a8,\n    0xf581cfa6,\n    0xee96d2b4,\n    0xe79bd9ba,\n    0x3bbb7bdb,\n    0x32b670d5,\n    0x29a16dc7,\n    0x20ac66c9,\n    0x1f8f57e3,\n    0x16825ced,\n    0x0d9541ff,\n    0x04984af1,\n    0x73d323ab,\n    0x7ade28a5,\n    0x61c935b7,\n    0x68c43eb9,\n    0x57e70f93,\n    0x5eea049d,\n    0x45fd198f,\n    0x4cf01281,\n    0xab6bcb3b,\n    0xa266c035,\n    0xb971dd27,\n    0xb07cd629,\n    0x8f5fe703,\n    0x8652ec0d,\n    0x9d45f11f,\n    0x9448fa11,\n    0xe303934b,\n    0xea0e9845,\n    0xf1198557,\n    0xf8148e59,\n    0xc737bf73,\n    0xce3ab47d,\n    0xd52da96f,\n    0xdc20a261,\n    0x766df6ad,\n    0x7f60fda3,\n    0x6477e0b1,\n    0x6d7aebbf,\n    0x5259da95,\n    0x5b54d19b,\n    0x4043cc89,\n    0x494ec787,\n    0x3e05aedd,\n    0x3708a5d3,\n    0x2c1fb8c1,\n    0x2512b3cf,\n    0x1a3182e5,\n    0x133c89eb,\n    0x082b94f9,\n    0x01269ff7,\n    0xe6bd464d,\n    0xefb04d43,\n    0xf4a75051,\n    0xfdaa5b5f,\n    0xc2896a75,\n    0xcb84617b,\n    0xd0937c69,\n    0xd99e7767,\n    0xaed51e3d,\n    0xa7d81533,\n    0xbccf0821,\n    0xb5c2032f,\n    0x8ae13205,\n    0x83ec390b,\n    0x98fb2419,\n    0x91f62f17,\n    0x4dd68d76,\n    0x44db8678,\n    0x5fcc9b6a,\n    0x56c19064,\n    0x69e2a14e,\n    0x60efaa40,\n    0x7bf8b752,\n    0x72f5bc5c,\n    0x05bed506,\n    0x0cb3de08,\n    0x17a4c31a,\n    0x1ea9c814,\n    0x218af93e,\n    0x2887f230,\n    0x3390ef22,\n    0x3a9de42c,\n    0xdd063d96,\n    0xd40b3698,\n    0xcf1c2b8a,\n    0xc6112084,\n    0xf93211ae,\n    0xf03f1aa0,\n    0xeb2807b2,\n    0xe2250cbc,\n    0x956e65e6,\n    0x9c636ee8,\n    0x877473fa,\n    0x8e7978f4,\n    0xb15a49de,\n    0xb85742d0,\n    0xa3405fc2,\n    0xaa4d54cc,\n    0xecdaf741,\n    0xe5d7fc4f,\n    0xfec0e15d,\n    0xf7cdea53,\n    0xc8eedb79,\n    0xc1e3d077,\n    0xdaf4cd65,\n    0xd3f9c66b,\n    0xa4b2af31,\n    0xadbfa43f,\n    0xb6a8b92d,\n    0xbfa5b223,\n    0x80868309,\n    0x898b8807,\n    0x929c9515,\n    0x9b919e1b,\n    0x7c0a47a1,\n    0x75074caf,\n    0x6e1051bd,\n    0x671d5ab3,\n    0x583e6b99,\n    0x51336097,\n    0x4a247d85,\n    0x4329768b,\n    0x34621fd1,\n    0x3d6f14df,\n    0x267809cd,\n    0x2f7502c3,\n    0x105633e9,\n    0x195b38e7,\n    0x024c25f5,\n    0x0b412efb,\n    0xd7618c9a,\n    0xde6c8794,\n    0xc57b9a86,\n    0xcc769188,\n    0xf355a0a2,\n    0xfa58abac,\n    0xe14fb6be,\n    0xe842bdb0,\n    0x9f09d4ea,\n    0x9604dfe4,\n    0x8d13c2f6,\n    0x841ec9f8,\n    0xbb3df8d2,\n    0xb230f3dc,\n    0xa927eece,\n    0xa02ae5c0,\n    0x47b13c7a,\n    0x4ebc3774,\n    0x55ab2a66,\n    0x5ca62168,\n    0x63851042,\n    0x6a881b4c,\n    0x719f065e,\n    0x78920d50,\n    0x0fd9640a,\n    0x06d46f04,\n    0x1dc37216,\n    0x14ce7918,\n    0x2bed4832,\n    0x22e0433c,\n    0x39f75e2e,\n    0x30fa5520,\n    0x9ab701ec,\n    0x93ba0ae2,\n    0x88ad17f0,\n    0x81a01cfe,\n    0xbe832dd4,\n    0xb78e26da,\n    0xac993bc8,\n    0xa59430c6,\n    0xd2df599c,\n    0xdbd25292,\n    0xc0c54f80,\n    0xc9c8448e,\n    0xf6eb75a4,\n    0xffe67eaa,\n    0xe4f163b8,\n    0xedfc68b6,\n    0x0a67b10c,\n    0x036aba02,\n    0x187da710,\n    0x1170ac1e,\n    0x2e539d34,\n    0x275e963a,\n    0x3c498b28,\n    0x35448026,\n    0x420fe97c,\n    0x4b02e272,\n    0x5015ff60,\n    0x5918f46e,\n    0x663bc544,\n    0x6f36ce4a,\n    0x7421d358,\n    0x7d2cd856,\n    0xa10c7a37,\n    0xa8017139,\n    0xb3166c2b,\n    0xba1b6725,\n    0x8538560f,\n    0x8c355d01,\n    0x97224013,\n    0x9e2f4b1d,\n    0xe9642247,\n    0xe0692949,\n    0xfb7e345b,\n    0xf2733f55,\n    0xcd500e7f,\n    0xc45d0571,\n    0xdf4a1863,\n    0xd647136d,\n    0x31dccad7,\n    0x38d1c1d9,\n    0x23c6dccb,\n    0x2acbd7c5,\n    0x15e8e6ef,\n    0x1ce5ede1,\n    0x07f2f0f3,\n    0x0efffbfd,\n    0x79b492a7,\n    0x70b999a9,\n    0x6bae84bb,\n    0x62a38fb5,\n    0x5d80be9f,\n    0x548db591,\n    0x4f9aa883,\n    0x4697a38d\n];\nfunction convertToInt32(bytes) {\n    const result = [];\n    for(let i = 0; i < bytes.length; i += 4){\n        result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);\n    }\n    return result;\n}\nclass AES {\n    get key() {\n        return __classPrivateFieldGet(this, _AES_key, \"f\").slice();\n    }\n    constructor(key){\n        _AES_key.set(this, void 0);\n        _AES_Kd.set(this, void 0);\n        _AES_Ke.set(this, void 0);\n        if (!(this instanceof AES)) {\n            throw Error(\"AES must be instanitated with `new`\");\n        }\n        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), \"f\");\n        const rounds = numberOfRounds[this.key.length];\n        if (rounds == null) {\n            throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\");\n        }\n        // encryption round keys\n        __classPrivateFieldSet(this, _AES_Ke, [], \"f\");\n        // decryption round keys\n        __classPrivateFieldSet(this, _AES_Kd, [], \"f\");\n        for(let i = 0; i <= rounds; i++){\n            __classPrivateFieldGet(this, _AES_Ke, \"f\").push([\n                0,\n                0,\n                0,\n                0\n            ]);\n            __classPrivateFieldGet(this, _AES_Kd, \"f\").push([\n                0,\n                0,\n                0,\n                0\n            ]);\n        }\n        const roundKeyCount = (rounds + 1) * 4;\n        const KC = this.key.length / 4;\n        // convert the key into ints\n        const tk = convertToInt32(this.key);\n        // copy values into round key arrays\n        let index;\n        for(let i = 0; i < KC; i++){\n            index = i >> 2;\n            __classPrivateFieldGet(this, _AES_Ke, \"f\")[index][i % 4] = tk[i];\n            __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - index][i % 4] = tk[i];\n        }\n        // key expansion (fips-197 section 5.2)\n        let rconpointer = 0;\n        let t = KC, tt;\n        while(t < roundKeyCount){\n            tt = tk[KC - 1];\n            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;\n            rconpointer += 1;\n            // key expansion (for non-256 bit)\n            if (KC != 8) {\n                for(let i = 1; i < KC; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n            // key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            } else {\n                for(let i = 1; i < KC / 2; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n                tt = tk[KC / 2 - 1];\n                tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;\n                for(let i = KC / 2 + 1; i < KC; i++){\n                    tk[i] ^= tk[i - 1];\n                }\n            }\n            // copy values into round key arrays\n            let i = 0, r, c;\n            while(i < KC && t < roundKeyCount){\n                r = t >> 2;\n                c = t % 4;\n                __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][c] = tk[i];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds - r][c] = tk[i++];\n                t++;\n            }\n        }\n        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for(let r = 1; r < rounds; r++){\n            for(let c = 0; c < 4; c++){\n                tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c];\n                __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];\n            }\n        }\n    }\n    encrypt(plaintext) {\n        if (plaintext.length != 16) {\n            throw new TypeError(\"invalid plaintext size (must be 16 bytes)\");\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Ke, \"f\").length - 1;\n        const a = [\n            0,\n            0,\n            0,\n            0\n        ];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(plaintext);\n        for(let i = 0; i < 4; i++){\n            t[i] ^= __classPrivateFieldGet(this, _AES_Ke, \"f\")[0][i];\n        }\n        // apply round transforms\n        for(let r = 1; r < rounds; r++){\n            for(let i = 0; i < 4; i++){\n                a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Ke, \"f\")[r][i];\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for(let i = 0; i < 4; i++){\n            tt = __classPrivateFieldGet(this, _AES_Ke, \"f\")[rounds][i];\n            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length != 16) {\n            throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\");\n        }\n        const rounds = __classPrivateFieldGet(this, _AES_Kd, \"f\").length - 1;\n        const a = [\n            0,\n            0,\n            0,\n            0\n        ];\n        // convert plaintext to (ints ^ key)\n        let t = convertToInt32(ciphertext);\n        for(let i = 0; i < 4; i++){\n            t[i] ^= __classPrivateFieldGet(this, _AES_Kd, \"f\")[0][i];\n        }\n        // apply round transforms\n        for(let r = 1; r < rounds; r++){\n            for(let i = 0; i < 4; i++){\n                a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Kd, \"f\")[r][i];\n            }\n            t = a.slice();\n        }\n        // the last round is special\n        const result = new Uint8Array(16);\n        let tt = 0;\n        for(let i = 0; i < 4; i++){\n            tt = __classPrivateFieldGet(this, _AES_Kd, \"f\")[rounds][i];\n            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;\n            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;\n            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;\n        }\n        return result;\n    }\n}\nexports.AES = AES;\n_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap(); //# sourceMappingURL=aes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2Flcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHFGQUFxRixHQUNyRixJQUFJQSx5QkFBeUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ04sWUFBWUcsSUFBSUEsRUFBRUksS0FBSyxHQUFHTixNQUFNTyxHQUFHLENBQUNSO0FBQ3hGO0FBQ0EsSUFBSVMseUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVNLEtBQUssRUFBRUwsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPLFNBQVUsTUFBTUQsRUFBRUcsSUFBSSxDQUFDTixVQUFVTyxTQUFTSixJQUFJQSxFQUFFSSxLQUFLLEdBQUdBLFFBQVFOLE1BQU1TLEdBQUcsQ0FBQ1YsVUFBVU8sUUFBU0E7QUFDeEc7QUFDQSxJQUFJSSxVQUFVQyxTQUFTQztBQUN2QkMsOENBQTZDO0lBQUVQLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RTLFdBQVcsR0FBRyxLQUFLO0FBQ25CLDhCQUE4QjtBQUM5QixNQUFNRSxpQkFBaUI7SUFBRSxJQUFJO0lBQUksSUFBSTtJQUFJLElBQUk7QUFBRztBQUNoRCx1QkFBdUI7QUFDdkIsTUFBTUMsT0FBTztJQUFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ2pNLGtEQUFrRDtBQUNsRCxNQUFNQyxJQUFJO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBSztBQUMxZ0QsTUFBTUMsS0FBSztJQUFDO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDM2dELGlDQUFpQztBQUNqQyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csaUNBQWlDO0FBQ2pDLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRywrQ0FBK0M7QUFDL0MsTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQVc7QUFDM2dHLE1BQU1DLEtBQUs7SUFBQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUFXO0FBQzNnRyxNQUFNQyxLQUFLO0lBQUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FBVztBQUMzZ0csTUFBTUMsS0FBSztJQUFDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJ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SUMsSUFBSSxFQUFFLEdBQUcsQ0FBQ2hCLEVBQUUsQ0FBQyxDQUFFLENBQUMsQ0FBQ2dCLElBQUksS0FBSyxFQUFFLElBQUksSUFBSyxLQUFLLEdBQUllLE1BQU0sQ0FBQyxJQUFLO1lBQ3JFaEIsTUFBTSxDQUFDLElBQUlDLElBQUksRUFBRSxHQUFHLENBQUNoQixFQUFFLENBQUM4QixDQUFDLENBQUMsQ0FBQ2QsSUFBSSxLQUFLLEVBQUUsR0FBRyxLQUFLLEdBQUdlLEVBQUMsSUFBSztRQUMzRDtRQUNBLE9BQU9oQjtJQUNYO0FBQ0o7QUFDQXBCLFdBQVcsR0FBR0M7QUFDZE4sV0FBVyxJQUFJaUQsV0FBV2hELFVBQVUsSUFBSWdELFdBQVcvQyxVQUFVLElBQUkrQyxXQUNqRSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2Flcy5qcz8zMTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIE1JVCBMaWNlbnNlLiBDb3B5cmlnaHQgMjAxNS0yMDIyIFJpY2hhcmQgTW9vcmUgPG1lQHJpY21vby5jb20+LiBTZWUgTElDRU5TRS50eHQuICovXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0FFU19rZXksIF9BRVNfS2QsIF9BRVNfS2U7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFFUyA9IHZvaWQgMDtcbi8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuY29uc3QgbnVtYmVyT2ZSb3VuZHMgPSB7IDE2OiAxMCwgMjQ6IDEyLCAzMjogMTQgfTtcbi8vIFJvdW5kIGNvbnN0YW50IHdvcmRzXG5jb25zdCByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuLy8gUy1ib3ggYW5kIEludmVyc2UgUy1ib3ggKFMgaXMgZm9yIFN1YnN0aXR1dGlvbilcbmNvbnN0IFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5jb25zdCBTaSA9IFsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcbi8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZW5jcnlwdGlvblxuY29uc3QgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5jb25zdCBUMiA9IFsweGE1YzY2MzYzLCAweDg0Zjg3YzdjLCAweDk5ZWU3Nzc3LCAweDhkZjY3YjdiLCAweDBkZmZmMmYyLCAweGJkZDY2YjZiLCAweGIxZGU2ZjZmLCAweDU0OTFjNWM1LCAweDUwNjAzMDMwLCAweDAzMDIwMTAxLCAweGE5Y2U2NzY3LCAweDdkNTYyYjJiLCAweDE5ZTdmZWZlLCAweDYyYjVkN2Q3LCAweGU2NGRhYmFiLCAweDlhZWM3Njc2LCAweDQ1OGZjYWNhLCAweDlkMWY4MjgyLCAweDQwODljOWM5LCAweDg3ZmE3ZDdkLCAweDE1ZWZmYWZhLCAweGViYjI1OTU5LCAweGM5OGU0NzQ3LCAweDBiZmJmMGYwLCAweGVjNDFhZGFkLCAweDY3YjNkNGQ0LCAweGZkNWZhMmEyLCAweGVhNDVhZmFmLCAweGJmMjM5YzljLCAweGY3NTNhNGE0LCAweDk2ZTQ3MjcyLCAweDViOWJjMGMwLCAweGMyNzViN2I3LCAweDFjZTFmZGZkLCAweGFlM2Q5MzkzLCAweDZhNGMyNjI2LCAweDVhNmMzNjM2LCAweDQxN2UzZjNmLCAweDAyZjVmN2Y3LCAweDRmODNjY2NjLCAweDVjNjgzNDM0LCAweGY0NTFhNWE1LCAweDM0ZDFlNWU1LCAweDA4ZjlmMWYxLCAweDkzZTI3MTcxLCAweDczYWJkOGQ4LCAweDUzNjIzMTMxLCAweDNmMmExNTE1LCAweDBjMDgwNDA0LCAweDUyOTVjN2M3LCAweDY1NDYyMzIzLCAweDVlOWRjM2MzLCAweDI4MzAxODE4LCAweGExMzc5Njk2LCAweDBmMGEwNTA1LCAweGI1MmY5YTlhLCAweDA5MGUwNzA3LCAweDM2MjQxMjEyLCAweDliMWI4MDgwLCAweDNkZGZlMmUyLCAweDI2Y2RlYmViLCAweDY5NGUyNzI3LCAweGNkN2ZiMmIyLCAweDlmZWE3NTc1LCAweDFiMTIwOTA5LCAweDllMWQ4MzgzLCAweDc0NTgyYzJjLCAweDJlMzQxYTFhLCAweDJkMzYxYjFiLCAweGIyZGM2ZTZlLCAweGVlYjQ1YTVhLCAweGZiNWJhMGEwLCAweGY2YTQ1MjUyLCAweDRkNzYzYjNiLCAweDYxYjdkNmQ2LCAweGNlN2RiM2IzLCAweDdiNTIyOTI5LCAweDNlZGRlM2UzLCAweDcxNWUyZjJmLCAweDk3MTM4NDg0LCAweGY1YTY1MzUzLCAweDY4YjlkMWQxLCAweDAwMDAwMDAwLCAweDJjYzFlZGVkLCAweDYwNDAyMDIwLCAweDFmZTNmY2ZjLCAweGM4NzliMWIxLCAweGVkYjY1YjViLCAweGJlZDQ2YTZhLCAweDQ2OGRjYmNiLCAweGQ5NjdiZWJlLCAweDRiNzIzOTM5LCAweGRlOTQ0YTRhLCAweGQ0OTg0YzRjLCAweGU4YjA1ODU4LCAweDRhODVjZmNmLCAweDZiYmJkMGQwLCAweDJhYzVlZmVmLCAweGU1NGZhYWFhLCAweDE2ZWRmYmZiLCAweGM1ODY0MzQzLCAweGQ3OWE0ZDRkLCAweDU1NjYzMzMzLCAweDk0MTE4NTg1LCAweGNmOGE0NTQ1LCAweDEwZTlmOWY5LCAweDA2MDQwMjAyLCAweDgxZmU3ZjdmLCAweGYwYTA1MDUwLCAweDQ0NzgzYzNjLCAweGJhMjU5ZjlmLCAweGUzNGJhOGE4LCAweGYzYTI1MTUxLCAweGZlNWRhM2EzLCAweGMwODA0MDQwLCAweDhhMDU4ZjhmLCAweGFkM2Y5MjkyLCAweGJjMjE5ZDlkLCAweDQ4NzAzODM4LCAweDA0ZjFmNWY1LCAweGRmNjNiY2JjLCAweGMxNzdiNmI2LCAweDc1YWZkYWRhLCAweDYzNDIyMTIxLCAweDMwMjAxMDEwLCAweDFhZTVmZmZmLCAweDBlZmRmM2YzLCAweDZkYmZkMmQyLCAweDRjODFjZGNkLCAweDE0MTgwYzBjLCAweDM1MjYxMzEzLCAweDJmYzNlY2VjLCAweGUxYmU1ZjVmLCAweGEyMzU5Nzk3LCAweGNjODg0NDQ0LCAweDM5MmUxNzE3LCAweDU3OTNjNGM0LCAweGYyNTVhN2E3LCAweDgyZmM3ZTdlLCAweDQ3N2EzZDNkLCAweGFjYzg2NDY0LCAweGU3YmE1ZDVkLCAweDJiMzIxOTE5LCAweDk1ZTY3MzczLCAweGEwYzA2MDYwLCAweDk4MTk4MTgxLCAweGQxOWU0ZjRmLCAweDdmYTNkY2RjLCAweDY2NDQyMjIyLCAweDdlNTQyYTJhLCAweGFiM2I5MDkwLCAweDgzMGI4ODg4LCAweGNhOGM0NjQ2LCAweDI5YzdlZWVlLCAweGQzNmJiOGI4LCAweDNjMjgxNDE0LCAweDc5YTdkZWRlLCAweGUyYmM1ZTVlLCAweDFkMTYwYjBiLCAweDc2YWRkYmRiLCAweDNiZGJlMGUwLCAweDU2NjQzMjMyLCAweDRlNzQzYTNhLCAweDFlMTQwYTBhLCAweGRiOTI0OTQ5LCAweDBhMGMwNjA2LCAweDZjNDgyNDI0LCAweGU0Yjg1YzVjLCAweDVkOWZjMmMyLCAweDZlYmRkM2QzLCAweGVmNDNhY2FjLCAweGE2YzQ2MjYyLCAweGE4Mzk5MTkxLCAweGE0MzE5NTk1LCAweDM3ZDNlNGU0LCAweDhiZjI3OTc5LCAweDMyZDVlN2U3LCAweDQzOGJjOGM4LCAweDU5NmUzNzM3LCAweGI3ZGE2ZDZkLCAweDhjMDE4ZDhkLCAweDY0YjFkNWQ1LCAweGQyOWM0ZTRlLCAweGUwNDlhOWE5LCAweGI0ZDg2YzZjLCAweGZhYWM1NjU2LCAweDA3ZjNmNGY0LCAweDI1Y2ZlYWVhLCAweGFmY2E2NTY1LCAweDhlZjQ3YTdhLCAweGU5NDdhZWFlLCAweDE4MTAwODA4LCAweGQ1NmZiYWJhLCAweDg4ZjA3ODc4LCAweDZmNGEyNTI1LCAweDcyNWMyZTJlLCAweDI0MzgxYzFjLCAweGYxNTdhNmE2LCAweGM3NzNiNGI0LCAweDUxOTdjNmM2LCAweDIzY2JlOGU4LCAweDdjYTFkZGRkLCAweDljZTg3NDc0LCAweDIxM2UxZjFmLCAweGRkOTY0YjRiLCAweGRjNjFiZGJkLCAweDg2MGQ4YjhiLCAweDg1MGY4YThhLCAweDkwZTA3MDcwLCAweDQyN2MzZTNlLCAweGM0NzFiNWI1LCAweGFhY2M2NjY2LCAweGQ4OTA0ODQ4LCAweDA1MDYwMzAzLCAweDAxZjdmNmY2LCAweDEyMWMwZTBlLCAweGEzYzI2MTYxLCAweDVmNmEzNTM1LCAweGY5YWU1NzU3LCAweGQwNjliOWI5LCAweDkxMTc4Njg2LCAweDU4OTljMWMxLCAweDI3M2ExZDFkLCAweGI5Mjc5ZTllLCAweDM4ZDllMWUxLCAweDEzZWJmOGY4LCAweGIzMmI5ODk4LCAweDMzMjIxMTExLCAweGJiZDI2OTY5LCAweDcwYTlkOWQ5LCAweDg5MDc4ZThlLCAweGE3MzM5NDk0LCAweGI2MmQ5YjliLCAweDIyM2MxZTFlLCAweDkyMTU4Nzg3LCAweDIwYzllOWU5LCAweDQ5ODdjZWNlLCAweGZmYWE1NTU1LCAweDc4NTAyODI4LCAweDdhYTVkZmRmLCAweDhmMDM4YzhjLCAweGY4NTlhMWExLCAweDgwMDk4OTg5LCAweDE3MWEwZDBkLCAweGRhNjViZmJmLCAweDMxZDdlNmU2LCAweGM2ODQ0MjQyLCAweGI4ZDA2ODY4LCAweGMzODI0MTQxLCAweGIwMjk5OTk5LCAweDc3NWEyZDJkLCAweDExMWUwZjBmLCAweGNiN2JiMGIwLCAweGZjYTg1NDU0LCAweGQ2NmRiYmJiLCAweDNhMmMxNjE2XTtcbmNvbnN0IFQzID0gWzB4NjNhNWM2NjMsIDB4N2M4NGY4N2MsIDB4Nzc5OWVlNzcsIDB4N2I4ZGY2N2IsIDB4ZjIwZGZmZjIsIDB4NmJiZGQ2NmIsIDB4NmZiMWRlNmYsIDB4YzU1NDkxYzUsIDB4MzA1MDYwMzAsIDB4MDEwMzAyMDEsIDB4NjdhOWNlNjcsIDB4MmI3ZDU2MmIsIDB4ZmUxOWU3ZmUsIDB4ZDc2MmI1ZDcsIDB4YWJlNjRkYWIsIDB4NzY5YWVjNzYsIDB4Y2E0NThmY2EsIDB4ODI5ZDFmODIsIDB4Yzk0MDg5YzksIDB4N2Q4N2ZhN2QsIDB4ZmExNWVmZmEsIDB4NTllYmIyNTksIDB4NDdjOThlNDcsIDB4ZjAwYmZiZjAsIDB4YWRlYzQxYWQsIDB4ZDQ2N2IzZDQsIDB4YTJmZDVmYTIsIDB4YWZlYTQ1YWYsIDB4OWNiZjIzOWMsIDB4YTRmNzUzYTQsIDB4NzI5NmU0NzIsIDB4YzA1YjliYzAsIDB4YjdjMjc1YjcsIDB4ZmQxY2UxZmQsIDB4OTNhZTNkOTMsIDB4MjY2YTRjMjYsIDB4MzY1YTZjMzYsIDB4M2Y0MTdlM2YsIDB4ZjcwMmY1ZjcsIDB4Y2M0ZjgzY2MsIDB4MzQ1YzY4MzQsIDB4YTVmNDUxYTUsIDB4ZTUzNGQxZTUsIDB4ZjEwOGY5ZjEsIDB4NzE5M2UyNzEsIDB4ZDg3M2FiZDgsIDB4MzE1MzYyMzEsIDB4MTUzZjJhMTUsIDB4MDQwYzA4MDQsIDB4Yzc1Mjk1YzcsIDB4MjM2NTQ2MjMsIDB4YzM1ZTlkYzMsIDB4MTgyODMwMTgsIDB4OTZhMTM3OTYsIDB4MDUwZjBhMDUsIDB4OWFiNTJmOWEsIDB4MDcwOTBlMDcsIDB4MTIzNjI0MTIsIDB4ODA5YjFiODAsIDB4ZTIzZGRmZTIsIDB4ZWIyNmNkZWIsIDB4Mjc2OTRlMjcsIDB4YjJjZDdmYjIsIDB4NzU5ZmVhNzUsIDB4MDkxYjEyMDksIDB4ODM5ZTFkODMsIDB4MmM3NDU4MmMsIDB4MWEyZTM0MWEsIDB4MWIyZDM2MWIsIDB4NmViMmRjNmUsIDB4NWFlZWI0NWEsIDB4YTBmYjViYTAsIDB4NTJmNmE0NTIsIDB4M2I0ZDc2M2IsIDB4ZDY2MWI3ZDYsIDB4YjNjZTdkYjMsIDB4Mjk3YjUyMjksIDB4ZTMzZWRkZTMsIDB4MmY3MTVlMmYsIDB4ODQ5NzEzODQsIDB4NTNmNWE2NTMsIDB4ZDE2OGI5ZDEsIDB4MDAwMDAwMDAsIDB4ZWQyY2MxZWQsIDB4MjA2MDQwMjAsIDB4ZmMxZmUzZmMsIDB4YjFjODc5YjEsIDB4NWJlZGI2NWIsIDB4NmFiZWQ0NmEsIDB4Y2I0NjhkY2IsIDB4YmVkOTY3YmUsIDB4Mzk0YjcyMzksIDB4NGFkZTk0NGEsIDB4NGNkNDk4NGMsIDB4NThlOGIwNTgsIDB4Y2Y0YTg1Y2YsIDB4ZDA2YmJiZDAsIDB4ZWYyYWM1ZWYsIDB4YWFlNTRmYWEsIDB4ZmIxNmVkZmIsIDB4NDNjNTg2NDMsIDB4NGRkNzlhNGQsIDB4MzM1NTY2MzMsIDB4ODU5NDExODUsIDB4NDVjZjhhNDUsIDB4ZjkxMGU5ZjksIDB4MDIwNjA0MDIsIDB4N2Y4MWZlN2YsIDB4NTBmMGEwNTAsIDB4M2M0NDc4M2MsIDB4OWZiYTI1OWYsIDB4YThlMzRiYTgsIDB4NTFmM2EyNTEsIDB4YTNmZTVkYTMsIDB4NDBjMDgwNDAsIDB4OGY4YTA1OGYsIDB4OTJhZDNmOTIsIDB4OWRiYzIxOWQsIDB4Mzg0ODcwMzgsIDB4ZjUwNGYxZjUsIDB4YmNkZjYzYmMsIDB4YjZjMTc3YjYsIDB4ZGE3NWFmZGEsIDB4MjE2MzQyMjEsIDB4MTAzMDIwMTAsIDB4ZmYxYWU1ZmYsIDB4ZjMwZWZkZjMsIDB4ZDI2ZGJmZDIsIDB4Y2Q0YzgxY2QsIDB4MGMxNDE4MGMsIDB4MTMzNTI2MTMsIDB4ZWMyZmMzZWMsIDB4NWZlMWJlNWYsIDB4OTdhMjM1OTcsIDB4NDRjYzg4NDQsIDB4MTczOTJlMTcsIDB4YzQ1NzkzYzQsIDB4YTdmMjU1YTcsIDB4N2U4MmZjN2UsIDB4M2Q0NzdhM2QsIDB4NjRhY2M4NjQsIDB4NWRlN2JhNWQsIDB4MTkyYjMyMTksIDB4NzM5NWU2NzMsIDB4NjBhMGMwNjAsIDB4ODE5ODE5ODEsIDB4NGZkMTllNGYsIDB4ZGM3ZmEzZGMsIDB4MjI2NjQ0MjIsIDB4MmE3ZTU0MmEsIDB4OTBhYjNiOTAsIDB4ODg4MzBiODgsIDB4NDZjYThjNDYsIDB4ZWUyOWM3ZWUsIDB4YjhkMzZiYjgsIDB4MTQzYzI4MTQsIDB4ZGU3OWE3ZGUsIDB4NWVlMmJjNWUsIDB4MGIxZDE2MGIsIDB4ZGI3NmFkZGIsIDB4ZTAzYmRiZTAsIDB4MzI1NjY0MzIsIDB4M2E0ZTc0M2EsIDB4MGExZTE0MGEsIDB4NDlkYjkyNDksIDB4MDYwYTBjMDYsIDB4MjQ2YzQ4MjQsIDB4NWNlNGI4NWMsIDB4YzI1ZDlmYzIsIDB4ZDM2ZWJkZDMsIDB4YWNlZjQzYWMsIDB4NjJhNmM0NjIsIDB4OTFhODM5OTEsIDB4OTVhNDMxOTUsIDB4ZTQzN2QzZTQsIDB4Nzk4YmYyNzksIDB4ZTczMmQ1ZTcsIDB4Yzg0MzhiYzgsIDB4Mzc1OTZlMzcsIDB4NmRiN2RhNmQsIDB4OGQ4YzAxOGQsIDB4ZDU2NGIxZDUsIDB4NGVkMjljNGUsIDB4YTllMDQ5YTksIDB4NmNiNGQ4NmMsIDB4NTZmYWFjNTYsIDB4ZjQwN2YzZjQsIDB4ZWEyNWNmZWEsIDB4NjVhZmNhNjUsIDB4N2E4ZWY0N2EsIDB4YWVlOTQ3YWUsIDB4MDgxODEwMDgsIDB4YmFkNTZmYmEsIDB4Nzg4OGYwNzgsIDB4MjU2ZjRhMjUsIDB4MmU3MjVjMmUsIDB4MWMyNDM4MWMsIDB4YTZmMTU3YTYsIDB4YjRjNzczYjQsIDB4YzY1MTk3YzYsIDB4ZTgyM2NiZTgsIDB4ZGQ3Y2ExZGQsIDB4NzQ5Y2U4NzQsIDB4MWYyMTNlMWYsIDB4NGJkZDk2NGIsIDB4YmRkYzYxYmQsIDB4OGI4NjBkOGIsIDB4OGE4NTBmOGEsIDB4NzA5MGUwNzAsIDB4M2U0MjdjM2UsIDB4YjVjNDcxYjUsIDB4NjZhYWNjNjYsIDB4NDhkODkwNDgsIDB4MDMwNTA2MDMsIDB4ZjYwMWY3ZjYsIDB4MGUxMjFjMGUsIDB4NjFhM2MyNjEsIDB4MzU1ZjZhMzUsIDB4NTdmOWFlNTcsIDB4YjlkMDY5YjksIDB4ODY5MTE3ODYsIDB4YzE1ODk5YzEsIDB4MWQyNzNhMWQsIDB4OWViOTI3OWUsIDB4ZTEzOGQ5ZTEsIDB4ZjgxM2ViZjgsIDB4OThiMzJiOTgsIDB4MTEzMzIyMTEsIDB4NjliYmQyNjksIDB4ZDk3MGE5ZDksIDB4OGU4OTA3OGUsIDB4OTRhNzMzOTQsIDB4OWJiNjJkOWIsIDB4MWUyMjNjMWUsIDB4ODc5MjE1ODcsIDB4ZTkyMGM5ZTksIDB4Y2U0OTg3Y2UsIDB4NTVmZmFhNTUsIDB4Mjg3ODUwMjgsIDB4ZGY3YWE1ZGYsIDB4OGM4ZjAzOGMsIDB4YTFmODU5YTEsIDB4ODk4MDA5ODksIDB4MGQxNzFhMGQsIDB4YmZkYTY1YmYsIDB4ZTYzMWQ3ZTYsIDB4NDJjNjg0NDIsIDB4NjhiOGQwNjgsIDB4NDFjMzgyNDEsIDB4OTliMDI5OTksIDB4MmQ3NzVhMmQsIDB4MGYxMTFlMGYsIDB4YjBjYjdiYjAsIDB4NTRmY2E4NTQsIDB4YmJkNjZkYmIsIDB4MTYzYTJjMTZdO1xuY29uc3QgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG4vLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb25cbmNvbnN0IFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuY29uc3QgVDYgPSBbMHg1MDUxZjRhNywgMHg1MzdlNDE2NSwgMHhjMzFhMTdhNCwgMHg5NjNhMjc1ZSwgMHhjYjNiYWI2YiwgMHhmMTFmOWQ0NSwgMHhhYmFjZmE1OCwgMHg5MzRiZTMwMywgMHg1NTIwMzBmYSwgMHhmNmFkNzY2ZCwgMHg5MTg4Y2M3NiwgMHgyNWY1MDI0YywgMHhmYzRmZTVkNywgMHhkN2M1MmFjYiwgMHg4MDI2MzU0NCwgMHg4ZmI1NjJhMywgMHg0OWRlYjE1YSwgMHg2NzI1YmExYiwgMHg5ODQ1ZWEwZSwgMHhlMTVkZmVjMCwgMHgwMmMzMmY3NSwgMHgxMjgxNGNmMCwgMHhhMzhkNDY5NywgMHhjNjZiZDNmOSwgMHhlNzAzOGY1ZiwgMHg5NTE1OTI5YywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHgyZGQ0YmU4MywgMHhkMzU4NzQyMSwgMHgyOTQ5ZTA2OSwgMHg0NDhlYzljOCwgMHg2YTc1YzI4OSwgMHg3OGY0OGU3OSwgMHg2Yjk5NTgzZSwgMHhkZDI3Yjk3MSwgMHhiNmJlZTE0ZiwgMHgxN2YwODhhZCwgMHg2NmM5MjBhYywgMHhiNDdkY2UzYSwgMHgxODYzZGY0YSwgMHg4MmU1MWEzMSwgMHg2MDk3NTEzMywgMHg0NTYyNTM3ZiwgMHhlMGIxNjQ3NywgMHg4NGJiNmJhZSwgMHgxY2ZlODFhMCwgMHg5NGY5MDgyYiwgMHg1ODcwNDg2OCwgMHgxOThmNDVmZCwgMHg4Nzk0ZGU2YywgMHhiNzUyN2JmOCwgMHgyM2FiNzNkMywgMHhlMjcyNGIwMiwgMHg1N2UzMWY4ZiwgMHgyYTY2NTVhYiwgMHgwN2IyZWIyOCwgMHgwMzJmYjVjMiwgMHg5YTg2YzU3YiwgMHhhNWQzMzcwOCwgMHhmMjMwMjg4NywgMHhiMjIzYmZhNSwgMHhiYTAyMDM2YSwgMHg1Y2VkMTY4MiwgMHgyYjhhY2YxYywgMHg5MmE3NzliNCwgMHhmMGYzMDdmMiwgMHhhMTRlNjllMiwgMHhjZDY1ZGFmNCwgMHhkNTA2MDViZSwgMHgxZmQxMzQ2MiwgMHg4YWM0YTZmZSwgMHg5ZDM0MmU1MywgMHhhMGEyZjM1NSwgMHgzMjA1OGFlMSwgMHg3NWE0ZjZlYiwgMHgzOTBiODNlYywgMHhhYTQwNjBlZiwgMHgwNjVlNzE5ZiwgMHg1MWJkNmUxMCwgMHhmOTNlMjE4YSwgMHgzZDk2ZGQwNiwgMHhhZWRkM2UwNSwgMHg0NjRkZTZiZCwgMHhiNTkxNTQ4ZCwgMHgwNTcxYzQ1ZCwgMHg2ZjA0MDZkNCwgMHhmZjYwNTAxNSwgMHgyNDE5OThmYiwgMHg5N2Q2YmRlOSwgMHhjYzg5NDA0MywgMHg3NzY3ZDk5ZSwgMHhiZGIwZTg0MiwgMHg4ODA3ODk4YiwgMHgzOGU3MTk1YiwgMHhkYjc5YzhlZSwgMHg0N2ExN2MwYSwgMHhlOTdjNDIwZiwgMHhjOWY4ODQxZSwgMHgwMDAwMDAwMCwgMHg4MzA5ODA4NiwgMHg0ODMyMmJlZCwgMHhhYzFlMTE3MCwgMHg0ZTZjNWE3MiwgMHhmYmZkMGVmZiwgMHg1NjBmODUzOCwgMHgxZTNkYWVkNSwgMHgyNzM2MmQzOSwgMHg2NDBhMGZkOSwgMHgyMTY4NWNhNiwgMHhkMTliNWI1NCwgMHgzYTI0MzYyZSwgMHhiMTBjMGE2NywgMHgwZjkzNTdlNywgMHhkMmI0ZWU5NiwgMHg5ZTFiOWI5MSwgMHg0ZjgwYzBjNSwgMHhhMjYxZGMyMCwgMHg2OTVhNzc0YiwgMHgxNjFjMTIxYSwgMHgwYWUyOTNiYSwgMHhlNWMwYTAyYSwgMHg0MzNjMjJlMCwgMHgxZDEyMWIxNywgMHgwYjBlMDkwZCwgMHhhZGYyOGJjNywgMHhiOTJkYjZhOCwgMHhjODE0MWVhOSwgMHg4NTU3ZjExOSwgMHg0Y2FmNzUwNywgMHhiYmVlOTlkZCwgMHhmZGEzN2Y2MCwgMHg5ZmY3MDEyNiwgMHhiYzVjNzJmNSwgMHhjNTQ0NjYzYiwgMHgzNDViZmI3ZSwgMHg3NjhiNDMyOSwgMHhkY2NiMjNjNiwgMHg2OGI2ZWRmYywgMHg2M2I4ZTRmMSwgMHhjYWQ3MzFkYywgMHgxMDQyNjM4NSwgMHg0MDEzOTcyMiwgMHgyMDg0YzYxMSwgMHg3ZDg1NGEyNCwgMHhmOGQyYmIzZCwgMHgxMWFlZjkzMiwgMHg2ZGM3MjlhMSwgMHg0YjFkOWUyZiwgMHhmM2RjYjIzMCwgMHhlYzBkODY1MiwgMHhkMDc3YzFlMywgMHg2YzJiYjMxNiwgMHg5OWE5NzBiOSwgMHhmYTExOTQ0OCwgMHgyMjQ3ZTk2NCwgMHhjNGE4ZmM4YywgMHgxYWEwZjAzZiwgMHhkODU2N2QyYywgMHhlZjIyMzM5MCwgMHhjNzg3NDk0ZSwgMHhjMWQ5MzhkMSwgMHhmZThjY2FhMiwgMHgzNjk4ZDQwYiwgMHhjZmE2ZjU4MSwgMHgyOGE1N2FkZSwgMHgyNmRhYjc4ZSwgMHhhNDNmYWRiZiwgMHhlNDJjM2E5ZCwgMHgwZDUwNzg5MiwgMHg5YjZhNWZjYywgMHg2MjU0N2U0NiwgMHhjMmY2OGQxMywgMHhlODkwZDhiOCwgMHg1ZTJlMzlmNywgMHhmNTgyYzNhZiwgMHhiZTlmNWQ4MCwgMHg3YzY5ZDA5MywgMHhhOTZmZDUyZCwgMHhiM2NmMjUxMiwgMHgzYmM4YWM5OSwgMHhhNzEwMTg3ZCwgMHg2ZWU4OWM2MywgMHg3YmRiM2JiYiwgMHgwOWNkMjY3OCwgMHhmNDZlNTkxOCwgMHgwMWVjOWFiNywgMHhhODgzNGY5YSwgMHg2NWU2OTU2ZSwgMHg3ZWFhZmZlNiwgMHgwODIxYmNjZiwgMHhlNmVmMTVlOCwgMHhkOWJhZTc5YiwgMHhjZTRhNmYzNiwgMHhkNGVhOWYwOSwgMHhkNjI5YjA3YywgMHhhZjMxYTRiMiwgMHgzMTJhM2YyMywgMHgzMGM2YTU5NCwgMHhjMDM1YTI2NiwgMHgzNzc0NGViYywgMHhhNmZjODJjYSwgMHhiMGUwOTBkMCwgMHgxNTMzYTdkOCwgMHg0YWYxMDQ5OCwgMHhmNzQxZWNkYSwgMHgwZTdmY2Q1MCwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg0ZDQzZWZiMCwgMHg1NGNjYWE0ZCwgMHhkZmU0OTYwNCwgMHhlMzllZDFiNSwgMHgxYjRjNmE4OCwgMHhiOGMxMmMxZiwgMHg3ZjQ2NjU1MSwgMHgwNDlkNWVlYSwgMHg1ZDAxOGMzNSwgMHg3M2ZhODc3NCwgMHgyZWZiMGI0MSwgMHg1YWIzNjcxZCwgMHg1MjkyZGJkMiwgMHgzM2U5MTA1NiwgMHgxMzZkZDY0NywgMHg4YzlhZDc2MSwgMHg3YTM3YTEwYywgMHg4ZTU5ZjgxNCwgMHg4OWViMTMzYywgMHhlZWNlYTkyNywgMHgzNWI3NjFjOSwgMHhlZGUxMWNlNSwgMHgzYzdhNDdiMSwgMHg1OTljZDJkZiwgMHgzZjU1ZjI3MywgMHg3OTE4MTRjZSwgMHhiZjczYzczNywgMHhlYTUzZjdjZCwgMHg1YjVmZmRhYSwgMHgxNGRmM2Q2ZiwgMHg4Njc4NDRkYiwgMHg4MWNhYWZmMywgMHgzZWI5NjhjNCwgMHgyYzM4MjQzNCwgMHg1ZmMyYTM0MCwgMHg3MjE2MWRjMywgMHgwY2JjZTIyNSwgMHg4YjI4M2M0OSwgMHg0MWZmMGQ5NSwgMHg3MTM5YTgwMSwgMHhkZTA4MGNiMywgMHg5Y2Q4YjRlNCwgMHg5MDY0NTZjMSwgMHg2MTdiY2I4NCwgMHg3MGQ1MzJiNiwgMHg3NDQ4NmM1YywgMHg0MmQwYjg1N107XG5jb25zdCBUNyA9IFsweGE3NTA1MWY0LCAweDY1NTM3ZTQxLCAweGE0YzMxYTE3LCAweDVlOTYzYTI3LCAweDZiY2IzYmFiLCAweDQ1ZjExZjlkLCAweDU4YWJhY2ZhLCAweDAzOTM0YmUzLCAweGZhNTUyMDMwLCAweDZkZjZhZDc2LCAweDc2OTE4OGNjLCAweDRjMjVmNTAyLCAweGQ3ZmM0ZmU1LCAweGNiZDdjNTJhLCAweDQ0ODAyNjM1LCAweGEzOGZiNTYyLCAweDVhNDlkZWIxLCAweDFiNjcyNWJhLCAweDBlOTg0NWVhLCAweGMwZTE1ZGZlLCAweDc1MDJjMzJmLCAweGYwMTI4MTRjLCAweDk3YTM4ZDQ2LCAweGY5YzY2YmQzLCAweDVmZTcwMzhmLCAweDljOTUxNTkyLCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDgzMmRkNGJlLCAweDIxZDM1ODc0LCAweDY5Mjk0OWUwLCAweGM4NDQ4ZWM5LCAweDg5NmE3NWMyLCAweDc5NzhmNDhlLCAweDNlNmI5OTU4LCAweDcxZGQyN2I5LCAweDRmYjZiZWUxLCAweGFkMTdmMDg4LCAweGFjNjZjOTIwLCAweDNhYjQ3ZGNlLCAweDRhMTg2M2RmLCAweDMxODJlNTFhLCAweDMzNjA5NzUxLCAweDdmNDU2MjUzLCAweDc3ZTBiMTY0LCAweGFlODRiYjZiLCAweGEwMWNmZTgxLCAweDJiOTRmOTA4LCAweDY4NTg3MDQ4LCAweGZkMTk4ZjQ1LCAweDZjODc5NGRlLCAweGY4Yjc1MjdiLCAweGQzMjNhYjczLCAweDAyZTI3MjRiLCAweDhmNTdlMzFmLCAweGFiMmE2NjU1LCAweDI4MDdiMmViLCAweGMyMDMyZmI1LCAweDdiOWE4NmM1LCAweDA4YTVkMzM3LCAweDg3ZjIzMDI4LCAweGE1YjIyM2JmLCAweDZhYmEwMjAzLCAweDgyNWNlZDE2LCAweDFjMmI4YWNmLCAweGI0OTJhNzc5LCAweGYyZjBmMzA3LCAweGUyYTE0ZTY5LCAweGY0Y2Q2NWRhLCAweGJlZDUwNjA1LCAweDYyMWZkMTM0LCAweGZlOGFjNGE2LCAweDUzOWQzNDJlLCAweDU1YTBhMmYzLCAweGUxMzIwNThhLCAweGViNzVhNGY2LCAweGVjMzkwYjgzLCAweGVmYWE0MDYwLCAweDlmMDY1ZTcxLCAweDEwNTFiZDZlLCAweDhhZjkzZTIxLCAweDA2M2Q5NmRkLCAweDA1YWVkZDNlLCAweGJkNDY0ZGU2LCAweDhkYjU5MTU0LCAweDVkMDU3MWM0LCAweGQ0NmYwNDA2LCAweDE1ZmY2MDUwLCAweGZiMjQxOTk4LCAweGU5OTdkNmJkLCAweDQzY2M4OTQwLCAweDllNzc2N2Q5LCAweDQyYmRiMGU4LCAweDhiODgwNzg5LCAweDViMzhlNzE5LCAweGVlZGI3OWM4LCAweDBhNDdhMTdjLCAweDBmZTk3YzQyLCAweDFlYzlmODg0LCAweDAwMDAwMDAwLCAweDg2ODMwOTgwLCAweGVkNDgzMjJiLCAweDcwYWMxZTExLCAweDcyNGU2YzVhLCAweGZmZmJmZDBlLCAweDM4NTYwZjg1LCAweGQ1MWUzZGFlLCAweDM5MjczNjJkLCAweGQ5NjQwYTBmLCAweGE2MjE2ODVjLCAweDU0ZDE5YjViLCAweDJlM2EyNDM2LCAweDY3YjEwYzBhLCAweGU3MGY5MzU3LCAweDk2ZDJiNGVlLCAweDkxOWUxYjliLCAweGM1NGY4MGMwLCAweDIwYTI2MWRjLCAweDRiNjk1YTc3LCAweDFhMTYxYzEyLCAweGJhMGFlMjkzLCAweDJhZTVjMGEwLCAweGUwNDMzYzIyLCAweDE3MWQxMjFiLCAweDBkMGIwZTA5LCAweGM3YWRmMjhiLCAweGE4YjkyZGI2LCAweGE5YzgxNDFlLCAweDE5ODU1N2YxLCAweDA3NGNhZjc1LCAweGRkYmJlZTk5LCAweDYwZmRhMzdmLCAweDI2OWZmNzAxLCAweGY1YmM1YzcyLCAweDNiYzU0NDY2LCAweDdlMzQ1YmZiLCAweDI5NzY4YjQzLCAweGM2ZGNjYjIzLCAweGZjNjhiNmVkLCAweGYxNjNiOGU0LCAweGRjY2FkNzMxLCAweDg1MTA0MjYzLCAweDIyNDAxMzk3LCAweDExMjA4NGM2LCAweDI0N2Q4NTRhLCAweDNkZjhkMmJiLCAweDMyMTFhZWY5LCAweGExNmRjNzI5LCAweDJmNGIxZDllLCAweDMwZjNkY2IyLCAweDUyZWMwZDg2LCAweGUzZDA3N2MxLCAweDE2NmMyYmIzLCAweGI5OTlhOTcwLCAweDQ4ZmExMTk0LCAweDY0MjI0N2U5LCAweDhjYzRhOGZjLCAweDNmMWFhMGYwLCAweDJjZDg1NjdkLCAweDkwZWYyMjMzLCAweDRlYzc4NzQ5LCAweGQxYzFkOTM4LCAweGEyZmU4Y2NhLCAweDBiMzY5OGQ0LCAweDgxY2ZhNmY1LCAweGRlMjhhNTdhLCAweDhlMjZkYWI3LCAweGJmYTQzZmFkLCAweDlkZTQyYzNhLCAweDkyMGQ1MDc4LCAweGNjOWI2YTVmLCAweDQ2NjI1NDdlLCAweDEzYzJmNjhkLCAweGI4ZTg5MGQ4LCAweGY3NWUyZTM5LCAweGFmZjU4MmMzLCAweDgwYmU5ZjVkLCAweDkzN2M2OWQwLCAweDJkYTk2ZmQ1LCAweDEyYjNjZjI1LCAweDk5M2JjOGFjLCAweDdkYTcxMDE4LCAweDYzNmVlODljLCAweGJiN2JkYjNiLCAweDc4MDljZDI2LCAweDE4ZjQ2ZTU5LCAweGI3MDFlYzlhLCAweDlhYTg4MzRmLCAweDZlNjVlNjk1LCAweGU2N2VhYWZmLCAweGNmMDgyMWJjLCAweGU4ZTZlZjE1LCAweDliZDliYWU3LCAweDM2Y2U0YTZmLCAweDA5ZDRlYTlmLCAweDdjZDYyOWIwLCAweGIyYWYzMWE0LCAweDIzMzEyYTNmLCAweDk0MzBjNmE1LCAweDY2YzAzNWEyLCAweGJjMzc3NDRlLCAweGNhYTZmYzgyLCAweGQwYjBlMDkwLCAweGQ4MTUzM2E3LCAweDk4NGFmMTA0LCAweGRhZjc0MWVjLCAweDUwMGU3ZmNkLCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGIwNGQ0M2VmLCAweDRkNTRjY2FhLCAweDA0ZGZlNDk2LCAweGI1ZTM5ZWQxLCAweDg4MWI0YzZhLCAweDFmYjhjMTJjLCAweDUxN2Y0NjY1LCAweGVhMDQ5ZDVlLCAweDM1NWQwMThjLCAweDc0NzNmYTg3LCAweDQxMmVmYjBiLCAweDFkNWFiMzY3LCAweGQyNTI5MmRiLCAweDU2MzNlOTEwLCAweDQ3MTM2ZGQ2LCAweDYxOGM5YWQ3LCAweDBjN2EzN2ExLCAweDE0OGU1OWY4LCAweDNjODllYjEzLCAweDI3ZWVjZWE5LCAweGM5MzViNzYxLCAweGU1ZWRlMTFjLCAweGIxM2M3YTQ3LCAweGRmNTk5Y2QyLCAweDczM2Y1NWYyLCAweGNlNzkxODE0LCAweDM3YmY3M2M3LCAweGNkZWE1M2Y3LCAweGFhNWI1ZmZkLCAweDZmMTRkZjNkLCAweGRiODY3ODQ0LCAweGYzODFjYWFmLCAweGM0M2ViOTY4LCAweDM0MmMzODI0LCAweDQwNWZjMmEzLCAweGMzNzIxNjFkLCAweDI1MGNiY2UyLCAweDQ5OGIyODNjLCAweDk1NDFmZjBkLCAweDAxNzEzOWE4LCAweGIzZGUwODBjLCAweGU0OWNkOGI0LCAweGMxOTA2NDU2LCAweDg0NjE3YmNiLCAweGI2NzBkNTMyLCAweDVjNzQ0ODZjLCAweDU3NDJkMGI4XTtcbmNvbnN0IFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuLy8gVHJhbnNmb3JtYXRpb25zIGZvciBkZWNyeXB0aW9uIGtleSBleHBhbnNpb25cbmNvbnN0IFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuY29uc3QgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG5jb25zdCBVMyA9IFsweDAwMDAwMDAwLCAweDBkMGIwZTA5LCAweDFhMTYxYzEyLCAweDE3MWQxMjFiLCAweDM0MmMzODI0LCAweDM5MjczNjJkLCAweDJlM2EyNDM2LCAweDIzMzEyYTNmLCAweDY4NTg3MDQ4LCAweDY1NTM3ZTQxLCAweDcyNGU2YzVhLCAweDdmNDU2MjUzLCAweDVjNzQ0ODZjLCAweDUxN2Y0NjY1LCAweDQ2NjI1NDdlLCAweDRiNjk1YTc3LCAweGQwYjBlMDkwLCAweGRkYmJlZTk5LCAweGNhYTZmYzgyLCAweGM3YWRmMjhiLCAweGU0OWNkOGI0LCAweGU5OTdkNmJkLCAweGZlOGFjNGE2LCAweGYzODFjYWFmLCAweGI4ZTg5MGQ4LCAweGI1ZTM5ZWQxLCAweGEyZmU4Y2NhLCAweGFmZjU4MmMzLCAweDhjYzRhOGZjLCAweDgxY2ZhNmY1LCAweDk2ZDJiNGVlLCAweDliZDliYWU3LCAweGJiN2JkYjNiLCAweGI2NzBkNTMyLCAweGExNmRjNzI5LCAweGFjNjZjOTIwLCAweDhmNTdlMzFmLCAweDgyNWNlZDE2LCAweDk1NDFmZjBkLCAweDk4NGFmMTA0LCAweGQzMjNhYjczLCAweGRlMjhhNTdhLCAweGM5MzViNzYxLCAweGM0M2ViOTY4LCAweGU3MGY5MzU3LCAweGVhMDQ5ZDVlLCAweGZkMTk4ZjQ1LCAweGYwMTI4MTRjLCAweDZiY2IzYmFiLCAweDY2YzAzNWEyLCAweDcxZGQyN2I5LCAweDdjZDYyOWIwLCAweDVmZTcwMzhmLCAweDUyZWMwZDg2LCAweDQ1ZjExZjlkLCAweDQ4ZmExMTk0LCAweDAzOTM0YmUzLCAweDBlOTg0NWVhLCAweDE5ODU1N2YxLCAweDE0OGU1OWY4LCAweDM3YmY3M2M3LCAweDNhYjQ3ZGNlLCAweDJkYTk2ZmQ1LCAweDIwYTI2MWRjLCAweDZkZjZhZDc2LCAweDYwZmRhMzdmLCAweDc3ZTBiMTY0LCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDU0ZDE5YjViLCAweDQzY2M4OTQwLCAweDRlYzc4NzQ5LCAweDA1YWVkZDNlLCAweDA4YTVkMzM3LCAweDFmYjhjMTJjLCAweDEyYjNjZjI1LCAweDMxODJlNTFhLCAweDNjODllYjEzLCAweDJiOTRmOTA4LCAweDI2OWZmNzAxLCAweGJkNDY0ZGU2LCAweGIwNGQ0M2VmLCAweGE3NTA1MWY0LCAweGFhNWI1ZmZkLCAweDg5NmE3NWMyLCAweDg0NjE3YmNiLCAweDkzN2M2OWQwLCAweDllNzc2N2Q5LCAweGQ1MWUzZGFlLCAweGQ4MTUzM2E3LCAweGNmMDgyMWJjLCAweGMyMDMyZmI1LCAweGUxMzIwNThhLCAweGVjMzkwYjgzLCAweGZiMjQxOTk4LCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGRiODY3ODQ0LCAweGNjOWI2YTVmLCAweGMxOTA2NDU2LCAweGUyYTE0ZTY5LCAweGVmYWE0MDYwLCAweGY4Yjc1MjdiLCAweGY1YmM1YzcyLCAweGJlZDUwNjA1LCAweGIzZGUwODBjLCAweGE0YzMxYTE3LCAweGE5YzgxNDFlLCAweDhhZjkzZTIxLCAweDg3ZjIzMDI4LCAweDkwZWYyMjMzLCAweDlkZTQyYzNhLCAweDA2M2Q5NmRkLCAweDBiMzY5OGQ0LCAweDFjMmI4YWNmLCAweDExMjA4NGM2LCAweDMyMTFhZWY5LCAweDNmMWFhMGYwLCAweDI4MDdiMmViLCAweDI1MGNiY2UyLCAweDZlNjVlNjk1LCAweDYzNmVlODljLCAweDc0NzNmYTg3LCAweDc5NzhmNDhlLCAweDVhNDlkZWIxLCAweDU3NDJkMGI4LCAweDQwNWZjMmEzLCAweDRkNTRjY2FhLCAweGRhZjc0MWVjLCAweGQ3ZmM0ZmU1LCAweGMwZTE1ZGZlLCAweGNkZWE1M2Y3LCAweGVlZGI3OWM4LCAweGUzZDA3N2MxLCAweGY0Y2Q2NWRhLCAweGY5YzY2YmQzLCAweGIyYWYzMWE0LCAweGJmYTQzZmFkLCAweGE4YjkyZGI2LCAweGE1YjIyM2JmLCAweDg2ODMwOTgwLCAweDhiODgwNzg5LCAweDljOTUxNTkyLCAweDkxOWUxYjliLCAweDBhNDdhMTdjLCAweDA3NGNhZjc1LCAweDEwNTFiZDZlLCAweDFkNWFiMzY3LCAweDNlNmI5OTU4LCAweDMzNjA5NzUxLCAweDI0N2Q4NTRhLCAweDI5NzY4YjQzLCAweDYyMWZkMTM0LCAweDZmMTRkZjNkLCAweDc4MDljZDI2LCAweDc1MDJjMzJmLCAweDU2MzNlOTEwLCAweDViMzhlNzE5LCAweDRjMjVmNTAyLCAweDQxMmVmYjBiLCAweDYxOGM5YWQ3LCAweDZjODc5NGRlLCAweDdiOWE4NmM1LCAweDc2OTE4OGNjLCAweDU1YTBhMmYzLCAweDU4YWJhY2ZhLCAweDRmYjZiZWUxLCAweDQyYmRiMGU4LCAweDA5ZDRlYTlmLCAweDA0ZGZlNDk2LCAweDEzYzJmNjhkLCAweDFlYzlmODg0LCAweDNkZjhkMmJiLCAweDMwZjNkY2IyLCAweDI3ZWVjZWE5LCAweDJhZTVjMGEwLCAweGIxM2M3YTQ3LCAweGJjMzc3NDRlLCAweGFiMmE2NjU1LCAweGE2MjE2ODVjLCAweDg1MTA0MjYzLCAweDg4MWI0YzZhLCAweDlmMDY1ZTcxLCAweDkyMGQ1MDc4LCAweGQ5NjQwYTBmLCAweGQ0NmYwNDA2LCAweGMzNzIxNjFkLCAweGNlNzkxODE0LCAweGVkNDgzMjJiLCAweGUwNDMzYzIyLCAweGY3NWUyZTM5LCAweGZhNTUyMDMwLCAweGI3MDFlYzlhLCAweGJhMGFlMjkzLCAweGFkMTdmMDg4LCAweGEwMWNmZTgxLCAweDgzMmRkNGJlLCAweDhlMjZkYWI3LCAweDk5M2JjOGFjLCAweDk0MzBjNmE1LCAweGRmNTk5Y2QyLCAweGQyNTI5MmRiLCAweGM1NGY4MGMwLCAweGM4NDQ4ZWM5LCAweGViNzVhNGY2LCAweGU2N2VhYWZmLCAweGYxNjNiOGU0LCAweGZjNjhiNmVkLCAweDY3YjEwYzBhLCAweDZhYmEwMjAzLCAweDdkYTcxMDE4LCAweDcwYWMxZTExLCAweDUzOWQzNDJlLCAweDVlOTYzYTI3LCAweDQ5OGIyODNjLCAweDQ0ODAyNjM1LCAweDBmZTk3YzQyLCAweDAyZTI3MjRiLCAweDE1ZmY2MDUwLCAweDE4ZjQ2ZTU5LCAweDNiYzU0NDY2LCAweDM2Y2U0YTZmLCAweDIxZDM1ODc0LCAweDJjZDg1NjdkLCAweDBjN2EzN2ExLCAweDAxNzEzOWE4LCAweDE2NmMyYmIzLCAweDFiNjcyNWJhLCAweDM4NTYwZjg1LCAweDM1NWQwMThjLCAweDIyNDAxMzk3LCAweDJmNGIxZDllLCAweDY0MjI0N2U5LCAweDY5Mjk0OWUwLCAweDdlMzQ1YmZiLCAweDczM2Y1NWYyLCAweDUwMGU3ZmNkLCAweDVkMDU3MWM0LCAweDRhMTg2M2RmLCAweDQ3MTM2ZGQ2LCAweGRjY2FkNzMxLCAweGQxYzFkOTM4LCAweGM2ZGNjYjIzLCAweGNiZDdjNTJhLCAweGU4ZTZlZjE1LCAweGU1ZWRlMTFjLCAweGYyZjBmMzA3LCAweGZmZmJmZDBlLCAweGI0OTJhNzc5LCAweGI5OTlhOTcwLCAweGFlODRiYjZiLCAweGEzOGZiNTYyLCAweDgwYmU5ZjVkLCAweDhkYjU5MTU0LCAweDlhYTg4MzRmLCAweDk3YTM4ZDQ2XTtcbmNvbnN0IFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuZnVuY3Rpb24gY29udmVydFRvSW50MzIoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChieXRlc1tpXSA8PCAyNCkgfCAoYnl0ZXNbaSArIDFdIDw8IDE2KSB8IChieXRlc1tpICsgMl0gPDwgOCkgfCBieXRlc1tpICsgM10pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgQUVTIHtcbiAgICBnZXQga2V5KCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX2tleSwgXCJmXCIpLnNsaWNlKCk7IH1cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0FFU19rZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Quc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BRVNfS2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBRVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BRVNfa2V5LCBuZXcgVWludDhBcnJheShrZXkpLCBcImZcIik7XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgc2l6ZSAobXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5jcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZSwgW10sIFwiZlwiKTtcbiAgICAgICAgLy8gZGVjcnlwdGlvbiByb3VuZCBrZXlzXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FFU19LZCwgW10sIFwiZlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLnB1c2goWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZEtleUNvdW50ID0gKHJvdW5kcyArIDEpICogNDtcbiAgICAgICAgY29uc3QgS0MgPSB0aGlzLmtleS5sZW5ndGggLyA0O1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG4gICAgICAgIGNvbnN0IHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ID0gaSA+PiAyO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICBsZXQgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICBsZXQgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAoU1t0dCAmIDB4RkZdIDw8IDgpIF5cbiAgICAgICAgICAgICAgICBTWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZm9yIG5vbi0yNTYgYml0KVxuICAgICAgICAgICAgaWYgKEtDICE9IDgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChLQyAvIDIpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0dCA9IHRrWyhLQyAvIDIpIC0gMV07XG4gICAgICAgICAgICAgICAgdGtbS0MgLyAyXSBePSAoU1t0dCAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDgpICYgMHhGRl0gPDwgOCkgXlxuICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gMTYpICYgMHhGRl0gPDwgMTYpIF5cbiAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChLQyAvIDIpICsgMTsgaSA8IEtDOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuICAgICAgICAgICAgbGV0IGkgPSAwLCByLCBjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBLQyAmJiB0IDwgcm91bmRLZXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG4gICAgICAgICAgICAgICAgYyA9IHQgJSA0O1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZSwgXCJmXCIpW3JdW2NdID0gdGtbaV07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tkLCBcImZcIilbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuICAgICAgICAgICAgICAgIHQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yIChsZXQgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUyWyh0dCA+PiAxNikgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgIFUzWyh0dCA+PiA4KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgVTRbdHQgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91bmRzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIikubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG4gICAgICAgIGxldCB0ID0gY29udmVydFRvSW50MzIocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQUVTX0tlLCBcImZcIilbMF1baV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgcm91bmQgdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKGxldCByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGFbaV0gPSAoVDFbKHRbaV0gPj4gMjQpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ0W3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBsYXN0IHJvdW5kIGlzIHNwZWNpYWxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBsZXQgdHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2UsIFwiZlwiKVtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpXSA9IChTWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF4gKHR0ID4+IDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTW3RbKGkgKyAzKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdW5kcyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIC8vIGNvbnZlcnQgcGxhaW50ZXh0IHRvIChpbnRzIF4ga2V5KVxuICAgICAgICBsZXQgdCA9IGNvbnZlcnRUb0ludDMyKGNpcGhlcnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BRVNfS2QsIFwiZlwiKVswXVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFtpXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIFQ3Wyh0WyhpICsgMikgJSA0XSA+PiA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgVDhbdFsoaSArIDEpICUgNF0gJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGxldCB0dCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB0dCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FFU19LZCwgXCJmXCIpW3JvdW5kc11baV07XG4gICAgICAgICAgICByZXN1bHRbNCAqIGldID0gKFNpWyh0W2ldID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+IDgpICYgMHhmZl0gXiAodHQgPj4gOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNpW3RbKGkgKyAxKSAlIDRdICYgMHhmZl0gXiB0dCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5BRVMgPSBBRVM7XG5fQUVTX2tleSA9IG5ldyBXZWFrTWFwKCksIF9BRVNfS2QgPSBuZXcgV2Vha01hcCgpLCBfQUVTX0tlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfQUVTX2tleSIsIl9BRVNfS2QiLCJfQUVTX0tlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiQUVTIiwibnVtYmVyT2ZSb3VuZHMiLCJyY29uIiwiUyIsIlNpIiwiVDEiLCJUMiIsIlQzIiwiVDQiLCJUNSIsIlQ2IiwiVDciLCJUOCIsIlUxIiwiVTIiLCJVMyIsIlU0IiwiY29udmVydFRvSW50MzIiLCJieXRlcyIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJwdXNoIiwia2V5Iiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiVWludDhBcnJheSIsInJvdW5kcyIsInJvdW5kS2V5Q291bnQiLCJLQyIsInRrIiwiaW5kZXgiLCJyY29ucG9pbnRlciIsInQiLCJ0dCIsInIiLCJjIiwiZW5jcnlwdCIsInBsYWludGV4dCIsImEiLCJkZWNyeXB0IiwiY2lwaGVydGV4dCIsIldlYWtNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;\nvar aes_js_1 = __webpack_require__(/*! ./aes.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\");\nObject.defineProperty(exports, \"AES\", ({\n    enumerable: true,\n    get: function() {\n        return aes_js_1.AES;\n    }\n}));\nvar mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nObject.defineProperty(exports, \"ModeOfOperation\", ({\n    enumerable: true,\n    get: function() {\n        return mode_js_1.ModeOfOperation;\n    }\n}));\nvar mode_cbc_js_1 = __webpack_require__(/*! ./mode-cbc.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js\");\nObject.defineProperty(exports, \"CBC\", ({\n    enumerable: true,\n    get: function() {\n        return mode_cbc_js_1.CBC;\n    }\n}));\nvar mode_cfb_js_1 = __webpack_require__(/*! ./mode-cfb.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js\");\nObject.defineProperty(exports, \"CFB\", ({\n    enumerable: true,\n    get: function() {\n        return mode_cfb_js_1.CFB;\n    }\n}));\nvar mode_ctr_js_1 = __webpack_require__(/*! ./mode-ctr.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js\");\nObject.defineProperty(exports, \"CTR\", ({\n    enumerable: true,\n    get: function() {\n        return mode_ctr_js_1.CTR;\n    }\n}));\nvar mode_ecb_js_1 = __webpack_require__(/*! ./mode-ecb.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js\");\nObject.defineProperty(exports, \"ECB\", ({\n    enumerable: true,\n    get: function() {\n        return mode_ecb_js_1.ECB;\n    }\n}));\nvar mode_ofb_js_1 = __webpack_require__(/*! ./mode-ofb.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js\");\nObject.defineProperty(exports, \"OFB\", ({\n    enumerable: true,\n    get: function() {\n        return mode_ofb_js_1.OFB;\n    }\n}));\nvar padding_js_1 = __webpack_require__(/*! ./padding.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js\");\nObject.defineProperty(exports, \"pkcs7Pad\", ({\n    enumerable: true,\n    get: function() {\n        return padding_js_1.pkcs7Pad;\n    }\n}));\nObject.defineProperty(exports, \"pkcs7Strip\", ({\n    enumerable: true,\n    get: function() {\n        return padding_js_1.pkcs7Strip;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSx1QkFBdUIsR0FBR0EsV0FBVyxHQUFHLEtBQUs7QUFDM0osSUFBSVcsV0FBV0MsbUJBQU9BLENBQUMscUZBQVU7QUFDakNkLHVDQUFzQztJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxTQUFTRCxHQUFHO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEcsSUFBSUssWUFBWUgsbUJBQU9BLENBQUMsdUZBQVc7QUFDbkNkLG1EQUFrRDtJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxVQUFVTixlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0gsSUFBSU8sZ0JBQWdCSixtQkFBT0EsQ0FBQywrRkFBZTtBQUMzQ2QsdUNBQXNDO0lBQUVlLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGNBQWNSLEdBQUc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzRyxJQUFJUyxnQkFBZ0JMLG1CQUFPQSxDQUFDLCtGQUFlO0FBQzNDZCx1Q0FBc0M7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csY0FBY1YsR0FBRztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNHLElBQUlXLGdCQUFnQk4sbUJBQU9BLENBQUMsK0ZBQWU7QUFDM0NkLHVDQUFzQztJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSSxjQUFjWixHQUFHO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0csSUFBSWEsZ0JBQWdCUCxtQkFBT0EsQ0FBQywrRkFBZTtBQUMzQ2QsdUNBQXNDO0lBQUVlLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9LLGNBQWNkLEdBQUc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzRyxJQUFJZSxnQkFBZ0JSLG1CQUFPQSxDQUFDLCtGQUFlO0FBQzNDZCx1Q0FBc0M7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT00sY0FBY2hCLEdBQUc7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzRyxJQUFJaUIsZUFBZVQsbUJBQU9BLENBQUMsNkZBQWM7QUFDekNkLDRDQUEyQztJQUFFZSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxhQUFhbEIsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BITCw4Q0FBNkM7SUFBRWUsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT08sYUFBYW5CLFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUN4SCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL2luZGV4LmpzPzE5YzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBrY3M3U3RyaXAgPSBleHBvcnRzLnBrY3M3UGFkID0gZXhwb3J0cy5PRkIgPSBleHBvcnRzLkVDQiA9IGV4cG9ydHMuQ1RSID0gZXhwb3J0cy5DRkIgPSBleHBvcnRzLkNCQyA9IGV4cG9ydHMuTW9kZU9mT3BlcmF0aW9uID0gZXhwb3J0cy5BRVMgPSB2b2lkIDA7XG52YXIgYWVzX2pzXzEgPSByZXF1aXJlKFwiLi9hZXMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBRVNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFlc19qc18xLkFFUzsgfSB9KTtcbnZhciBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9kZU9mT3BlcmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uOyB9IH0pO1xudmFyIG1vZGVfY2JjX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLWNiYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNCQ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZV9jYmNfanNfMS5DQkM7IH0gfSk7XG52YXIgbW9kZV9jZmJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtY2ZiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ0ZCXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX2NmYl9qc18xLkNGQjsgfSB9KTtcbnZhciBtb2RlX2N0cl9qc18xID0gcmVxdWlyZShcIi4vbW9kZS1jdHIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDVFJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZGVfY3RyX2pzXzEuQ1RSOyB9IH0pO1xudmFyIG1vZGVfZWNiX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLWVjYi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVDQlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZV9lY2JfanNfMS5FQ0I7IH0gfSk7XG52YXIgbW9kZV9vZmJfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUtb2ZiLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT0ZCXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlX29mYl9qc18xLk9GQjsgfSB9KTtcbnZhciBwYWRkaW5nX2pzXzEgPSByZXF1aXJlKFwiLi9wYWRkaW5nLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGtjczdQYWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhZGRpbmdfanNfMS5wa2NzN1BhZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBrY3M3U3RyaXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhZGRpbmdfanNfMS5wa2NzN1N0cmlwOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGtjczdTdHJpcCIsInBrY3M3UGFkIiwiT0ZCIiwiRUNCIiwiQ1RSIiwiQ0ZCIiwiQ0JDIiwiTW9kZU9mT3BlcmF0aW9uIiwiQUVTIiwiYWVzX2pzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsIm1vZGVfanNfMSIsIm1vZGVfY2JjX2pzXzEiLCJtb2RlX2NmYl9qc18xIiwibW9kZV9jdHJfanNfMSIsIm1vZGVfZWNiX2pzXzEiLCJtb2RlX29mYl9qc18xIiwicGFkZGluZ19qc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Cipher Block Chaining\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CBC_iv, _CBC_lastBlock;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CBC = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CBC extends mode_js_1.ModeOfOperation {\n    constructor(key, iv){\n        super(\"ECC\", key, CBC);\n        _CBC_iv.set(this, void 0);\n        _CBC_lastBlock.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _CBC_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CBC_lastBlock, this.iv, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext.length);\n        for(let i = 0; i < plaintext.length; i += 16){\n            for(let j = 0; j < 16; j++){\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] ^= plaintext[i + j];\n            }\n            __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\")), \"f\");\n            ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, \"f\"), i);\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(ciphertext.length);\n        for(let i = 0; i < ciphertext.length; i += 16){\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));\n            for(let j = 0; j < 16; j++){\n                plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j];\n                __classPrivateFieldGet(this, _CBC_lastBlock, \"f\")[j] = ciphertext[i + j];\n            }\n        }\n        return plaintext;\n    }\n}\nexports.CBC = CBC;\n_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap(); //# sourceMappingURL=mode-cbc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2JjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isd0JBQXdCO0FBQ3hCLElBQUlBLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVFLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNQLFlBQVlJLElBQUlBLEVBQUVGLEtBQUssR0FBR0QsTUFBTVMsR0FBRyxDQUFDVjtBQUN4RjtBQUNBLElBQUlXLFNBQVNDO0FBQ2JDLDhDQUE2QztJQUFFWCxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEYSxXQUFXLEdBQUcsS0FBSztBQUNuQixNQUFNRSxZQUFZQyxtQkFBT0EsQ0FBQyx1RkFBVztBQUNyQyxNQUFNRixZQUFZQyxVQUFVRSxlQUFlO0lBQ3ZDQyxZQUFZQyxHQUFHLEVBQUVDLEVBQUUsQ0FBRTtRQUNqQixLQUFLLENBQUMsT0FBT0QsS0FBS0w7UUFDbEJMLFFBQVFILEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUN2QkksZUFBZUosR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLO1FBQzlCLElBQUljLElBQUk7WUFDSixJQUFJQSxHQUFHQyxNQUFNLEdBQUcsSUFBSTtnQkFDaEIsTUFBTSxJQUFJbEIsVUFBVTtZQUN4QjtZQUNBTix1QkFBdUIsSUFBSSxFQUFFWSxTQUFTLElBQUlhLFdBQVdGLEtBQUs7UUFDOUQsT0FDSztZQUNEdkIsdUJBQXVCLElBQUksRUFBRVksU0FBUyxJQUFJYSxXQUFXLEtBQUs7UUFDOUQ7UUFDQXpCLHVCQUF1QixJQUFJLEVBQUVhLGdCQUFnQixJQUFJLENBQUNVLEVBQUUsRUFBRTtJQUMxRDtJQUNBLElBQUlBLEtBQUs7UUFBRSxPQUFPLElBQUlFLFdBQVdmLHVCQUF1QixJQUFJLEVBQUVFLFNBQVM7SUFBTztJQUM5RWMsUUFBUUMsU0FBUyxFQUFFO1FBQ2YsSUFBSUEsVUFBVUgsTUFBTSxHQUFHLElBQUk7WUFDdkIsTUFBTSxJQUFJbEIsVUFBVTtRQUN4QjtRQUNBLE1BQU1zQixhQUFhLElBQUlILFdBQVdFLFVBQVVILE1BQU07UUFDbEQsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlGLFVBQVVILE1BQU0sRUFBRUssS0FBSyxHQUFJO1lBQzNDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQ3pCcEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLElBQUksQ0FBQ2lCLEVBQUUsSUFBSUgsU0FBUyxDQUFDRSxJQUFJQyxFQUFFO1lBQzVFO1lBQ0E5Qix1QkFBdUIsSUFBSSxFQUFFYSxnQkFBZ0IsSUFBSSxDQUFDa0IsR0FBRyxDQUFDTCxPQUFPLENBQUNoQix1QkFBdUIsSUFBSSxFQUFFRyxnQkFBZ0IsT0FBTztZQUNsSGUsV0FBV25CLEdBQUcsQ0FBQ0MsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLE1BQU1nQjtRQUN0RTtRQUNBLE9BQU9EO0lBQ1g7SUFDQUksUUFBUUosVUFBVSxFQUFFO1FBQ2hCLElBQUlBLFdBQVdKLE1BQU0sR0FBRyxJQUFJO1lBQ3hCLE1BQU0sSUFBSWxCLFVBQVU7UUFDeEI7UUFDQSxNQUFNcUIsWUFBWSxJQUFJRixXQUFXRyxXQUFXSixNQUFNO1FBQ2xELElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJRCxXQUFXSixNQUFNLEVBQUVLLEtBQUssR0FBSTtZQUM1QyxNQUFNSSxRQUFRLElBQUksQ0FBQ0YsR0FBRyxDQUFDQyxPQUFPLENBQUNKLFdBQVdNLFFBQVEsQ0FBQ0wsR0FBR0EsSUFBSTtZQUMxRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO2dCQUN6QkgsU0FBUyxDQUFDRSxJQUFJQyxFQUFFLEdBQUdHLEtBQUssQ0FBQ0gsRUFBRSxHQUFHcEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLElBQUksQ0FBQ2lCLEVBQUU7Z0JBQ2xGcEIsdUJBQXVCLElBQUksRUFBRUcsZ0JBQWdCLElBQUksQ0FBQ2lCLEVBQUUsR0FBR0YsVUFBVSxDQUFDQyxJQUFJQyxFQUFFO1lBQzVFO1FBQ0o7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFDQVgsV0FBVyxHQUFHQztBQUNkTCxVQUFVLElBQUl1QixXQUFXdEIsaUJBQWlCLElBQUlzQixXQUM5QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2JjLmpzP2VlOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ0JDX2l2LCBfQ0JDX2xhc3RCbG9jaztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0JDID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIENCQyBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0NcIiwga2V5LCBDQkMpO1xuICAgICAgICBfQ0JDX2l2LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ0JDX2xhc3RCbG9jay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DQkNfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuaXYsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGl2KCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2l2LCBcImZcIikpOyB9XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFpbnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal0gXj0gcGxhaW50ZXh0W2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NCQ19sYXN0QmxvY2ssIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgY2lwaGVydGV4dC5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmFlcy5kZWNyeXB0KGNpcGhlcnRleHQuc3ViYXJyYXkoaSwgaSArIDE2KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHRbaSArIGpdID0gYmxvY2tbal0gXiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DQkNfbGFzdEJsb2NrLCBcImZcIilbal07XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0JDX2xhc3RCbG9jaywgXCJmXCIpW2pdID0gY2lwaGVydGV4dFtpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG59XG5leHBvcnRzLkNCQyA9IENCQztcbl9DQkNfaXYgPSBuZXcgV2Vha01hcCgpLCBfQ0JDX2xhc3RCbG9jayA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNiYy5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfQ0JDX2l2IiwiX0NCQ19sYXN0QmxvY2siLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJDQkMiLCJtb2RlX2pzXzEiLCJyZXF1aXJlIiwiTW9kZU9mT3BlcmF0aW9uIiwiY29uc3RydWN0b3IiLCJrZXkiLCJpdiIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJlbmNyeXB0IiwicGxhaW50ZXh0IiwiY2lwaGVydGV4dCIsImkiLCJqIiwiYWVzIiwiZGVjcnlwdCIsImJsb2NrIiwic3ViYXJyYXkiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cbc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Cipher Feedback\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CFB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CFB extends mode_js_1.ModeOfOperation {\n    constructor(key, iv, segmentSize = 8){\n        super(\"CFB\", key, CFB);\n        _CFB_instances.add(this);\n        _CFB_iv.set(this, void 0);\n        _CFB_shiftRegister.set(this, void 0);\n        // This library currently only handles byte-aligned segmentSize\n        if (!Number.isInteger(segmentSize) || segmentSize % 8) {\n            throw new TypeError(\"invalid segmentSize\");\n        }\n        Object.defineProperties(this, {\n            segmentSize: {\n                enumerable: true,\n                value: segmentSize\n            }\n        });\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _CFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _CFB_shiftRegister, this.iv, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        if (8 * plaintext.length % this.segmentSize) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const ciphertext = new Uint8Array(plaintext);\n        for(let i = 0; i < ciphertext.length; i += segmentSize){\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for(let j = 0; j < segmentSize; j++){\n                ciphertext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (8 * ciphertext.length % this.segmentSize) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of segmentSize bytes)\");\n        }\n        const segmentSize = this.segmentSize / 8;\n        const plaintext = new Uint8Array(ciphertext);\n        for(let i = 0; i < plaintext.length; i += segmentSize){\n            const xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\"));\n            for(let j = 0; j < segmentSize; j++){\n                plaintext[i + j] ^= xorSegment[j];\n            }\n            __classPrivateFieldGet(this, _CFB_instances, \"m\", _CFB_shift).call(this, ciphertext.subarray(i));\n        }\n        return plaintext;\n    }\n}\nexports.CFB = CFB;\n_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {\n    const segmentSize = this.segmentSize / 8;\n    // Shift the register\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(__classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").subarray(segmentSize));\n    __classPrivateFieldGet(this, _CFB_shiftRegister, \"f\").set(data.subarray(0, segmentSize), 16 - segmentSize);\n}; //# sourceMappingURL=mode-cfb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY2ZiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLElBQUlBLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVFLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNQLFlBQVlJLElBQUlBLEVBQUVGLEtBQUssR0FBR0QsTUFBTVMsR0FBRyxDQUFDVjtBQUN4RjtBQUNBLElBQUlXLGdCQUFn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SUFBSSxDQUFDLElBQUksRUFBRTRCLFdBQVdLLFFBQVEsQ0FBQ0o7UUFDakc7UUFDQSxPQUFPRjtJQUNYO0FBQ0o7QUFDQWpCLFdBQVcsR0FBR0M7QUFDZE4sVUFBVSxJQUFJOEIsV0FBVzdCLHFCQUFxQixJQUFJNkIsV0FBVy9CLGlCQUFpQixJQUFJZ0MsV0FBVzdCLGFBQWEsU0FBU0EsV0FBVzhCLElBQUk7SUFDOUgsTUFBTW5CLGNBQWMsSUFBSSxDQUFDQSxXQUFXLEdBQUc7SUFDdkMscUJBQXFCO0lBQ3JCaEIsdUJBQXVCLElBQUksRUFBRUksb0JBQW9CLEtBQUtMLEdBQUcsQ0FBQ0MsdUJBQXVCLElBQUksRUFBRUksb0JBQW9CLEtBQUsyQixRQUFRLENBQUNmO0lBQ3pIaEIsdUJBQXVCLElBQUksRUFBRUksb0JBQW9CLEtBQUtMLEdBQUcsQ0FBQ29DLEtBQUtKLFFBQVEsQ0FBQyxHQUFHZixjQUFjLEtBQUtBO0FBQ2xHLEdBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9tb2RlLWNmYi5qcz9lMjBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ2lwaGVyIEZlZWRiYWNrXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NGQl9pbnN0YW5jZXMsIF9DRkJfaXYsIF9DRkJfc2hpZnRSZWdpc3RlciwgX0NGQl9zaGlmdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0ZCID0gdm9pZCAwO1xuY29uc3QgbW9kZV9qc18xID0gcmVxdWlyZShcIi4vbW9kZS5qc1wiKTtcbmNsYXNzIENGQiBleHRlbmRzIG1vZGVfanNfMS5Nb2RlT2ZPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgaXYsIHNlZ21lbnRTaXplID0gOCkge1xuICAgICAgICBzdXBlcihcIkNGQlwiLCBrZXksIENGQik7XG4gICAgICAgIF9DRkJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0NGQl9pdi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NGQl9zaGlmdFJlZ2lzdGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBUaGlzIGxpYnJhcnkgY3VycmVudGx5IG9ubHkgaGFuZGxlcyBieXRlLWFsaWduZWQgc2VnbWVudFNpemVcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZ21lbnRTaXplKSB8fCAoc2VnbWVudFNpemUgJSA4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc2VnbWVudFNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgc2VnbWVudFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHNlZ21lbnRTaXplIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgaWYgKGl2Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaXYgc2l6ZSAobXVzdCBiZSAxNiBieXRlcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfaXYsIG5ldyBVaW50OEFycmF5KGl2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ0ZCX2l2LCBuZXcgVWludDhBcnJheSgxNiksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DRkJfc2hpZnRSZWdpc3RlciwgdGhpcy5pdiwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgaXYoKSB7IHJldHVybiBuZXcgVWludDhBcnJheShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaXYsIFwiZlwiKSk7IH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAoOCAqIHBsYWludGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IHhvclNlZ21lbnQgPSB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWdtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9pbnN0YW5jZXMsIFwibVwiLCBfQ0ZCX3NoaWZ0KS5jYWxsKHRoaXMsIGNpcGhlcnRleHQuc3ViYXJyYXkoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKDggKiBjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiBzZWdtZW50U2l6ZSBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudFNpemUgPSB0aGlzLnNlZ21lbnRTaXplIC8gODtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSBzZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgeG9yU2VnbWVudCA9IHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHRbaSArIGpdIF49IHhvclNlZ21lbnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DRkJfaW5zdGFuY2VzLCBcIm1cIiwgX0NGQl9zaGlmdCkuY2FsbCh0aGlzLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuQ0ZCID0gQ0ZCO1xuX0NGQl9pdiA9IG5ldyBXZWFrTWFwKCksIF9DRkJfc2hpZnRSZWdpc3RlciA9IG5ldyBXZWFrTWFwKCksIF9DRkJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0NGQl9zaGlmdCA9IGZ1bmN0aW9uIF9DRkJfc2hpZnQoZGF0YSkge1xuICAgIGNvbnN0IHNlZ21lbnRTaXplID0gdGhpcy5zZWdtZW50U2l6ZSAvIDg7XG4gICAgLy8gU2hpZnQgdGhlIHJlZ2lzdGVyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ0ZCX3NoaWZ0UmVnaXN0ZXIsIFwiZlwiKS5zdWJhcnJheShzZWdtZW50U2l6ZSkpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NGQl9zaGlmdFJlZ2lzdGVyLCBcImZcIikuc2V0KGRhdGEuc3ViYXJyYXkoMCwgc2VnbWVudFNpemUpLCAxNiAtIHNlZ21lbnRTaXplKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLWNmYi5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfQ0ZCX2luc3RhbmNlcyIsIl9DRkJfaXYiLCJfQ0ZCX3NoaWZ0UmVnaXN0ZXIiLCJfQ0ZCX3NoaWZ0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiQ0ZCIiwibW9kZV9qc18xIiwicmVxdWlyZSIsIk1vZGVPZk9wZXJhdGlvbiIsImNvbnN0cnVjdG9yIiwia2V5IiwiaXYiLCJzZWdtZW50U2l6ZSIsImFkZCIsIk51bWJlciIsImlzSW50ZWdlciIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwibGVuZ3RoIiwiVWludDhBcnJheSIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJjaXBoZXJ0ZXh0IiwiaSIsInhvclNlZ21lbnQiLCJhZXMiLCJqIiwic3ViYXJyYXkiLCJkZWNyeXB0IiwiV2Vha01hcCIsIldlYWtTZXQiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-cfb.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Counter Mode\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CTR = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass CTR extends mode_js_1.ModeOfOperation {\n    constructor(key, initialValue){\n        super(\"CTR\", key, CTR);\n        // Remaining bytes for the one-time pad\n        _CTR_remaining.set(this, void 0);\n        _CTR_remainingIndex.set(this, void 0);\n        // The current counter\n        _CTR_counter.set(this, void 0);\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\");\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0);\n        __classPrivateFieldSet(this, _CTR_remaining, __classPrivateFieldGet(this, _CTR_counter, \"f\"), \"f\"); // This will be discarded immediately\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\");\n        if (initialValue == null) {\n            initialValue = 1;\n        }\n        if (typeof initialValue === \"number\") {\n            this.setCounterValue(initialValue);\n        } else {\n            this.setCounterBytes(initialValue);\n        }\n    }\n    get counter() {\n        return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\"));\n    }\n    setCounterValue(value) {\n        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError(\"invalid counter initial integer value\");\n        }\n        for(let index = 15; index >= 0; --index){\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256;\n            value = Math.floor(value / 256);\n        }\n    }\n    setCounterBytes(value) {\n        if (value.length !== 16) {\n            throw new TypeError(\"invalid counter initial Uint8Array value length\");\n        }\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value);\n    }\n    increment() {\n        for(let i = 15; i >= 0; i--){\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0;\n            } else {\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++;\n                break;\n            }\n        }\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        const crypttext = new Uint8Array(plaintext);\n        for(let i = 0; i < crypttext.length; i++){\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\");\n                this.increment();\n            }\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return crypttext;\n    }\n    decrypt(ciphertext) {\n        return this.encrypt(ciphertext);\n    }\n}\nexports.CTR = CTR;\n_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap(); //# sourceMappingURL=mode-ctr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY3RyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZTtBQUNmLElBQUlBLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVFLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNQLFlBQVlJLElBQUlBLEVBQUVGLEtBQUssR0FBR0QsTUFBTVMsR0FBRyxDQUFDVjtBQUN4RjtBQUNBLElBQUlXLGdCQUFnQkMs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STVCLHVCQUF1QixJQUFJLEVBQUVFLGdCQUFnQixJQUFJLENBQUNaLHVCQUF1QixJQUFJLEVBQUVhLHFCQUFzQjZCLENBQUFBLEtBQUtoQyx1QkFBdUIsSUFBSSxFQUFFRyxxQkFBcUIsTUFBTTRCLEtBQUtDLE1BQU1BLEVBQUMsR0FBSSxNQUFNRCxHQUFHO1FBQy9NO1FBQ0EsT0FBT0U7SUFDWDtJQUNBRSxRQUFRQyxVQUFVLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNQLE9BQU8sQ0FBQ087SUFDeEI7QUFDSjtBQUNBN0IsV0FBVyxHQUFHQztBQUNkTixpQkFBaUIsSUFBSW1DLFdBQVdsQyxzQkFBc0IsSUFBSWtDLFdBQVdqQyxlQUFlLElBQUlpQyxXQUN4RixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ldmVudGNyaWIvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtY3RyLmpzPzc1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3VudGVyIE1vZGVcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQ1RSX3JlbWFpbmluZywgX0NUUl9yZW1haW5pbmdJbmRleCwgX0NUUl9jb3VudGVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DVFIgPSB2b2lkIDA7XG5jb25zdCBtb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2RlLmpzXCIpO1xuY2xhc3MgQ1RSIGV4dGVuZHMgbW9kZV9qc18xLk1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgc3VwZXIoXCJDVFJcIiwga2V5LCBDVFIpO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXMgZm9yIHRoZSBvbmUtdGltZSBwYWRcbiAgICAgICAgX0NUUl9yZW1haW5pbmcuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DVFJfcmVtYWluaW5nSW5kZXguc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgX0NUUl9jb3VudGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfY291bnRlciwgbmV3IFVpbnQ4QXJyYXkoMTYpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIikuZmlsbCgwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ1RSX3JlbWFpbmluZywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSwgXCJmXCIpOyAvLyBUaGlzIHdpbGwgYmUgZGlzY2FyZGVkIGltbWVkaWF0ZWx5XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgMTYsIFwiZlwiKTtcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGluaXRpYWxWYWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q291bnRlclZhbHVlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvdW50ZXJCeXRlcyhpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb3VudGVyKCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSk7IH1cbiAgICBzZXRDb3VudGVyVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY291bnRlciBpbml0aWFsIGludGVnZXIgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKVtpbmRleF0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDI1Nik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q291bnRlckJ5dGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBjb3VudGVyIGluaXRpYWwgVWludDhBcnJheSB2YWx1ZSBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBpbmNyZW1lbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DVFJfY291bnRlciwgXCJmXCIpW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9jb3VudGVyLCBcImZcIilbaV0rKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjcnlwdHRleHQgPSBuZXcgVWludDhBcnJheShwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyeXB0dGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpID09PSAxNikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIHRoaXMuYWVzLmVuY3J5cHQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ1RSX2NvdW50ZXIsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIDAsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3J5cHR0ZXh0W2ldIF49IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmcsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DVFJfcmVtYWluaW5nSW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NUUl9yZW1haW5pbmdJbmRleCwgXCJmXCIpLCBfYSA9IF9iKyssIF9iKSwgXCJmXCIpLCBfYV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy5DVFIgPSBDVFI7XG5fQ1RSX3JlbWFpbmluZyA9IG5ldyBXZWFrTWFwKCksIF9DVFJfcmVtYWluaW5nSW5kZXggPSBuZXcgV2Vha01hcCgpLCBfQ1RSX2NvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1jdHIuanMubWFwIl0sIm5hbWVzIjpbIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJyZWNlaXZlciIsInN0YXRlIiwidmFsdWUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJzZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwiZ2V0IiwiX0NUUl9yZW1haW5pbmciLCJfQ1RSX3JlbWFpbmluZ0luZGV4IiwiX0NUUl9jb3VudGVyIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiQ1RSIiwibW9kZV9qc18xIiwicmVxdWlyZSIsIk1vZGVPZk9wZXJhdGlvbiIsImNvbnN0cnVjdG9yIiwia2V5IiwiaW5pdGlhbFZhbHVlIiwiVWludDhBcnJheSIsImZpbGwiLCJzZXRDb3VudGVyVmFsdWUiLCJzZXRDb3VudGVyQnl0ZXMiLCJjb3VudGVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiTUFYX1NBRkVfSU5URUdFUiIsImluZGV4IiwiTWF0aCIsImZsb29yIiwibGVuZ3RoIiwiaW5jcmVtZW50IiwiaSIsImVuY3J5cHQiLCJwbGFpbnRleHQiLCJfYSIsIl9iIiwiY3J5cHR0ZXh0IiwiYWVzIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ctr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Electronic Code Book\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ECB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass ECB extends mode_js_1.ModeOfOperation {\n    constructor(key){\n        super(\"ECB\", key, ECB);\n    }\n    encrypt(plaintext) {\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const crypttext = new Uint8Array(plaintext.length);\n        for(let i = 0; i < plaintext.length; i += 16){\n            crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);\n        }\n        return crypttext;\n    }\n    decrypt(crypttext) {\n        if (crypttext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        const plaintext = new Uint8Array(crypttext.length);\n        for(let i = 0; i < crypttext.length; i += 16){\n            plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);\n        }\n        return plaintext;\n    }\n}\nexports.ECB = ECB; //# sourceMappingURL=mode-ecb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtZWNiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsV0FBVyxHQUFHLEtBQUs7QUFDbkIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsdUZBQVc7QUFDckMsTUFBTUYsWUFBWUMsVUFBVUUsZUFBZTtJQUN2Q0MsWUFBWUMsR0FBRyxDQUFFO1FBQ2IsS0FBSyxDQUFDLE9BQU9BLEtBQUtMO0lBQ3RCO0lBQ0FNLFFBQVFDLFNBQVMsRUFBRTtRQUNmLElBQUlBLFVBQVVDLE1BQU0sR0FBRyxJQUFJO1lBQ3ZCLE1BQU0sSUFBSUMsVUFBVTtRQUN4QjtRQUNBLE1BQU1DLFlBQVksSUFBSUMsV0FBV0osVUFBVUMsTUFBTTtRQUNqRCxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUwsVUFBVUMsTUFBTSxFQUFFSSxLQUFLLEdBQUk7WUFDM0NGLFVBQVVHLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ1IsT0FBTyxDQUFDQyxVQUFVUSxRQUFRLENBQUNILEdBQUdBLElBQUksTUFBTUE7UUFDbkU7UUFDQSxPQUFPRjtJQUNYO0lBQ0FNLFFBQVFOLFNBQVMsRUFBRTtRQUNmLElBQUlBLFVBQVVGLE1BQU0sR0FBRyxJQUFJO1lBQ3ZCLE1BQU0sSUFBSUMsVUFBVTtRQUN4QjtRQUNBLE1BQU1GLFlBQVksSUFBSUksV0FBV0QsVUFBVUYsTUFBTTtRQUNqRCxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUYsVUFBVUYsTUFBTSxFQUFFSSxLQUFLLEdBQUk7WUFDM0NMLFVBQVVNLEdBQUcsQ0FBQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0UsT0FBTyxDQUFDTixVQUFVSyxRQUFRLENBQUNILEdBQUdBLElBQUksTUFBTUE7UUFDbkU7UUFDQSxPQUFPTDtJQUNYO0FBQ0o7QUFDQVQsV0FBVyxHQUFHRSxLQUNkLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1lY2IuanM/MGI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEVsZWN0cm9uaWMgQ29kZSBCb29rXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVDQiA9IHZvaWQgMDtcbmNvbnN0IG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5jbGFzcyBFQ0IgZXh0ZW5kcyBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgc3VwZXIoXCJFQ0JcIiwga2V5LCBFQ0IpO1xuICAgIH1cbiAgICBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3J5cHR0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY3J5cHR0ZXh0LnNldCh0aGlzLmFlcy5lbmNyeXB0KHBsYWludGV4dC5zdWJhcnJheShpLCBpICsgMTYpKSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyeXB0dGV4dDtcbiAgICB9XG4gICAgZGVjcnlwdChjcnlwdHRleHQpIHtcbiAgICAgICAgaWYgKGNyeXB0dGV4dC5sZW5ndGggJSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBuZXcgVWludDhBcnJheShjcnlwdHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcnlwdHRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBwbGFpbnRleHQuc2V0KHRoaXMuYWVzLmRlY3J5cHQoY3J5cHR0ZXh0LnN1YmFycmF5KGksIGkgKyAxNikpLCBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuRUNCID0gRUNCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZS1lY2IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRUNCIiwibW9kZV9qc18xIiwicmVxdWlyZSIsIk1vZGVPZk9wZXJhdGlvbiIsImNvbnN0cnVjdG9yIiwia2V5IiwiZW5jcnlwdCIsInBsYWludGV4dCIsImxlbmd0aCIsIlR5cGVFcnJvciIsImNyeXB0dGV4dCIsIlVpbnQ4QXJyYXkiLCJpIiwic2V0IiwiYWVzIiwic3ViYXJyYXkiLCJkZWNyeXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ecb.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Output Feedback\nvar __classPrivateFieldSet = (void 0) && (void 0).__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = (void 0) && (void 0).__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OFB = void 0;\nconst mode_js_1 = __webpack_require__(/*! ./mode.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\");\nclass OFB extends mode_js_1.ModeOfOperation {\n    constructor(key, iv){\n        super(\"OFB\", key, OFB);\n        _OFB_iv.set(this, void 0);\n        _OFB_lastPrecipher.set(this, void 0);\n        _OFB_lastPrecipherIndex.set(this, void 0);\n        if (iv) {\n            if (iv.length % 16) {\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\");\n            }\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(iv), \"f\");\n        } else {\n            __classPrivateFieldSet(this, _OFB_iv, new Uint8Array(16), \"f\");\n        }\n        __classPrivateFieldSet(this, _OFB_lastPrecipher, this.iv, \"f\");\n        __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 16, \"f\");\n    }\n    get iv() {\n        return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, \"f\"));\n    }\n    encrypt(plaintext) {\n        var _a, _b;\n        if (plaintext.length % 16) {\n            throw new TypeError(\"invalid plaintext size (must be multiple of 16 bytes)\");\n        }\n        const ciphertext = new Uint8Array(plaintext);\n        for(let i = 0; i < ciphertext.length; i++){\n            if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\") === 16) {\n                __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")), \"f\");\n                __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, \"f\");\n            }\n            ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, \"f\")[__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, \"f\"), _a = _b++, _b), \"f\"), _a];\n        }\n        return ciphertext;\n    }\n    decrypt(ciphertext) {\n        if (ciphertext.length % 16) {\n            throw new TypeError(\"invalid ciphertext size (must be multiple of 16 bytes)\");\n        }\n        return this.encrypt(ciphertext);\n    }\n}\nexports.OFB = OFB;\n_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap(); //# sourceMappingURL=mode-ofb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUtb2ZiLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLElBQUlBLHlCQUF5QixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9KLFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRyxJQUFJLENBQUNILE1BQU1LLEdBQUcsQ0FBQ04sV0FBVyxNQUFNLElBQUlLLFVBQVU7SUFDdkcsT0FBTyxTQUFVLE1BQU1ELEVBQUVHLElBQUksQ0FBQ1AsVUFBVUUsU0FBU0UsSUFBSUEsRUFBRUYsS0FBSyxHQUFHQSxRQUFRRCxNQUFNTyxHQUFHLENBQUNSLFVBQVVFLFFBQVNBO0FBQ3hHO0FBQ0EsSUFBSU8seUJBQXlCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVFLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNQLFlBQVlJLElBQUlBLEVBQUVGLEtBQUssR0FBR0QsTUFBTVMsR0FBRyxDQUFDVjtBQUN4RjtBQUNBLElBQUlXLFNBQVNDLG9CQUFvQkM7QUFDakNDLDhDQUE2QztJQUFFWixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEYyxXQUFXLEdBQUcsS0FBSztBQUNuQixNQUFNRSxZQUFZQyxtQkFBT0EsQ0FBQyx1RkFBVztBQUNyQyxNQUFNRixZQUFZQyxVQUFVRSxlQUFlO0lBQ3ZDQyxZQUFZQyxHQUFHLEVBQUVDLEVBQUUsQ0FBRTtRQUNqQixLQUFLLENBQUMsT0FBT0QsS0FBS0w7UUFDbEJOLFFBQVFILEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSztRQUN2QkksbUJBQW1CSixHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUs7UUFDbENLLHdCQUF3QkwsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLO1FBQ3ZDLElBQUllLElBQUk7WUFDSixJQUFJQSxHQUFHQyxNQUFNLEdBQUcsSUFBSTtnQkFDaEIsTUFBTSxJQUFJbkIsVUFBVTtZQUN4QjtZQUNBTix1QkFBdUIsSUFBSSxFQUFFWSxTQUFTLElBQUljLFdBQVdGLEtBQUs7UUFDOUQsT0FDSztZQUNEeEIsdUJBQXVCLElBQUksRUFBRVksU0FBUyxJQUFJYyxXQUFXLEtBQUs7UUFDOUQ7UUFDQTFCLHVCQUF1QixJQUFJLEVBQUVhLG9CQUFvQixJQUFJLENBQUNXLEVBQUUsRUFBRTtRQUMxRHhCLHVCQUF1QixJQUFJLEVBQUVjLHlCQUF5QixJQUFJO0lBQzlEO0lBQ0EsSUFBSVUsS0FBSztRQUFFLE9BQU8sSUFBSUUsV0FBV2hCLHVCQUF1QixJQUFJLEVBQUVFLFNBQVM7SUFBTztJQUM5RWUsUUFBUUMsU0FBUyxFQUFFO1FBQ2YsSUFBSUMsSUFBSUM7UUFDUixJQUFJRixVQUFVSCxNQUFNLEdBQUcsSUFBSTtZQUN2QixNQUFNLElBQUluQixVQUFVO1FBQ3hCO1FBQ0EsTUFBTXlCLGFBQWEsSUFBSUwsV0FBV0U7UUFDbEMsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUlELFdBQVdOLE1BQU0sRUFBRU8sSUFBSztZQUN4QyxJQUFJdEIsdUJBQXVCLElBQUksRUFBRUkseUJBQXlCLFNBQVMsSUFBSTtnQkFDbkVkLHVCQUF1QixJQUFJLEVBQUVhLG9CQUFvQixJQUFJLENBQUNvQixHQUFHLENBQUNOLE9BQU8sQ0FBQ2pCLHVCQUF1QixJQUFJLEVBQUVHLG9CQUFvQixPQUFPO2dCQUMxSGIsdUJBQXVCLElBQUksRUFBRWMseUJBQXlCLEdBQUc7WUFDN0Q7WUFDQWlCLFVBQVUsQ0FBQ0MsRUFBRSxJQUFJdEIsdUJBQXVCLElBQUksRUFBRUcsb0JBQW9CLElBQUksQ0FBQ2IsdUJBQXVCLElBQUksRUFBRWMseUJBQTBCZ0IsQ0FBQUEsS0FBS3BCLHVCQUF1QixJQUFJLEVBQUVJLHlCQUF5QixNQUFNZSxLQUFLQyxNQUFNQSxFQUFDLEdBQUksTUFBTUQsR0FBRztRQUM1TjtRQUNBLE9BQU9FO0lBQ1g7SUFDQUcsUUFBUUgsVUFBVSxFQUFFO1FBQ2hCLElBQUlBLFdBQVdOLE1BQU0sR0FBRyxJQUFJO1lBQ3hCLE1BQU0sSUFBSW5CLFVBQVU7UUFDeEI7UUFDQSxPQUFPLElBQUksQ0FBQ3FCLE9BQU8sQ0FBQ0k7SUFDeEI7QUFDSjtBQUNBZCxXQUFXLEdBQUdDO0FBQ2ROLFVBQVUsSUFBSXVCLFdBQVd0QixxQkFBcUIsSUFBSXNCLFdBQVdyQiwwQkFBMEIsSUFBSXFCLFdBQzNGLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS1vZmIuanM/MWE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE91dHB1dCBGZWVkYmFja1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9PRkJfaXYsIF9PRkJfbGFzdFByZWNpcGhlciwgX09GQl9sYXN0UHJlY2lwaGVySW5kZXg7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9GQiA9IHZvaWQgMDtcbmNvbnN0IG1vZGVfanNfMSA9IHJlcXVpcmUoXCIuL21vZGUuanNcIik7XG5jbGFzcyBPRkIgZXh0ZW5kcyBtb2RlX2pzXzEuTW9kZU9mT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIGl2KSB7XG4gICAgICAgIHN1cGVyKFwiT0ZCXCIsIGtleSwgT0ZCKTtcbiAgICAgICAgX09GQl9pdi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX09GQl9sYXN0UHJlY2lwaGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICBpZiAoaXYubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpdiBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9pdiwgbmV3IFVpbnQ4QXJyYXkoaXYpLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9PRkJfaXYsIG5ldyBVaW50OEFycmF5KDE2KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCB0aGlzLml2LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIDE2LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBpdigpIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9pdiwgXCJmXCIpKTsgfVxuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChwbGFpbnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgXCJmXCIpID09PSAxNikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCB0aGlzLmFlcy5lbmNyeXB0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVyLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCwgMCwgXCJmXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2lwaGVydGV4dFtpXSBePSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9PRkJfbGFzdFByZWNpcGhlciwgXCJmXCIpW19fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIChfYiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX09GQl9sYXN0UHJlY2lwaGVySW5kZXgsIFwiZlwiKSwgX2EgPSBfYisrLCBfYiksIFwiZlwiKSwgX2FdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICAgIH1cbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdChjaXBoZXJ0ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLk9GQiA9IE9GQjtcbl9PRkJfaXYgPSBuZXcgV2Vha01hcCgpLCBfT0ZCX2xhc3RQcmVjaXBoZXIgPSBuZXcgV2Vha01hcCgpLCBfT0ZCX2xhc3RQcmVjaXBoZXJJbmRleCA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlLW9mYi5qcy5tYXAiXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInJlY2VpdmVyIiwic3RhdGUiLCJ2YWx1ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInNldCIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJnZXQiLCJfT0ZCX2l2IiwiX09GQl9sYXN0UHJlY2lwaGVyIiwiX09GQl9sYXN0UHJlY2lwaGVySW5kZXgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJPRkIiLCJtb2RlX2pzXzEiLCJyZXF1aXJlIiwiTW9kZU9mT3BlcmF0aW9uIiwiY29uc3RydWN0b3IiLCJrZXkiLCJpdiIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJlbmNyeXB0IiwicGxhaW50ZXh0IiwiX2EiLCJfYiIsImNpcGhlcnRleHQiLCJpIiwiYWVzIiwiZGVjcnlwdCIsIldlYWtNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode-ofb.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ModeOfOperation = void 0;\nconst aes_js_1 = __webpack_require__(/*! ./aes.js */ \"(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/aes.js\");\nclass ModeOfOperation {\n    constructor(name, key, cls){\n        if (cls && !(this instanceof cls)) {\n            throw new Error(`${name} must be instantiated with \"new\"`);\n        }\n        Object.defineProperties(this, {\n            aes: {\n                enumerable: true,\n                value: new aes_js_1.AES(key)\n            },\n            name: {\n                enumerable: true,\n                value: name\n            }\n        });\n    }\n}\nexports.ModeOfOperation = ModeOfOperation; //# sourceMappingURL=mode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL21vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMscUZBQVU7QUFDbkMsTUFBTUY7SUFDRkcsWUFBWUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsQ0FBRTtRQUN4QixJQUFJQSxPQUFPLENBQUUsS0FBSSxZQUFZQSxHQUFFLEdBQUk7WUFDL0IsTUFBTSxJQUFJQyxNQUFNLENBQUMsRUFBRUgsS0FBSyxnQ0FBZ0MsQ0FBQztRQUM3RDtRQUNBUixPQUFPWSxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7WUFDMUJDLEtBQUs7Z0JBQUVDLFlBQVk7Z0JBQU1YLE9BQU8sSUFBSUUsU0FBU1UsR0FBRyxDQUFDTjtZQUFLO1lBQ3RERCxNQUFNO2dCQUFFTSxZQUFZO2dCQUFNWCxPQUFPSztZQUFLO1FBQzFDO0lBQ0o7QUFDSjtBQUNBTix1QkFBdUIsR0FBR0UsaUJBQzFCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V2ZW50Y3JpYi8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbm9kZV9tb2R1bGVzL2Flcy1qcy9saWIuY29tbW9uanMvbW9kZS5qcz8yYjEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nb2RlT2ZPcGVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBhZXNfanNfMSA9IHJlcXVpcmUoXCIuL2Flcy5qc1wiKTtcbmNsYXNzIE1vZGVPZk9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwga2V5LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBcIm5ld1wiYCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgYWVzOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBuZXcgYWVzX2pzXzEuQUVTKGtleSkgfSxcbiAgICAgICAgICAgIG5hbWU6IHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IG5hbWUgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1vZGVPZk9wZXJhdGlvbiA9IE1vZGVPZk9wZXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTW9kZU9mT3BlcmF0aW9uIiwiYWVzX2pzXzEiLCJyZXF1aXJlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwia2V5IiwiY2xzIiwiRXJyb3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYWVzIiwiZW51bWVyYWJsZSIsIkFFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/mode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pkcs7Strip = exports.pkcs7Pad = void 0;\nfunction pkcs7Pad(data) {\n    const padder = 16 - data.length % 16;\n    const result = new Uint8Array(data.length + padder);\n    result.set(data);\n    for(let i = data.length; i < result.length; i++){\n        result[i] = padder;\n    }\n    return result;\n}\nexports.pkcs7Pad = pkcs7Pad;\nfunction pkcs7Strip(data) {\n    if (data.length < 16) {\n        throw new TypeError(\"PKCS#7 invalid length\");\n    }\n    const padder = data[data.length - 1];\n    if (padder > 16) {\n        throw new TypeError(\"PKCS#7 padding byte out of range\");\n    }\n    const length = data.length - padder;\n    for(let i = 0; i < padder; i++){\n        if (data[length + i] !== padder) {\n            throw new TypeError(\"PKCS#7 invalid padding byte\");\n        }\n    }\n    return new Uint8Array(data.subarray(0, length));\n}\nexports.pkcs7Strip = pkcs7Strip; //# sourceMappingURL=padding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXRoZXJzL25vZGVfbW9kdWxlcy9hZXMtanMvbGliLmNvbW1vbmpzL3BhZGRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQzdDLFNBQVNHLFNBQVNDLElBQUk7SUFDbEIsTUFBTUMsU0FBUyxLQUFNRCxLQUFLRSxNQUFNLEdBQUc7SUFDbkMsTUFBTUMsU0FBUyxJQUFJQyxXQUFXSixLQUFLRSxNQUFNLEdBQUdEO0lBQzVDRSxPQUFPRSxHQUFHLENBQUNMO0lBQ1gsSUFBSyxJQUFJTSxJQUFJTixLQUFLRSxNQUFNLEVBQUVJLElBQUlILE9BQU9ELE1BQU0sRUFBRUksSUFBSztRQUM5Q0gsTUFBTSxDQUFDRyxFQUFFLEdBQUdMO0lBQ2hCO0lBQ0EsT0FBT0U7QUFDWDtBQUNBUCxnQkFBZ0IsR0FBR0c7QUFDbkIsU0FBU0QsV0FBV0UsSUFBSTtJQUNwQixJQUFJQSxLQUFLRSxNQUFNLEdBQUcsSUFBSTtRQUNsQixNQUFNLElBQUlLLFVBQVU7SUFDeEI7SUFDQSxNQUFNTixTQUFTRCxJQUFJLENBQUNBLEtBQUtFLE1BQU0sR0FBRyxFQUFFO0lBQ3BDLElBQUlELFNBQVMsSUFBSTtRQUNiLE1BQU0sSUFBSU0sVUFBVTtJQUN4QjtJQUNBLE1BQU1MLFNBQVNGLEtBQUtFLE1BQU0sR0FBR0Q7SUFDN0IsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlMLFFBQVFLLElBQUs7UUFDN0IsSUFBSU4sSUFBSSxDQUFDRSxTQUFTSSxFQUFFLEtBQUtMLFFBQVE7WUFDN0IsTUFBTSxJQUFJTSxVQUFVO1FBQ3hCO0lBQ0o7SUFDQSxPQUFPLElBQUlILFdBQVdKLEtBQUtRLFFBQVEsQ0FBQyxHQUFHTjtBQUMzQztBQUNBTixrQkFBa0IsR0FBR0UsWUFDckIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXZlbnRjcmliLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9ub2RlX21vZHVsZXMvYWVzLWpzL2xpYi5jb21tb25qcy9wYWRkaW5nLmpzP2Y1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBrY3M3U3RyaXAgPSBleHBvcnRzLnBrY3M3UGFkID0gdm9pZCAwO1xuZnVuY3Rpb24gcGtjczdQYWQoZGF0YSkge1xuICAgIGNvbnN0IHBhZGRlciA9IDE2IC0gKGRhdGEubGVuZ3RoICUgMTYpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcbiAgICByZXN1bHQuc2V0KGRhdGEpO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBwYWRkZXI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBrY3M3UGFkID0gcGtjczdQYWQ7XG5mdW5jdGlvbiBwa2NzN1N0cmlwKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVyID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgIGlmIChwYWRkZXIgPiAxNikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIHBhZGRlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZGRlcjsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLnN1YmFycmF5KDAsIGxlbmd0aCkpO1xufVxuZXhwb3J0cy5wa2NzN1N0cmlwID0gcGtjczdTdHJpcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZGRpbmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGtjczdTdHJpcCIsInBrY3M3UGFkIiwiZGF0YSIsInBhZGRlciIsImxlbmd0aCIsInJlc3VsdCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpIiwiVHlwZUVycm9yIiwic3ViYXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ethers/node_modules/aes-js/lib.commonjs/padding.js\n");

/***/ })

};
;